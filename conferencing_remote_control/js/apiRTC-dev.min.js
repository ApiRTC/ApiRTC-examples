!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).adapter=e()}}(function(){return function(){function e(t,r,n){function i(o,s){if(!r[o]){if(!t[o]){var c="function"==typeof require&&require;if(!s&&c)return c(o,!0);if(a)return a(o,!0);var d=new Error("Cannot find module '"+o+"'");throw d.code="MODULE_NOT_FOUND",d}var p=r[o]={exports:{}};t[o][0].call(p.exports,function(e){return i(t[o][1][e]||e)},p,p.exports,e,t,r,n)}return r[o].exports}for(var a="function"==typeof require&&require,o=0;o<n.length;o++)i(n[o]);return i}return e}()({1:[function(e,t,r){"use strict";var n=(0,e("./adapter_factory.js").adapterFactory)({window:window});t.exports=n},{"./adapter_factory.js":2}],2:[function(e,t,r){"use strict";function n(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}Object.defineProperty(r,"__esModule",{value:!0}),r.adapterFactory=function(){var e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}).window,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{shimChrome:!0,shimFirefox:!0,shimEdge:!0,shimSafari:!0},r=i.log,n=i.detectBrowser(e),p={browserDetails:n,commonShim:d,extractVersion:i.extractVersion,disableLog:i.disableLog,disableWarnings:i.disableWarnings};switch(n.browser){case"chrome":if(!a||!a.shimPeerConnection||!t.shimChrome)return r("Chrome shim is not included in this adapter release."),p;r("adapter.js shimming chrome."),p.browserShim=a,a.shimGetUserMedia(e),a.shimMediaStream(e),a.shimPeerConnection(e),a.shimOnTrack(e),a.shimAddTrackRemoveTrack(e),a.shimGetSendersWithDtmf(e),a.shimGetStats(e),a.shimSenderReceiverGetStats(e),a.fixNegotiationNeeded(e),d.shimRTCIceCandidate(e),d.shimConnectionState(e),d.shimMaxMessageSize(e),d.shimSendThrowTypeError(e),d.removeAllowExtmapMixed(e);break;case"firefox":if(!s||!s.shimPeerConnection||!t.shimFirefox)return r("Firefox shim is not included in this adapter release."),p;r("adapter.js shimming firefox."),p.browserShim=s,s.shimGetUserMedia(e),s.shimPeerConnection(e),s.shimOnTrack(e),s.shimRemoveStream(e),s.shimSenderGetStats(e),s.shimReceiverGetStats(e),s.shimRTCDataChannel(e),d.shimRTCIceCandidate(e),d.shimConnectionState(e),d.shimMaxMessageSize(e),d.shimSendThrowTypeError(e);break;case"edge":if(!o||!o.shimPeerConnection||!t.shimEdge)return r("MS edge shim is not included in this adapter release."),p;r("adapter.js shimming edge."),p.browserShim=o,o.shimGetUserMedia(e),o.shimGetDisplayMedia(e),o.shimPeerConnection(e),o.shimReplaceTrack(e),d.shimMaxMessageSize(e),d.shimSendThrowTypeError(e);break;case"safari":if(!c||!t.shimSafari)return r("Safari shim is not included in this adapter release."),p;r("adapter.js shimming safari."),p.browserShim=c,c.shimRTCIceServerUrls(e),c.shimCreateOfferLegacy(e),c.shimCallbacksAPI(e),c.shimLocalStreamsAPI(e),c.shimRemoteStreamsAPI(e),c.shimTrackEventTransceiver(e),c.shimGetUserMedia(e),d.shimRTCIceCandidate(e),d.shimMaxMessageSize(e),d.shimSendThrowTypeError(e),d.removeAllowExtmapMixed(e);break;default:r("Unsupported browser!")}return p};var i=n(e("./utils")),a=n(e("./chrome/chrome_shim")),o=n(e("./edge/edge_shim")),s=n(e("./firefox/firefox_shim")),c=n(e("./safari/safari_shim")),d=n(e("./common_shim"))},{"./chrome/chrome_shim":3,"./common_shim":6,"./edge/edge_shim":7,"./firefox/firefox_shim":11,"./safari/safari_shim":14,"./utils":15}],3:[function(e,t,r){"use strict";function n(e){e.RTCPeerConnection.prototype.getLocalStreams=function(){var e=this;return this._shimmedLocalStreams=this._shimmedLocalStreams||{},Object.keys(this._shimmedLocalStreams).map(function(t){return e._shimmedLocalStreams[t][0]})};var t=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addTrack=function(e,r){if(!r)return t.apply(this,arguments);this._shimmedLocalStreams=this._shimmedLocalStreams||{};var n=t.apply(this,arguments);return this._shimmedLocalStreams[r.id]?-1===this._shimmedLocalStreams[r.id].indexOf(n)&&this._shimmedLocalStreams[r.id].push(n):this._shimmedLocalStreams[r.id]=[r,n],n};var r=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(e){var t=this;this._shimmedLocalStreams=this._shimmedLocalStreams||{},e.getTracks().forEach(function(e){if(t.getSenders().find(function(t){return t.track===e}))throw new DOMException("Track already exists.","InvalidAccessError")});var n=this.getSenders();r.apply(this,arguments);var i=this.getSenders().filter(function(e){return-1===n.indexOf(e)});this._shimmedLocalStreams[e.id]=[e].concat(i)};var n=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},delete this._shimmedLocalStreams[e.id],n.apply(this,arguments)};var i=e.RTCPeerConnection.prototype.removeTrack;e.RTCPeerConnection.prototype.removeTrack=function(e){var t=this;return this._shimmedLocalStreams=this._shimmedLocalStreams||{},e&&Object.keys(this._shimmedLocalStreams).forEach(function(r){var n=t._shimmedLocalStreams[r].indexOf(e);-1!==n&&t._shimmedLocalStreams[r].splice(n,1),1===t._shimmedLocalStreams[r].length&&delete t._shimmedLocalStreams[r]}),i.apply(this,arguments)}}Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=r.shimGetUserMedia=void 0;var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},a=e("./getusermedia");Object.defineProperty(r,"shimGetUserMedia",{enumerable:!0,get:function(){return a.shimGetUserMedia}});var o=e("./getdisplaymedia");Object.defineProperty(r,"shimGetDisplayMedia",{enumerable:!0,get:function(){return o.shimGetDisplayMedia}}),r.shimMediaStream=function(e){e.MediaStream=e.MediaStream||e.webkitMediaStream},r.shimOnTrack=function(e){if("object"!==(void 0===e?"undefined":i(e))||!e.RTCPeerConnection||"ontrack"in e.RTCPeerConnection.prototype)s.wrapPeerConnectionEvent(e,"track",function(e){return e.transceiver||Object.defineProperty(e,"transceiver",{value:{receiver:e.receiver}}),e});else{Object.defineProperty(e.RTCPeerConnection.prototype,"ontrack",{get:function(){return this._ontrack},set:function(e){this._ontrack&&this.removeEventListener("track",this._ontrack),this.addEventListener("track",this._ontrack=e)},enumerable:!0,configurable:!0});var t=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(){var r=this;return this._ontrackpoly||(this._ontrackpoly=function(t){t.stream.addEventListener("addtrack",function(n){var i=void 0;i=e.RTCPeerConnection.prototype.getReceivers?r.getReceivers().find(function(e){return e.track&&e.track.id===n.track.id}):{track:n.track};var a=new Event("track");a.track=n.track,a.receiver=i,a.transceiver={receiver:i},a.streams=[t.stream],r.dispatchEvent(a)}),t.stream.getTracks().forEach(function(n){var i=void 0;i=e.RTCPeerConnection.prototype.getReceivers?r.getReceivers().find(function(e){return e.track&&e.track.id===n.id}):{track:n};var a=new Event("track");a.track=n,a.receiver=i,a.transceiver={receiver:i},a.streams=[t.stream],r.dispatchEvent(a)})},this.addEventListener("addstream",this._ontrackpoly)),t.apply(this,arguments)}}},r.shimGetSendersWithDtmf=function(e){if("object"===(void 0===e?"undefined":i(e))&&e.RTCPeerConnection&&!("getSenders"in e.RTCPeerConnection.prototype)&&"createDTMFSender"in e.RTCPeerConnection.prototype){var t=function(e,t){return{track:t,get dtmf(){return void 0===this._dtmf&&("audio"===t.kind?this._dtmf=e.createDTMFSender(t):this._dtmf=null),this._dtmf},_pc:e}};if(!e.RTCPeerConnection.prototype.getSenders){e.RTCPeerConnection.prototype.getSenders=function(){return this._senders=this._senders||[],this._senders.slice()};var r=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addTrack=function(e,n){var i=r.apply(this,arguments);return i||(i=t(this,e),this._senders.push(i)),i};var n=e.RTCPeerConnection.prototype.removeTrack;e.RTCPeerConnection.prototype.removeTrack=function(e){n.apply(this,arguments);var t=this._senders.indexOf(e);-1!==t&&this._senders.splice(t,1)}}var a=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(e){var r=this;this._senders=this._senders||[],a.apply(this,[e]),e.getTracks().forEach(function(e){r._senders.push(t(r,e))})};var o=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){var t=this;this._senders=this._senders||[],o.apply(this,[e]),e.getTracks().forEach(function(e){var r=t._senders.find(function(t){return t.track===e});r&&t._senders.splice(t._senders.indexOf(r),1)})}}else if("object"===(void 0===e?"undefined":i(e))&&e.RTCPeerConnection&&"getSenders"in e.RTCPeerConnection.prototype&&"createDTMFSender"in e.RTCPeerConnection.prototype&&e.RTCRtpSender&&!("dtmf"in e.RTCRtpSender.prototype)){var s=e.RTCPeerConnection.prototype.getSenders;e.RTCPeerConnection.prototype.getSenders=function(){var e=this,t=s.apply(this,[]);return t.forEach(function(t){return t._pc=e}),t},Object.defineProperty(e.RTCRtpSender.prototype,"dtmf",{get:function(){return void 0===this._dtmf&&("audio"===this.track.kind?this._dtmf=this._pc.createDTMFSender(this.track):this._dtmf=null),this._dtmf}})}},r.shimGetStats=function(e){if(e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(e,r,n){var i=this,a=arguments;if(arguments.length>0&&"function"==typeof e)return t.apply(this,arguments);if(0===t.length&&(0===arguments.length||"function"!=typeof arguments[0]))return t.apply(this,[]);var o=function(e){var t={};return e.result().forEach(function(e){var r={id:e.id,timestamp:e.timestamp,type:{localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[e.type]||e.type};e.names().forEach(function(t){r[t]=e.stat(t)}),t[r.id]=r}),t},s=function(e){return new Map(Object.keys(e).map(function(t){return[t,e[t]]}))};if(arguments.length>=2){var c=function(e){a[1](s(o(e)))};return t.apply(this,[c,arguments[0]])}return new Promise(function(e,r){t.apply(i,[function(t){e(s(o(t)))},r])}).then(r,n)}}},r.shimSenderReceiverGetStats=function(e){if("object"===(void 0===e?"undefined":i(e))&&e.RTCPeerConnection&&e.RTCRtpSender&&e.RTCRtpReceiver){if(!("getStats"in e.RTCRtpSender.prototype)){var t=e.RTCPeerConnection.prototype.getSenders;t&&(e.RTCPeerConnection.prototype.getSenders=function(){var e=this,r=t.apply(this,[]);return r.forEach(function(t){return t._pc=e}),r});var r=e.RTCPeerConnection.prototype.addTrack;r&&(e.RTCPeerConnection.prototype.addTrack=function(){var e=r.apply(this,arguments);return e._pc=this,e}),e.RTCRtpSender.prototype.getStats=function(){var e=this;return this._pc.getStats().then(function(t){return s.filterStats(t,e.track,!0)})}}if(!("getStats"in e.RTCRtpReceiver.prototype)){var n=e.RTCPeerConnection.prototype.getReceivers;n&&(e.RTCPeerConnection.prototype.getReceivers=function(){var e=this,t=n.apply(this,[]);return t.forEach(function(t){return t._pc=e}),t}),s.wrapPeerConnectionEvent(e,"track",function(e){return e.receiver._pc=e.srcElement,e}),e.RTCRtpReceiver.prototype.getStats=function(){var e=this;return this._pc.getStats().then(function(t){return s.filterStats(t,e.track,!1)})}}if("getStats"in e.RTCRtpSender.prototype&&"getStats"in e.RTCRtpReceiver.prototype){var a=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(){if(arguments.length>0&&arguments[0]instanceof e.MediaStreamTrack){var t=arguments[0],r=void 0,n=void 0,i=void 0;return this.getSenders().forEach(function(e){e.track===t&&(r?i=!0:r=e)}),this.getReceivers().forEach(function(e){return e.track===t&&(n?i=!0:n=e),e.track===t}),i||r&&n?Promise.reject(new DOMException("There are more than one sender or receiver for the track.","InvalidAccessError")):r?r.getStats():n?n.getStats():Promise.reject(new DOMException("There is no sender or receiver for the track.","InvalidAccessError"))}return a.apply(this,arguments)}}}},r.shimAddTrackRemoveTrackWithNative=n,r.shimAddTrackRemoveTrack=function(e){function t(e,t){var r=t.sdp;return Object.keys(e._reverseStreams||[]).forEach(function(t){var n=e._reverseStreams[t],i=e._streams[n.id];r=r.replace(new RegExp(i.id,"g"),n.id)}),new RTCSessionDescription({type:t.type,sdp:r})}function r(e,t){var r=t.sdp;return Object.keys(e._reverseStreams||[]).forEach(function(t){var n=e._reverseStreams[t],i=e._streams[n.id];r=r.replace(new RegExp(n.id,"g"),i.id)}),new RTCSessionDescription({type:t.type,sdp:r})}if(e.RTCPeerConnection){var i=s.detectBrowser(e);if(e.RTCPeerConnection.prototype.addTrack&&i.version>=65)return n(e);var a=e.RTCPeerConnection.prototype.getLocalStreams;e.RTCPeerConnection.prototype.getLocalStreams=function(){var e=this,t=a.apply(this);return this._reverseStreams=this._reverseStreams||{},t.map(function(t){return e._reverseStreams[t.id]})};var o=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(t){var r=this;if(this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},t.getTracks().forEach(function(e){if(r.getSenders().find(function(t){return t.track===e}))throw new DOMException("Track already exists.","InvalidAccessError")}),!this._reverseStreams[t.id]){var n=new e.MediaStream(t.getTracks());this._streams[t.id]=n,this._reverseStreams[n.id]=t,t=n}o.apply(this,[t])};var c=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},c.apply(this,[this._streams[e.id]||e]),delete this._reverseStreams[this._streams[e.id]?this._streams[e.id].id:e.id],delete this._streams[e.id]},e.RTCPeerConnection.prototype.addTrack=function(t,r){var n=this;if("closed"===this.signalingState)throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");var i=[].slice.call(arguments,1);if(1!==i.length||!i[0].getTracks().find(function(e){return e===t}))throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.","NotSupportedError");if(this.getSenders().find(function(e){return e.track===t}))throw new DOMException("Track already exists.","InvalidAccessError");this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{};var a=this._streams[r.id];if(a)a.addTrack(t),Promise.resolve().then(function(){n.dispatchEvent(new Event("negotiationneeded"))});else{var o=new e.MediaStream([t]);this._streams[r.id]=o,this._reverseStreams[o.id]=r,this.addStream(o)}return this.getSenders().find(function(e){return e.track===t})},["createOffer","createAnswer"].forEach(function(r){var n=e.RTCPeerConnection.prototype[r];e.RTCPeerConnection.prototype[r]=function(){var e=this,r=arguments;return arguments.length&&"function"==typeof arguments[0]?n.apply(this,[function(n){var i=t(e,n);r[0].apply(null,[i])},function(e){r[1]&&r[1].apply(null,e)},arguments[2]]):n.apply(this,arguments).then(function(r){return t(e,r)})}});var d=e.RTCPeerConnection.prototype.setLocalDescription;e.RTCPeerConnection.prototype.setLocalDescription=function(){return arguments.length&&arguments[0].type?(arguments[0]=r(this,arguments[0]),d.apply(this,arguments)):d.apply(this,arguments)};var p=Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype,"localDescription");Object.defineProperty(e.RTCPeerConnection.prototype,"localDescription",{get:function(){var e=p.get.apply(this);return""===e.type?e:t(this,e)}}),e.RTCPeerConnection.prototype.removeTrack=function(e){var t=this;if("closed"===this.signalingState)throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");if(!e._pc)throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.","TypeError");if(e._pc!==this)throw new DOMException("Sender was not created by this connection.","InvalidAccessError");this._streams=this._streams||{};var r=void 0;Object.keys(this._streams).forEach(function(n){t._streams[n].getTracks().find(function(t){return e.track===t})&&(r=t._streams[n])}),r&&(1===r.getTracks().length?this.removeStream(this._reverseStreams[r.id]):r.removeTrack(e.track),this.dispatchEvent(new Event("negotiationneeded")))}}},r.shimPeerConnection=function(e){if(!e.RTCPeerConnection&&e.webkitRTCPeerConnection&&(e.RTCPeerConnection=e.webkitRTCPeerConnection),e.RTCPeerConnection){["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(t){var r=e.RTCPeerConnection.prototype[t];e.RTCPeerConnection.prototype[t]=function(){return arguments[0]=new("addIceCandidate"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),r.apply(this,arguments)}});var t=e.RTCPeerConnection.prototype.addIceCandidate;e.RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?t.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())}}},r.fixNegotiationNeeded=function(e){s.wrapPeerConnectionEvent(e,"negotiationneeded",function(e){if("stable"===e.target.signalingState)return e})};var s=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(e("../utils.js"))},{"../utils.js":15,"./getdisplaymedia":4,"./getusermedia":5}],4:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=function(e,t){e.navigator.mediaDevices&&"getDisplayMedia"in e.navigator.mediaDevices||e.navigator.mediaDevices&&("function"==typeof t?e.navigator.mediaDevices.getDisplayMedia=function(r){return t(r).then(function(t){var n=r.video&&r.video.width,i=r.video&&r.video.height,a=r.video&&r.video.frameRate;return r.video={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:t,maxFrameRate:a||3}},n&&(r.video.mandatory.maxWidth=n),i&&(r.video.mandatory.maxHeight=i),e.navigator.mediaDevices.getUserMedia(r)})}:console.error("shimGetDisplayMedia: getSourceId argument is not a function"))}},{}],5:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.shimGetUserMedia=function(e){var t=e&&e.navigator;if(t.mediaDevices){var r=i.detectBrowser(e),o=function(e){if("object"!==(void 0===e?"undefined":n(e))||e.mandatory||e.optional)return e;var t={};return Object.keys(e).forEach(function(r){if("require"!==r&&"advanced"!==r&&"mediaSource"!==r){var i="object"===n(e[r])?e[r]:{ideal:e[r]};void 0!==i.exact&&"number"==typeof i.exact&&(i.min=i.max=i.exact);var a=function(e,t){return e?e+t.charAt(0).toUpperCase()+t.slice(1):"deviceId"===t?"sourceId":t};if(void 0!==i.ideal){t.optional=t.optional||[];var o={};"number"==typeof i.ideal?(o[a("min",r)]=i.ideal,t.optional.push(o),(o={})[a("max",r)]=i.ideal,t.optional.push(o)):(o[a("",r)]=i.ideal,t.optional.push(o))}void 0!==i.exact&&"number"!=typeof i.exact?(t.mandatory=t.mandatory||{},t.mandatory[a("",r)]=i.exact):["min","max"].forEach(function(e){void 0!==i[e]&&(t.mandatory=t.mandatory||{},t.mandatory[a(e,r)]=i[e])})}}),e.advanced&&(t.optional=(t.optional||[]).concat(e.advanced)),t},s=function(e,i){if(r.version>=61)return i(e);if((e=JSON.parse(JSON.stringify(e)))&&"object"===n(e.audio)){var s=function(e,t,r){t in e&&!(r in e)&&(e[r]=e[t],delete e[t])};s((e=JSON.parse(JSON.stringify(e))).audio,"autoGainControl","googAutoGainControl"),s(e.audio,"noiseSuppression","googNoiseSuppression"),e.audio=o(e.audio)}if(e&&"object"===n(e.video)){var c=e.video.facingMode;c=c&&("object"===(void 0===c?"undefined":n(c))?c:{ideal:c});var d=r.version<66;if(c&&("user"===c.exact||"environment"===c.exact||"user"===c.ideal||"environment"===c.ideal)&&(!t.mediaDevices.getSupportedConstraints||!t.mediaDevices.getSupportedConstraints().facingMode||d)){delete e.video.facingMode;var p=void 0;if("environment"===c.exact||"environment"===c.ideal?p=["back","rear"]:"user"!==c.exact&&"user"!==c.ideal||(p=["front"]),p)return t.mediaDevices.enumerateDevices().then(function(t){var r=(t=t.filter(function(e){return"videoinput"===e.kind})).find(function(e){return p.some(function(t){return e.label.toLowerCase().includes(t)})});return!r&&t.length&&p.includes("back")&&(r=t[t.length-1]),r&&(e.video.deviceId=c.exact?{exact:r.deviceId}:{ideal:r.deviceId}),e.video=o(e.video),a("chrome: "+JSON.stringify(e)),i(e)})}e.video=o(e.video)}return a("chrome: "+JSON.stringify(e)),i(e)},c=function(e){return r.version>=64?e:{name:{PermissionDeniedError:"NotAllowedError",PermissionDismissedError:"NotAllowedError",InvalidStateError:"NotAllowedError",DevicesNotFoundError:"NotFoundError",ConstraintNotSatisfiedError:"OverconstrainedError",TrackStartError:"NotReadableError",MediaDeviceFailedDueToShutdown:"NotAllowedError",MediaDeviceKillSwitchOn:"NotAllowedError",TabCaptureError:"AbortError",ScreenCaptureError:"AbortError",DeviceCaptureError:"AbortError"}[e.name]||e.name,message:e.message,constraint:e.constraint||e.constraintName,toString:function(){return this.name+(this.message&&": ")+this.message}}};if(t.getUserMedia=function(e,r,n){s(e,function(e){t.webkitGetUserMedia(e,r,function(e){n&&n(c(e))})})}.bind(t),t.mediaDevices.getUserMedia){var d=t.mediaDevices.getUserMedia.bind(t.mediaDevices);t.mediaDevices.getUserMedia=function(e){return s(e,function(e){return d(e).then(function(t){if(e.audio&&!t.getAudioTracks().length||e.video&&!t.getVideoTracks().length)throw t.getTracks().forEach(function(e){e.stop()}),new DOMException("","NotFoundError");return t},function(e){return Promise.reject(c(e))})})}}}};var i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(e("../utils.js")),a=i.log},{"../utils.js":15}],6:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.shimRTCIceCandidate=function(e){if(e.RTCIceCandidate&&!(e.RTCIceCandidate&&"foundation"in e.RTCIceCandidate.prototype)){var t=e.RTCIceCandidate;e.RTCIceCandidate=function(e){if("object"===(void 0===e?"undefined":n(e))&&e.candidate&&0===e.candidate.indexOf("a=")&&((e=JSON.parse(JSON.stringify(e))).candidate=e.candidate.substr(2)),e.candidate&&e.candidate.length){var r=new t(e),a=i.default.parseCandidate(e.candidate),o=Object.assign(r,a);return o.toJSON=function(){return{candidate:o.candidate,sdpMid:o.sdpMid,sdpMLineIndex:o.sdpMLineIndex,usernameFragment:o.usernameFragment}},o}return new t(e)},e.RTCIceCandidate.prototype=t.prototype,a.wrapPeerConnectionEvent(e,"icecandidate",function(t){return t.candidate&&Object.defineProperty(t,"candidate",{value:new e.RTCIceCandidate(t.candidate),writable:"false"}),t})}},r.shimMaxMessageSize=function(e){if(!e.RTCSctpTransport&&e.RTCPeerConnection){var t=a.detectBrowser(e);"sctp"in e.RTCPeerConnection.prototype||Object.defineProperty(e.RTCPeerConnection.prototype,"sctp",{get:function(){return void 0===this._sctp?null:this._sctp}});var r=function(e){if(!e||!e.sdp)return!1;var t=i.default.splitSections(e.sdp);return t.shift(),t.some(function(e){var t=i.default.parseMLine(e);return t&&"application"===t.kind&&-1!==t.protocol.indexOf("SCTP")})},n=function(e){var t=e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);if(null===t||t.length<2)return-1;var r=parseInt(t[1],10);return r!==r?-1:r},o=function(e){var r=65536;return"firefox"===t.browser&&(r=t.version<57?-1===e?16384:2147483637:t.version<60?57===t.version?65535:65536:2147483637),r},s=function(e,r){var n=65536;"firefox"===t.browser&&57===t.version&&(n=65535);var a=i.default.matchPrefix(e.sdp,"a=max-message-size:");return a.length>0?n=parseInt(a[0].substr(19),10):"firefox"===t.browser&&-1!==r&&(n=2147483637),n},c=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(){if(this._sctp=null,r(arguments[0])){var e=n(arguments[0]),t=o(e),i=s(arguments[0],e),a=void 0;a=0===t&&0===i?Number.POSITIVE_INFINITY:0===t||0===i?Math.max(t,i):Math.min(t,i);var d={};Object.defineProperty(d,"maxMessageSize",{get:function(){return a}}),this._sctp=d}return c.apply(this,arguments)}}},r.shimSendThrowTypeError=function(e){function t(e,t){var r=e.send;e.send=function(){var n=arguments[0],i=n.length||n.size||n.byteLength;if("open"===e.readyState&&t.sctp&&i>t.sctp.maxMessageSize)throw new TypeError("Message too large (can send a maximum of "+t.sctp.maxMessageSize+" bytes)");return r.apply(e,arguments)}}if(e.RTCPeerConnection&&"createDataChannel"in e.RTCPeerConnection.prototype){var r=e.RTCPeerConnection.prototype.createDataChannel;e.RTCPeerConnection.prototype.createDataChannel=function(){var e=r.apply(this,arguments);return t(e,this),e},a.wrapPeerConnectionEvent(e,"datachannel",function(e){return t(e.channel,e.target),e})}},r.shimConnectionState=function(e){if(e.RTCPeerConnection&&!("connectionState"in e.RTCPeerConnection.prototype)){var t=e.RTCPeerConnection.prototype;Object.defineProperty(t,"connectionState",{get:function(){return{completed:"connected",checking:"connecting"}[this.iceConnectionState]||this.iceConnectionState},enumerable:!0,configurable:!0}),Object.defineProperty(t,"onconnectionstatechange",{get:function(){return this._onconnectionstatechange||null},set:function(e){this._onconnectionstatechange&&(this.removeEventListener("connectionstatechange",this._onconnectionstatechange),delete this._onconnectionstatechange),e&&this.addEventListener("connectionstatechange",this._onconnectionstatechange=e)},enumerable:!0,configurable:!0}),["setLocalDescription","setRemoteDescription"].forEach(function(e){var r=t[e];t[e]=function(){return this._connectionstatechangepoly||(this._connectionstatechangepoly=function(e){var t=e.target;if(t._lastConnectionState!==t.connectionState){t._lastConnectionState=t.connectionState;var r=new Event("connectionstatechange",e);t.dispatchEvent(r)}return e},this.addEventListener("iceconnectionstatechange",this._connectionstatechangepoly)),r.apply(this,arguments)}})}},r.removeAllowExtmapMixed=function(e){if(e.RTCPeerConnection){var t=a.detectBrowser(e);if(!("chrome"===t.browser&&t.version>=71||"safari"===t.browser&&t.version>=605)){var r=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(e){return e&&e.sdp&&-1!==e.sdp.indexOf("\na=extmap-allow-mixed")&&(e.sdp=e.sdp.split("\n").filter(function(e){return"a=extmap-allow-mixed"!==e.trim()}).join("\n")),r.apply(this,arguments)}}}};var i=function(e){return e&&e.__esModule?e:{default:e}}(e("sdp")),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(e("./utils"))},{"./utils":15,sdp:17}],7:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=r.shimGetUserMedia=void 0;var n=e("./getusermedia");Object.defineProperty(r,"shimGetUserMedia",{enumerable:!0,get:function(){return n.shimGetUserMedia}});var i=e("./getdisplaymedia");Object.defineProperty(r,"shimGetDisplayMedia",{enumerable:!0,get:function(){return i.shimGetDisplayMedia}}),r.shimPeerConnection=function(e){var t=a.detectBrowser(e);if(e.RTCIceGatherer&&(e.RTCIceCandidate||(e.RTCIceCandidate=function(e){return e}),e.RTCSessionDescription||(e.RTCSessionDescription=function(e){return e}),t.version<15025)){var r=Object.getOwnPropertyDescriptor(e.MediaStreamTrack.prototype,"enabled");Object.defineProperty(e.MediaStreamTrack.prototype,"enabled",{set:function(e){r.set.call(this,e);var t=new Event("enabled");t.enabled=e,this.dispatchEvent(t)}})}!e.RTCRtpSender||"dtmf"in e.RTCRtpSender.prototype||Object.defineProperty(e.RTCRtpSender.prototype,"dtmf",{get:function(){return void 0===this._dtmf&&("audio"===this.track.kind?this._dtmf=new e.RTCDtmfSender(this):"video"===this.track.kind&&(this._dtmf=null)),this._dtmf}}),e.RTCDtmfSender&&!e.RTCDTMFSender&&(e.RTCDTMFSender=e.RTCDtmfSender);var n=(0,s.default)(e,t.version);e.RTCPeerConnection=function(e){return e&&e.iceServers&&(e.iceServers=(0,o.filterIceServers)(e.iceServers,t.version),a.log("ICE servers after filtering:",e.iceServers)),new n(e)},e.RTCPeerConnection.prototype=n.prototype},r.shimReplaceTrack=function(e){!e.RTCRtpSender||"replaceTrack"in e.RTCRtpSender.prototype||(e.RTCRtpSender.prototype.replaceTrack=e.RTCRtpSender.prototype.setTrack)};var a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(e("../utils")),o=e("./filtericeservers"),s=function(e){return e&&e.__esModule?e:{default:e}}(e("rtcpeerconnection-shim"))},{"../utils":15,"./filtericeservers":8,"./getdisplaymedia":9,"./getusermedia":10,"rtcpeerconnection-shim":16}],8:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.filterIceServers=function(e,t){var r=!1;return(e=JSON.parse(JSON.stringify(e))).filter(function(e){if(e&&(e.urls||e.url)){var t=e.urls||e.url;e.url&&!e.urls&&n.deprecated("RTCIceServer.url","RTCIceServer.urls");var i="string"==typeof t;return i&&(t=[t]),t=t.filter(function(e){if(0===e.indexOf("stun:"))return!1;var t=e.startsWith("turn")&&!e.startsWith("turn:[")&&e.includes("transport=udp");return t&&!r?(r=!0,!0):t&&!r}),delete e.url,e.urls=i?t[0]:t,!!t.length}})};var n=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(e("../utils"))},{"../utils":15}],9:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=function(e){"getDisplayMedia"in e.navigator&&e.navigator.mediaDevices&&(e.navigator.mediaDevices&&"getDisplayMedia"in e.navigator.mediaDevices||(e.navigator.mediaDevices.getDisplayMedia=e.navigator.getDisplayMedia.bind(e.navigator)))}},{}],10:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetUserMedia=function(e){var t=e&&e.navigator,r=function(e){return{name:{PermissionDeniedError:"NotAllowedError"}[e.name]||e.name,message:e.message,constraint:e.constraint,toString:function(){return this.name}}},n=t.mediaDevices.getUserMedia.bind(t.mediaDevices);t.mediaDevices.getUserMedia=function(e){return n(e).catch(function(e){return Promise.reject(r(e))})}}},{}],11:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=r.shimGetUserMedia=void 0;var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=e("./getusermedia");Object.defineProperty(r,"shimGetUserMedia",{enumerable:!0,get:function(){return i.shimGetUserMedia}});var a=e("./getdisplaymedia");Object.defineProperty(r,"shimGetDisplayMedia",{enumerable:!0,get:function(){return a.shimGetDisplayMedia}}),r.shimOnTrack=function(e){"object"===(void 0===e?"undefined":n(e))&&e.RTCTrackEvent&&"receiver"in e.RTCTrackEvent.prototype&&!("transceiver"in e.RTCTrackEvent.prototype)&&Object.defineProperty(e.RTCTrackEvent.prototype,"transceiver",{get:function(){return{receiver:this.receiver}}})},r.shimPeerConnection=function(e){var t=o.detectBrowser(e);if("object"===(void 0===e?"undefined":n(e))&&(e.RTCPeerConnection||e.mozRTCPeerConnection)){!e.RTCPeerConnection&&e.mozRTCPeerConnection&&(e.RTCPeerConnection=e.mozRTCPeerConnection),["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach(function(t){var r=e.RTCPeerConnection.prototype[t];e.RTCPeerConnection.prototype[t]=function(){return arguments[0]=new("addIceCandidate"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),r.apply(this,arguments)}});var r=e.RTCPeerConnection.prototype.addIceCandidate;e.RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?r.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())};var i={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"},a=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(e,r,n){return a.apply(this,[e||null]).then(function(e){if(t.version<53&&!r)try{e.forEach(function(e){e.type=i[e.type]||e.type})}catch(t){if("TypeError"!==t.name)throw t;e.forEach(function(t,r){e.set(r,Object.assign({},t,{type:i[t.type]||t.type}))})}return e}).then(r,n)}}},r.shimSenderGetStats=function(e){if("object"===(void 0===e?"undefined":n(e))&&e.RTCPeerConnection&&e.RTCRtpSender&&!(e.RTCRtpSender&&"getStats"in e.RTCRtpSender.prototype)){var t=e.RTCPeerConnection.prototype.getSenders;t&&(e.RTCPeerConnection.prototype.getSenders=function(){var e=this,r=t.apply(this,[]);return r.forEach(function(t){return t._pc=e}),r});var r=e.RTCPeerConnection.prototype.addTrack;r&&(e.RTCPeerConnection.prototype.addTrack=function(){var e=r.apply(this,arguments);return e._pc=this,e}),e.RTCRtpSender.prototype.getStats=function(){return this.track?this._pc.getStats(this.track):Promise.resolve(new Map)}}},r.shimReceiverGetStats=function(e){if("object"===(void 0===e?"undefined":n(e))&&e.RTCPeerConnection&&e.RTCRtpSender&&!(e.RTCRtpSender&&"getStats"in e.RTCRtpReceiver.prototype)){var t=e.RTCPeerConnection.prototype.getReceivers;t&&(e.RTCPeerConnection.prototype.getReceivers=function(){var e=this,r=t.apply(this,[]);return r.forEach(function(t){return t._pc=e}),r}),o.wrapPeerConnectionEvent(e,"track",function(e){return e.receiver._pc=e.srcElement,e}),e.RTCRtpReceiver.prototype.getStats=function(){return this._pc.getStats(this.track)}}},r.shimRemoveStream=function(e){!e.RTCPeerConnection||"removeStream"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.removeStream=function(e){var t=this;o.deprecated("removeStream","removeTrack"),this.getSenders().forEach(function(r){r.track&&e.getTracks().includes(r.track)&&t.removeTrack(r)})})},r.shimRTCDataChannel=function(e){e.DataChannel&&!e.RTCDataChannel&&(e.RTCDataChannel=e.DataChannel)};var o=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(e("../utils"))},{"../utils":15,"./getdisplaymedia":12,"./getusermedia":13}],12:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.shimGetDisplayMedia=function(e,t){e.navigator.mediaDevices&&"getDisplayMedia"in e.navigator.mediaDevices||e.navigator.mediaDevices&&(e.navigator.mediaDevices.getDisplayMedia=function(r){if(!r||!r.video){var n=new DOMException("getDisplayMedia without video constraints is undefined");return n.name="NotFoundError",n.code=8,Promise.reject(n)}return!0===r.video?r.video={mediaSource:t}:r.video.mediaSource=t,e.navigator.mediaDevices.getUserMedia(r)})}},{}],13:[function(e,t,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0});var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.shimGetUserMedia=function(e){var t=i.detectBrowser(e),r=e&&e.navigator,a=e&&e.MediaStreamTrack;if(r.getUserMedia=function(e,t,n){i.deprecated("navigator.getUserMedia","navigator.mediaDevices.getUserMedia"),r.mediaDevices.getUserMedia(e).then(t,n)},!(t.version>55&&"autoGainControl"in r.mediaDevices.getSupportedConstraints())){var o=function(e,t,r){t in e&&!(r in e)&&(e[r]=e[t],delete e[t])},s=r.mediaDevices.getUserMedia.bind(r.mediaDevices);if(r.mediaDevices.getUserMedia=function(e){return"object"===(void 0===e?"undefined":n(e))&&"object"===n(e.audio)&&(e=JSON.parse(JSON.stringify(e)),o(e.audio,"autoGainControl","mozAutoGainControl"),o(e.audio,"noiseSuppression","mozNoiseSuppression")),s(e)},a&&a.prototype.getSettings){var c=a.prototype.getSettings;a.prototype.getSettings=function(){var e=c.apply(this,arguments);return o(e,"mozAutoGainControl","autoGainControl"),o(e,"mozNoiseSuppression","noiseSuppression"),e}}if(a&&a.prototype.applyConstraints){var d=a.prototype.applyConstraints;a.prototype.applyConstraints=function(e){return"audio"===this.kind&&"object"===(void 0===e?"undefined":n(e))&&(e=JSON.parse(JSON.stringify(e)),o(e,"autoGainControl","mozAutoGainControl"),o(e,"noiseSuppression","mozNoiseSuppression")),d.apply(this,[e])}}}};var i=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(e("../utils"))},{"../utils":15}],14:[function(e,t,r){"use strict";function n(e){return e&&void 0!==e.video?Object.assign({},e,{video:a.compactObject(e.video)}):e}Object.defineProperty(r,"__esModule",{value:!0});var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.shimLocalStreamsAPI=function(e){if("object"===(void 0===e?"undefined":i(e))&&e.RTCPeerConnection){if("getLocalStreams"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getLocalStreams=function(){return this._localStreams||(this._localStreams=[]),this._localStreams}),!("addStream"in e.RTCPeerConnection.prototype)){var t=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addStream=function(e){var r=this;this._localStreams||(this._localStreams=[]),this._localStreams.includes(e)||this._localStreams.push(e),e.getTracks().forEach(function(n){return t.call(r,n,e)})},e.RTCPeerConnection.prototype.addTrack=function(e,r){return r&&(this._localStreams?this._localStreams.includes(r)||this._localStreams.push(r):this._localStreams=[r]),t.call(this,e,r)}}"removeStream"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.removeStream=function(e){var t=this;this._localStreams||(this._localStreams=[]);var r=this._localStreams.indexOf(e);if(-1!==r){this._localStreams.splice(r,1);var n=e.getTracks();this.getSenders().forEach(function(e){n.includes(e.track)&&t.removeTrack(e)})}})}},r.shimRemoteStreamsAPI=function(e){if("object"===(void 0===e?"undefined":i(e))&&e.RTCPeerConnection&&("getRemoteStreams"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getRemoteStreams=function(){return this._remoteStreams?this._remoteStreams:[]}),!("onaddstream"in e.RTCPeerConnection.prototype))){Object.defineProperty(e.RTCPeerConnection.prototype,"onaddstream",{get:function(){return this._onaddstream},set:function(e){var t=this;this._onaddstream&&(this.removeEventListener("addstream",this._onaddstream),this.removeEventListener("track",this._onaddstreampoly)),this.addEventListener("addstream",this._onaddstream=e),this.addEventListener("track",this._onaddstreampoly=function(e){e.streams.forEach(function(e){if(t._remoteStreams||(t._remoteStreams=[]),!t._remoteStreams.includes(e)){t._remoteStreams.push(e);var r=new Event("addstream");r.stream=e,t.dispatchEvent(r)}})})}});var t=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(){var e=this;return this._onaddstreampoly||this.addEventListener("track",this._onaddstreampoly=function(t){t.streams.forEach(function(t){if(e._remoteStreams||(e._remoteStreams=[]),!(e._remoteStreams.indexOf(t)>=0)){e._remoteStreams.push(t);var r=new Event("addstream");r.stream=t,e.dispatchEvent(r)}})}),t.apply(e,arguments)}}},r.shimCallbacksAPI=function(e){if("object"===(void 0===e?"undefined":i(e))&&e.RTCPeerConnection){var t=e.RTCPeerConnection.prototype,r=t.createOffer,n=t.createAnswer,a=t.setLocalDescription,o=t.setRemoteDescription,s=t.addIceCandidate;t.createOffer=function(e,t){var n=arguments.length>=2?arguments[2]:arguments[0],i=r.apply(this,[n]);return t?(i.then(e,t),Promise.resolve()):i},t.createAnswer=function(e,t){var r=arguments.length>=2?arguments[2]:arguments[0],i=n.apply(this,[r]);return t?(i.then(e,t),Promise.resolve()):i};var c=function(e,t,r){var n=a.apply(this,[e]);return r?(n.then(t,r),Promise.resolve()):n};t.setLocalDescription=c,c=function(e,t,r){var n=o.apply(this,[e]);return r?(n.then(t,r),Promise.resolve()):n},t.setRemoteDescription=c,c=function(e,t,r){var n=s.apply(this,[e]);return r?(n.then(t,r),Promise.resolve()):n},t.addIceCandidate=c}},r.shimGetUserMedia=function(e){var t=e&&e.navigator;if(t.mediaDevices&&t.mediaDevices.getUserMedia){var r=t.mediaDevices,i=r.getUserMedia.bind(r);t.mediaDevices.getUserMedia=function(e){return i(n(e))}}!t.getUserMedia&&t.mediaDevices&&t.mediaDevices.getUserMedia&&(t.getUserMedia=function(e,r,n){t.mediaDevices.getUserMedia(e).then(r,n)}.bind(t))},r.shimConstraints=n,r.shimRTCIceServerUrls=function(e){var t=e.RTCPeerConnection;e.RTCPeerConnection=function(e,r){if(e&&e.iceServers){for(var n=[],i=0;i<e.iceServers.length;i++){var o=e.iceServers[i];!o.hasOwnProperty("urls")&&o.hasOwnProperty("url")?(a.deprecated("RTCIceServer.url","RTCIceServer.urls"),(o=JSON.parse(JSON.stringify(o))).urls=o.url,delete o.url,n.push(o)):n.push(e.iceServers[i])}e.iceServers=n}return new t(e,r)},e.RTCPeerConnection.prototype=t.prototype,"generateCertificate"in e.RTCPeerConnection&&Object.defineProperty(e.RTCPeerConnection,"generateCertificate",{get:function(){return t.generateCertificate}})},r.shimTrackEventTransceiver=function(e){"object"===(void 0===e?"undefined":i(e))&&e.RTCPeerConnection&&"receiver"in e.RTCTrackEvent.prototype&&!e.RTCTransceiver&&Object.defineProperty(e.RTCTrackEvent.prototype,"transceiver",{get:function(){return{receiver:this.receiver}}})},r.shimCreateOfferLegacy=function(e){var t=e.RTCPeerConnection.prototype.createOffer;e.RTCPeerConnection.prototype.createOffer=function(e){if(e){void 0!==e.offerToReceiveAudio&&(e.offerToReceiveAudio=!!e.offerToReceiveAudio);var r=this.getTransceivers().find(function(e){return"audio"===e.receiver.track.kind});!1===e.offerToReceiveAudio&&r?"sendrecv"===r.direction?r.setDirection?r.setDirection("sendonly"):r.direction="sendonly":"recvonly"===r.direction&&(r.setDirection?r.setDirection("inactive"):r.direction="inactive"):!0!==e.offerToReceiveAudio||r||this.addTransceiver("audio"),void 0!==e.offerToReceiveVideo&&(e.offerToReceiveVideo=!!e.offerToReceiveVideo);var n=this.getTransceivers().find(function(e){return"video"===e.receiver.track.kind});!1===e.offerToReceiveVideo&&n?"sendrecv"===n.direction?n.setDirection?n.setDirection("sendonly"):n.direction="sendonly":"recvonly"===n.direction&&(n.setDirection?n.setDirection("inactive"):n.direction="inactive"):!0!==e.offerToReceiveVideo||n||this.addTransceiver("video")}return t.apply(this,arguments)}};var a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return t.default=e,t}(e("../utils"))},{"../utils":15}],15:[function(e,t,r){"use strict";function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t,r){var n=e.match(t);return n&&n.length>=r&&parseInt(n[r],10)}function a(e){return"object"!==(void 0===e?"undefined":s(e))?e:Object.keys(e).reduce(function(t,r){var i="object"===s(e[r]),o=i?a(e[r]):e[r],c=i&&!Object.keys(o).length;return void 0===o||c?t:Object.assign(t,n({},r,o))},{})}function o(e,t,r){t&&!r.has(t.id)&&(r.set(t.id,t),Object.keys(t).forEach(function(n){n.endsWith("Id")?o(e,e.get(t[n]),r):n.endsWith("Ids")&&t[n].forEach(function(t){o(e,e.get(t),r)})}))}Object.defineProperty(r,"__esModule",{value:!0});var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};r.extractVersion=i,r.wrapPeerConnectionEvent=function(e,t,r){if(e.RTCPeerConnection){var n=e.RTCPeerConnection.prototype,i=n.addEventListener;n.addEventListener=function(e,n){if(e!==t)return i.apply(this,arguments);var a=function(e){var t=r(e);t&&n(t)};return this._eventMap=this._eventMap||{},this._eventMap[n]=a,i.apply(this,[e,a])};var a=n.removeEventListener;n.removeEventListener=function(e,r){if(e!==t||!this._eventMap||!this._eventMap[r])return a.apply(this,arguments);var n=this._eventMap[r];return delete this._eventMap[r],a.apply(this,[e,n])},Object.defineProperty(n,"on"+t,{get:function(){return this["_on"+t]},set:function(e){this["_on"+t]&&(this.removeEventListener(t,this["_on"+t]),delete this["_on"+t]),e&&this.addEventListener(t,this["_on"+t]=e)},enumerable:!0,configurable:!0})}},r.disableLog=function(e){return"boolean"!=typeof e?new Error("Argument type: "+(void 0===e?"undefined":s(e))+". Please use a boolean."):(c=e,e?"adapter.js logging disabled":"adapter.js logging enabled")},r.disableWarnings=function(e){return"boolean"!=typeof e?new Error("Argument type: "+(void 0===e?"undefined":s(e))+". Please use a boolean."):(d=!e,"adapter.js deprecation warnings "+(e?"disabled":"enabled"))},r.log=function(){if("object"===("undefined"==typeof window?"undefined":s(window))){if(c)return;"undefined"!=typeof console&&"function"==typeof console.log&&console.log.apply(console,arguments)}},r.deprecated=function(e,t){d&&console.warn(e+" is deprecated, please use "+t+" instead.")},r.detectBrowser=function(e){var t=e.navigator,r={browser:null,version:null};if(void 0===e||!e.navigator)return r.browser="Not a browser.",r;if(t.mozGetUserMedia)r.browser="firefox",r.version=i(t.userAgent,/Firefox\/(\d+)\./,1);else if(t.webkitGetUserMedia||!1===e.isSecureContext&&e.webkitRTCPeerConnection&&!e.RTCIceGatherer)r.browser="chrome",r.version=i(t.userAgent,/Chrom(e|ium)\/(\d+)\./,2);else if(t.mediaDevices&&t.userAgent.match(/Edge\/(\d+).(\d+)$/))r.browser="edge",r.version=i(t.userAgent,/Edge\/(\d+).(\d+)$/,2);else{if(!e.RTCPeerConnection||!t.userAgent.match(/AppleWebKit\/(\d+)\./))return r.browser="Not a supported browser.",r;r.browser="safari",r.version=i(t.userAgent,/AppleWebKit\/(\d+)\./,1)}return r},r.compactObject=a,r.walkStats=o,r.filterStats=function(e,t,r){var n=r?"outbound-rtp":"inbound-rtp",i=new Map;if(null===t)return i;var a=[];return e.forEach(function(e){"track"===e.type&&e.trackIdentifier===t.id&&a.push(e)}),a.forEach(function(t){e.forEach(function(r){r.type===n&&r.trackId===t.id&&o(e,r,i)})}),i};var c=!0,d=!0},{}],16:[function(e,t,r){"use strict";function n(e){return{inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[e.type]||e.type}function i(e,t,r,n,i){var a=p.writeRtpDescription(e.kind,t);if(a+=p.writeIceParameters(e.iceGatherer.getLocalParameters()),a+=p.writeDtlsParameters(e.dtlsTransport.getLocalParameters(),"offer"===r?"actpass":i||"active"),a+="a=mid:"+e.mid+"\r\n",e.rtpSender&&e.rtpReceiver?a+="a=sendrecv\r\n":e.rtpSender?a+="a=sendonly\r\n":e.rtpReceiver?a+="a=recvonly\r\n":a+="a=inactive\r\n",e.rtpSender){var o=e.rtpSender._initialTrackId||e.rtpSender.track.id;e.rtpSender._initialTrackId=o;var s="msid:"+(n?n.id:"-")+" "+o+"\r\n";a+="a="+s,a+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" "+s,e.sendEncodingParameters[0].rtx&&(a+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" "+s,a+="a=ssrc-group:FID "+e.sendEncodingParameters[0].ssrc+" "+e.sendEncodingParameters[0].rtx.ssrc+"\r\n")}return a+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" cname:"+p.localCName+"\r\n",e.rtpSender&&e.sendEncodingParameters[0].rtx&&(a+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" cname:"+p.localCName+"\r\n"),a}function a(e,t){var r=!1;return(e=JSON.parse(JSON.stringify(e))).filter(function(e){if(e&&(e.urls||e.url)){var n=e.urls||e.url;e.url&&!e.urls&&console.warn("RTCIceServer.url is deprecated! Use urls instead.");var i="string"==typeof n;return i&&(n=[n]),n=n.filter(function(e){return 0===e.indexOf("turn:")&&-1!==e.indexOf("transport=udp")&&-1===e.indexOf("turn:[")&&!r?(r=!0,!0):0===e.indexOf("stun:")&&t>=14393&&-1===e.indexOf("?transport=udp")}),delete e.url,e.urls=i?n[0]:n,!!n.length}})}function o(e,t){var r={codecs:[],headerExtensions:[],fecMechanisms:[]},n=function(e,t){e=parseInt(e,10);for(var r=0;r<t.length;r++)if(t[r].payloadType===e||t[r].preferredPayloadType===e)return t[r]},i=function(e,t,r,i){var a=n(e.parameters.apt,r),o=n(t.parameters.apt,i);return a&&o&&a.name.toLowerCase()===o.name.toLowerCase()};return e.codecs.forEach(function(n){for(var a=0;a<t.codecs.length;a++){var o=t.codecs[a];if(n.name.toLowerCase()===o.name.toLowerCase()&&n.clockRate===o.clockRate){if("rtx"===n.name.toLowerCase()&&n.parameters&&o.parameters.apt&&!i(n,o,e.codecs,t.codecs))continue;(o=JSON.parse(JSON.stringify(o))).numChannels=Math.min(n.numChannels,o.numChannels),r.codecs.push(o),o.rtcpFeedback=o.rtcpFeedback.filter(function(e){for(var t=0;t<n.rtcpFeedback.length;t++)if(n.rtcpFeedback[t].type===e.type&&n.rtcpFeedback[t].parameter===e.parameter)return!0;return!1});break}}}),e.headerExtensions.forEach(function(e){for(var n=0;n<t.headerExtensions.length;n++){var i=t.headerExtensions[n];if(e.uri===i.uri){r.headerExtensions.push(i);break}}}),r}function s(e,t,r){return-1!=={offer:{setLocalDescription:["stable","have-local-offer"],setRemoteDescription:["stable","have-remote-offer"]},answer:{setLocalDescription:["have-remote-offer","have-local-pranswer"],setRemoteDescription:["have-local-offer","have-remote-pranswer"]}}[t][e].indexOf(r)}function c(e,t){var r=e.getRemoteCandidates().find(function(e){return t.foundation===e.foundation&&t.ip===e.ip&&t.port===e.port&&t.priority===e.priority&&t.protocol===e.protocol&&t.type===e.type});return r||e.addRemoteCandidate(t),!r}function d(e,t){var r=new Error(t);return r.name=e,r.code={NotSupportedError:9,InvalidStateError:11,InvalidAccessError:15,TypeError:void 0,OperationError:void 0}[e],r}var p=e("sdp");t.exports=function(e,t){function r(t,r){r.addTrack(t),r.dispatchEvent(new e.MediaStreamTrackEvent("addtrack",{track:t}))}function u(t,r){r.removeTrack(t),r.dispatchEvent(new e.MediaStreamTrackEvent("removetrack",{track:t}))}function f(t,r,n,i){var a=new Event("track");a.track=r,a.receiver=n,a.transceiver={receiver:n},a.streams=i,e.setTimeout(function(){t._dispatchEvent("track",a)})}var l=function(r){var n=this,i=document.createDocumentFragment();if(["addEventListener","removeEventListener","dispatchEvent"].forEach(function(e){n[e]=i[e].bind(i)}),this.canTrickleIceCandidates=null,this.needNegotiation=!1,this.localStreams=[],this.remoteStreams=[],this._localDescription=null,this._remoteDescription=null,this.signalingState="stable",this.iceConnectionState="new",this.connectionState="new",this.iceGatheringState="new",r=JSON.parse(JSON.stringify(r||{})),this.usingBundle="max-bundle"===r.bundlePolicy,"negotiate"===r.rtcpMuxPolicy)throw d("NotSupportedError","rtcpMuxPolicy 'negotiate' is not supported");switch(r.rtcpMuxPolicy||(r.rtcpMuxPolicy="require"),r.iceTransportPolicy){case"all":case"relay":break;default:r.iceTransportPolicy="all"}switch(r.bundlePolicy){case"balanced":case"max-compat":case"max-bundle":break;default:r.bundlePolicy="balanced"}if(r.iceServers=a(r.iceServers||[],t),this._iceGatherers=[],r.iceCandidatePoolSize)for(var o=r.iceCandidatePoolSize;o>0;o--)this._iceGatherers.push(new e.RTCIceGatherer({iceServers:r.iceServers,gatherPolicy:r.iceTransportPolicy}));else r.iceCandidatePoolSize=0;this._config=r,this.transceivers=[],this._sdpSessionId=p.generateSessionId(),this._sdpSessionVersion=0,this._dtlsRole=void 0,this._isClosed=!1};Object.defineProperty(l.prototype,"localDescription",{configurable:!0,get:function(){return this._localDescription}}),Object.defineProperty(l.prototype,"remoteDescription",{configurable:!0,get:function(){return this._remoteDescription}}),l.prototype.onicecandidate=null,l.prototype.onaddstream=null,l.prototype.ontrack=null,l.prototype.onremovestream=null,l.prototype.onsignalingstatechange=null,l.prototype.oniceconnectionstatechange=null,l.prototype.onconnectionstatechange=null,l.prototype.onicegatheringstatechange=null,l.prototype.onnegotiationneeded=null,l.prototype.ondatachannel=null,l.prototype._dispatchEvent=function(e,t){this._isClosed||(this.dispatchEvent(t),"function"==typeof this["on"+e]&&this["on"+e](t))},l.prototype._emitGatheringStateChange=function(){var e=new Event("icegatheringstatechange");this._dispatchEvent("icegatheringstatechange",e)},l.prototype.getConfiguration=function(){return this._config},l.prototype.getLocalStreams=function(){return this.localStreams},l.prototype.getRemoteStreams=function(){return this.remoteStreams},l.prototype._createTransceiver=function(e,t){var r=this.transceivers.length>0,n={track:null,iceGatherer:null,iceTransport:null,dtlsTransport:null,localCapabilities:null,remoteCapabilities:null,rtpSender:null,rtpReceiver:null,kind:e,mid:null,sendEncodingParameters:null,recvEncodingParameters:null,stream:null,associatedRemoteMediaStreams:[],wantReceive:!0};if(this.usingBundle&&r)n.iceTransport=this.transceivers[0].iceTransport,n.dtlsTransport=this.transceivers[0].dtlsTransport;else{var i=this._createIceAndDtlsTransports();n.iceTransport=i.iceTransport,n.dtlsTransport=i.dtlsTransport}return t||this.transceivers.push(n),n},l.prototype.addTrack=function(t,r){if(this._isClosed)throw d("InvalidStateError","Attempted to call addTrack on a closed peerconnection.");if(this.transceivers.find(function(e){return e.track===t}))throw d("InvalidAccessError","Track already exists.");for(var n,i=0;i<this.transceivers.length;i++)this.transceivers[i].track||this.transceivers[i].kind!==t.kind||(n=this.transceivers[i]);return n||(n=this._createTransceiver(t.kind)),this._maybeFireNegotiationNeeded(),-1===this.localStreams.indexOf(r)&&this.localStreams.push(r),n.track=t,n.stream=r,n.rtpSender=new e.RTCRtpSender(t,n.dtlsTransport),n.rtpSender},l.prototype.addStream=function(e){var r=this;if(t>=15025)e.getTracks().forEach(function(t){r.addTrack(t,e)});else{var n=e.clone();e.getTracks().forEach(function(e,t){var r=n.getTracks()[t];e.addEventListener("enabled",function(e){r.enabled=e.enabled})}),n.getTracks().forEach(function(e){r.addTrack(e,n)})}},l.prototype.removeTrack=function(t){if(this._isClosed)throw d("InvalidStateError","Attempted to call removeTrack on a closed peerconnection.");if(!(t instanceof e.RTCRtpSender))throw new TypeError("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.");var r=this.transceivers.find(function(e){return e.rtpSender===t});if(!r)throw d("InvalidAccessError","Sender was not created by this connection.");var n=r.stream;r.rtpSender.stop(),r.rtpSender=null,r.track=null,r.stream=null,-1===this.transceivers.map(function(e){return e.stream}).indexOf(n)&&this.localStreams.indexOf(n)>-1&&this.localStreams.splice(this.localStreams.indexOf(n),1),this._maybeFireNegotiationNeeded()},l.prototype.removeStream=function(e){var t=this;e.getTracks().forEach(function(e){var r=t.getSenders().find(function(t){return t.track===e});r&&t.removeTrack(r)})},l.prototype.getSenders=function(){return this.transceivers.filter(function(e){return!!e.rtpSender}).map(function(e){return e.rtpSender})},l.prototype.getReceivers=function(){return this.transceivers.filter(function(e){return!!e.rtpReceiver}).map(function(e){return e.rtpReceiver})},l.prototype._createIceGatherer=function(t,r){var n=this;if(r&&t>0)return this.transceivers[0].iceGatherer;if(this._iceGatherers.length)return this._iceGatherers.shift();var i=new e.RTCIceGatherer({iceServers:this._config.iceServers,gatherPolicy:this._config.iceTransportPolicy});return Object.defineProperty(i,"state",{value:"new",writable:!0}),this.transceivers[t].bufferedCandidateEvents=[],this.transceivers[t].bufferCandidates=function(e){var r=!e.candidate||0===Object.keys(e.candidate).length;i.state=r?"completed":"gathering",null!==n.transceivers[t].bufferedCandidateEvents&&n.transceivers[t].bufferedCandidateEvents.push(e)},i.addEventListener("localcandidate",this.transceivers[t].bufferCandidates),i},l.prototype._gather=function(t,r){var n=this,i=this.transceivers[r].iceGatherer;if(!i.onlocalcandidate){var a=this.transceivers[r].bufferedCandidateEvents;this.transceivers[r].bufferedCandidateEvents=null,i.removeEventListener("localcandidate",this.transceivers[r].bufferCandidates),i.onlocalcandidate=function(e){if(!(n.usingBundle&&r>0)){var a=new Event("icecandidate");a.candidate={sdpMid:t,sdpMLineIndex:r};var o=e.candidate,s=!o||0===Object.keys(o).length;if(s)"new"!==i.state&&"gathering"!==i.state||(i.state="completed");else{"new"===i.state&&(i.state="gathering"),o.component=1,o.ufrag=i.getLocalParameters().usernameFragment;var c=p.writeCandidate(o);a.candidate=Object.assign(a.candidate,p.parseCandidate(c)),a.candidate.candidate=c,a.candidate.toJSON=function(){return{candidate:a.candidate.candidate,sdpMid:a.candidate.sdpMid,sdpMLineIndex:a.candidate.sdpMLineIndex,usernameFragment:a.candidate.usernameFragment}}}var d=p.getMediaSections(n._localDescription.sdp);d[a.candidate.sdpMLineIndex]+=s?"a=end-of-candidates\r\n":"a="+a.candidate.candidate+"\r\n",n._localDescription.sdp=p.getDescription(n._localDescription.sdp)+d.join("");var u=n.transceivers.every(function(e){return e.iceGatherer&&"completed"===e.iceGatherer.state});"gathering"!==n.iceGatheringState&&(n.iceGatheringState="gathering",n._emitGatheringStateChange()),s||n._dispatchEvent("icecandidate",a),u&&(n._dispatchEvent("icecandidate",new Event("icecandidate")),n.iceGatheringState="complete",n._emitGatheringStateChange())}},e.setTimeout(function(){a.forEach(function(e){i.onlocalcandidate(e)})},0)}},l.prototype._createIceAndDtlsTransports=function(){var t=this,r=new e.RTCIceTransport(null);r.onicestatechange=function(){t._updateIceConnectionState(),t._updateConnectionState()};var n=new e.RTCDtlsTransport(r);return n.ondtlsstatechange=function(){t._updateConnectionState()},n.onerror=function(){Object.defineProperty(n,"state",{value:"failed",writable:!0}),t._updateConnectionState()},{iceTransport:r,dtlsTransport:n}},l.prototype._disposeIceAndDtlsTransports=function(e){var t=this.transceivers[e].iceGatherer;t&&(delete t.onlocalcandidate,delete this.transceivers[e].iceGatherer);var r=this.transceivers[e].iceTransport;r&&(delete r.onicestatechange,delete this.transceivers[e].iceTransport);var n=this.transceivers[e].dtlsTransport;n&&(delete n.ondtlsstatechange,delete n.onerror,delete this.transceivers[e].dtlsTransport)},l.prototype._transceive=function(e,r,n){var i=o(e.localCapabilities,e.remoteCapabilities);r&&e.rtpSender&&(i.encodings=e.sendEncodingParameters,i.rtcp={cname:p.localCName,compound:e.rtcpParameters.compound},e.recvEncodingParameters.length&&(i.rtcp.ssrc=e.recvEncodingParameters[0].ssrc),e.rtpSender.send(i)),n&&e.rtpReceiver&&i.codecs.length>0&&("video"===e.kind&&e.recvEncodingParameters&&t<15019&&e.recvEncodingParameters.forEach(function(e){delete e.rtx}),e.recvEncodingParameters.length?i.encodings=e.recvEncodingParameters:i.encodings=[{}],i.rtcp={compound:e.rtcpParameters.compound},e.rtcpParameters.cname&&(i.rtcp.cname=e.rtcpParameters.cname),e.sendEncodingParameters.length&&(i.rtcp.ssrc=e.sendEncodingParameters[0].ssrc),e.rtpReceiver.receive(i))},l.prototype.setLocalDescription=function(e){var t=this;if(-1===["offer","answer"].indexOf(e.type))return Promise.reject(d("TypeError",'Unsupported type "'+e.type+'"'));if(!s("setLocalDescription",e.type,t.signalingState)||t._isClosed)return Promise.reject(d("InvalidStateError","Can not set local "+e.type+" in state "+t.signalingState));var r,n;if("offer"===e.type)r=p.splitSections(e.sdp),n=r.shift(),r.forEach(function(e,r){var n=p.parseRtpParameters(e);t.transceivers[r].localCapabilities=n}),t.transceivers.forEach(function(e,r){t._gather(e.mid,r)});else if("answer"===e.type){r=p.splitSections(t._remoteDescription.sdp),n=r.shift();var i=p.matchPrefix(n,"a=ice-lite").length>0;r.forEach(function(e,r){var a=t.transceivers[r],s=a.iceGatherer,c=a.iceTransport,d=a.dtlsTransport,u=a.localCapabilities,f=a.remoteCapabilities;if(!(p.isRejected(e)&&0===p.matchPrefix(e,"a=bundle-only").length)&&!a.rejected){var l=p.getIceParameters(e,n),m=p.getDtlsParameters(e,n);i&&(m.role="server"),t.usingBundle&&0!==r||(t._gather(a.mid,r),"new"===c.state&&c.start(s,l,i?"controlling":"controlled"),"new"===d.state&&d.start(m));var h=o(u,f);t._transceive(a,h.codecs.length>0,!1)}})}return t._localDescription={type:e.type,sdp:e.sdp},"offer"===e.type?t._updateSignalingState("have-local-offer"):t._updateSignalingState("stable"),Promise.resolve()},l.prototype.setRemoteDescription=function(n){var i=this;if(-1===["offer","answer"].indexOf(n.type))return Promise.reject(d("TypeError",'Unsupported type "'+n.type+'"'));if(!s("setRemoteDescription",n.type,i.signalingState)||i._isClosed)return Promise.reject(d("InvalidStateError","Can not set remote "+n.type+" in state "+i.signalingState));var a={};i.remoteStreams.forEach(function(e){a[e.id]=e});var l=[],m=p.splitSections(n.sdp),h=m.shift(),v=p.matchPrefix(h,"a=ice-lite").length>0,y=p.matchPrefix(h,"a=group:BUNDLE ").length>0;i.usingBundle=y;var g=p.matchPrefix(h,"a=ice-options:")[0];return i.canTrickleIceCandidates=!!g&&g.substr(14).split(" ").indexOf("trickle")>=0,m.forEach(function(s,d){var f=p.splitLines(s),m=p.getKind(s),g=p.isRejected(s)&&0===p.matchPrefix(s,"a=bundle-only").length,C=f[0].substr(2).split(" ")[2],S=p.getDirection(s,h),T=p.parseMsid(s),R=p.getMid(s)||p.generateIdentifier();if(g||"application"===m&&("DTLS/SCTP"===C||"UDP/DTLS/SCTP"===C))i.transceivers[d]={mid:R,kind:m,protocol:C,rejected:!0};else{!g&&i.transceivers[d]&&i.transceivers[d].rejected&&(i.transceivers[d]=i._createTransceiver(m,!0));var P,b,E,_,w,k,M,D,x,O,I,j=p.parseRtpParameters(s);g||(O=p.getIceParameters(s,h),(I=p.getDtlsParameters(s,h)).role="client"),M=p.parseRtpEncodingParameters(s);var L=p.parseRtcpParameters(s),G=p.matchPrefix(s,"a=end-of-candidates",h).length>0,A=p.matchPrefix(s,"a=candidate:").map(function(e){return p.parseCandidate(e)}).filter(function(e){return 1===e.component});if(("offer"===n.type||"answer"===n.type)&&!g&&y&&d>0&&i.transceivers[d]&&(i._disposeIceAndDtlsTransports(d),i.transceivers[d].iceGatherer=i.transceivers[0].iceGatherer,i.transceivers[d].iceTransport=i.transceivers[0].iceTransport,i.transceivers[d].dtlsTransport=i.transceivers[0].dtlsTransport,i.transceivers[d].rtpSender&&i.transceivers[d].rtpSender.setTransport(i.transceivers[0].dtlsTransport),i.transceivers[d].rtpReceiver&&i.transceivers[d].rtpReceiver.setTransport(i.transceivers[0].dtlsTransport)),"offer"!==n.type||g)"answer"!==n.type||g||(b=(P=i.transceivers[d]).iceGatherer,E=P.iceTransport,_=P.dtlsTransport,w=P.rtpReceiver,k=P.sendEncodingParameters,D=P.localCapabilities,i.transceivers[d].recvEncodingParameters=M,i.transceivers[d].remoteCapabilities=j,i.transceivers[d].rtcpParameters=L,A.length&&"new"===E.state&&(!v&&!G||y&&0!==d?A.forEach(function(e){c(P.iceTransport,e)}):E.setRemoteCandidates(A)),y&&0!==d||("new"===E.state&&E.start(b,O,"controlling"),"new"===_.state&&_.start(I)),!o(P.localCapabilities,P.remoteCapabilities).codecs.filter(function(e){return"rtx"===e.name.toLowerCase()}).length&&P.sendEncodingParameters[0].rtx&&delete P.sendEncodingParameters[0].rtx,i._transceive(P,"sendrecv"===S||"recvonly"===S,"sendrecv"===S||"sendonly"===S),!w||"sendrecv"!==S&&"sendonly"!==S?delete P.rtpReceiver:(x=w.track,T?(a[T.stream]||(a[T.stream]=new e.MediaStream),r(x,a[T.stream]),l.push([x,w,a[T.stream]])):(a.default||(a.default=new e.MediaStream),r(x,a.default),l.push([x,w,a.default]))));else{(P=i.transceivers[d]||i._createTransceiver(m)).mid=R,P.iceGatherer||(P.iceGatherer=i._createIceGatherer(d,y)),A.length&&"new"===P.iceTransport.state&&(!G||y&&0!==d?A.forEach(function(e){c(P.iceTransport,e)}):P.iceTransport.setRemoteCandidates(A)),D=e.RTCRtpReceiver.getCapabilities(m),t<15019&&(D.codecs=D.codecs.filter(function(e){return"rtx"!==e.name})),k=P.sendEncodingParameters||[{ssrc:1001*(2*d+2)}];var N=!1;if("sendrecv"===S||"sendonly"===S){if(N=!P.rtpReceiver,w=P.rtpReceiver||new e.RTCRtpReceiver(P.dtlsTransport,m),N){var U;x=w.track,T&&"-"===T.stream||(T?(a[T.stream]||(a[T.stream]=new e.MediaStream,Object.defineProperty(a[T.stream],"id",{get:function(){return T.stream}})),Object.defineProperty(x,"id",{get:function(){return T.track}}),U=a[T.stream]):(a.default||(a.default=new e.MediaStream),U=a.default)),U&&(r(x,U),P.associatedRemoteMediaStreams.push(U)),l.push([x,w,U])}}else P.rtpReceiver&&P.rtpReceiver.track&&(P.associatedRemoteMediaStreams.forEach(function(e){var t=e.getTracks().find(function(e){return e.id===P.rtpReceiver.track.id});t&&u(t,e)}),P.associatedRemoteMediaStreams=[]);P.localCapabilities=D,P.remoteCapabilities=j,P.rtpReceiver=w,P.rtcpParameters=L,P.sendEncodingParameters=k,P.recvEncodingParameters=M,i._transceive(i.transceivers[d],!1,N)}}}),void 0===i._dtlsRole&&(i._dtlsRole="offer"===n.type?"active":"passive"),i._remoteDescription={type:n.type,sdp:n.sdp},"offer"===n.type?i._updateSignalingState("have-remote-offer"):i._updateSignalingState("stable"),Object.keys(a).forEach(function(t){var r=a[t];if(r.getTracks().length){if(-1===i.remoteStreams.indexOf(r)){i.remoteStreams.push(r);var n=new Event("addstream");n.stream=r,e.setTimeout(function(){i._dispatchEvent("addstream",n)})}l.forEach(function(e){var t=e[0],n=e[1];r.id===e[2].id&&f(i,t,n,[r])})}}),l.forEach(function(e){e[2]||f(i,e[0],e[1],[])}),e.setTimeout(function(){i&&i.transceivers&&i.transceivers.forEach(function(e){e.iceTransport&&"new"===e.iceTransport.state&&e.iceTransport.getRemoteCandidates().length>0&&(console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"),e.iceTransport.addRemoteCandidate({}))})},4e3),Promise.resolve()},l.prototype.close=function(){this.transceivers.forEach(function(e){e.iceTransport&&e.iceTransport.stop(),e.dtlsTransport&&e.dtlsTransport.stop(),e.rtpSender&&e.rtpSender.stop(),e.rtpReceiver&&e.rtpReceiver.stop()}),this._isClosed=!0,this._updateSignalingState("closed")},l.prototype._updateSignalingState=function(e){this.signalingState=e;var t=new Event("signalingstatechange");this._dispatchEvent("signalingstatechange",t)},l.prototype._maybeFireNegotiationNeeded=function(){var t=this;"stable"===this.signalingState&&!0!==this.needNegotiation&&(this.needNegotiation=!0,e.setTimeout(function(){if(t.needNegotiation){t.needNegotiation=!1;var e=new Event("negotiationneeded");t._dispatchEvent("negotiationneeded",e)}},0))},l.prototype._updateIceConnectionState=function(){var e,t={new:0,closed:0,checking:0,connected:0,completed:0,disconnected:0,failed:0};if(this.transceivers.forEach(function(e){e.iceTransport&&!e.rejected&&t[e.iceTransport.state]++}),e="new",t.failed>0?e="failed":t.checking>0?e="checking":t.disconnected>0?e="disconnected":t.new>0?e="new":t.connected>0?e="connected":t.completed>0&&(e="completed"),e!==this.iceConnectionState){this.iceConnectionState=e;var r=new Event("iceconnectionstatechange");this._dispatchEvent("iceconnectionstatechange",r)}},l.prototype._updateConnectionState=function(){var e,t={new:0,closed:0,connecting:0,connected:0,completed:0,disconnected:0,failed:0};if(this.transceivers.forEach(function(e){e.iceTransport&&e.dtlsTransport&&!e.rejected&&(t[e.iceTransport.state]++,t[e.dtlsTransport.state]++)}),t.connected+=t.completed,e="new",t.failed>0?e="failed":t.connecting>0?e="connecting":t.disconnected>0?e="disconnected":t.new>0?e="new":t.connected>0&&(e="connected"),e!==this.connectionState){this.connectionState=e;var r=new Event("connectionstatechange");this._dispatchEvent("connectionstatechange",r)}},l.prototype.createOffer=function(){var r=this;if(r._isClosed)return Promise.reject(d("InvalidStateError","Can not call createOffer after close"));var n=r.transceivers.filter(function(e){return"audio"===e.kind}).length,a=r.transceivers.filter(function(e){return"video"===e.kind}).length,o=arguments[0];if(o){if(o.mandatory||o.optional)throw new TypeError("Legacy mandatory/optional constraints not supported.");void 0!==o.offerToReceiveAudio&&(n=!0===o.offerToReceiveAudio?1:!1===o.offerToReceiveAudio?0:o.offerToReceiveAudio),void 0!==o.offerToReceiveVideo&&(a=!0===o.offerToReceiveVideo?1:!1===o.offerToReceiveVideo?0:o.offerToReceiveVideo)}for(r.transceivers.forEach(function(e){"audio"===e.kind?--n<0&&(e.wantReceive=!1):"video"===e.kind&&--a<0&&(e.wantReceive=!1)});n>0||a>0;)n>0&&(r._createTransceiver("audio"),n--),a>0&&(r._createTransceiver("video"),a--);var s=p.writeSessionBoilerplate(r._sdpSessionId,r._sdpSessionVersion++);r.transceivers.forEach(function(n,i){var a=n.track,o=n.kind,s=n.mid||p.generateIdentifier();n.mid=s,n.iceGatherer||(n.iceGatherer=r._createIceGatherer(i,r.usingBundle));var c=e.RTCRtpSender.getCapabilities(o);t<15019&&(c.codecs=c.codecs.filter(function(e){return"rtx"!==e.name})),c.codecs.forEach(function(e){"H264"===e.name&&void 0===e.parameters["level-asymmetry-allowed"]&&(e.parameters["level-asymmetry-allowed"]="1"),n.remoteCapabilities&&n.remoteCapabilities.codecs&&n.remoteCapabilities.codecs.forEach(function(t){e.name.toLowerCase()===t.name.toLowerCase()&&e.clockRate===t.clockRate&&(e.preferredPayloadType=t.payloadType)})}),c.headerExtensions.forEach(function(e){(n.remoteCapabilities&&n.remoteCapabilities.headerExtensions||[]).forEach(function(t){e.uri===t.uri&&(e.id=t.id)})});var d=n.sendEncodingParameters||[{ssrc:1001*(2*i+1)}];a&&t>=15019&&"video"===o&&!d[0].rtx&&(d[0].rtx={ssrc:d[0].ssrc+1}),n.wantReceive&&(n.rtpReceiver=new e.RTCRtpReceiver(n.dtlsTransport,o)),n.localCapabilities=c,n.sendEncodingParameters=d}),"max-compat"!==r._config.bundlePolicy&&(s+="a=group:BUNDLE "+r.transceivers.map(function(e){return e.mid}).join(" ")+"\r\n"),s+="a=ice-options:trickle\r\n",r.transceivers.forEach(function(e,t){s+=i(e,e.localCapabilities,"offer",e.stream,r._dtlsRole),s+="a=rtcp-rsize\r\n",!e.iceGatherer||"new"===r.iceGatheringState||0!==t&&r.usingBundle||(e.iceGatherer.getLocalCandidates().forEach(function(e){e.component=1,s+="a="+p.writeCandidate(e)+"\r\n"}),"completed"===e.iceGatherer.state&&(s+="a=end-of-candidates\r\n"))});var c=new e.RTCSessionDescription({type:"offer",sdp:s});return Promise.resolve(c)},l.prototype.createAnswer=function(){var r=this;if(r._isClosed)return Promise.reject(d("InvalidStateError","Can not call createAnswer after close"));if("have-remote-offer"!==r.signalingState&&"have-local-pranswer"!==r.signalingState)return Promise.reject(d("InvalidStateError","Can not call createAnswer in signalingState "+r.signalingState));var n=p.writeSessionBoilerplate(r._sdpSessionId,r._sdpSessionVersion++);r.usingBundle&&(n+="a=group:BUNDLE "+r.transceivers.map(function(e){return e.mid}).join(" ")+"\r\n"),n+="a=ice-options:trickle\r\n";var a=p.getMediaSections(r._remoteDescription.sdp).length;r.transceivers.forEach(function(e,s){if(!(s+1>a)){if(e.rejected)return"application"===e.kind?"DTLS/SCTP"===e.protocol?n+="m=application 0 DTLS/SCTP 5000\r\n":n+="m=application 0 "+e.protocol+" webrtc-datachannel\r\n":"audio"===e.kind?n+="m=audio 0 UDP/TLS/RTP/SAVPF 0\r\na=rtpmap:0 PCMU/8000\r\n":"video"===e.kind&&(n+="m=video 0 UDP/TLS/RTP/SAVPF 120\r\na=rtpmap:120 VP8/90000\r\n"),void(n+="c=IN IP4 0.0.0.0\r\na=inactive\r\na=mid:"+e.mid+"\r\n");if(e.stream){var c;"audio"===e.kind?c=e.stream.getAudioTracks()[0]:"video"===e.kind&&(c=e.stream.getVideoTracks()[0]),c&&t>=15019&&"video"===e.kind&&!e.sendEncodingParameters[0].rtx&&(e.sendEncodingParameters[0].rtx={ssrc:e.sendEncodingParameters[0].ssrc+1})}var d=o(e.localCapabilities,e.remoteCapabilities);!d.codecs.filter(function(e){return"rtx"===e.name.toLowerCase()}).length&&e.sendEncodingParameters[0].rtx&&delete e.sendEncodingParameters[0].rtx,n+=i(e,d,"answer",e.stream,r._dtlsRole),e.rtcpParameters&&e.rtcpParameters.reducedSize&&(n+="a=rtcp-rsize\r\n")}});var s=new e.RTCSessionDescription({type:"answer",sdp:n});return Promise.resolve(s)},l.prototype.addIceCandidate=function(e){var t,r=this;return e&&void 0===e.sdpMLineIndex&&!e.sdpMid?Promise.reject(new TypeError("sdpMLineIndex or sdpMid required")):new Promise(function(n,i){if(!r._remoteDescription)return i(d("InvalidStateError","Can not add ICE candidate without a remote description"));if(e&&""!==e.candidate){var a=e.sdpMLineIndex;if(e.sdpMid)for(var o=0;o<r.transceivers.length;o++)if(r.transceivers[o].mid===e.sdpMid){a=o;break}var s=r.transceivers[a];if(!s)return i(d("OperationError","Can not add ICE candidate"));if(s.rejected)return n();var u=Object.keys(e.candidate).length>0?p.parseCandidate(e.candidate):{};if("tcp"===u.protocol&&(0===u.port||9===u.port))return n();if(u.component&&1!==u.component)return n();if((0===a||a>0&&s.iceTransport!==r.transceivers[0].iceTransport)&&!c(s.iceTransport,u))return i(d("OperationError","Can not add ICE candidate"));var f=e.candidate.trim();0===f.indexOf("a=")&&(f=f.substr(2)),(t=p.getMediaSections(r._remoteDescription.sdp))[a]+="a="+(u.type?f:"end-of-candidates")+"\r\n",r._remoteDescription.sdp=p.getDescription(r._remoteDescription.sdp)+t.join("")}else for(var l=0;l<r.transceivers.length&&(r.transceivers[l].rejected||(r.transceivers[l].iceTransport.addRemoteCandidate({}),t=p.getMediaSections(r._remoteDescription.sdp),t[l]+="a=end-of-candidates\r\n",r._remoteDescription.sdp=p.getDescription(r._remoteDescription.sdp)+t.join(""),!r.usingBundle));l++);n()})},l.prototype.getStats=function(t){if(t&&t instanceof e.MediaStreamTrack){var r=null;if(this.transceivers.forEach(function(e){e.rtpSender&&e.rtpSender.track===t?r=e.rtpSender:e.rtpReceiver&&e.rtpReceiver.track===t&&(r=e.rtpReceiver)}),!r)throw d("InvalidAccessError","Invalid selector.");return r.getStats()}var n=[];return this.transceivers.forEach(function(e){["rtpSender","rtpReceiver","iceGatherer","iceTransport","dtlsTransport"].forEach(function(t){e[t]&&n.push(e[t].getStats())})}),Promise.all(n).then(function(e){var t=new Map;return e.forEach(function(e){e.forEach(function(e){t.set(e.id,e)})}),t})},["RTCRtpSender","RTCRtpReceiver","RTCIceGatherer","RTCIceTransport","RTCDtlsTransport"].forEach(function(t){var r=e[t];if(r&&r.prototype&&r.prototype.getStats){var i=r.prototype.getStats;r.prototype.getStats=function(){return i.apply(this).then(function(e){var t=new Map;return Object.keys(e).forEach(function(r){e[r].type=n(e[r]),t.set(r,e[r])}),t})}}});var m=["createOffer","createAnswer"];return m.forEach(function(e){var t=l.prototype[e];l.prototype[e]=function(){var e=arguments;return"function"==typeof e[0]||"function"==typeof e[1]?t.apply(this,[arguments[2]]).then(function(t){"function"==typeof e[0]&&e[0].apply(null,[t])},function(t){"function"==typeof e[1]&&e[1].apply(null,[t])}):t.apply(this,arguments)}}),(m=["setLocalDescription","setRemoteDescription","addIceCandidate"]).forEach(function(e){var t=l.prototype[e];l.prototype[e]=function(){var e=arguments;return"function"==typeof e[1]||"function"==typeof e[2]?t.apply(this,arguments).then(function(){"function"==typeof e[1]&&e[1].apply(null)},function(t){"function"==typeof e[2]&&e[2].apply(null,[t])}):t.apply(this,arguments)}}),["getStats"].forEach(function(e){var t=l.prototype[e];l.prototype[e]=function(){var e=arguments;return"function"==typeof e[1]?t.apply(this,arguments).then(function(){"function"==typeof e[1]&&e[1].apply(null)}):t.apply(this,arguments)}}),l}},{sdp:17}],17:[function(e,t,r){"use strict";var n={};n.generateIdentifier=function(){return Math.random().toString(36).substr(2,10)},n.localCName=n.generateIdentifier(),n.splitLines=function(e){return e.trim().split("\n").map(function(e){return e.trim()})},n.splitSections=function(e){return e.split("\nm=").map(function(e,t){return(t>0?"m="+e:e).trim()+"\r\n"})},n.getDescription=function(e){var t=n.splitSections(e);return t&&t[0]},n.getMediaSections=function(e){var t=n.splitSections(e);return t.shift(),t},n.matchPrefix=function(e,t){return n.splitLines(e).filter(function(e){return 0===e.indexOf(t)})},n.parseCandidate=function(e){for(var t,r={foundation:(t=0===e.indexOf("a=candidate:")?e.substring(12).split(" "):e.substring(10).split(" "))[0],component:parseInt(t[1],10),protocol:t[2].toLowerCase(),priority:parseInt(t[3],10),ip:t[4],address:t[4],port:parseInt(t[5],10),type:t[7]},n=8;n<t.length;n+=2)switch(t[n]){case"raddr":r.relatedAddress=t[n+1];break;case"rport":r.relatedPort=parseInt(t[n+1],10);break;case"tcptype":r.tcpType=t[n+1];break;case"ufrag":r.ufrag=t[n+1],r.usernameFragment=t[n+1];break;default:r[t[n]]=t[n+1]}return r},n.writeCandidate=function(e){var t=[];t.push(e.foundation),t.push(e.component),t.push(e.protocol.toUpperCase()),t.push(e.priority),t.push(e.address||e.ip),t.push(e.port);var r=e.type;return t.push("typ"),t.push(r),"host"!==r&&e.relatedAddress&&e.relatedPort&&(t.push("raddr"),t.push(e.relatedAddress),t.push("rport"),t.push(e.relatedPort)),e.tcpType&&"tcp"===e.protocol.toLowerCase()&&(t.push("tcptype"),t.push(e.tcpType)),(e.usernameFragment||e.ufrag)&&(t.push("ufrag"),t.push(e.usernameFragment||e.ufrag)),"candidate:"+t.join(" ")},n.parseIceOptions=function(e){return e.substr(14).split(" ")},n.parseRtpMap=function(e){var t=e.substr(9).split(" "),r={payloadType:parseInt(t.shift(),10)};return t=t[0].split("/"),r.name=t[0],r.clockRate=parseInt(t[1],10),r.channels=3===t.length?parseInt(t[2],10):1,r.numChannels=r.channels,r},n.writeRtpMap=function(e){var t=e.payloadType;void 0!==e.preferredPayloadType&&(t=e.preferredPayloadType);var r=e.channels||e.numChannels||1;return"a=rtpmap:"+t+" "+e.name+"/"+e.clockRate+(1!==r?"/"+r:"")+"\r\n"},n.parseExtmap=function(e){var t=e.substr(9).split(" ");return{id:parseInt(t[0],10),direction:t[0].indexOf("/")>0?t[0].split("/")[1]:"sendrecv",uri:t[1]}},n.writeExtmap=function(e){return"a=extmap:"+(e.id||e.preferredId)+(e.direction&&"sendrecv"!==e.direction?"/"+e.direction:"")+" "+e.uri+"\r\n"},n.parseFmtp=function(e){for(var t,r={},n=e.substr(e.indexOf(" ")+1).split(";"),i=0;i<n.length;i++)r[(t=n[i].trim().split("="))[0].trim()]=t[1];return r},n.writeFmtp=function(e){var t="",r=e.payloadType;if(void 0!==e.preferredPayloadType&&(r=e.preferredPayloadType),e.parameters&&Object.keys(e.parameters).length){var n=[];Object.keys(e.parameters).forEach(function(t){e.parameters[t]?n.push(t+"="+e.parameters[t]):n.push(t)}),t+="a=fmtp:"+r+" "+n.join(";")+"\r\n"}return t},n.parseRtcpFb=function(e){var t=e.substr(e.indexOf(" ")+1).split(" ");return{type:t.shift(),parameter:t.join(" ")}},n.writeRtcpFb=function(e){var t="",r=e.payloadType;return void 0!==e.preferredPayloadType&&(r=e.preferredPayloadType),e.rtcpFeedback&&e.rtcpFeedback.length&&e.rtcpFeedback.forEach(function(e){t+="a=rtcp-fb:"+r+" "+e.type+(e.parameter&&e.parameter.length?" "+e.parameter:"")+"\r\n"}),t},n.parseSsrcMedia=function(e){var t=e.indexOf(" "),r={ssrc:parseInt(e.substr(7,t-7),10)},n=e.indexOf(":",t);return n>-1?(r.attribute=e.substr(t+1,n-t-1),r.value=e.substr(n+1)):r.attribute=e.substr(t+1),r},n.parseSsrcGroup=function(e){var t=e.substr(13).split(" ");return{semantics:t.shift(),ssrcs:t.map(function(e){return parseInt(e,10)})}},n.getMid=function(e){var t=n.matchPrefix(e,"a=mid:")[0];if(t)return t.substr(6)},n.parseFingerprint=function(e){var t=e.substr(14).split(" ");return{algorithm:t[0].toLowerCase(),value:t[1]}},n.getDtlsParameters=function(e,t){return{role:"auto",fingerprints:n.matchPrefix(e+t,"a=fingerprint:").map(n.parseFingerprint)}},n.writeDtlsParameters=function(e,t){var r="a=setup:"+t+"\r\n";return e.fingerprints.forEach(function(e){r+="a=fingerprint:"+e.algorithm+" "+e.value+"\r\n"}),r},n.getIceParameters=function(e,t){var r=n.splitLines(e);return{usernameFragment:(r=r.concat(n.splitLines(t))).filter(function(e){return 0===e.indexOf("a=ice-ufrag:")})[0].substr(12),password:r.filter(function(e){return 0===e.indexOf("a=ice-pwd:")})[0].substr(10)}},n.writeIceParameters=function(e){return"a=ice-ufrag:"+e.usernameFragment+"\r\na=ice-pwd:"+e.password+"\r\n"},n.parseRtpParameters=function(e){for(var t={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},r=n.splitLines(e)[0].split(" "),i=3;i<r.length;i++){var a=r[i],o=n.matchPrefix(e,"a=rtpmap:"+a+" ")[0];if(o){var s=n.parseRtpMap(o),c=n.matchPrefix(e,"a=fmtp:"+a+" ");switch(s.parameters=c.length?n.parseFmtp(c[0]):{},s.rtcpFeedback=n.matchPrefix(e,"a=rtcp-fb:"+a+" ").map(n.parseRtcpFb),t.codecs.push(s),s.name.toUpperCase()){case"RED":case"ULPFEC":t.fecMechanisms.push(s.name.toUpperCase())}}}return n.matchPrefix(e,"a=extmap:").forEach(function(e){t.headerExtensions.push(n.parseExtmap(e))}),t},n.writeRtpDescription=function(e,t){var r="";r+="m="+e+" ",r+=t.codecs.length>0?"9":"0",r+=" UDP/TLS/RTP/SAVPF ",r+=t.codecs.map(function(e){return void 0!==e.preferredPayloadType?e.preferredPayloadType:e.payloadType}).join(" ")+"\r\n",r+="c=IN IP4 0.0.0.0\r\n",r+="a=rtcp:9 IN IP4 0.0.0.0\r\n",t.codecs.forEach(function(e){r+=n.writeRtpMap(e),r+=n.writeFmtp(e),r+=n.writeRtcpFb(e)});var i=0;return t.codecs.forEach(function(e){e.maxptime>i&&(i=e.maxptime)}),i>0&&(r+="a=maxptime:"+i+"\r\n"),r+="a=rtcp-mux\r\n",t.headerExtensions&&t.headerExtensions.forEach(function(e){r+=n.writeExtmap(e)}),r},n.parseRtpEncodingParameters=function(e){var t,r=[],i=n.parseRtpParameters(e),a=-1!==i.fecMechanisms.indexOf("RED"),o=-1!==i.fecMechanisms.indexOf("ULPFEC"),s=n.matchPrefix(e,"a=ssrc:").map(function(e){return n.parseSsrcMedia(e)}).filter(function(e){return"cname"===e.attribute}),c=s.length>0&&s[0].ssrc,d=n.matchPrefix(e,"a=ssrc-group:FID").map(function(e){return e.substr(17).split(" ").map(function(e){return parseInt(e,10)})});d.length>0&&d[0].length>1&&d[0][0]===c&&(t=d[0][1]),i.codecs.forEach(function(e){if("RTX"===e.name.toUpperCase()&&e.parameters.apt){var n={ssrc:c,codecPayloadType:parseInt(e.parameters.apt,10)};c&&t&&(n.rtx={ssrc:t}),r.push(n),a&&((n=JSON.parse(JSON.stringify(n))).fec={ssrc:c,mechanism:o?"red+ulpfec":"red"},r.push(n))}}),0===r.length&&c&&r.push({ssrc:c});var p=n.matchPrefix(e,"b=");return p.length&&(p=0===p[0].indexOf("b=TIAS:")?parseInt(p[0].substr(7),10):0===p[0].indexOf("b=AS:")?1e3*parseInt(p[0].substr(5),10)*.95-16e3:void 0,r.forEach(function(e){e.maxBitrate=p})),r},n.parseRtcpParameters=function(e){var t={},r=n.matchPrefix(e,"a=ssrc:").map(function(e){return n.parseSsrcMedia(e)}).filter(function(e){return"cname"===e.attribute})[0];r&&(t.cname=r.value,t.ssrc=r.ssrc);var i=n.matchPrefix(e,"a=rtcp-rsize");t.reducedSize=i.length>0,t.compound=0===i.length;var a=n.matchPrefix(e,"a=rtcp-mux");return t.mux=a.length>0,t},n.parseMsid=function(e){var t,r=n.matchPrefix(e,"a=msid:");if(1===r.length)return t=r[0].substr(7).split(" "),{stream:t[0],track:t[1]};var i=n.matchPrefix(e,"a=ssrc:").map(function(e){return n.parseSsrcMedia(e)}).filter(function(e){return"msid"===e.attribute});return i.length>0?(t=i[0].value.split(" "),{stream:t[0],track:t[1]}):void 0},n.generateSessionId=function(){return Math.random().toString().substr(2,21)},n.writeSessionBoilerplate=function(e,t,r){var i,a=void 0!==t?t:2;return i=e||n.generateSessionId(),"v=0\r\no="+(r||"thisisadapterortc")+" "+i+" "+a+" IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"},n.writeMediaSection=function(e,t,r,i){var a=n.writeRtpDescription(e.kind,t);if(a+=n.writeIceParameters(e.iceGatherer.getLocalParameters()),a+=n.writeDtlsParameters(e.dtlsTransport.getLocalParameters(),"offer"===r?"actpass":"active"),a+="a=mid:"+e.mid+"\r\n",e.direction?a+="a="+e.direction+"\r\n":e.rtpSender&&e.rtpReceiver?a+="a=sendrecv\r\n":e.rtpSender?a+="a=sendonly\r\n":e.rtpReceiver?a+="a=recvonly\r\n":a+="a=inactive\r\n",e.rtpSender){var o="msid:"+i.id+" "+e.rtpSender.track.id+"\r\n";a+="a="+o,a+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" "+o,e.sendEncodingParameters[0].rtx&&(a+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" "+o,a+="a=ssrc-group:FID "+e.sendEncodingParameters[0].ssrc+" "+e.sendEncodingParameters[0].rtx.ssrc+"\r\n")}return a+="a=ssrc:"+e.sendEncodingParameters[0].ssrc+" cname:"+n.localCName+"\r\n",e.rtpSender&&e.sendEncodingParameters[0].rtx&&(a+="a=ssrc:"+e.sendEncodingParameters[0].rtx.ssrc+" cname:"+n.localCName+"\r\n"),a},n.getDirection=function(e,t){for(var r=n.splitLines(e),i=0;i<r.length;i++)switch(r[i]){case"a=sendrecv":case"a=sendonly":case"a=recvonly":case"a=inactive":return r[i].substr(2)}return t?n.getDirection(t):"sendrecv"},n.getKind=function(e){return n.splitLines(e)[0].split(" ")[0].substr(2)},n.isRejected=function(e){return"0"===e.split(" ",2)[1]},n.parseMLine=function(e){var t=n.splitLines(e)[0].substr(2).split(" ");return{kind:t[0],port:parseInt(t[1],10),protocol:t[2],fmt:t.slice(3).join(" ")}},n.parseOLine=function(e){var t=n.matchPrefix(e,"o=")[0].substr(2).split(" ");return{username:t[0],sessionId:t[1],sessionVersion:parseInt(t[2],10),netType:t[3],addressType:t[4],address:t[5]}},n.isValidSDP=function(e){if("string"!=typeof e||0===e.length)return!1;for(var t=n.splitLines(e),r=0;r<t.length;r++)if(t[r].length<2||"="!==t[r].charAt(1))return!1;return!0},"object"==typeof t&&(t.exports=n)},{}]},{},[1])(1)});
!function(t){"use strict";function e(t){if("string"!=typeof t&&(t=String(t)),/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(t))throw new TypeError("Invalid character in header field name");return t.toLowerCase()}function r(t){return"string"!=typeof t&&(t=String(t)),t}function o(t){var e={next:function(){var e=t.shift();return{done:void 0===e,value:e}}};return m.iterable&&(e[Symbol.iterator]=function(){return e}),e}function n(t){this.map={},t instanceof n?t.forEach(function(t,e){this.append(e,t)},this):Array.isArray(t)?t.forEach(function(t){this.append(t[0],t[1])},this):t&&Object.getOwnPropertyNames(t).forEach(function(e){this.append(e,t[e])},this)}function i(t){if(t.bodyUsed)return Promise.reject(new TypeError("Already read"));t.bodyUsed=!0}function s(t){return new Promise(function(e,r){t.onload=function(){e(t.result)},t.onerror=function(){r(t.error)}})}function a(t){var e=new FileReader,r=s(e);return e.readAsArrayBuffer(t),r}function u(t){var e=new FileReader,r=s(e);return e.readAsText(t),r}function h(t){for(var e=new Uint8Array(t),r=new Array(e.length),o=0;o<e.length;o++)r[o]=String.fromCharCode(e[o]);return r.join("")}function f(t){if(t.slice)return t.slice(0);var e=new Uint8Array(t.byteLength);return e.set(new Uint8Array(t)),e.buffer}function d(){return this.bodyUsed=!1,this._initBody=function(t){if(this._bodyInit=t,t)if("string"==typeof t)this._bodyText=t;else if(m.blob&&Blob.prototype.isPrototypeOf(t))this._bodyBlob=t;else if(m.formData&&FormData.prototype.isPrototypeOf(t))this._bodyFormData=t;else if(m.searchParams&&URLSearchParams.prototype.isPrototypeOf(t))this._bodyText=t.toString();else if(m.arrayBuffer&&m.blob&&v(t))this._bodyArrayBuffer=f(t.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer]);else{if(!m.arrayBuffer||!ArrayBuffer.prototype.isPrototypeOf(t)&&!B(t))throw new Error("unsupported BodyInit type");this._bodyArrayBuffer=f(t)}else this._bodyText="";this.headers.get("content-type")||("string"==typeof t?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):m.searchParams&&URLSearchParams.prototype.isPrototypeOf(t)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"))},m.blob&&(this.blob=function(){var t=i(this);if(t)return t;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){return this._bodyArrayBuffer?i(this)||Promise.resolve(this._bodyArrayBuffer):this.blob().then(a)}),this.text=function(){var t=i(this);if(t)return t;if(this._bodyBlob)return u(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(h(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},m.formData&&(this.formData=function(){return this.text().then(p)}),this.json=function(){return this.text().then(JSON.parse)},this}function y(t){var e=t.toUpperCase();return _.indexOf(e)>-1?e:t}function l(t,e){var r=(e=e||{}).body;if(t instanceof l){if(t.bodyUsed)throw new TypeError("Already read");this.url=t.url,this.credentials=t.credentials,e.headers||(this.headers=new n(t.headers)),this.method=t.method,this.mode=t.mode,r||null==t._bodyInit||(r=t._bodyInit,t.bodyUsed=!0)}else this.url=String(t);if(this.credentials=e.credentials||this.credentials||"omit",!e.headers&&this.headers||(this.headers=new n(e.headers)),this.method=y(e.method||this.method||"GET"),this.mode=e.mode||this.mode||null,this.referrer=null,("GET"===this.method||"HEAD"===this.method)&&r)throw new TypeError("Body not allowed for GET or HEAD requests");this._initBody(r)}function p(t){var e=new FormData;return t.trim().split("&").forEach(function(t){if(t){var r=t.split("="),o=r.shift().replace(/\+/g," "),n=r.join("=").replace(/\+/g," ");e.append(decodeURIComponent(o),decodeURIComponent(n))}}),e}function c(t){var e=new n;return t.split(/\r?\n/).forEach(function(t){var r=t.split(":"),o=r.shift().trim();if(o){var n=r.join(":").trim();e.append(o,n)}}),e}function b(t,e){e||(e={}),this.type="default",this.status="status"in e?e.status:200,this.ok=this.status>=200&&this.status<300,this.statusText="statusText"in e?e.statusText:"OK",this.headers=new n(e.headers),this.url=e.url||"",this._initBody(t)}if(!t.fetch){var m={searchParams:"URLSearchParams"in t,iterable:"Symbol"in t&&"iterator"in Symbol,blob:"FileReader"in t&&"Blob"in t&&function(){try{return new Blob,!0}catch(t){return!1}}(),formData:"FormData"in t,arrayBuffer:"ArrayBuffer"in t};if(m.arrayBuffer)var w=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],v=function(t){return t&&DataView.prototype.isPrototypeOf(t)},B=ArrayBuffer.isView||function(t){return t&&w.indexOf(Object.prototype.toString.call(t))>-1};n.prototype.append=function(t,o){t=e(t),o=r(o);var n=this.map[t];this.map[t]=n?n+","+o:o},n.prototype.delete=function(t){delete this.map[e(t)]},n.prototype.get=function(t){return t=e(t),this.has(t)?this.map[t]:null},n.prototype.has=function(t){return this.map.hasOwnProperty(e(t))},n.prototype.set=function(t,o){this.map[e(t)]=r(o)},n.prototype.forEach=function(t,e){for(var r in this.map)this.map.hasOwnProperty(r)&&t.call(e,this.map[r],r,this)},n.prototype.keys=function(){var t=[];return this.forEach(function(e,r){t.push(r)}),o(t)},n.prototype.values=function(){var t=[];return this.forEach(function(e){t.push(e)}),o(t)},n.prototype.entries=function(){var t=[];return this.forEach(function(e,r){t.push([r,e])}),o(t)},m.iterable&&(n.prototype[Symbol.iterator]=n.prototype.entries);var _=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];l.prototype.clone=function(){return new l(this,{body:this._bodyInit})},d.call(l.prototype),d.call(b.prototype),b.prototype.clone=function(){return new b(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new n(this.headers),url:this.url})},b.error=function(){var t=new b(null,{status:0,statusText:""});return t.type="error",t};var A=[301,302,303,307,308];b.redirect=function(t,e){if(-1===A.indexOf(e))throw new RangeError("Invalid status code");return new b(null,{status:e,headers:{location:t}})},t.Headers=n,t.Request=l,t.Response=b,t.fetch=function(t,e){return new Promise(function(r,o){var n=new l(t,e),i=new XMLHttpRequest;i.onload=function(){var t={status:i.status,statusText:i.statusText,headers:c(i.getAllResponseHeaders()||"")};t.url="responseURL"in i?i.responseURL:t.headers.get("X-Request-URL");var e="response"in i?i.response:i.responseText;r(new b(e,t))},i.onerror=function(){o(new TypeError("Network request failed"))},i.ontimeout=function(){o(new TypeError("Network request failed"))},i.open(n.method,n.url,!0),"include"===n.credentials&&(i.withCredentials=!0),"responseType"in i&&m.blob&&(i.responseType="blob"),n.headers.forEach(function(t,e){i.setRequestHeader(e,t)}),i.send(void 0===n._bodyInit?null:n._bodyInit)})},t.fetch.polyfill=!0}}("undefined"!=typeof self?self:this);
var loadjs={};loadjs=function(){function e(e,n){var t,r,c,i=[],s=(e=e.push?e:[e]).length,o=s;for(t=function(e,t){t.length&&i.push(e),--o||n(i)};s--;)r=e[s],(c=u[r])?t(r,c):(f[r]=f[r]||[]).push(t)}function n(e,n){if(e){var t=f[e];if(u[e]=n,t)for(;t.length;)t[0](e,n),t.splice(0,1)}}function t(e,n){e.call&&(e={success:e}),n.length?(e.error||s)(n):(e.success||s)(e)}function r(e,n,t,c){var i,o,u=document,f=t.async,l=(t.numRetries||0)+1,h=t.before||s,d=e.replace(/^(css|img)!/,""),p=t.reqdelay||0;c=c||0,/(^css!|\.css$)/.test(e)?(i=!0,(o=u.createElement("link")).rel="stylesheet",o.href=d):/(^img!|\.(png|gif|jpg|svg)$)/.test(e)?(o=u.createElement("img")).src=d:((o=u.createElement("script")).src=e,o.async=void 0===f||f),o.onload=o.onerror=o.onbeforeload=function(s){var u=s.type[0];if(i&&"hideFocus"in o)try{o.sheet.cssText.length||(u="e")}catch(e){u="e"}if("e"==u&&(c+=1)<l)return a=p*c,setTimeout(function(){r(e,n,t,c)},a),void(t.retrycb&&t.retrycb(c,a));n(e,u,s.defaultPrevented)},!1!==h(e,o)&&u.head.appendChild(o)}function c(e,n,t){var c,i,s=(e=e.push?e:[e]).length,o=s,u=[];for(c=function(e,t,r){if("e"==t&&u.push(e),"b"==t){if(!r)return;u.push(e)}--s||n(u)},i=0;i<o;i++)r(e[i],c,t)}function i(e,r,i){var s,o;r&&r.trim&&(s=r),c(e,function(e){t(o,e),n(s,e)},o=(s?i:r)||{})}var s=function(){},o={},u={},f={},a=0;return i.ready=function(n,r){return e(n,function(e){t(r,e)}),i},i.done=function(e){n(e,[])},i.reset=function(){o={},u={},f={}},i.isDefined=function(e){return e in o},i}();
!function(o,e){"use strict";var s={};s.load=function(e,s,i){if("function"==typeof define&&define.amd&&"undefined"!=typeof requirejs){var r=[],c=e+"://"+s.ccsServer+"/socket.io/v3/socket.io.js",t={};r.push("sio"),t={sio:c},requirejs.config({shim:{sio:{exports:"io"}},wrap:!1,paths:t}),requirejs(r,function(e){o.rtcio=e,i.success()})}else if(void 0!==typeof loadjs&&"undefined"==typeof apiRTC_React){var n={async:!0,numRetries:s.extJsLoadingRetryNb||100,reqdelay:s.extJsLoadingRetryDelay||200,success:function(){o.rtcio=io,i.success()},error:function(o){console.error("socket.io loading error"),i.error()},retrycb:function(o,e){console.warn("socket.io loading retry :"+o+" ,delay before retry :"+e),i.retrycb()}};void 0!==s.socketioUrl?loadjs([s.socketioUrl],"socketio",n):loadjs([e+"://"+s.ccsServer+"/socket.io/v3/socket.io.js"],"socketio",n)}else console.log("Else loadjs io"),o.rtcio=io,i.success()},o.apiRTC_sioLoader=s}(window);
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@apizee/cloudapi-js-sdk/CloudAPI.js":
/*!**********************************************************!*\
  !*** ./node_modules/@apizee/cloudapi-js-sdk/CloudAPI.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: !0
}));

var log = __webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js"),
    prefix = __webpack_require__(/*! loglevel-plugin-prefix */ "./node_modules/loglevel-plugin-prefix/lib/loglevel-plugin-prefix.js"),
    logger = log.getLogger("CloudAPI");

prefix.reg(log), prefix.apply(logger, {
  format: function format(e, t, r) {
    return r + " - [" + e + "] " + t + " : ";
  }
}), logger.setDefaultLevel("error"), logger.setLevel("error");

var DEFAULT_CLOUD_URL = "https://cloud.apizee.com",
    AUTHENTICATE_URL = "/api/v2/authenticate",
    GET_PREFERRED_CCS_URL = "/api/v2/preferredCCS",
    GET_ENTERPRISE_INFORMATION_URL = "/api/v2/enterpriseInformation",
    GET_CONNECTED_USERINFO_URL = "/api/v2/users/me",
    GET_USER_PROFILE_URL = "/api/v2/users/{userId}/profile",
    GET_SITE_AGENTS_URL = "/api/v2/sites/{siteKey}/agents",
    CHECKTOKEN_URL = "/api/v2/checkToken",
    PROFILE_PHOTO_URL = "/profile/getImage",
    INVALIDATE_TOKEN_URL = "/api/v2/invalidateToken",
    GET_SESSION_HISTORY_URL = "/api/v2/messages",
    SAVE_NEW_MESSAGE_URL = "/api/v2/messages",
    SAVE_GROUPCHAT_MESSAGE_URL = "/api/v2/groupChatMessages",
    LOAD_GROUPCHAT_MESSAGES_URL = "/api/v2/groupChatMessages",
    UPLOAD_URL = "/api/v2/media/upload",
    CONVERSATION_MEDIA_URL = "/api/v2/conversation/{convId}/media",
    CONVERSATION_DATA_URL = "/api/v2/conversation/{convId}/data",
    CONFERENCES_URL = "/api/v2/conferences",
    GET_WEBSESSION_URL = "/api/v2/webSession",
    GET_OR_CREATE_CONVERSATION_URL = "/api/v2/conversation",
    GET_WEBCONF_URL = "/api/v2/conferences/{roomname}",
    GET_WEBCONF_CONVERSATION_URL = "/api/v2/conferences/{roomname}/conversation",
    CHECK_CONFERENCE_ACCESS_URL = "/api/v2/conferences/{roomname}/checkAccess",
    UPDATE_CONFERENCE_PRESENCE_URL = "/api/v2/conferences/{roomname}/updatePresence",
    CLOSE_CONFERENCE_INSTANCE_URL = "/api/v2/conferences/{roomname}/closeInstance",
    ENTREPRISE_USERLIST_URL = "/api/v2/enterprises/{enterpriseId}/users",
    ENTREPRISE_TAGLIST_URL = "/api/v2/enterprises/{enterpriseId}/tags",
    UPDATE_WEBCONF_URL = "/api/enterprises/{enterpriseId}/conferences/{conferenceId}",
    ERROR_NETWORK_UNAVAILABLE = 2,
    ERROR_SERVER_UNAVAILABLE = 3,
    ERROR_HTTP = 13,
    DEFAULT_FETCH_RETRIES = 100,
    DEFAULT_FETCH_RETRY_DELAY = 200,
    logTypes = ["trace", "debug", "info", "warn", "error", "silent"],
    routeParams = {
  updateWebconfTags: {
    fetchRetryCount: 3,
    fetchRetryDelay: 500
  }
},
    instance = null,
    CloudAPI = function () {
  function e() {
    if (this.cloudUrl = DEFAULT_CLOUD_URL, this.fetchRetries = DEFAULT_FETCH_RETRIES, this.fetchRetryDelay = DEFAULT_FETCH_RETRY_DELAY, null !== instance) return logger.debug("Cannot construct multiple CloudAPI, this is a singleton."), instance;
    instance = this;
  }

  return e.get = function () {
    return instance = null === instance ? new e() : instance;
  }, e.prototype.setLogLevel = function (e) {
    logger.setLevel(e);
  }, e.prototype.getLogLevel = function () {
    var e = "";

    switch (logger.getLevel()) {
      case 0:
        e = "trace";
        break;

      case 1:
        e = "debug";
        break;

      case 2:
        e = "info";
        break;

      case 3:
        e = "warn";
        break;

      case 4:
        e = "error";
        break;

      case 5:
        e = "silent";
    }

    return e;
  }, e.prototype.setCloudURL = function (e) {
    logger.debug("setCloudURL :", e), this.cloudUrl = e;
  }, e.prototype.setFetchRetries = function (e) {
    logger.debug("setFetchRetries :", e), null != e && (this.fetchRetries = e);
  }, e.prototype.setFetchRetryDelay = function (e) {
    logger.log("setFetchRetryDelay :", e), null != e && (this.fetchRetryDelay = e);
  }, e.prototype.request = function (e, c, l, g, p) {
    var d = -1 === e.indexOf(this.cloudUrl) ? this.cloudUrl + e : e,
        E = null;
    return new Promise(function (r, o) {
      var e,
          n = new XMLHttpRequest();
      if (n.onreadystatechange = function (e) {
        if (n.readyState === XMLHttpRequest.DONE) if (logger.debug("request onreadystatechange status :", n.status), 200 <= n.status && n.status < 300) {
          if (n.responseText) {
            var t = null;

            try {
              t = JSON.parse(n.responseText);
            } catch (e) {
              t = n.responseText;
            }

            r(t);
          }
        } else {
          t = {
            status: n.status,
            text: n.statusText
          };
          if (n.responseText) try {
            t.response = JSON.parse(n.responseText);
          } catch (e) {
            t.responseText = n.responseText;
          }
          o(t);
        }
      }, n.onprogress = function (e) {
        "function" == typeof g && g(e);
      }, n.onerror = function (e) {
        o(e);
      }, "GET" === l) 0 < Object.keys(c).length && (e = new URLSearchParams(c), logger.debug("johann", e, e.toString, c), d += "?" + e.toString());else {
        E = new FormData();

        for (var t = 0, s = Object.keys(c); t < s.length; t++) {
          var a = s[t];
          E.append(a, c[a]);
        }
      }
      if (n.open(l, d, !0), null != p) for (var i = 0, u = Object.keys(p); i < u.length; i++) {
        a = u[i];
        n.setRequestHeader(a, p[a]);
      }
      n.send(E);
    });
  }, e.prototype.get = function (e, t, r) {
    return logger.log("Send HTTP request : GET " + e), this.request(e, t, "GET", null, r);
  }, e.prototype.post = function (e, t, r, o) {
    return logger.log("Send HTTP request : POST " + e), this.request(e, t, "POST", r, o);
  }, e.prototype.put = function (e, t, r, o) {
    return logger.log("Send HTTP request : PUT " + e), (t = null === t || "object" != _typeof(t) ? {} : t)._method = "PUT", this.request(e, t, "POST", r, o);
  }, e.prototype["delete"] = function (e, t, r) {
    return logger.log("Send HTTP request : DELETE " + e), (t = null === t || "object" != _typeof(t) ? {} : t)._method = "DELETE", this.request(e, t, "POST", null, r);
  }, e.prototype.cloudRequest = function (u, c, l, g) {
    var p = this;
    return void 0 === g && (g = {}), new Promise(function (e, o) {
      logger.trace(l + " cloudRequest to " + instance.cloudUrl, c);
      var t = {
        method: l.toUpperCase()
      },
          r = instance.cloudUrl + u;
      if ("GET" === t.method) 0 < Object.keys(c).length && (r += "?" + new URLSearchParams(c).toString());else {
        for (var n = new FormData(), s = 0, a = Object.keys(c); s < a.length; s++) {
          var i = a[s];
          n.append(i, c[i]);
        }

        t.body = n;
      }
      g.hasOwnProperty("bearerToken") && (t.headers = {
        Authorization: "Bearer " + g.bearerToken
      }), g.hasOwnProperty("fetchRetryCount") ? t.retries = g.fetchRetryCount : t.retries = p.fetchRetries, g.hasOwnProperty("fetchRetryDelay") ? t.retryDelay = g.fetchRetryDelay : t.retryDelay = p.fetchRetryDelay, fetchRetry(r, t).then(function (e) {
        var t = null;

        if (e.status < 200 || 299 < e.status) {
          var r = "cloudRequest - response status Code: " + e.status;
          return logger.warn(r), o(createError(ERROR_HTTP, r, logger, {
            httpCode: e.status
          }));
        }

        return "cloudApiNoFetch" === e.gettype ? e.response : (t = e.headers ? e.headers.get("content-type") : t) && -1 !== t.indexOf("application/json") ? e.json() : o(createError(ERROR_SERVER_UNAVAILABLE, "cloudRequest - response is not JSON", logger));
      }).then(e)["catch"](function (e) {
        logger.error("err :", e), o(createError(ERROR_NETWORK_UNAVAILABLE, "cloudRequest - Fetch Error", logger));
      });
    });
  }, e.prototype.authentication = function (e, t) {
    return logger.debug("authentication to " + instance.cloudUrl), this.cloudRequest(AUTHENTICATE_URL, {
      username: e,
      password: t
    }, "POST");
  }, e.prototype.getConnectedUserInformation = function (e) {
    return logger.debug("getConnectedUserInformation to " + instance.cloudUrl), this.cloudRequest(GET_CONNECTED_USERINFO_URL, {}, "GET", {
      bearerToken: e
    });
  }, e.prototype.getUserProfile = function (e, t) {
    if (logger.debug("getUserProfile to " + instance.cloudUrl), "string" != typeof e || "string" != typeof t) return Promise.reject("wrongArguments");
    e = {
      apiKey: e
    };
    return this.cloudRequest(GET_USER_PROFILE_URL.replace("{userId}", t), e, "GET");
  }, e.prototype.getSiteAgents = function (e, t, r) {
    if (void 0 === r && (r = {}), logger.debug("getSiteAgents to " + instance.cloudUrl), "string" != typeof e || "string" != typeof t) return Promise.reject("wrongArguments");
    e = {
      apiKey: e
    };
    return r.useAcd && (e.useAcd = 1), r.usePresence && (e.usePresence = 1), r.convId && (e.convId = r.convId), this.cloudRequest(GET_SITE_AGENTS_URL.replace("{siteKey}", t), e, "GET");
  }, e.prototype.getEnterpriseInformation = function (e) {
    return void 0 === e && (e = {}), logger.debug("getEnterpriseInformation to " + instance.cloudUrl), this.cloudRequest(GET_ENTERPRISE_INFORMATION_URL, e, "GET");
  }, e.prototype.getPreferredCCS = function (e) {
    return logger.debug("getPreferredCCS to " + instance.cloudUrl), this.cloudRequest(GET_PREFERRED_CCS_URL, {
      apiKey: e
    }, "GET");
  }, e.prototype.checkUserToken = function (e) {
    return logger.debug("checkUserToken to " + instance.cloudUrl), this.cloudRequest(CHECKTOKEN_URL, {}, "GET", {
      bearerToken: e
    });
  }, e.prototype.invalidateUserToken = function (e) {
    return logger.debug("invalidateUserToken to " + instance.cloudUrl), this.cloudRequest(INVALIDATE_TOKEN_URL, {}, "POST", {
      bearerToken: e
    });
  }, e.prototype.uploadFile = function (e, t, r) {
    logger.debug("uploadMedia to " + instance.cloudUrl);
    var o = {
      file: e
    };
    if (null != r) for (var n = 0, s = Object.keys(r); n < s.length; n++) {
      var a = s[n];
      o[a] = r[a];
    }
    return this.cloudRequest(UPLOAD_URL, o, "POST", {
      bearerToken: t
    });
  }, e.prototype.uploadSnapshot = function (e, t, r) {
    void 0 === r && (r = {}), logger.debug("uploadSnapshot to " + instance.cloudUrl);

    for (var o = {
      dataUri: 1,
      file: e
    }, n = 0, s = Object.keys(r); n < s.length; n++) {
      var a = s[n];
      o[a] = r[a];
    }

    return this.cloudRequest(UPLOAD_URL, o, "POST", {
      bearerToken: t
    });
  }, e.prototype.getUserPhotoUrl = function (e) {
    return instance.cloudUrl + PROFILE_PHOTO_URL + "?userId=" + e;
  }, e.prototype.getEnterpriseUserList = function (e, t) {
    return logger.debug("getEnterpriseUserList to " + instance.cloudUrl), this.cloudRequest(ENTREPRISE_USERLIST_URL.replace("{enterpriseId}", e), {
      json: !0
    }, "GET", {
      bearerToken: t
    });
  }, e.prototype.getEnterpriseTagList = function (e, t, r) {
    void 0 === r && (r = {}), logger.debug("getEnterpriseTagList to " + instance.cloudUrl);
    return r.hasOwnProperty("webconfId") && r.webconfId, this.cloudRequest(ENTREPRISE_TAGLIST_URL.replace("{enterpriseId}", e), {}, "GET", {
      bearerToken: t
    });
  }, e.prototype.updateWebconfTags = function (e, t, r, o) {
    logger.debug("updateWebconfTags to " + instance.cloudUrl);
    r = {
      _method: "PUT",
      tags: r.join(",")
    }, o = {
      bearerToken: o
    };
    return setRouteParams(o, "updateWebconfTags"), this.cloudRequest(UPDATE_WEBCONF_URL.replace("{enterpriseId}", e).replace("{conferenceId}", t), r, "POST", o);
  }, e.prototype.getConferenceList = function (e) {
    return logger.debug("getConferenceList to " + instance.cloudUrl), this.cloudRequest(CONFERENCES_URL, {}, "GET", {
      bearerToken: e
    });
  }, e.prototype.getOrCreateConversation = function (e, t, r) {
    if (void 0 === r && (r = {}), logger.debug("getOrCreateConversation to " + instance.cloudUrl), null === e || "object" != _typeof(e) || "string" != typeof t) return Promise.reject("wrongArguments");
    e = {
      name: e._getTechnicalName(),
      type: e.getType(),
      apiKey: t
    }, t = {};
    return r.hasOwnProperty("token") && r.token && (t.bearerToken = r.token), r.hasOwnProperty("active") && "boolean" == typeof r.active && (e.active = 1), this.cloudRequest(GET_OR_CREATE_CONVERSATION_URL, e, "POST", t);
  }, e.prototype.createConference = function (e, t, r) {
    void 0 === r && (r = {}), logger.debug("createConference to " + instance.cloudUrl);
    t = {
      name: t
    };
    return r.hasOwnProperty("password") && (t.password = r.password), this.cloudRequest(CONFERENCES_URL, t, "POST", {
      bearerToken: e
    });
  }, e.prototype.checkConferenceAccess = function (e, t, r) {
    if (void 0 === r && (r = {}), logger.debug("checkConferenceAccess for " + e + " to " + instance.cloudUrl), "string" != typeof t) return Promise.reject("wrongArguments");
    var o = {
      apiKey: t
    };
    r.convId && (o.conv_id = r.convId), r.hasOwnProperty("password") && (o.password = r.password);
    t = {};
    return r.hasOwnProperty("session") && "function" == typeof r.session.getToken && null !== r.session.getToken() && (t.bearerToken = r.session.getToken()), this.cloudRequest(CHECK_CONFERENCE_ACCESS_URL.replace("{roomname}", e), o, "POST", t);
  }, e.prototype.getWebconf = function (e, t) {
    void 0 === t && (t = {}), logger.debug("getWebconf for " + e + " to " + instance.cloudUrl);
    var r = {};
    return t.hasOwnProperty("token") && t.token && (r.bearerToken = t.token), this.cloudRequest(GET_WEBCONF_URL.replace("{roomname}", e), {}, "GET", r);
  }, e.prototype.getWebconfConversation = function (e, t, r) {
    if (void 0 === r && (r = {}), logger.debug("getWebconfConversation for " + e + " to " + instance.cloudUrl), "string" != typeof t) return Promise.reject("wrongArguments");
    var o = {
      apiKey: t
    },
        t = {};
    return r.hasOwnProperty("token") && r.token && (t.bearerToken = r.token), this.cloudRequest(GET_WEBCONF_CONVERSATION_URL.replace("{roomname}", e), o, "GET", t);
  }, e.prototype.updateConferencePresence = function (e, t, r) {
    logger.trace("updateConferencePresence for " + e.getName() + " to " + instance.cloudUrl);
    var o = {
      ccid: t.getId(),
      name: t.getUserAgent().getUsername(),
      instanceId: e.getInstanceId(),
      apiKey: r
    },
        r = {};
    return null !== t.getToken() && (r.bearerToken = t.getToken()), this.cloudRequest(UPDATE_CONFERENCE_PRESENCE_URL.replace("{roomname}", e._getTechnicalName()), o, "POST", r);
  }, e.prototype.closeConferenceInstance = function (e, t) {
    logger.debug("closeConferenceInstance for " + e.getName() + " to " + instance.cloudUrl);
    var r = {
      instanceId: e.getInstanceId()
    };
    return this.cloudRequest(CLOSE_CONFERENCE_INSTANCE_URL.replace("{roomname}", e._getTechnicalName()), r, "POST", {
      bearerToken: t.getToken()
    });
  }, e.prototype.getConversationMediaList = function (e, t, r) {
    if (void 0 === r && (r = {}), logger.debug("getConversationMediaList for " + e + " to " + instance.cloudUrl), !e || "string" != typeof t) return Promise.reject("wrongArguments");
    var o = {
      apiKey: t
    },
        t = {};
    return r.hasOwnProperty("token") && r.token && (t.bearerToken = r.token), r.hasOwnProperty("offset") && (o.offset = r.offset), r.hasOwnProperty("limit") && (o.limit = r.limit), this.cloudRequest(CONVERSATION_MEDIA_URL.replace("{convId}", e.toString()), o, "GET", t);
  }, e.prototype.pushConversationMedia = function (e, t, r, o) {
    if (void 0 === o && (o = {}), logger.debug("pushConversationMedia for " + e + " to " + instance.cloudUrl), !e || !t || "string" != typeof r) return Promise.reject("wrongArguments");
    t = {
      media: t,
      apiKey: r
    }, r = {};
    return o.hasOwnProperty("token") && o.token && (r.bearerToken = o.token), o.hasOwnProperty("metadata") && o.metadata && (t.metadata = o.metadata), o.hasOwnProperty("asFile") && o.asFile && (t.asFile = o.asFile), o.hasOwnProperty("filename") && o.filename && (t.filename = o.filename), !0 === o.overwrite && (t.overwrite = 1), "number" == typeof o.ttl && 0 < o.ttl && (t.ttl = o.ttl), this.cloudRequest(CONVERSATION_MEDIA_URL.replace("{convId}", e.toString()), t, "POST", r);
  }, e.prototype.setConversationData = function (e, t, r, o) {
    if (void 0 === o && (o = {}), logger.debug("setConversationData for " + e + " to " + instance.cloudUrl), !e || "string" != typeof t || "string" != typeof r) return Promise.reject("wrongArguments");
    t = {
      data: t,
      apiKey: r
    }, r = {};
    return o.hasOwnProperty("token") && o.token && (r.bearerToken = o.token), this.cloudRequest(CONVERSATION_DATA_URL.replace("{convId}", e.toString()), t, "POST", r);
  }, e.prototype.getSessionHistory = function (e, t, r) {
    void 0 === r && (r = {}), logger.debug("getSessionHistory to " + instance.cloudUrl);
    var o = {
      sessionId: e
    };
    if (null != r) for (var n = 0, s = Object.keys(r); n < s.length; n++) {
      var a = s[n];
      o[a] = r[a];
    }
    return this.cloudRequest(GET_SESSION_HISTORY_URL, o, "GET", {
      bearerToken: t
    });
  }, e.prototype.getWebSession = function (e, t, r) {
    if (logger.debug("getSessionHistory to " + instance.cloudUrl), "string" != typeof r) return Promise.reject("wrongArguments");
    t = {
      destId: t.getId(),
      apiKey: r
    }, r = {};
    return null !== e.getToken() ? r.bearerToken = e.getToken() : t.userId = e.getId(), this.cloudRequest(GET_WEBSESSION_URL, t, "GET", r);
  }, e.prototype.saveNewMessage = function (e, t, r, o, n, s) {
    logger.debug("saveNewMessage to " + instance.cloudUrl);
    e = {
      uuid: n,
      destId: r,
      message: o,
      sessionId: e,
      userId: t.getId(),
      apiKey: s
    }, s = {};
    return null !== t.getToken() && (s.bearerToken = t.getToken()), this.cloudRequest(SAVE_NEW_MESSAGE_URL, e, "POST", s);
  }, e.prototype.saveGroupChatMessage = function (e, t, r, o, n, s) {
    void 0 === s && (s = {}), logger.debug("saveGroupChatMessage to " + instance.cloudUrl);
    e = {
      apiKey: r,
      message: o,
      ccid: t.getId(),
      name: t.getUserAgent().getUsername(),
      parent_conv_id: e.getCloudConversationId(),
      uuid: n,
      htmlEnable: s.metadata && s.metadata.htmlEnable || !1
    }, n = {};
    return void 0 !== s.token && null !== s.token ? n.bearerToken = s.token : null !== t.getToken() ? n.bearerToken = t.getToken() : e.userId = t.getId(), this.cloudRequest(SAVE_GROUPCHAT_MESSAGE_URL, e, "POST", n);
  }, e.prototype.loadGroupChatMessages = function (e, t, r) {
    void 0 === r && (r = ""), logger.debug("loadGroupChatMessages to " + instance.cloudUrl);
    var o = {
      parent_conv_id: e.getCloudConversationId()
    },
        e = {};
    return e.bearerToken = "" !== r ? r : t.getToken(), this.cloudRequest(LOAD_GROUPCHAT_MESSAGES_URL, o, "GET", e);
  }, e;
}();

function createError(e, t, r, o) {
  void 0 === o && (o = {}), r && r.error(t);
  t = {
    code: e,
    error: t instanceof String ? new Error(t) : t instanceof Error ? t : new Error(String(t))
  };
  return o.hasOwnProperty("httpCode") && (t.httpCode = o.httpCode), t;
}

function setRouteParams(e, t) {
  if (null !== e && "object" == _typeof(e) || (e = {}), routeParams.hasOwnProperty(t)) for (var r = routeParams[t], o = 0, n = ["fetchRetryCount", "fetchRetryDelay"]; o < n.length; o++) {
    var s = n[o];
    r.hasOwnProperty(s) && (e[s] = r[s]);
  }
  return e;
}

function fetchRetry(a, i) {
  logger.log("fetchRetry");
  var u = 3,
      c = 1e3,
      l = [];

  if (i && i.retries && (u = i.retries), i && i.retryDelay && (c = i.retryDelay), i && i.retryOn) {
    if (!(i.retryOn instanceof Array)) throw {
      name: "ArgumentError",
      message: "retryOn property expects an array"
    };
    l = i.retryOn;
  }

  return new Promise(function (o, n) {
    function r(t) {
      var e, r;
      logger.log("wrappedFetch n:", t), void 0 !== window.fetch ? fetch(a, i).then(function (e) {
        -1 === l.indexOf(e.status) ? o(e) : 0 < t ? s(t) : n(e);
      })["catch"](function (e) {
        0 < t ? s(t) : n(e);
      }) : (logger.debug("Cannot use fetch in this browser, using XHR"), e = CloudAPI.get(), r = {}, i.body && i.body.forEach(function (e, t) {
        return r[t] = e;
      }), e.request(a, r, i.method, null, i.headers).then(function (e) {
        o({
          gettype: "cloudApiNoFetch",
          response: e
        });
      })["catch"](function (e) {
        logger.error("error :", e), n(e);
      }));
    }

    function s(e) {
      logger.error("retry n:", e);
      var t = u - e + 1;
      logger.error("retry number is :", t), setTimeout(function () {
        r(--e);
      }, c * t);
    }

    r(u);
  });
}

exports["default"] = CloudAPI;

/***/ }),

/***/ "./node_modules/@babel/polyfill/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@babel/polyfill/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./noConflict */ "./node_modules/@babel/polyfill/lib/noConflict.js");

var _global = _interopRequireDefault(__webpack_require__(/*! core-js/library/fn/global */ "./node_modules/@babel/polyfill/node_modules/core-js/library/fn/global.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

if (_global["default"]._babelPolyfill && typeof console !== "undefined" && console.warn) {
  console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended " + "and may have consequences if different versions of the polyfills are applied sequentially. " + "If you do need to load the polyfill more than once, use @babel/polyfill/noConflict " + "instead to bypass the warning.");
}

_global["default"]._babelPolyfill = true;

/***/ }),

/***/ "./node_modules/@babel/polyfill/lib/noConflict.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/polyfill/lib/noConflict.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! core-js/es6 */ "./node_modules/@babel/polyfill/node_modules/core-js/es6/index.js");

__webpack_require__(/*! core-js/fn/array/includes */ "./node_modules/@babel/polyfill/node_modules/core-js/fn/array/includes.js");

__webpack_require__(/*! core-js/fn/array/flat-map */ "./node_modules/@babel/polyfill/node_modules/core-js/fn/array/flat-map.js");

__webpack_require__(/*! core-js/fn/string/pad-start */ "./node_modules/@babel/polyfill/node_modules/core-js/fn/string/pad-start.js");

__webpack_require__(/*! core-js/fn/string/pad-end */ "./node_modules/@babel/polyfill/node_modules/core-js/fn/string/pad-end.js");

__webpack_require__(/*! core-js/fn/string/trim-start */ "./node_modules/@babel/polyfill/node_modules/core-js/fn/string/trim-start.js");

__webpack_require__(/*! core-js/fn/string/trim-end */ "./node_modules/@babel/polyfill/node_modules/core-js/fn/string/trim-end.js");

__webpack_require__(/*! core-js/fn/symbol/async-iterator */ "./node_modules/@babel/polyfill/node_modules/core-js/fn/symbol/async-iterator.js");

__webpack_require__(/*! core-js/fn/object/get-own-property-descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/fn/object/get-own-property-descriptors.js");

__webpack_require__(/*! core-js/fn/object/values */ "./node_modules/@babel/polyfill/node_modules/core-js/fn/object/values.js");

__webpack_require__(/*! core-js/fn/object/entries */ "./node_modules/@babel/polyfill/node_modules/core-js/fn/object/entries.js");

__webpack_require__(/*! core-js/fn/promise/finally */ "./node_modules/@babel/polyfill/node_modules/core-js/fn/promise/finally.js");

__webpack_require__(/*! core-js/web */ "./node_modules/@babel/polyfill/node_modules/core-js/web/index.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/es6/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/es6/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../modules/es6.symbol */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.symbol.js");

__webpack_require__(/*! ../modules/es6.object.create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.create.js");

__webpack_require__(/*! ../modules/es6.object.define-property */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! ../modules/es6.object.define-properties */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.define-properties.js");

__webpack_require__(/*! ../modules/es6.object.get-own-property-descriptor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.get-own-property-descriptor.js");

__webpack_require__(/*! ../modules/es6.object.get-prototype-of */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.get-prototype-of.js");

__webpack_require__(/*! ../modules/es6.object.keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__(/*! ../modules/es6.object.get-own-property-names */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.get-own-property-names.js");

__webpack_require__(/*! ../modules/es6.object.freeze */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.freeze.js");

__webpack_require__(/*! ../modules/es6.object.seal */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.seal.js");

__webpack_require__(/*! ../modules/es6.object.prevent-extensions */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.prevent-extensions.js");

__webpack_require__(/*! ../modules/es6.object.is-frozen */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is-frozen.js");

__webpack_require__(/*! ../modules/es6.object.is-sealed */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is-sealed.js");

__webpack_require__(/*! ../modules/es6.object.is-extensible */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is-extensible.js");

__webpack_require__(/*! ../modules/es6.object.assign */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.assign.js");

__webpack_require__(/*! ../modules/es6.object.is */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is.js");

__webpack_require__(/*! ../modules/es6.object.set-prototype-of */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.set-prototype-of.js");

__webpack_require__(/*! ../modules/es6.object.to-string */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.to-string.js");

__webpack_require__(/*! ../modules/es6.function.bind */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.function.bind.js");

__webpack_require__(/*! ../modules/es6.function.name */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.function.name.js");

__webpack_require__(/*! ../modules/es6.function.has-instance */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.function.has-instance.js");

__webpack_require__(/*! ../modules/es6.parse-int */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.parse-int.js");

__webpack_require__(/*! ../modules/es6.parse-float */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.parse-float.js");

__webpack_require__(/*! ../modules/es6.number.constructor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.constructor.js");

__webpack_require__(/*! ../modules/es6.number.to-fixed */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.to-fixed.js");

__webpack_require__(/*! ../modules/es6.number.to-precision */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.to-precision.js");

__webpack_require__(/*! ../modules/es6.number.epsilon */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.epsilon.js");

__webpack_require__(/*! ../modules/es6.number.is-finite */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-finite.js");

__webpack_require__(/*! ../modules/es6.number.is-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-integer.js");

__webpack_require__(/*! ../modules/es6.number.is-nan */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-nan.js");

__webpack_require__(/*! ../modules/es6.number.is-safe-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-safe-integer.js");

__webpack_require__(/*! ../modules/es6.number.max-safe-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.max-safe-integer.js");

__webpack_require__(/*! ../modules/es6.number.min-safe-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.min-safe-integer.js");

__webpack_require__(/*! ../modules/es6.number.parse-float */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.parse-float.js");

__webpack_require__(/*! ../modules/es6.number.parse-int */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.parse-int.js");

__webpack_require__(/*! ../modules/es6.math.acosh */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.acosh.js");

__webpack_require__(/*! ../modules/es6.math.asinh */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.asinh.js");

__webpack_require__(/*! ../modules/es6.math.atanh */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.atanh.js");

__webpack_require__(/*! ../modules/es6.math.cbrt */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.cbrt.js");

__webpack_require__(/*! ../modules/es6.math.clz32 */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.clz32.js");

__webpack_require__(/*! ../modules/es6.math.cosh */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.cosh.js");

__webpack_require__(/*! ../modules/es6.math.expm1 */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.expm1.js");

__webpack_require__(/*! ../modules/es6.math.fround */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.fround.js");

__webpack_require__(/*! ../modules/es6.math.hypot */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.hypot.js");

__webpack_require__(/*! ../modules/es6.math.imul */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.imul.js");

__webpack_require__(/*! ../modules/es6.math.log10 */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.log10.js");

__webpack_require__(/*! ../modules/es6.math.log1p */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.log1p.js");

__webpack_require__(/*! ../modules/es6.math.log2 */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.log2.js");

__webpack_require__(/*! ../modules/es6.math.sign */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.sign.js");

__webpack_require__(/*! ../modules/es6.math.sinh */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.sinh.js");

__webpack_require__(/*! ../modules/es6.math.tanh */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.tanh.js");

__webpack_require__(/*! ../modules/es6.math.trunc */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.trunc.js");

__webpack_require__(/*! ../modules/es6.string.from-code-point */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.from-code-point.js");

__webpack_require__(/*! ../modules/es6.string.raw */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.raw.js");

__webpack_require__(/*! ../modules/es6.string.trim */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.trim.js");

__webpack_require__(/*! ../modules/es6.string.iterator */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.iterator.js");

__webpack_require__(/*! ../modules/es6.string.code-point-at */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.code-point-at.js");

__webpack_require__(/*! ../modules/es6.string.ends-with */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.ends-with.js");

__webpack_require__(/*! ../modules/es6.string.includes */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.includes.js");

__webpack_require__(/*! ../modules/es6.string.repeat */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.repeat.js");

__webpack_require__(/*! ../modules/es6.string.starts-with */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.starts-with.js");

__webpack_require__(/*! ../modules/es6.string.anchor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.anchor.js");

__webpack_require__(/*! ../modules/es6.string.big */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.big.js");

__webpack_require__(/*! ../modules/es6.string.blink */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.blink.js");

__webpack_require__(/*! ../modules/es6.string.bold */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.bold.js");

__webpack_require__(/*! ../modules/es6.string.fixed */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.fixed.js");

__webpack_require__(/*! ../modules/es6.string.fontcolor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.fontcolor.js");

__webpack_require__(/*! ../modules/es6.string.fontsize */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.fontsize.js");

__webpack_require__(/*! ../modules/es6.string.italics */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.italics.js");

__webpack_require__(/*! ../modules/es6.string.link */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.link.js");

__webpack_require__(/*! ../modules/es6.string.small */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.small.js");

__webpack_require__(/*! ../modules/es6.string.strike */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.strike.js");

__webpack_require__(/*! ../modules/es6.string.sub */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.sub.js");

__webpack_require__(/*! ../modules/es6.string.sup */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.sup.js");

__webpack_require__(/*! ../modules/es6.date.now */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.now.js");

__webpack_require__(/*! ../modules/es6.date.to-json */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-json.js");

__webpack_require__(/*! ../modules/es6.date.to-iso-string */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-iso-string.js");

__webpack_require__(/*! ../modules/es6.date.to-string */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-string.js");

__webpack_require__(/*! ../modules/es6.date.to-primitive */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-primitive.js");

__webpack_require__(/*! ../modules/es6.array.is-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.is-array.js");

__webpack_require__(/*! ../modules/es6.array.from */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.from.js");

__webpack_require__(/*! ../modules/es6.array.of */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.of.js");

__webpack_require__(/*! ../modules/es6.array.join */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.join.js");

__webpack_require__(/*! ../modules/es6.array.slice */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.slice.js");

__webpack_require__(/*! ../modules/es6.array.sort */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.sort.js");

__webpack_require__(/*! ../modules/es6.array.for-each */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.for-each.js");

__webpack_require__(/*! ../modules/es6.array.map */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.map.js");

__webpack_require__(/*! ../modules/es6.array.filter */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__(/*! ../modules/es6.array.some */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.some.js");

__webpack_require__(/*! ../modules/es6.array.every */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.every.js");

__webpack_require__(/*! ../modules/es6.array.reduce */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.reduce.js");

__webpack_require__(/*! ../modules/es6.array.reduce-right */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.reduce-right.js");

__webpack_require__(/*! ../modules/es6.array.index-of */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.index-of.js");

__webpack_require__(/*! ../modules/es6.array.last-index-of */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.last-index-of.js");

__webpack_require__(/*! ../modules/es6.array.copy-within */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.copy-within.js");

__webpack_require__(/*! ../modules/es6.array.fill */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.fill.js");

__webpack_require__(/*! ../modules/es6.array.find */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.find.js");

__webpack_require__(/*! ../modules/es6.array.find-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.find-index.js");

__webpack_require__(/*! ../modules/es6.array.species */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.species.js");

__webpack_require__(/*! ../modules/es6.array.iterator */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__(/*! ../modules/es6.regexp.constructor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.constructor.js");

__webpack_require__(/*! ../modules/es6.regexp.exec */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.exec.js");

__webpack_require__(/*! ../modules/es6.regexp.to-string */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.to-string.js");

__webpack_require__(/*! ../modules/es6.regexp.flags */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.flags.js");

__webpack_require__(/*! ../modules/es6.regexp.match */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.match.js");

__webpack_require__(/*! ../modules/es6.regexp.replace */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! ../modules/es6.regexp.search */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.search.js");

__webpack_require__(/*! ../modules/es6.regexp.split */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__(/*! ../modules/es6.promise */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! ../modules/es6.map */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.map.js");

__webpack_require__(/*! ../modules/es6.set */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.set.js");

__webpack_require__(/*! ../modules/es6.weak-map */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.weak-map.js");

__webpack_require__(/*! ../modules/es6.weak-set */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.weak-set.js");

__webpack_require__(/*! ../modules/es6.typed.array-buffer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.array-buffer.js");

__webpack_require__(/*! ../modules/es6.typed.data-view */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.data-view.js");

__webpack_require__(/*! ../modules/es6.typed.int8-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.int8-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint8-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint8-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint8-clamped-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint8-clamped-array.js");

__webpack_require__(/*! ../modules/es6.typed.int16-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.int16-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint16-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint16-array.js");

__webpack_require__(/*! ../modules/es6.typed.int32-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.int32-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint32-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint32-array.js");

__webpack_require__(/*! ../modules/es6.typed.float32-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.float32-array.js");

__webpack_require__(/*! ../modules/es6.typed.float64-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.float64-array.js");

__webpack_require__(/*! ../modules/es6.reflect.apply */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.apply.js");

__webpack_require__(/*! ../modules/es6.reflect.construct */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.construct.js");

__webpack_require__(/*! ../modules/es6.reflect.define-property */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.define-property.js");

__webpack_require__(/*! ../modules/es6.reflect.delete-property */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.delete-property.js");

__webpack_require__(/*! ../modules/es6.reflect.enumerate */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.enumerate.js");

__webpack_require__(/*! ../modules/es6.reflect.get */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.get.js");

__webpack_require__(/*! ../modules/es6.reflect.get-own-property-descriptor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js");

__webpack_require__(/*! ../modules/es6.reflect.get-prototype-of */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.get-prototype-of.js");

__webpack_require__(/*! ../modules/es6.reflect.has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.has.js");

__webpack_require__(/*! ../modules/es6.reflect.is-extensible */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.is-extensible.js");

__webpack_require__(/*! ../modules/es6.reflect.own-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.own-keys.js");

__webpack_require__(/*! ../modules/es6.reflect.prevent-extensions */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.prevent-extensions.js");

__webpack_require__(/*! ../modules/es6.reflect.set */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.set.js");

__webpack_require__(/*! ../modules/es6.reflect.set-prototype-of */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.set-prototype-of.js");

module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js");

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/fn/array/flat-map.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/fn/array/flat-map.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../modules/es7.array.flat-map */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.array.flat-map.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").Array.flatMap;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/fn/array/includes.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/fn/array/includes.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../modules/es7.array.includes */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.array.includes.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").Array.includes;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/fn/object/entries.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/fn/object/entries.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../modules/es7.object.entries */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.object.entries.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").Object.entries;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/fn/object/get-own-property-descriptors.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/fn/object/get-own-property-descriptors.js ***!
  \*****************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../modules/es7.object.get-own-property-descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").Object.getOwnPropertyDescriptors;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/fn/object/values.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/fn/object/values.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../modules/es7.object.values */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.object.values.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").Object.values;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/fn/promise/finally.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/fn/promise/finally.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ../../modules/es6.promise */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! ../../modules/es7.promise.finally */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.promise.finally.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").Promise["finally"];

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/fn/string/pad-end.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/fn/string/pad-end.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../modules/es7.string.pad-end */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.pad-end.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").String.padEnd;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/fn/string/pad-start.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/fn/string/pad-start.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../modules/es7.string.pad-start */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.pad-start.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").String.padStart;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/fn/string/trim-end.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/fn/string/trim-end.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../modules/es7.string.trim-right */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.trim-right.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").String.trimRight;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/fn/string/trim-start.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/fn/string/trim-start.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../modules/es7.string.trim-left */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.trim-left.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").String.trimLeft;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/fn/symbol/async-iterator.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/fn/symbol/async-iterator.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../../modules/es7.symbol.async-iterator */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.symbol.async-iterator.js");

module.exports = (__webpack_require__(/*! ../../modules/_wks-ext */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks-ext.js").f)('asyncIterator');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/fn/global.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/fn/global.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../modules/es7.global */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/es7.global.js");

module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_core.js").global;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_a-function.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_a-function.js ***!
  \******************************************************************************************/
/***/ ((module) => {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_an-object.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_an-object.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_core.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_core.js ***!
  \************************************************************************************/
/***/ ((module) => {

var core = module.exports = {
  version: '2.6.12'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_ctx.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_ctx.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function
    /* ...args */
  () {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_descriptors.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_descriptors.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_dom-create.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_dom-create.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_is-object.js");

var document = (__webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_global.js").document); // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_export.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_export.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_core.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_ctx.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_hide.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_has.js");

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue; // export native or passed

    out = own ? target[key] : source[key]; // prevent global pollution for namespaces

    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function F(a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();

            case 1:
              return new C(a);

            case 2:
              return new C(a, b);
          }

          return new C(a, b, c);
        }

        return C.apply(this, arguments);
      };

      F[PROTOTYPE] = C[PROTOTYPE];
      return F; // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
}; // type bitmap


$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_fails.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_fails.js ***!
  \*************************************************************************************/
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_global.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_global.js ***!
  \**************************************************************************************/
/***/ ((module) => {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_has.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_has.js ***!
  \***********************************************************************************/
/***/ ((module) => {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_hide.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_hide.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_property-desc.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_is-object.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_is-object.js ***!
  \*****************************************************************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

module.exports = function (it) {
  return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_object-dp.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_object-dp.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_an-object.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_ie8-dom-define.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_to-primitive.js");

var dP = Object.defineProperty;
exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_property-desc.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_property-desc.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_to-primitive.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_to-primitive.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/es7.global.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/library/modules/es7.global.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_export.js");

$export($export.G, {
  global: __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/library/modules/_global.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js ***!
  \**********************************************************************************/
/***/ ((module) => {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-number-value.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-number-value.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_cof.js");

module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_add-to-unscopables.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_add-to-unscopables.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('unscopables');

var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});

module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_advance-string-index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_advance-string-index.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var at = __webpack_require__(/*! ./_string-at */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-at.js")(true); // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex


module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-instance.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-instance.js ***!
  \***********************************************************************************/
/***/ ((module) => {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }

  return it;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-copy-within.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-copy-within.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-fill.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-fill.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

module.exports = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) {
    O[index++] = value;
  }

  return O;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-includes.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-includes.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-absolute-index.js");

module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }
    return !IS_INCLUDES && -1;
  };
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iobject.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var asc = __webpack_require__(/*! ./_array-species-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-species-create.js");

module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;

    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);

        if (TYPE) {
          if (IS_MAP) result[index] = res; // map
          else if (res) switch (TYPE) {
            case 3:
              return true;
            // some

            case 5:
              return val;
            // find

            case 6:
              return index;
            // findIndex

            case 2:
              result.push(val);
            // filter
          } else if (IS_EVERY) return false; // every
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-reduce.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-reduce.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }

    index += i;

    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }

  for (; isRight ? index >= 0 : length > index; index += i) {
    if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
  }

  return memo;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-species-constructor.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-species-constructor.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-array.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;

  if (isArray(original)) {
    C = original.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array : C;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-species-create.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-species-create.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_bind.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_bind.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_invoke.js");

var arraySlice = [].slice;
var factories = {};

var construct = function construct(F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) {
      n[i] = 'a[' + i + ']';
    } // eslint-disable-next-line no-new-func


    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }

  return factories[len](F, args);
};

module.exports = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);

  var bound = function
    /* args... */
  bound() {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };

  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_classof.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_classof.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_cof.js");

var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('toStringTag'); // ES3 wrong here


var ARG = cof(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {
    /* empty */
  }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
  : ARG ? cof(O) // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_cof.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_cof.js ***!
  \***************************************************************************/
/***/ ((module) => {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection-strong.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection-strong.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var dP = (__webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js").f);

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-create.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine-all.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_for-of.js");

var $iterDefine = __webpack_require__(/*! ./_iter-define */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-define.js");

var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-step.js");

var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-species.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js");

var fastKey = (__webpack_require__(/*! ./_meta */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_meta.js").fastKey);

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_validate-collection.js");

var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function getEntry(that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index]; // frozen object case

  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = create(null); // index

      that._f = undefined; // first entry

      that._l = undefined; // last entry

      that[SIZE] = 0; // size

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }

        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this); // revert to the last existing entry

          while (entry && entry.r) {
            entry = entry.p;
          }
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function get() {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var entry = getEntry(that, key);
    var prev, index; // change existing entry

    if (entry) {
      entry.v = value; // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true),
        // <- index
        k: key,
        // <- key
        v: value,
        // <- value
        p: prev = that._l,
        // <- previous entry
        n: undefined,
        // <- next entry
        r: false // <- removed

      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++; // add to index

      if (index !== 'F') that._i[index] = entry;
    }

    return that;
  },
  getEntry: getEntry,
  setStrong: function setStrong(C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target

      this._k = kind; // kind

      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l; // revert to the last existing entry

      while (entry && entry.r) {
        entry = entry.p;
      } // get next entry


      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      } // return step by kind


      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(NAME);
  }
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection-weak.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection-weak.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine-all.js");

var getWeak = (__webpack_require__(/*! ./_meta */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_meta.js").getWeak);

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_for-of.js");

var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js");

var $has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_validate-collection.js");

var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.a = [];
};

var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function get(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function has(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function _delete(key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = id++; // collection id

      that._l = undefined; // leak store for uncaught frozen objects

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function _delete(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine-all.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_meta.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_for-of.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-instance.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-detect.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-to-string-tag.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_inherit-if-required.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};

  var fixMethod = function fixMethod(KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);
      return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);
      return this;
    });
  };

  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly

    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;

      while (index--) {
        $instance[ADDER](index, index);
      }

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);
  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);
  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  return C;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js ***!
  \****************************************************************************/
/***/ ((module) => {

var core = module.exports = {
  version: '2.6.12'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_create-property.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_create-property.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $defineProperty = __webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function
    /* ...args */
  () {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_date-to-iso-string.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_date-to-iso-string.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function lz(num) {
  return num > 9 ? num : '0' + num;
}; // PhantomJS / old WebKit has a broken implementations


module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_date-to-primitive.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_date-to-primitive.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-primitive.js");

var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_defined.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_defined.js ***!
  \*******************************************************************************/
/***/ ((module) => {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_dom-create.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_dom-create.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var document = (__webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js").document); // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_enum-bug-keys.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_enum-bug-keys.js ***!
  \*************************************************************************************/
/***/ ((module) => {

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_enum-keys.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_enum-keys.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-pie.js");

module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;

    while (symbols.length > i) {
      if (isEnum.call(it, key = symbols[i++])) result.push(key);
    }
  }

  return result;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js");

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

    out = (own ? target : source)[key]; // bind timers to global for call from export context

    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

    if (target) redefine(target, key, out, type & $export.U); // export

    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

global.core = core; // type bitmap

$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails-is-regexp.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails-is-regexp.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('match');

module.exports = function (KEY) {
  var re = /./;

  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {
      /* empty */
    }
  }

  return true;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js ***!
  \*****************************************************************************/
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fix-re-wks.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_fix-re-wks.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./es6.regexp.exec */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.exec.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_defined.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_regexp-exec.js");

var SPECIES = wks('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
}();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    re.exec = function () {
      execCalled = true;
      return null;
    };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};

      re.constructor[SPECIES] = function () {
        return re;
      };
    }

    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    });
    var strfn = fns[0];
    var rxfn = fns[1];
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_flags.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_flags.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // 21.2.5.3 get RegExp.prototype.flags

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_flatten-into-array.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_flatten-into-array.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-array.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js");

var IS_CONCAT_SPREADABLE = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      spreadable = false;

      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
}

module.exports = flattenIntoArray;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_for-of.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_for-of.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js");

var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-array-iter.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/core.get-iterator-method.js");

var BREAK = {};
var RETURN = {};

var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};

exports.BREAK = BREAK;
exports.RETURN = RETURN;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_function-to-string.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_function-to-string.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./_shared */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_shared.js")('native-function-to-string', Function.toString);

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js ***!
  \******************************************************************************/
/***/ ((module) => {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js ***!
  \***************************************************************************/
/***/ ((module) => {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_property-desc.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_html.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_html.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var document = (__webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js").document);

module.exports = document && document.documentElement;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ie8-dom-define.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_ie8-dom-define.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = !__webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_dom-create.js")('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_inherit-if-required.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_inherit-if-required.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var setPrototypeOf = (__webpack_require__(/*! ./_set-proto */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-proto.js").set);

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;

  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }

  return that;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_invoke.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_invoke.js ***!
  \******************************************************************************/
/***/ ((module) => {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iobject.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_iobject.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_cof.js"); // eslint-disable-next-line no-prototype-builtins


module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-array-iter.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-array-iter.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iterators.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('iterator');

var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-array.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-array.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_cof.js");

module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-integer.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-integer.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var floor = Math.floor;

module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js ***!
  \*********************************************************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

module.exports = function (it) {
  return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-regexp.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-regexp.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_cof.js");

var MATCH = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('match');

module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-call.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-call.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-create.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-create.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var create = __webpack_require__(/*! ./_object-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-create.js");

var descriptor = __webpack_require__(/*! ./_property-desc */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_property-desc.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-to-string-tag.js");

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

__webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, {
    next: descriptor(1, next)
  });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-define.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-define.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_library.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iterators.js");

var $iterCreate = __webpack_require__(/*! ./_iter-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-create.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-to-string-tag.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gpo.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('iterator');

var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);

  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  } // Plug for library


  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-detect.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-detect.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('iterator');

var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {
  /* empty */
}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR]();

    iter.next = function () {
      return {
        done: safe = true
      };
    };

    arr[ITERATOR] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {
    /* empty */
  }

  return safe;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-step.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-step.js ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = function (done, value) {
  return {
    value: value,
    done: !!done
  };
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iterators.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_iterators.js ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = {};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_library.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_library.js ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = false;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-expm1.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-expm1.js ***!
  \**********************************************************************************/
/***/ ((module) => {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1 // Old FF bug
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-fround.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-fround.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-sign.js");

var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function roundTiesToEven(n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs); // eslint-disable-next-line no-self-compare

  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-log1p.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-log1p.js ***!
  \**********************************************************************************/
/***/ ((module) => {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-sign.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-sign.js ***!
  \*********************************************************************************/
/***/ ((module) => {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_meta.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_meta.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var META = __webpack_require__(/*! ./_uid */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_uid.js")('meta');

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

var setDesc = (__webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js").f);

var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var FREEZE = !__webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});

var setMeta = function setMeta(it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      // object ID
      w: {} // weak collections IDs

    }
  });
};

var fastKey = function fastKey(it, create) {
  // return primitive with prefix
  if (!isObject(it)) return _typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMeta(it); // return object ID
  }

  return it[META].i;
};

var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMeta(it); // return hash weak collections IDs
  }

  return it[META].w;
}; // add metadata on freeze-family methods calling


var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};

var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_microtask.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_microtask.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var macrotask = (__webpack_require__(/*! ./_task */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_task.js").set);

var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function flush() {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (isNode) {
    notify = function notify() {
      process.nextTick(flush);
    }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, {
      characterData: true
    }); // eslint-disable-line no-new

    notify = function notify() {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);

    notify = function notify() {
      promise.then(flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function notify() {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_new-promise-capability.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_new-promise-capability.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-assign.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-assign.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // 19.1.2.1 Object.assign(target, source, ...)

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-pie.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iobject.js");

var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

module.exports = !$assign || __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;

  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : $assign;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-create.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-create.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var dPs = __webpack_require__(/*! ./_object-dps */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dps.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_enum-bug-keys.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var Empty = function Empty() {
  /* empty */
};

var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_dom-create.js")('iframe');

  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  (__webpack_require__(/*! ./_html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_html.js").appendChild)(iframe);

  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;

  while (i--) {
    delete _createDict[PROTOTYPE][enumBugKeys[i]];
  }

  return _createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = _createDict();

  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ie8-dom-define.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-primitive.js");

var dP = Object.defineProperty;
exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dps.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dps.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) {
    dP.f(O, P = keys[i++], Properties[P]);
  }

  return O;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var pIE = __webpack_require__(/*! ./_object-pie */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-pie.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_property-desc.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-primitive.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ie8-dom-define.js");

var gOPD = Object.getOwnPropertyDescriptor;
exports.f = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {
    /* empty */
  }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn-ext.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn-ext.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js");

var gOPN = (__webpack_require__(/*! ./_object-gopn */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn.js").f);

var toString = {}.toString;
var windowNames = (typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys-internal.js");

var hiddenKeys = (__webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_enum-bug-keys.js").concat)('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gops.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gops.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gpo.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gpo.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys-internal.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys-internal.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js");

var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-includes.js")(false);

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) {
    if (key != IE_PROTO) has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys


  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }

  return result;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys-internal.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-pie.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-pie.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

exports.f = {}.propertyIsEnumerable;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-to-array.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-to-array.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js");

var isEnum = (__webpack_require__(/*! ./_object-pie */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-pie.js").f);

module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_own-keys.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_own-keys.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(/*! ./_object-gopn */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gops.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var Reflect = (__webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js").Reflect);

module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_parse-float.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_parse-float.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $parseFloat = (__webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js").parseFloat);

var $trim = (__webpack_require__(/*! ./_string-trim */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-trim.js").trim);

module.exports = 1 / $parseFloat(__webpack_require__(/*! ./_string-ws */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-ws.js") + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_parse-int.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_parse-int.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $parseInt = (__webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js").parseInt);

var $trim = (__webpack_require__(/*! ./_string-trim */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-trim.js").trim);

var ws = __webpack_require__(/*! ./_string-ws */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-ws.js");

var hex = /^[-+]?0[xX]/;
module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_perform.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_perform.js ***!
  \*******************************************************************************/
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return {
      e: false,
      v: exec()
    };
  } catch (e) {
    return {
      e: true,
      v: e
    };
  }
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_promise-resolve.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_promise-resolve.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_property-desc.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_property-desc.js ***!
  \*************************************************************************************/
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine-all.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine-all.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js");

module.exports = function (target, src, safe) {
  for (var key in src) {
    redefine(target, key, src[key], safe);
  }

  return target;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

var SRC = __webpack_require__(/*! ./_uid */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_uid.js")('src');

var $toString = __webpack_require__(/*! ./_function-to-string */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_function-to-string.js");

var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

(__webpack_require__(/*! ./_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").inspectSource) = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_regexp-exec-abstract.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_regexp-exec-abstract.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_classof.js");

var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec

module.exports = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (_typeof(result) !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }

  return builtinExec.call(R, S);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_regexp-exec.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_regexp-exec.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexpFlags = __webpack_require__(/*! ./_flags */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_flags.js");

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;
var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_same-value.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_same-value.js ***!
  \**********************************************************************************/
/***/ ((module) => {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-proto.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-proto.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var check = function check(O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};

module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__(/*! ./_ctx */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js")(Function.call, (__webpack_require__(/*! ./_object-gopd */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js").f)(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }

    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-species.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-species.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function get() {
      return this;
    }
  });
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-to-string-tag.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-to-string-tag.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var def = (__webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js").f);

var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

var TAG = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_shared-key.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_shared-key.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_shared.js")('keys');

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_uid.js");

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_shared.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_shared.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var core = __webpack_require__(/*! ./_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: ' 2020 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_species-constructor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_species-constructor.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('species');

module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {
      /* empty */
    }, 1) : method.call(null);
  });
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-at.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-at.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_defined.js"); // true  -> String#at
// false -> String#codePointAt


module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-context.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-context.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-regexp.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_defined.js");

var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

var createHTML = function createHTML(string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-pad.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-pad.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-repeat.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_defined.js");

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-repeat.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-repeat.js ***!
  \*************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_defined.js");

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

  for (; n > 0; (n >>>= 1) && (str += str)) {
    if (n & 1) res += str;
  }

  return res;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-trim.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-trim.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_defined.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var spaces = __webpack_require__(/*! ./_string-ws */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-ws.js");

var space = '[' + spaces + ']';
var non = "\u200B\x85";
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function exporter(KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
}; // 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim


var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-ws.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-ws.js ***!
  \*********************************************************************************/
/***/ ((module) => {

module.exports = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_task.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_task.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js");

var invoke = __webpack_require__(/*! ./_invoke */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_invoke.js");

var html = __webpack_require__(/*! ./_html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_html.js");

var cel = __webpack_require__(/*! ./_dom-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_dom-create.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function run() {
  var id = +this; // eslint-disable-next-line no-prototype-builtins

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function listener(event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (__webpack_require__(/*! ./_cof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function defer(id) {
      Dispatch.now(ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-absolute-index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-absolute-index.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js");

var max = Math.max;
var min = Math.min;

module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-index.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js ***!
  \**********************************************************************************/
/***/ ((module) => {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;

module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iobject.js");

var defined = __webpack_require__(/*! ./_defined */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js");

var min = Math.min;

module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-primitive.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-primitive.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-array.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-array.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_library.js");

  var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

  var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

  var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

  var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed.js");

  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-buffer.js");

  var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js");

  var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-instance.js");

  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_property-desc.js");

  var hide = __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js");

  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine-all.js");

  var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js");

  var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

  var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-index.js");

  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-absolute-index.js");

  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-primitive.js");

  var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

  var classof = __webpack_require__(/*! ./_classof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_classof.js");

  var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

  var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-array-iter.js");

  var create = __webpack_require__(/*! ./_object-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-create.js");

  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gpo.js");

  var gOPN = (__webpack_require__(/*! ./_object-gopn */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn.js").f);

  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/core.get-iterator-method.js");

  var uid = __webpack_require__(/*! ./_uid */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_uid.js");

  var wks = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js");

  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js");

  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-includes.js");

  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_species-constructor.js");

  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.iterator.js");

  var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iterators.js");

  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-detect.js");

  var setSpecies = __webpack_require__(/*! ./_set-species */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-species.js");

  var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-fill.js");

  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-copy-within.js");

  var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js");

  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js");

  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';
  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });
  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });
  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function toOffset(it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function validate(it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function allocate(C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    }

    return new C(length);
  };

  var speciesFromList = function speciesFromList(O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function fromList(C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);

    while (length > index) {
      result[index] = list[index++];
    }

    return result;
  };

  var addGetter = function addGetter(it, key, internal) {
    dP(it, key, {
      get: function get() {
        return this._d[internal];
      }
    });
  };

  var $from = function from(source
  /* , mapfn, thisArg */
  ) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;

    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      }

      O = values;
    }

    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }

    return result;
  };

  var $of = function
    /* ...items */
  of() {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);

    while (length > index) {
      result[index] = arguments[index++];
    }

    return result;
  }; // iOS Safari 6.x fails here


  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
    arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start
    /* , end */
    ) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn
    /* , thisArg */
    ) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value
    /* , start, end */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate
    /* , thisArg */
    ) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate
    /* , thisArg */
    ) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn
    /* , thisArg */
    ) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement
    /* , fromIndex */
    ) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement
    /* , fromIndex */
    ) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) {
      // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement
    /* , fromIndex */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn
    /* , thisArg */
    ) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;

      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }

      return that;
    },
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike
  /* , offset */
  ) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);

    while (index < len) {
      this[offset + index] = src[index++];
    }
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function isTAIndex(target, key) {
    return isObject(target) && target[TYPED_ARRAY] && _typeof(key) != 'symbol' && key in target && String(+key) == String(key);
  };

  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };

  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
      target[key] = desc.value;
      return target;
    }

    return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function constructor() {
      /* noop */
    },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function get() {
      return this[TYPED_ARRAY];
    }
  }); // eslint-disable-next-line max-statements

  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

    var getter = function getter(that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };

    var setter = function setter(that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };

    var addElement = function addElement(that, index) {
      dP(that, index, {
        get: function get() {
          return getter(this, index);
        },
        set: function set(value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;

        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;

          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }

          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }

        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });

        while (index < length) {
          addElement(that, index++);
        }
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new

      new TypedArray(null); // eslint-disable-line no-new

      new TypedArray(1.5); // eslint-disable-line no-new

      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645

        if (!isObject(data)) return new Base(toIndex(data));

        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
        }

        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }

    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function get() {
          return NAME;
        }
      });
    }

    O[NAME] = TypedArray;
    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });
    $export($export.S + $export.F * fails(function () {
      Base.of.call(TypedArray, 1);
    }), NAME, {
      from: $from,
      of: $of
    });
    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
    $export($export.P, NAME, proto);
    setSpecies(NAME);
    $export($export.P + $export.F * FORCED_SET, NAME, {
      set: $set
    });
    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, {
      slice: $slice
    });
    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {
      toLocaleString: $toLocaleString
    });
    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {
  /* empty */
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-buffer.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-buffer.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_library.js");

var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine-all.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-instance.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var toIndex = __webpack_require__(/*! ./_to-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-index.js");

var gOPN = (__webpack_require__(/*! ./_object-gopn */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn.js").f);

var dP = (__webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js").f);

var arrayFill = __webpack_require__(/*! ./_array-fill */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-fill.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-to-string-tag.js");

var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value); // eslint-disable-next-line no-self-compare

  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);

    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {
    ;
  }

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {
    ;
  }

  buffer[--i] |= s * 128;
  return buffer;
}

function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;

  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {
    ;
  }

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {
    ;
  }

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}

function packI8(it) {
  return [it & 0xff];
}

function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}

function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}

function packF64(it) {
  return packIEEE754(it, 52, 8);
}

function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, {
    get: function get() {
      return this[internal];
    }
  });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}

function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);

  for (var i = 0; i < bytes; i++) {
    store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
  }
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new

    new $ArrayBuffer(1.5); // eslint-disable-line no-new

    new $ArrayBuffer(NaN); // eslint-disable-line no-new

    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };

    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }

    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  } // iOS Safari 7.x bug


  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js");

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_uid.js");

var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;
var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_uid.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_uid.js ***!
  \***************************************************************************/
/***/ ((module) => {

var id = 0;
var px = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_user-agent.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_user-agent.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var navigator = global.navigator;
module.exports = navigator && navigator.userAgent || '';

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_validate-collection.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_validate-collection.js ***!
  \*******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks-define.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks-define.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_library.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks-ext.js");

var defineProperty = (__webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js").f);

module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: wksExt.f(name)
  });
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks-ext.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks-ext.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.f = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js");

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var store = __webpack_require__(/*! ./_shared */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_shared.js")('wks');

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_uid.js");

var _Symbol = (__webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js").Symbol);

var USE_SYMBOL = typeof _Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/core.get-iterator-method.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/core.get-iterator-method.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_classof.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('iterator');

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iterators.js");

module.exports = (__webpack_require__(/*! ./_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js").getIteratorMethod) = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.copy-within.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.copy-within.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  copyWithin: __webpack_require__(/*! ./_array-copy-within */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-copy-within.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_add-to-unscopables.js")('copyWithin');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.every.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.every.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $every = __webpack_require__(/*! ./_array-methods */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js")(4);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js")([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.fill.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.fill.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  fill: __webpack_require__(/*! ./_array-fill */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-fill.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_add-to-unscopables.js")('fill');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.filter.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.filter.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $filter = __webpack_require__(/*! ./_array-methods */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.find-index.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.find-index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js")(6);

var KEY = 'findIndex';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.find.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.find.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js")(5);

var KEY = 'find';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.for-each.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.for-each.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $forEach = __webpack_require__(/*! ./_array-methods */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js")(0);

var STRICT = __webpack_require__(/*! ./_strict-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.from.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.from.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var call = __webpack_require__(/*! ./_iter-call */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-array-iter.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_create-property.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);

      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.index-of.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.index-of.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $indexOf = __webpack_require__(/*! ./_array-includes */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-includes.js")(false);

var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.is-array.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.is-array.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', {
  isArray: __webpack_require__(/*! ./_is-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-array.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.iterator.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.iterator.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_add-to-unscopables.js");

var step = __webpack_require__(/*! ./_iter-step */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-step.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iterators.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js"); // 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()


module.exports = __webpack_require__(/*! ./_iter-define */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target

  this._i = 0; // next index

  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }

  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.join.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.join.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // 22.1.3.13 Array.prototype.join(separator)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js");

var arrayJoin = [].join; // fallback for not array-like strings

$export($export.P + $export.F * (__webpack_require__(/*! ./_iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iobject.js") != Object || !__webpack_require__(/*! ./_strict-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js")(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.last-index-of.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.last-index-of.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement
  /* , fromIndex = @[*-1] */
  ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;

    for (; index >= 0; index--) {
      if (index in O) if (O[index] === searchElement) return index || 0;
    }

    return -1;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.map.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.map.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $map = __webpack_require__(/*! ./_array-methods */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.of.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.of.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_create-property.js"); // WebKit Array.of isn't generic


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  function F() {
    /* empty */
  }

  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function
    /* ...args */
  of() {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);

    while (aLen > index) {
      createProperty(result, index, arguments[index++]);
    }

    result.length = aLen;
    return result;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.reduce-right.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.reduce-right.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js")([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.reduce.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.reduce.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.slice.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.slice.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var html = __webpack_require__(/*! ./_html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_html.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_cof.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;

    for (; i < size; i++) {
      cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
    }

    return cloned;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.some.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.some.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $some = __webpack_require__(/*! ./_array-methods */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js")(3);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.sort.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.sort.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var $sort = [].sort;
var test = [1, 2, 3];
$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null); // Old WebKit
}) || !__webpack_require__(/*! ./_strict-method */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_strict-method.js")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.species.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.species.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./_set-species */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-species.js")('Array');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.now.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.now.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', {
  now: function now() {
    return new Date().getTime();
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-iso-string.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-iso-string.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var toISOString = __webpack_require__(/*! ./_date-to-iso-string */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_date-to-iso-string.js"); // PhantomJS / old WebKit has a broken implementations


$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-json.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-json.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-primitive.js");

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function toISOString() {
      return 1;
    }
  }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-primitive.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-primitive.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var TO_PRIMITIVE = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('toPrimitive');

var proto = Date.prototype;
if (!(TO_PRIMITIVE in proto)) __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js")(proto, TO_PRIMITIVE, __webpack_require__(/*! ./_date-to-primitive */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_date-to-primitive.js"));

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-string.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.date.to-string.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;

if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.function.bind.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.function.bind.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.P, 'Function', {
  bind: __webpack_require__(/*! ./_bind */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_bind.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.function.has-instance.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.function.has-instance.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gpo.js");

var HAS_INSTANCE = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('hasInstance');

var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

if (!(HAS_INSTANCE in FunctionProto)) (__webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js").f)(FunctionProto, HAS_INSTANCE, {
  value: function value(O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

    while (O = getPrototypeOf(O)) {
      if (this.prototype === O) return true;
    }

    return false;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.function.name.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.function.name.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var dP = (__webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js").f);

var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // 19.2.4.2 name

NAME in FProto || __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function get() {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.map.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.map.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_validate-collection.js");

var MAP = 'Map'; // 23.1 Map Objects

module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection.js")(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.acosh.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.acosh.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var log1p = __webpack_require__(/*! ./_math-log1p */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-log1p.js");

var sqrt = Math.sqrt;
var $acosh = Math.acosh;
$export($export.S + $export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
&& Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.asinh.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.asinh.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
} // Tor Browser bug: Math.asinh(0) -> -0


$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
  asinh: asinh
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.atanh.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.atanh.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.cbrt.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.cbrt.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var sign = __webpack_require__(/*! ./_math-sign */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-sign.js");

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.clz32.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.clz32.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.cosh.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.cosh.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.expm1.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.expm1.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-expm1.js");

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {
  expm1: $expm1
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.fround.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.fround.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  fround: __webpack_require__(/*! ./_math-fround */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-fround.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.hypot.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.hypot.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var abs = Math.abs;
$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
    // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.imul.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.imul.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.log10.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.log10.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.log1p.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.log1p.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log1p: __webpack_require__(/*! ./_math-log1p */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-log1p.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.log2.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.log2.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.sign.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.sign.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  sign: __webpack_require__(/*! ./_math-sign */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-sign.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.sinh.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.sinh.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.tanh.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.tanh.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.trunc.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.math.trunc.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.constructor.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.constructor.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

var cof = __webpack_require__(/*! ./_cof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_cof.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_inherit-if-required.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-primitive.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var gOPN = (__webpack_require__(/*! ./_object-gopn */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn.js").f);

var gOPD = (__webpack_require__(/*! ./_object-gopd */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js").f);

var dP = (__webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js").f);

var $trim = (__webpack_require__(/*! ./_string-trim */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-trim.js").trim);

var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype; // Opera ~12 has broken Object#toString

var BROKEN_COF = cof(__webpack_require__(/*! ./_object-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-create.js")(proto)) == NUMBER;
var TRIM = ('trim' in String.prototype); // 7.1.3 ToNumber(argument)

var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);

  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal /^0o[0-7]+$/i

        default:
          return +it;
      }

      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number // check on 1..constructor(foo) case
    && (BROKEN_COF ? fails(function () {
      proto.valueOf.call(that);
    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };

  for (var keys = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js") ? gOPN(Base) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }

  $Number.prototype = proto;
  proto.constructor = $Number;

  __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js")(global, NUMBER, $Number);
}

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.epsilon.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.epsilon.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  EPSILON: Math.pow(2, -52)
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-finite.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-finite.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var _isFinite = (__webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js").isFinite);

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-integer.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-integer.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isInteger: __webpack_require__(/*! ./_is-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-integer.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-nan.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-nan.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-safe-integer.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.is-safe-integer.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var isInteger = __webpack_require__(/*! ./_is-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-integer.js");

var abs = Math.abs;
$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.max-safe-integer.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.max-safe-integer.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MAX_SAFE_INTEGER: 0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.min-safe-integer.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.min-safe-integer.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MIN_SAFE_INTEGER: -0x1fffffffffffff
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.parse-float.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.parse-float.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_parse-float.js"); // 20.1.2.12 Number.parseFloat(string)


$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.parse-int.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.parse-int.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_parse-int.js"); // 20.1.2.13 Number.parseInt(string, radix)


$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.to-fixed.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.to-fixed.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-number-value.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-repeat.js");

var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function multiply(n, c) {
  var i = -1;
  var c2 = c;

  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function divide(n) {
  var i = 6;
  var c = 0;

  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = c % n * 1e7;
  }
};

var numToString = function numToString() {
  var i = 6;
  var s = '';

  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  }

  return s;
};

var pow = function pow(x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function log(x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);

    if (x < 0) {
      s = '-';
      x = -x;
    }

    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(0, z);
        j = f;

        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }

        multiply(pow(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }

        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }

    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    }

    return m;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.to-precision.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.number.to-precision.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-number-value.js");

var $toPrecision = 1.0.toPrecision;
$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.assign.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.assign.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S + $export.F, 'Object', {
  assign: __webpack_require__(/*! ./_object-assign */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-assign.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.create.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.create.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js"); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


$export($export.S, 'Object', {
  create: __webpack_require__(/*! ./_object-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-create.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.define-properties.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.define-properties.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js"); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperties: __webpack_require__(/*! ./_object-dps */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dps.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.define-property.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.define-property.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js"); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperty: (__webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js").f)
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.freeze.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.freeze.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var meta = (__webpack_require__(/*! ./_meta */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_meta.js").onFreeze);

__webpack_require__(/*! ./_object-sap */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.get-own-property-descriptor.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js");

var $getOwnPropertyDescriptor = (__webpack_require__(/*! ./_object-gopd */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js").f);

__webpack_require__(/*! ./_object-sap */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.get-own-property-names.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.get-own-property-names.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(/*! ./_object-sap */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return (__webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn-ext.js").f);
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.get-prototype-of.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.get-prototype-of.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gpo.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is-extensible.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is-extensible.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js")('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is-frozen.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is-frozen.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js")('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is-sealed.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is-sealed.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js")('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.is.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  is: __webpack_require__(/*! ./_same-value */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_same-value.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.keys.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.keys.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.prevent-extensions.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.prevent-extensions.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var meta = (__webpack_require__(/*! ./_meta */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_meta.js").onFreeze);

__webpack_require__(/*! ./_object-sap */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js")('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.seal.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.seal.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var meta = (__webpack_require__(/*! ./_meta */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_meta.js").onFreeze);

__webpack_require__(/*! ./_object-sap */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-sap.js")('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.set-prototype-of.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.set-prototype-of.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  setPrototypeOf: (__webpack_require__(/*! ./_set-proto */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-proto.js").set)
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.to-string.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.object.to-string.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // 19.1.3.6 Object.prototype.toString()

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_classof.js");

var test = {};
test[__webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('toStringTag')] = 'z';

if (test + '' != '[object z]') {
  __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.parse-float.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.parse-float.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_parse-float.js"); // 18.2.4 parseFloat(string)


$export($export.G + $export.F * (parseFloat != $parseFloat), {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.parse-int.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.parse-int.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_parse-int.js"); // 18.2.5 parseInt(string, radix)


$export($export.G + $export.F * (parseInt != $parseInt), {
  parseInt: $parseInt
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.promise.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.promise.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_library.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var ctx = __webpack_require__(/*! ./_ctx */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_ctx.js");

var classof = __webpack_require__(/*! ./_classof */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_classof.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_for-of.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_species-constructor.js");

var task = (__webpack_require__(/*! ./_task */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_task.js").set);

var microtask = __webpack_require__(/*! ./_microtask */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_microtask.js")();

var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__(/*! ./_perform */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_perform.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_user-agent.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_promise-resolve.js");

var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';

var empty = function empty() {
  /* empty */
};

var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);

    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) {
    /* empty */
  }
}(); // helpers

var isThenable = function isThenable(it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function notify(promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;

    var run = function run(reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // may throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };

    while (chain.length > i) {
      run(chain[i++]);
    } // variable length - can't use forEach


    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};

var onUnhandled = function onUnhandled(promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;

    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({
            promise: promise,
            reason: value
          });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }

    promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};

var isUnhandled = function isUnhandled(promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};

var onHandleUnhandled = function onHandleUnhandled(promise) {
  task.call(global, function () {
    var handler;

    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({
        promise: promise,
        reason: promise._v
      });
    }
  });
};

var $reject = function $reject(value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};

var $resolve = function $resolve(value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");

    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = {
          _w: promise,
          _d: false
        }; // wrap

        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({
      _w: promise,
      _d: false
    }, e); // wrap
  }
}; // constructor polyfill


if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);

    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions

    this._a = undefined; // <- checked in isUnhandled reactions

    this._s = 0; // <- state

    this._d = false; // <- done

    this._v = undefined; // <- value

    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

    this._n = false; // <- notify
  };

  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;

      this._c.push(reaction);

      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function _catch(onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function OwnPromiseCapability() {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Promise: $Promise
});

__webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);

__webpack_require__(/*! ./_set-species */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-species.js")(PROMISE);

Wrapper = __webpack_require__(/*! ./_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js")[PROMISE]; // statics

$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.apply.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.apply.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var rApply = ((__webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js").Reflect) || {}).apply;
var fApply = Function.apply; // MS Edge argumentsList argument is optional

$export($export.S + $export.F * !__webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  rApply(function () {
    /* empty */
  });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.construct.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.construct.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var create = __webpack_require__(/*! ./_object-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-create.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var bind = __webpack_require__(/*! ./_bind */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_bind.js");

var rConstruct = ((__webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js").Reflect) || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails(function () {
  function F() {
    /* empty */
  }

  return !(rConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {
    /* empty */
  });
});
$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.define-property.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.define-property.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-primitive.js"); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, {
    value: 1
  }), 1, {
    value: 2
  });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);

    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.delete-property.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.delete-property.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var gOPD = (__webpack_require__(/*! ./_object-gopd */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js").f);

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.enumerate.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.enumerate.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // 26.1.5 Reflect.enumerate(target)

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var Enumerate = function Enumerate(iterated) {
  this._t = anObject(iterated); // target

  this._i = 0; // next index

  var keys = this._k = []; // keys

  var key;

  for (key in iterated) {
    keys.push(key);
  }
};

__webpack_require__(/*! ./_iter-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-create.js")(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;

  do {
    if (that._i >= keys.length) return {
      value: undefined,
      done: true
    };
  } while (!((key = keys[that._i++]) in that._t));

  return {
    value: key,
    done: false
  };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.get-prototype-of.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.get-prototype-of.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var getProto = __webpack_require__(/*! ./_object-gpo */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gpo.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.get.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.get.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

function get(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {
  get: get
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.has.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.has.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.is-extensible.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.is-extensible.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var $isExtensible = Object.isExtensible;
$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.own-keys.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.own-keys.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  ownKeys: __webpack_require__(/*! ./_own-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_own-keys.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.prevent-extensions.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.prevent-extensions.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var $preventExtensions = Object.preventExtensions;
$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);

    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.set-prototype-of.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.set-prototype-of.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var setProto = __webpack_require__(/*! ./_set-proto */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-proto.js");

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);

    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.set.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.reflect.set.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_property-desc.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

function set(target, propertyKey, V
/* , receiver */
) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;

  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }

    ownDesc = createDesc(0);
  }

  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;

    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));

    return true;
  }

  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {
  set: set
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.constructor.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.constructor.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_inherit-if-required.js");

var dP = (__webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js").f);

var gOPN = (__webpack_require__(/*! ./_object-gopn */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn.js").f);

var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-regexp.js");

var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_flags.js");

var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" creates a new object, old webkit buggy here

var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js")('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };

  var proxy = function proxy(key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function get() {
        return Base[key];
      },
      set: function set(it) {
        Base[key] = it;
      }
    });
  };

  for (var keys = gOPN(Base), i = 0; keys.length > i;) {
    proxy(keys[i++]);
  }

  proto.constructor = $RegExp;
  $RegExp.prototype = proto;

  __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__(/*! ./_set-species */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-species.js")('RegExp');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.exec.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.exec.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_regexp-exec.js");

__webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.flags.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.flags.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') (__webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js").f)(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(/*! ./_flags */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_flags.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.match.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.match.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@match logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative($match, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regExpExec(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regExpExec(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.replace.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.replace.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-integer.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_regexp-exec-abstract.js");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function maybeToString(it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative($replace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max(min(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) {
        captures.push(maybeToString(result[j]));
      }

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.search.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.search.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var sameValue = __webpack_require__(/*! ./_same-value */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_same-value.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@search logic


__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [// `String.prototype.search` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, // `RegExp.prototype[@@search]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
  function (regexp) {
    var res = maybeCallNative($search, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var previousLastIndex = rx.lastIndex;
    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = regExpExec(rx, S);
    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.split.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.split.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isRegExp = __webpack_require__(/*! ./_is-regexp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-regexp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_species-constructor.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_advance-string-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var callRegExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_regexp-exec-abstract.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_regexp-exec.js");

var fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !fails(function () {
  RegExp(MAX_UINT32, 'y');
}); // @@split logic

__webpack_require__(/*! ./_fix-re-wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;

  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function internalSplit(separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }

        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }

      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    }; // Chakra, V8

  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function internalSplit(separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = defined(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.to-string.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.to-string.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ./es6.regexp.flags */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.regexp.flags.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var $flags = __webpack_require__(/*! ./_flags */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_flags.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js");

var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function define(fn) {
  __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
}; // 21.2.5.14 RegExp.prototype.toString()


if (__webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return $toString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
})) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  }); // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.set.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.set.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_validate-collection.js");

var SET = 'Set'; // 23.2 Set Objects

module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection.js")(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.anchor.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.anchor.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.2 String.prototype.anchor(name)

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.big.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.big.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.3 String.prototype.big()

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.blink.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.blink.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.4 String.prototype.blink()

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.bold.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.bold.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.5 String.prototype.bold()

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.code-point-at.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.code-point-at.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-at.js")(false);

$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.ends-with.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.ends-with.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-context.js");

var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails-is-regexp.js")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.fixed.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.fixed.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.6 String.prototype.fixed()

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.fontcolor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.fontcolor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.7 String.prototype.fontcolor(color)

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.fontsize.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.fontsize.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.8 String.prototype.fontsize(size)

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.from-code-point.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.from-code-point.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-absolute-index.js");

var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;

    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.includes.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.includes.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-context.js");

var INCLUDES = 'includes';
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails-is-regexp.js")(INCLUDES), 'String', {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.italics.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.italics.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.9 String.prototype.italics()

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.iterator.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.iterator.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $at = __webpack_require__(/*! ./_string-at */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-at.js")(true); // 21.1.3.27 String.prototype[@@iterator]()


__webpack_require__(/*! ./_iter-define */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target

  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.link.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.link.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.10 String.prototype.link(url)

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.raw.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.raw.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;

    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.repeat.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.repeat.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(/*! ./_string-repeat */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-repeat.js")
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.small.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.small.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.11 String.prototype.small()

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.starts-with.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.starts-with.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-context.js");

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails-is-regexp.js")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.strike.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.strike.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.12 String.prototype.strike()

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.sub.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.sub.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.13 String.prototype.sub()

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.sup.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.sup.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // B.2.3.14 String.prototype.sup()

__webpack_require__(/*! ./_string-html */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-html.js")('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.trim.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.string.trim.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // 21.1.3.25 String.prototype.trim()

__webpack_require__(/*! ./_string-trim */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-trim.js")('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.symbol.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.symbol.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // ECMAScript 6 symbols shim

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_has.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_descriptors.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js");

var META = (__webpack_require__(/*! ./_meta */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_meta.js").KEY);

var $fails = __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js");

var shared = __webpack_require__(/*! ./_shared */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_shared.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-to-string-tag.js");

var uid = __webpack_require__(/*! ./_uid */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_uid.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks-ext.js");

var wksDefine = __webpack_require__(/*! ./_wks-define */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks-define.js");

var enumKeys = __webpack_require__(/*! ./_enum-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_enum-keys.js");

var isArray = __webpack_require__(/*! ./_is-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-array.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-primitive.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_property-desc.js");

var _create = __webpack_require__(/*! ./_object-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-create.js");

var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn-ext.js");

var $GOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js");

var $GOPS = __webpack_require__(/*! ./_object-gops */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gops.js");

var $DP = __webpack_require__(/*! ./_object-dp */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-dp.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys.js");

var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function get() {
      return dP(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && _typeof($Symbol.iterator) == 'symbol' ? function (it) {
  return _typeof(it) == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);

  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, {
        enumerable: createDesc(0, false)
      });
    }

    return setSymbolDesc(it, key, D);
  }

  return dP(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) {
    $defineProperty(it, key = keys[i++], P[key]);
  }

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
}; // 19.4.1.1 Symbol([description])


if (!USE_NATIVE) {
  $Symbol = function _Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function $set(value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };

    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: $set
    });
    return wrap(tag);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  (__webpack_require__(/*! ./_object-gopn */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopn.js").f) = gOPNExt.f = $getOwnPropertyNames;
  (__webpack_require__(/*! ./_object-pie */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-pie.js").f) = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Symbol: $Symbol
});

for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
  wks(es6Symbols[j++]);
}

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
  wksDefine(wellKnownSymbols[k++]);
}

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function _for(key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) {
      if (SymbolRegistry[key] === sym) return key;
    }
  },
  useSetter: function useSetter() {
    setter = true;
  },
  useSimple: function useSimple() {
    setter = false;
  }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443

var FAILS_ON_PRIMITIVES = $fails(function () {
  $GOPS.f(1);
});
$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
}); // 24.3.2 JSON.stringify(value [, replacer [, space]])

$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols

  return _stringify([S]) != '[null]' || _stringify({
    a: S
  }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function replacer(key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
}); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

setToStringTag(global.JSON, 'JSON', true);

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.array-buffer.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.array-buffer.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $typed = __webpack_require__(/*! ./_typed */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed.js");

var buffer = __webpack_require__(/*! ./_typed-buffer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-buffer.js");

var anObject = __webpack_require__(/*! ./_an-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_an-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var ArrayBuffer = (__webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js").ArrayBuffer);

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_species-constructor.js");

var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';
$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
  ArrayBuffer: $ArrayBuffer
});
$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});
$export($export.P + $export.U + $export.F * __webpack_require__(/*! ./_fails */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_fails.js")(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix

    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;

    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }

    return result;
  }
});

__webpack_require__(/*! ./_set-species */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_set-species.js")(ARRAY_BUFFER);

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.data-view.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.data-view.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

$export($export.G + $export.W + $export.F * !(__webpack_require__(/*! ./_typed */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed.js").ABV), {
  DataView: (__webpack_require__(/*! ./_typed-buffer */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-buffer.js").DataView)
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.float32-array.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.float32-array.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./_typed-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-array.js")('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.float64-array.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.float64-array.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./_typed-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-array.js")('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.int16-array.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.int16-array.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./_typed-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-array.js")('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.int32-array.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.int32-array.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./_typed-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-array.js")('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.int8-array.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.int8-array.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./_typed-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-array.js")('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint16-array.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint16-array.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./_typed-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint32-array.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint32-array.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./_typed-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./_typed-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.typed.uint8-clamped-array.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./_typed-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.weak-map.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.weak-map.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var each = __webpack_require__(/*! ./_array-methods */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-methods.js")(0);

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js");

var meta = __webpack_require__(/*! ./_meta */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_meta.js");

var assign = __webpack_require__(/*! ./_object-assign */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-assign.js");

var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection-weak.js");

var isObject = __webpack_require__(/*! ./_is-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_is-object.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_validate-collection.js");

var NATIVE_WEAK_MAP = __webpack_require__(/*! ./_validate-collection */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_validate-collection.js");

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function wrapper(get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
}; // 23.3 WeakMap Objects

var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix


if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();

        var result = this._f[key](a, b);

        return key == 'set' ? this : result; // store all the rest on native weakmap
      }

      return method.call(this, a, b);
    });
  });
}

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.weak-set.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.weak-set.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var weak = __webpack_require__(/*! ./_collection-weak */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection-weak.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_validate-collection.js");

var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

__webpack_require__(/*! ./_collection */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_collection.js")(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.array.flat-map.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.array.flat-map.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__(/*! ./_to-object */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-length.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_a-function.js");

var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_add-to-unscopables.js")('flatMap');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.array.includes.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.array.includes.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // https://github.com/tc39/Array.prototype.includes

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $includes = __webpack_require__(/*! ./_array-includes */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_array-includes.js")(true);

$export($export.P, 'Array', {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_add-to-unscopables.js")('includes');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.object.entries.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.object.entries.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $entries = __webpack_require__(/*! ./_object-to-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-to-array.js")(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var ownKeys = __webpack_require__(/*! ./_own-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_own-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_to-iobject.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-gopd.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;

    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }

    return result;
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.object.values.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.object.values.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $values = __webpack_require__(/*! ./_object-to-array */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-to-array.js")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.promise.finally.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.promise.finally.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_species-constructor.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', {
  'finally': function _finally(onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.pad-end.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.pad-end.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.pad-start.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.pad-start.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.trim-left.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.trim-left.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-trim.js")('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.trim-right.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.string.trim-right.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_string-trim.js")('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ./_wks-define */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks-define.js")('asyncIterator');

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/web.dom.iterable.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/web.dom.iterable.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $iterators = __webpack_require__(/*! ./es6.array.iterator */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/es6.array.iterator.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_object-keys.js");

var redefine = __webpack_require__(/*! ./_redefine */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_redefine.js");

var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_iterators.js");

var wks = __webpack_require__(/*! ./_wks */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_wks.js");

var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;
var DOMIterables = {
  CSSRuleList: true,
  // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true,
  // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true,
  // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;

  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) {
      if (!proto[key]) redefine(proto, key, $iterators[key], true);
    }
  }
}

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/web.immediate.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/web.immediate.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var $task = __webpack_require__(/*! ./_task */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_task.js");

$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/modules/web.timers.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/modules/web.timers.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(/*! ./_global */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_export.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_user-agent.js");

var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function wrap(set) {
  return function (fn, time
  /* , ...args */
  ) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};

$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),

/***/ "./node_modules/@babel/polyfill/node_modules/core-js/web/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babel/polyfill/node_modules/core-js/web/index.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! ../modules/web.timers */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/web.timers.js");

__webpack_require__(/*! ../modules/web.immediate */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/web.immediate.js");

__webpack_require__(/*! ../modules/web.dom.iterable */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/web.dom.iterable.js");

module.exports = __webpack_require__(/*! ../modules/_core */ "./node_modules/@babel/polyfill/node_modules/core-js/modules/_core.js");

/***/ }),

/***/ "./node_modules/idempotent-babel-polyfill/lib/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/idempotent-babel-polyfill/lib/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.idempotentBabelPolyfill = idempotentBabelPolyfill;
exports["default"] = void 0;

function idempotentBabelPolyfill() {
  if (!__webpack_require__.g._babelPolyfill && ( // eslint-disable-next-line no-undef
  typeof window === 'undefined' || !window._babelPolyfill)) {
    return __webpack_require__(/*! @babel/polyfill */ "./node_modules/@babel/polyfill/lib/index.js");
  }

  return null;
}

var _default = idempotentBabelPolyfill();

exports["default"] = _default;

/***/ }),

/***/ "./node_modules/loglevel-plugin-prefix/lib/loglevel-plugin-prefix.js":
/*!***************************************************************************!*\
  !*** ./node_modules/loglevel-plugin-prefix/lib/loglevel-plugin-prefix.js ***!
  \***************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function (root) {
  'use strict';

  var merge = function merge(target) {
    var i = 1;
    var length = arguments.length;
    var key;

    for (; i < length; i++) {
      for (key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          target[key] = arguments[i][key];
        }
      }
    }

    return target;
  };

  var defaults = {
    template: '[%t] %l:',
    levelFormatter: function levelFormatter(level) {
      return level.toUpperCase();
    },
    nameFormatter: function nameFormatter(name) {
      return name || 'root';
    },
    timestampFormatter: function timestampFormatter(date) {
      return date.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, '$1');
    },
    format: undefined
  };
  var loglevel;
  var configs = {};

  var reg = function reg(rootLogger) {
    if (!rootLogger || !rootLogger.getLogger) {
      throw new TypeError('Argument is not a root logger');
    }

    loglevel = rootLogger;
  };

  var apply = function apply(logger, config) {
    if (!logger || !logger.setLevel) {
      throw new TypeError('Argument is not a logger');
    }
    /* eslint-disable vars-on-top */


    var originalFactory = logger.methodFactory;
    var name = logger.name || '';
    var parent = configs[name] || configs[''] || defaults;
    /* eslint-enable vars-on-top */

    function methodFactory(methodName, logLevel, loggerName) {
      var originalMethod = originalFactory(methodName, logLevel, loggerName);
      var options = configs[loggerName] || configs[''];
      var hasTimestamp = options.template.indexOf('%t') !== -1;
      var hasLevel = options.template.indexOf('%l') !== -1;
      var hasName = options.template.indexOf('%n') !== -1;
      return function () {
        var content = '';
        var length = arguments.length;
        var args = Array(length);
        var key = 0;

        for (; key < length; key++) {
          args[key] = arguments[key];
        } // skip the root method for child loggers to prevent duplicate logic


        if (name || !configs[loggerName]) {
          /* eslint-disable vars-on-top */
          var timestamp = options.timestampFormatter(new Date());
          var level = options.levelFormatter(methodName);
          var lname = options.nameFormatter(loggerName);
          /* eslint-enable vars-on-top */

          if (options.format) {
            content += options.format(level, lname, timestamp);
          } else {
            content += options.template;

            if (hasTimestamp) {
              content = content.replace(/%t/, timestamp);
            }

            if (hasLevel) content = content.replace(/%l/, level);
            if (hasName) content = content.replace(/%n/, lname);
          }

          if (args.length && typeof args[0] === 'string') {
            // concat prefix with first argument to support string substitutions
            args[0] = content + ' ' + args[0];
          } else {
            args.unshift(content);
          }
        }

        originalMethod.apply(undefined, args);
      };
    }

    if (!configs[name]) {
      logger.methodFactory = methodFactory;
    } // for remove inherited format option if template option preset


    config = config || {};
    if (config.template) config.format = undefined;
    configs[name] = merge({}, parent, config);
    logger.setLevel(logger.getLevel());

    if (!loglevel) {
      logger.warn('It is necessary to call the function reg() of loglevel-plugin-prefix before calling apply. From the next release, it will throw an error. See more: https://github.com/kutuluk/loglevel-plugin-prefix/blob/master/README.md');
    }

    return logger;
  };

  var api = {
    reg: reg,
    apply: apply
  };
  var save;

  if (root) {
    save = root.prefix;

    api.noConflict = function () {
      if (root.prefix === api) {
        root.prefix = save;
      }

      return api;
    };
  }

  return api;
});

/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
  "use strict";

  if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function () {
  "use strict"; // Slightly dubious tricks to cut down minimized file size

  var noop = function noop() {};

  var undefinedType = "undefined";
  var isIE = (typeof window === "undefined" ? "undefined" : _typeof(window)) !== undefinedType && _typeof(window.navigator) !== undefinedType && /Trident\/|MSIE /.test(window.navigator.userAgent);
  var logMethods = ["trace", "debug", "info", "warn", "error"]; // Cross-browser bind equivalent that works at least back to IE6

  function bindMethod(obj, methodName) {
    var method = obj[methodName];

    if (typeof method.bind === 'function') {
      return method.bind(obj);
    } else {
      try {
        return Function.prototype.bind.call(method, obj);
      } catch (e) {
        // Missing bind shim or IE8 + Modernizr, fallback to wrapping
        return function () {
          return Function.prototype.apply.apply(method, [obj, arguments]);
        };
      }
    }
  } // Trace() doesn't print the message in IE, so for that case we need to wrap it


  function traceForIE() {
    if (console.log) {
      if (console.log.apply) {
        console.log.apply(console, arguments);
      } else {
        // In old IE, native console methods themselves don't have apply().
        Function.prototype.apply.apply(console.log, [console, arguments]);
      }
    }

    if (console.trace) console.trace();
  } // Build the best logging method possible for this env
  // Wherever possible we want to bind, not wrap, to preserve stack traces


  function realMethod(methodName) {
    if (methodName === 'debug') {
      methodName = 'log';
    }

    if ((typeof console === "undefined" ? "undefined" : _typeof(console)) === undefinedType) {
      return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
    } else if (methodName === 'trace' && isIE) {
      return traceForIE;
    } else if (console[methodName] !== undefined) {
      return bindMethod(console, methodName);
    } else if (console.log !== undefined) {
      return bindMethod(console, 'log');
    } else {
      return noop;
    }
  } // These private functions always need `this` to be set properly


  function replaceLoggingMethods(level, loggerName) {
    /*jshint validthis:true */
    for (var i = 0; i < logMethods.length; i++) {
      var methodName = logMethods[i];
      this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);
    } // Define log.log as an alias for log.debug


    this.log = this.debug;
  } // In old IE versions, the console isn't present until you first open it.
  // We build realMethod() replacements here that regenerate logging methods


  function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
    return function () {
      if ((typeof console === "undefined" ? "undefined" : _typeof(console)) !== undefinedType) {
        replaceLoggingMethods.call(this, level, loggerName);
        this[methodName].apply(this, arguments);
      }
    };
  } // By default, we use closely bound real methods wherever possible, and
  // otherwise we wait for a console to appear, and then try again.


  function defaultMethodFactory(methodName, level, loggerName) {
    /*jshint validthis:true */
    return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);
  }

  function Logger(name, defaultLevel, factory) {
    var self = this;
    var currentLevel;
    defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;
    var storageKey = "loglevel";

    if (typeof name === "string") {
      storageKey += ":" + name;
    } else if (_typeof(name) === "symbol") {
      storageKey = undefined;
    }

    function persistLevelIfPossible(levelNum) {
      var levelName = (logMethods[levelNum] || 'silent').toUpperCase();
      if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === undefinedType || !storageKey) return; // Use localStorage if available

      try {
        window.localStorage[storageKey] = levelName;
        return;
      } catch (ignore) {} // Use session cookie as fallback


      try {
        window.document.cookie = encodeURIComponent(storageKey) + "=" + levelName + ";";
      } catch (ignore) {}
    }

    function getPersistedLevel() {
      var storedLevel;
      if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === undefinedType || !storageKey) return;

      try {
        storedLevel = window.localStorage[storageKey];
      } catch (ignore) {} // Fallback to cookies if local storage gives us nothing


      if (_typeof(storedLevel) === undefinedType) {
        try {
          var cookie = window.document.cookie;
          var location = cookie.indexOf(encodeURIComponent(storageKey) + "=");

          if (location !== -1) {
            storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
          }
        } catch (ignore) {}
      } // If the stored level is not valid, treat it as if nothing was stored.


      if (self.levels[storedLevel] === undefined) {
        storedLevel = undefined;
      }

      return storedLevel;
    }

    function clearPersistedLevel() {
      if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === undefinedType || !storageKey) return; // Use localStorage if available

      try {
        window.localStorage.removeItem(storageKey);
        return;
      } catch (ignore) {} // Use session cookie as fallback


      try {
        window.document.cookie = encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
      } catch (ignore) {}
    }
    /*
     *
     * Public logger API - see https://github.com/pimterry/loglevel for details
     *
     */


    self.name = name;
    self.levels = {
      "TRACE": 0,
      "DEBUG": 1,
      "INFO": 2,
      "WARN": 3,
      "ERROR": 4,
      "SILENT": 5
    };
    self.methodFactory = factory || defaultMethodFactory;

    self.getLevel = function () {
      return currentLevel;
    };

    self.setLevel = function (level, persist) {
      if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
        level = self.levels[level.toUpperCase()];
      }

      if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
        currentLevel = level;

        if (persist !== false) {
          // defaults to true
          persistLevelIfPossible(level);
        }

        replaceLoggingMethods.call(self, level, name);

        if ((typeof console === "undefined" ? "undefined" : _typeof(console)) === undefinedType && level < self.levels.SILENT) {
          return "No console available for logging";
        }
      } else {
        throw "log.setLevel() called with invalid level: " + level;
      }
    };

    self.setDefaultLevel = function (level) {
      defaultLevel = level;

      if (!getPersistedLevel()) {
        self.setLevel(level, false);
      }
    };

    self.resetLevel = function () {
      self.setLevel(defaultLevel, false);
      clearPersistedLevel();
    };

    self.enableAll = function (persist) {
      self.setLevel(self.levels.TRACE, persist);
    };

    self.disableAll = function (persist) {
      self.setLevel(self.levels.SILENT, persist);
    }; // Initialize with the right level


    var initialLevel = getPersistedLevel();

    if (initialLevel == null) {
      initialLevel = defaultLevel;
    }

    self.setLevel(initialLevel, false);
  }
  /*
   *
   * Top-level API
   *
   */


  var defaultLogger = new Logger();
  var _loggersByName = {};

  defaultLogger.getLogger = function getLogger(name) {
    if (_typeof(name) !== "symbol" && typeof name !== "string" || name === "") {
      throw new TypeError("You must supply a name when creating a logger.");
    }

    var logger = _loggersByName[name];

    if (!logger) {
      logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);
    }

    return logger;
  }; // Grab the current global log variable in case of overwrite


  var _log = (typeof window === "undefined" ? "undefined" : _typeof(window)) !== undefinedType ? window.log : undefined;

  defaultLogger.noConflict = function () {
    if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== undefinedType && window.log === defaultLogger) {
      window.log = _log;
    }

    return defaultLogger;
  };

  defaultLogger.getLoggers = function getLoggers() {
    return _loggersByName;
  }; // ES6 default export, for compatibility


  defaultLogger['default'] = defaultLogger;
  return defaultLogger;
});

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }

  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  define(Gp, iteratorSymbol, function () {
    return this;
  });
  define(Gp, "toString", function () {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
( false ? 0 : _typeof(module)) === "object" ? module.exports : {});

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if ((typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

/***/ }),

/***/ "./node_modules/wasm-check/dist/wasm-check.min.js":
/*!********************************************************!*\
  !*** ./node_modules/wasm-check/dist/wasm-check.min.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function e(e, n) {
  if (!r) return !1;
  var u = e.buffer;
  var i = l.get(u);

  if (null == i) {
    if ((i = t.validate(u)) && n) try {
      new t.Instance(new t.Module(u)).exports[0]();
    } catch (e) {
      i = !1;
    }
    l.set(u, i);
  }

  return i;
}

var t = globalThis.WebAssembly,
    r = "object" == _typeof(t),
    n = function n(e) {
  return void 0 !== e;
},
    u = function u() {
  for (var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++) {
    e[_key] = arguments[_key];
  }

  return Uint8Array.of.apply(Uint8Array, [0, 97, 115, 109, 1, 0, 0, 0].concat(e));
},
    i = function i() {
  for (var _len2 = arguments.length, e = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    e[_key2] = arguments[_key2];
  }

  return Uint32Array.of.apply(Uint32Array, [1836278016, 1].concat(e));
},
    o = function o() {
  for (var _len3 = arguments.length, e = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    e[_key3] = arguments[_key3];
  }

  return i.apply(void 0, [1610679297, 33751040].concat(e, [40239360, 259]));
},
    a = function a() {
  for (var _len4 = arguments.length, e = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    e[_key4] = arguments[_key4];
  }

  return u.apply(void 0, [1, 4, 1, 96, 0, 0, 3, 2, 1, 0].concat(e, [11, 0, 10, 4, 110, 97, 109, 101, 2, 3, 1, 0, 0]));
},
    s = function s() {
  for (var _len5 = arguments.length, e = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    e[_key5] = arguments[_key5];
  }

  return Uint16Array.of.apply(Uint16Array, [24832, 28019, 1, 0, 1025, 24577, 0, 515, 1].concat(e));
},
    g = function g() {
  for (var _len6 = arguments.length, e = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    e[_key6] = arguments[_key6];
  }

  return s.apply(void 0, e.concat([2842, 4096, 28164, 28001, 357, 260, 256, 560, 259, 0]));
},
    l = new WeakMap(),
    f = i(1610679553, 58589440, 117440770, 805372165, 101318656, 1107297281, 268438272, 1835101700, 17039717, 36700416, 259),
    c = u(5, 3, 1, 4, 1, 0, 8, 4, 110, 97, 109, 101, 2, 1, 0),
    y = s(773, 1, 2561, 269, 11, 65, 65, 65, 3068, 2816, 2560, 28164, 28001, 613, 259, 0),
    p = i(1610679297, 33751040, 134873089, 100664833, 185276736),
    m = u(2, 8, 1, 1, 97, 1, 98, 3, 127, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 5, 1, 1, 97, 3, 1, 0, 8, 4, 110, 97, 109, 101, 2, 1, 0),
    b = Uint16Array.of(24832, 28019, 1, 0, 1537, 24577, 512, 32639, 515, 1, 2058, 1537, 16640, 16640, 2816, 2560, 28164, 28001, 613, 259, 0),
    d = g(3082, 2561, 17152, 0, 0, 252),
    A = g(2058, 1537, 16640, 49152),
    U = o(101318657, 301990913, 268438272, 1835101700, 17039717),
    x = a(5, 4, 1, 3, 1, 1, 10, 7, 1, 5, 0, 254, 3, 0),
    h = o(84344833, 6357249, 17369600, 4259847, 186257917, 1845758464),
    v = a(10, 7, 1, 5, 0, 208, 112, 26);

module.exports = {
  support: function support() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return r && e(Uint32Array.of(1836278016, t));
  },

  get supportStreaming() {
    return r && n(t.instantiateStreaming);
  },

  feature: {
    get bigInt() {
      return e(f, !0);
    },

    get bulk() {
      return e(y);
    },

    get exceptions() {
      return e(p);
    },

    get memory64() {
      return e(c);
    },

    get mutableGlobal() {
      return e(m);
    },

    get multiValue() {
      return e(b);
    },

    get saturateConversions() {
      return e(d);
    },

    get signExtensions() {
      return e(A);
    },

    get tailCall() {
      return e(U);
    },

    get threads() {
      return e(x);
    },

    get simd() {
      return e(h);
    },

    get references() {
      return e(v);
    },

    get typeReflection() {
      return r && n(t.Memory.type);
    },

    get funcReferences() {
      return r && n(t.Function);
    }

  }
};

/***/ }),

/***/ "./src/Core/AicConsoleManager.js":
/*!***************************************!*\
  !*** ./src/Core/AicConsoleManager.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AicConsoleManager": () => (/* binding */ AicConsoleManager)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }


var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ReceivedInvitation');
/**
 * Aic_controle_manager interact with AIC console at - https://cdn.apizee.com/apiRTC/aic-console.exe
 * Remote stream class
 * 
 * 
 * 
 */

var AicConsoleManager = /*#__PURE__*/function () {
  /**
   * Create new manager only 1 adviced
   * 
   * @param {object} contact
   * @return {AicConsoleManager} this
   */
  function AicConsoleManager(contact) {
    _classCallCheck(this, AicConsoleManager);

    logger.info("Create AicConsoleManager");
    this.ws = null;
    this.status = "Not connected";
    this.domStream = null; // Set keyboard_mode=1 to use scan codes (leading to keymap issues)

    this.keyboard_mode = 0;
    this.contact = contact;
  }
  /**
   * Send RaWData in the contact with : 
   *  - event: 'command'
   *  - value: <your message>
   * Usually mouse or keyboard aic message 
   * 
   * @ignore
   * @param {String} message 
   */


  _createClass(AicConsoleManager, [{
    key: "aic_control_onmessage",
    value: function aic_control_onmessage(message) {
      // Receive local events from mouse and keyboard
      if (this.contact) {
        // Send local events (mouse, keyboard) to other party
        this.contact.sendRemoteControlInvitation(this.contact.getId(), null, {
          event: 'command',
          value: message
        });
      }
    }
  }, {
    key: "getWs",
    value: function getWs() {
      return this.ws;
    }
    /**
     * Send a text message to the agent using the websocket
     * 
     * @param {String} message 
     * @return {void}
     */

  }, {
    key: "aic_agent_send_message",
    value: function aic_agent_send_message(message) {
      try {
        this.ws.send(message);
      } catch (e) {
        _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.warn('Console deconnected');
      }
    }
    /**
     * Set ws status
     * 
     * @param {String} status
     * @return {void} 
     */

  }, {
    key: "ws_set_status",
    value: function ws_set_status(status) {
      this.status = status;
    }
    /**
     * gett ws status
     * 
     * @return {String} 
     */

  }, {
    key: "get_set_status",
    value: function get_set_status() {
      return this.status;
    }
    /**
     * 
     * Function establish mouse and keybord listener on Stream parameter
     * 
     * @param {Stream} stream 
     * @return {void}
     */

  }, {
    key: "aic_control_start",
    value: function aic_control_start(streamID, screenWidth, screenHeight) {
      var _this = this;

      window.oncontextmenu = function () {
        return false; // cancel default menu
      }; //LISTENER MUST BE A DOM ELEMENT


      var domSearchFilter = "remote-stream-" + streamID;
      this.searchDOMElement(domSearchFilter).then(function () {
        if (_this.domStream) {
          _this.domStream.style.cursor = "none";
          /*
           * 
           */

          document.addEventListener('keyup', function (e) {
            _this.key_up(e);
          }, {
            passive: false
          });
          /*
           * 
           */

          document.addEventListener('keydown', function (e) {
            _this.key_down(e);
          }, {
            passive: false
          });
          /*
           * listener fire when mouse move 
           */

          _this.domStream.addEventListener('mousemove', function (e) {
            _this.mouse_move(e, screenWidth, screenHeight);
          }, true);
          /*
           * listener fire when double clic on mouse 
           */


          _this.domStream.addEventListener('dblclick', function (e) {
            _this.mouse_doubleclick(e);
          }, true);
          /*
           *  listener fire when mouse clic is press 
           */


          _this.domStream.addEventListener('mousedown', function (e) {
            _this.mouse_down(e);
          }, true);
          /*
           * listener fire when mouse clic is release 
           */


          _this.domStream.addEventListener('mouseup', function (e) {
            _this.mouse_up(e);
          }, true);
          /*
           *  listener fire when wheel mouse is detected 
           */


          _this.domStream.addEventListener('wheel', function (e) {
            _this.mouse_wheel(e);
          }, {
            passive: false
          });
        } else {
          _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.warn("element d'coute non trouv");
        }
      });
    }
  }, {
    key: "searchDOMElement",
    value: function searchDOMElement(domSearchFilter) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2.domStream = document.getElementById(domSearchFilter);

        if (_this2.domStream) {
          resolve();
        } else {
          setTimeout(function () {
            _this2.searchDOMElement(domSearchFilter).then(function () {
              resolve();
            });
          }, 500);
        }
      });
    }
    /**
     * Event launch by double clic on mouse
     * 
     * @param {event} e 
     */

  }, {
    key: "mouse_doubleclick",
    value: function mouse_doubleclick(e) {
      this.mouse_move(e);
      this.aic_control_onmessage("aic_mouse_doubleclick(" + e.which + ")");
    }
    /**
     * Event launch when clic mousse release
     * 
     * @param {event} e 
     */

  }, {
    key: "mouse_down",
    value: function mouse_down(e) {
      this.mouse_move(e);
      this.aic_control_onmessage("aic_mouse_down(" + e.which + ")");
    }
    /**
     * Event launch when clic mousse press
     * 
     * @param {event} e 
     */

  }, {
    key: "mouse_up",
    value: function mouse_up(e) {
      this.mouse_move(e);
      this.aic_control_onmessage("aic_mouse_up(" + e.which + ")");
    }
    /**
     * Event launch when wheel mouse is detected 
     * 
     * @param {event} e 
     */

  }, {
    key: "mouse_wheel",
    value: function mouse_wheel(e) {
      e.preventDefault();
      this.aic_control_onmessage("aic_mouse_scroll(" + e.deltaX + "," + e.deltaY * -1 + ")");
    }
    /*
         * listener fire when a key is press on keyboard 
         */

  }, {
    key: "key_down",
    value: function key_down(e) {
      e.preventDefault();

      if (e.isComposing || e.keyCode == 229) {
        _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.warn("Ignoring event : " + e);
      } else if (this.keyboard_mode == 0) {
        var flags = (e.altKey ? "MOD_ALT," : "") + (e.ctrlKey ? "MOD_CONTROL," : "") + (e.metaKey ? "MOD_META," : "") + (e.shiftKey ? "MOD_SHIFT," : "");
        this.aic_keyboard_keydown(e.key, flags);
      } else {
        this.aic_control_onmessage("aic_keyboard_keydown(" + e.code + ")");
      }
    }
    /*
     *listener fire when a key is release on keyboard 
     */

  }, {
    key: "key_up",
    value: function key_up(e) {
      e.preventDefault();

      if (e.isComposing || e.keyCode == 229) {
        _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.warn("Ignoring event : " + e);
      } else if (this.keyboard_mode == 0) {
        var flags = (e.altKey ? "MOD_ALT," : "") + (e.ctrlKey ? "MOD_CONTROL," : "") + (e.metaKey ? "MOD_META," : "") + (e.shiftKey ? "MOD_SHIFT," : "");
        this.aic_keyboard_keyup(e.key, flags);
      } else {
        this.aic_control_onmessage("aic_keyboard_keyup(" + e.code + ")");
      }
    }
    /**
     * Event launch when mouse move
     * 
     * @param {event} e 
     * @param {number} screenWidth 
     * @param {number} screenHeight 
     */

  }, {
    key: "mouse_move",
    value: function mouse_move(e, screenWidth, screenHeight) {
      var rect = e.target.getBoundingClientRect();
      var x = e.clientX - rect.left; //x position within the element.

      var y = e.clientY - rect.top; //y position within the element.

      var posx = Math.floor(x / this.domStream.clientWidth * screenWidth);
      var posy = Math.floor(y / this.domStream.clientHeight * screenHeight); //aic_mouse_move_smooth    TOTEST

      this.aic_control_onmessage("aic_mouse_move(" + posx + "," + posy + ")");
    }
    /**
     * Set flags
     * 
     * @param {*} key 
     * @param {*} flags 
     */

  }, {
    key: "aic_keyboard_keydown",
    value: function aic_keyboard_keydown(key, flags) {
      this.aic_control_onmessage("aic_keyboard_keypress(\"" + key + "\",\"KEY_DOWN," + flags + "\")");
    }
    /**
     * Set flags
     * 
     * @param {*} key 
     * @param {*} flags 
     */

  }, {
    key: "aic_keyboard_keyup",
    value: function aic_keyboard_keyup(key, flags) {
      this.aic_control_onmessage("aic_keyboard_keypress(\"" + key + "\",\"KEY_UP," + flags + "\")");
    }
    /**
     * Exit console
     */

  }, {
    key: "aic_agent_exit",
    value: function aic_agent_exit() {
      aic_control_onmessage("aic_agent_exit()");
    }
    /*
     * Start agent part which talks to the local agent using a websocket
     * 
     * @param {String} ip 
     * @returns 
     */

  }, {
    key: "aic_agent_start",
    value: function aic_agent_start(ip) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (!("WebSocket" in window)) {
          reject("WebSocket NOT supported by your Browser!");
          return;
        }

        if (_this3.status !== "Connected") {
          _this3.ws = new WebSocket("ws://" + ip + ":4545/ws", "ws-server-aic");
        } else {
          resolve();
        }

        _this3.ws.addEventListener('open', function () {
          _this3.ws_onopen(ip, resolve);
        });

        _this3.ws.addEventListener('message', _this3.ws_onmessage);

        _this3.ws.addEventListener('close', function (e) {
          _this3.ws_onclose(e);
        });

        _this3.ws.addEventListener('error', function (e) {
          _this3.ws_onerror(ip, resolve, e);
        });
      });
    }
    /**
     * Event launch when WS receive message
     * 
     * @param {event} e 
     */

  }, {
    key: "ws_onmessage",
    value: function ws_onmessage(e) {
      _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.info(e);
    }
    /**
     * Event launch when WS is close
     */

  }, {
    key: "ws_onclose",
    value: function ws_onclose(e) {
      _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.info(e);
      this.ws_set_status("Disconnected");
    }
    /**
     * Event launch when WS receive error
     * 
     * @param {number} ip 
     * @param {resolve} resolve 
     * @param {event} e 
     */

  }, {
    key: "ws_onerror",
    value: function ws_onerror(ip, resolve, e) {
      var _this4 = this;

      this.ws_set_status("Error: " + e);
      this.ws.removeEventListener('open', this.ws_onopen);
      this.ws.removeEventListener('message', this.ws_onmessage);
      this.ws.removeEventListener('close', this.ws_onclose);
      this.ws.removeEventListener('error', function () {
        return _this4.ws_onerror(ip);
      });
      this.ws.close();
      this.ws = null;
      setTimeout(function () {
        _this4.aic_agent_start(ip).then(function () {
          resolve();
        });
      }, 2000);
    }
    /**
     * Event launch when WS is open
     * 
     * @param {number} ip 
     * @param {resolve} resolve 
     */

  }, {
    key: "ws_onopen",
    value: function ws_onopen(ip, resolve) {
      this.ws_set_status("Connected");
      this.aic_agent_start(ip).then(function () {
        resolve();
      });
    }
    /**
     * to test, smooth mouse move
     * Stream have too much delay to lerp
     * 
     * @param {number} start 
     * @param {number} end 
     * @param {number} amt 
     * @returns {number} lerp position
     */

  }, {
    key: "lerp",
    value: function lerp(start, end, amt) {
      return (1 - amt) * start + amt * end;
    }
  }]);

  return AicConsoleManager;
}();



/***/ }),

/***/ "./src/Core/ApiCC.js":
/*!***************************!*\
  !*** ./src/Core/ApiCC.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "apiCC": () => (/* binding */ apiCC)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ApiCC');


var LOG_LEVEL_LABELS = {},
    LOG_LEVEL_OFF = 0,
    LOG_LEVEL_ERROR = 1,
    LOG_LEVEL_WARN = 2,
    LOG_LEVEL_INFO = 3,
    LOG_LEVEL_DEBUG = 4,
    LOG_LEVEL_TRACE = 5,
    LOG_PREFIX = "apiRTC",
    DEFAULT_LOG_LEVEL = LOG_LEVEL_DEBUG;
LOG_LEVEL_LABELS[LOG_LEVEL_ERROR] = "ERROR";
LOG_LEVEL_LABELS[LOG_LEVEL_WARN] = "WARN";
LOG_LEVEL_LABELS[LOG_LEVEL_INFO] = "INFO";
LOG_LEVEL_LABELS[LOG_LEVEL_DEBUG] = "DEBUG";
LOG_LEVEL_LABELS[LOG_LEVEL_TRACE] = "TRACE";
var apiCC = {
  /**
  * ApiRTC expose some additional parameters :
  * @typedef {Object} ApiRTC
  * @memberof module:ApiRTC
  * @property {string} version version of ApiRTC library
  * @property {string} description 'ApiRTC Cloud Communication Library'
  * @property {string} browser Browser used by your user agent
  * @property {string} browser_major_version Browser major version used by your user agent
  * @property {string} browser_version Browser version used by your user agent
  * @property {string} osName Operating system used by your user agent
  * @property {string} osVersion Operating system version used by your user agent
  */
  description: 'ApiRTC Cloud Communication Library',
  session: null,
  jsLoaded: false,
  initApiKey: null,
  initApiCCId: null,
  extJsLoadingRetryNb: null,
  extJsLoadingRetryDelay: null,
  bandwidthTestServer: "https://cloud.apizee.com",
  //thresholds are in kbps
  bandwidthRatingThresholds: [300, //Audio only
  500, //Minimal for video
  1000, 1500, 2000],
  LOG_LEVEL_OFF: LOG_LEVEL_OFF,
  LOG_LEVEL_ERROR: LOG_LEVEL_ERROR,
  LOG_LEVEL_WARN: LOG_LEVEL_WARN,
  LOG_LEVEL_INFO: LOG_LEVEL_INFO,
  LOG_LEVEL_DEBUG: LOG_LEVEL_DEBUG,
  LOG_LEVEL_TRACE: LOG_LEVEL_TRACE,
  browser: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser,
  browser_major_version: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version,
  browser_version: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version,
  osName: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osName,
  osVersion: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osVersion,
  osUAParser: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser,
  browserInfo: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browserInfo,
  browserDetails: _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails,
  parser: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.parser,
  logStorageActivated: false,
  logStorageLevel: LOG_LEVEL_INFO,
  logStorage: [],
  eventCenter: null,
  sioEmbedded: false,
  //if socketIO is embedded with apiRTC or lazy loaded
  apizee_version: "5.0"
};

/**
 * This is the description for Server API. (Deprecated)
 *
 * @module Server_Side_API
 * @deprecated Please note that this module is now deprecated as we have enhanced our recorded file management.
 * This module is keep for compatibility with former version.
 * Please contact our support for any questions concerning this subject.
**/

/**
 * <b>Description</b>
 * <p>This API can be used to read recorded video stream</p>
 * <b>http://data2.apizee.com:10000/videoManager?action=play&userId="value"&confId="value"&apiKey="value"</b>
 * </br>
 * <b>Parameters :</b>
 * action = play
 * userId = Id of the user
 * confId = Id of the registered conference
 * apiKey = apiKey of the registered user
 * </br><b>Success 200 :</b>
 * Video stream to be used as src in HTML video element
 * </br><b>Error 4xx :</b>
 * 400 - Format error
 * 404 - File error
 * 400 - file format error
 * </br><b>Error 5xx :</b>
 * 500 - stream error
 * </br><b>Example :</b>
 * <b>http://data2.apizee.com:10000/videoManager?action=play&userId=254510&confId=846445&apiKey=myDemoApiKey</b>
 * @method play
 **/

/**
 * <b>Description</b>
 * <p>This API can be used to download recorded video stream</p>
 * <b>http://data2.apizee.com:10000/videoManager?action=get&userId="value"&confId="value"&apiKey="value"</b>
 * </br>
 * <b>Parameters :</b>
 * action = get
 * userId = Id of the user
 * confId = Id of the registered conference
 * apiKey = apiKey of the registered user
 * </br><b>Success 200 :</b>
 * Video stream to be downloaded
 * </br><b>Error 4xx :</b>
 * 400 - Format error
 * 404 - File error
 * </br><b>Error 5xx :</b>
 * 500 - stream error
 * </br><b>Example :</b>
 * <b>http://data2.apizee.com:10000/videoManager?action=get&userId=254510&confId=846445&apiKey=myDemoApiKey</b>
 * @method get
 **/

/**
 * <b>Description</b>
 * <p>This API can be used to delete recorded video stream</p>
 * <b>http://data2.apizee.com:10000/videoManager?action=delete&userId="value"&confId="value"&apiKey="value"</b>
 * </br>
 * <b>Parameters :</b>
 * action = delete
 * userId = Id of the user
 * confId = Id of the registered conference
 * apiKey = apiKey of the registered user
 * </br><b>Success 200 :</b>
 * File deleted
 * </br><b>Error 4xx :</b>
 * 400 - Format error
 * 404 - File not deleted
 * </br><b>Example :</b>
 * <b>http://data2.apizee.com:10000/videoManager?action=delete&userId=254510&confId=846445&apiKey=myDemoApiKey</b>
 * @method delete
 **/

/***/ }),

/***/ "./src/Core/ApiCCDataClient.js":
/*!*************************************!*\
  !*** ./src/Core/ApiCCDataClient.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiCCDataClient": () => (/* binding */ ApiCCDataClient)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ApiCCDataClient');
var myWebRTC_Event = apiCC.myWebRTC_Event;
/**
* <p>This is the ApiRTCDataClient.</p>
* <p>This class enables you to manage JSON data exchanges between two client</p>
*
* @module ApiRTCDataClient
**/

var ApiCCDataClient = function ApiCCDataClient(session) {
  //logger.info('apiCC.ApiCCDataClient');

  /**
      * <b>Description</b>
      * <p>This method enables you to send data message</p>
      * <b>Associated events :</b>
      * <li>error</li>
      * @method sendData
      * @param {String} dstId Id of the destination
      * @param {JSON} data sended data in a JSON format
      * @param {function} callback for message acknowledgment. JSON with reason (values can be ack, destNotFound, timerReached) and cSeq Number is fired.
      * @return {String} cSeq Identifier of the message
      */
  this.sendData = function (dstRoomId, data, callback) {
    logger.info('Call sending data function .... to :' + dstRoomId + ' message :' + data);
    var messageToSend = null,
        msgString = null,
        cSeq = session.channel.getNewCSeq(),
        timeOutId = null;
    messageToSend = {
      type: 'dataMessage',
      senderId: session.apiCCId,
      dstRoomId: dstRoomId,
      data: data,
      cSeq: cSeq
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);

    if (callback !== undefined) {
      logger.log('Ack management activated');
      timeOutId = setTimeout(function () {
        var callBackData = {
          reason: 'timeoutReached',
          cSeq: cSeq
        };
        callback(callBackData);

        if (apiCC.session !== null && apiCC.session !== undefined) {
          delete apiCC.session.messageTimeOutTable[cSeq];
        }
      }, session.messageTimeOutTimer);
      logger.log('timeOutId: ' + timeOutId);
      session.messageTimeOutTable[cSeq] = timeOutId;
      session.channel.socket.emit('dataMessage', msgString, function (data) {
        logger.log("callback on dataMessage");
        logger.log("callback reason :" + data.reason);
        logger.log('cSeq :' + data.cSeq);
        callback(data);

        if (apiCC.session.messageTimeOutTable[cSeq] !== undefined) {
          logger.log('clearing timeOutId: ' + apiCC.session.messageTimeOutTable[cSeq]);
          clearTimeout(apiCC.session.messageTimeOutTable[cSeq]);

          if (apiCC.session !== null && apiCC.session !== undefined) {
            delete apiCC.session.messageTimeOutTable[cSeq];
          }
        } else {
          logger.warn('messageTimeOutTable was already deleted : timeout may have been reached before Ack');
        }
      });
    } else {
      logger.log('Ack management not activated');
      session.channel.socket.emit('dataMessage', msgString);
    }

    return cSeq;
  };
  /**
      * <b>Description</b>
      * <p>This method enables you to broadcast data message to whole specifed presence group excluding self.</p>
      * <b>Associated events :</b>
      * <li>error</li>
      * @method sendDataToGroup
      * @param {String} group Id of the destination
      * @param {String} data sent text message
      * @return {Void}
  */


  this.sendDataToGroup = function (group, data) {
    logger.info("[ApiCCDataClient] sendDataToGroup - " + group);
    var i,
        list = session.getConnectedUsersList(group);

    for (i = 0; i < list.length; i++) {
      if (session.apiCCId != list[i].userId) {
        this.sendData(list[i].userId, data);
      }
    }
  };

  this.receiveData = function (msg) {
    logger.info('receiveData :' + msg.data); //ReceiveDataEvent

    myWebRTC_Event.createReceiveDataEvent(msg.senderId, msg.dstRoomId, msg.data);
  };
}; //End DataClient class

/**
* Fired when data is received
* @event receiveData
* @param {String} e.detail.time Date
* @param {String} e.detail.eventType 'receiveData'
* @param {String} e.detail.senderId Id of the data sender
* @param {String} e.detail.dstRoomId Id of the destination
* @param {String} e.detail.data received data
*/




/***/ }),

/***/ "./src/Core/ApiCCIMClient.js":
/*!***********************************!*\
  !*** ./src/Core/ApiCCIMClient.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiCCIMClient": () => (/* binding */ ApiCCIMClient)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* harmony import */ var _WebRTC_Stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebRTC_Stack */ "./src/Core/WebRTC_Stack.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ApiCCIMClient');


/**
 * <p>This is the ApiRTCIMClient.</p>
 * <p>This class enables you to manage nstant messaging communication (Chat, group Chat)</p>
 *
 * @module ApiRTCIMClient
 */

var ApiCCIMClient = function ApiCCIMClient(session, conversationElementId) {
  this.convTable = [];
  this.myWebRTC_Event = apiCC.myWebRTC_Event;
  this.nickname = session.nickname;
  this.photoURL = null;
  this.userDataSetted = false;
  this.myWebRTC_Stack = new _WebRTC_Stack__WEBPACK_IMPORTED_MODULE_2__.WebRTC_Stack(session.channel.socket);

  this.findIMIdWithDestID = function (destId) {
    var i,
        convNumber = this.convTable.length;
    logger.log('findIMIdWithDestID = ' + destId);

    for (i = 0; i < convNumber; i += 1) {
      logger.log('this.convTable[i].dest_roomId = ' + this.convTable[i].dest_roomId);

      if (this.convTable[i].dest_roomId == destId) {
        return this.convTable[i].IMId;
      }
    }

    logger.log('Conversation IMId not found');
    return 0;
  };

  this.addInConvTable = function (conv) {
    logger.debug('addInConvTable');
    var i,
        convNumber = this.convTable.length;

    for (i = 0; i < convNumber; i += 1) {
      logger.log('this.convTable[i].dest_roomId = ' + this.convTable[i].dest_roomId);

      if (this.convTable[i].dest_roomId == conv.dest_roomId) {
        //already an entry with this dest, updating convId
        this.convTable[i].IMId = conv.IMId;
        return;
      }
    }

    logger.log('Conversation not found in the table, adding ..');
    this.convTable.push(conv);
    return;
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to send text message</p>
   * <b>Associated events :</b>
   * <li>error</li>
   * @method sendMessage
   * @param {String} dstRoomId Id of the destination
   * @param {String} message sended text message
   * @param {function} callback for message acknowledgment. JSON with reason (values can be ack, destNotFound, timerReached) and cSeq Number is fired.
   * @param {JSON} data parameter. JSON Data can be added on call and retrieved on CDR
   * @return {String} cSeq Identifier of the message
   **/


  this.sendMessage = function (dstRoomId, message, callback, data) {
    logger.info('Call sending message function .... from :' + this.nickname + ' message :' + message);
    var IMConvId = this.findIMIdWithDestID(dstRoomId),
        messageToSend = null,
        msgString = null,
        messageText = null,
        timeOutId = null,
        cSeq = session.channel.getNewCSeq();

    if (IMConvId === 0) {
      //Conv with this destination doesn't exist, Creation of a new conversation
      logger.log('Creation of a new IM conversation'); //New conversation, convId will be received from server
    } else {
      //Conversation already exist
      logger.log('Message is for existing conversation with ID : ' + IMConvId);
    }

    logger.log('IMConvId :' + IMConvId);
    messageToSend = {
      type: 'IMMessage',
      IMId: IMConvId,
      senderId: session.apiCCId,
      nickname: this.nickname,
      photoURL: this.photoURL,
      dstRoomId: dstRoomId,
      data: message,
      cSeq: cSeq,
      convData: data
    };
    session.getConnectedUserIdsList().forEach(function (element) {
      if (element.userId == dstRoomId && element.hasOwnProperty("userData") && element.userData !== null && _typeof(element.userData.hasOwnProperty("isChatbot")) && element.userData.isChatbot) {
        messageToSend.pubSub = "BotConnector";
      }
    });
    msgString = JSON.stringify(messageToSend);
    messageText = document.createElement('message');
    logger.log('C->S: ' + msgString);

    if (callback !== undefined) {
      logger.log('Ack management activated');
      timeOutId = setTimeout(function () {
        var callBackData = {
          reason: 'timeoutReached',
          cSeq: cSeq
        };
        callback(callBackData);

        if (apiCC.session !== null && apiCC.session !== undefined) {
          delete apiCC.session.messageTimeOutTable[cSeq];
        }
      }, session.messageTimeOutTimer);
      logger.log('timeOutId: ' + timeOutId);
      session.messageTimeOutTable[cSeq] = timeOutId;
      session.channel.socket.emit('IMMessage', msgString, function (data) {
        logger.log("callback on IMMessage");
        logger.log("data :", data);
        logger.log("callback reason :" + data.reason);
        logger.log("callback convId :" + data.convId);
        logger.log('cSeq :' + data.cSeq);
        callback(data);

        if (apiCC.session.messageTimeOutTable[cSeq] !== undefined) {
          logger.log('clearing timeOutId: ' + apiCC.session.messageTimeOutTable[cSeq]);
          clearTimeout(apiCC.session.messageTimeOutTable[cSeq]);

          if (apiCC.session !== null && apiCC.session !== undefined) {
            delete apiCC.session.messageTimeOutTable[cSeq];
          }
        } else {
          logger.warn('messageTimeOutTable was already deleted : timeout may have been reached before Ack');
        }
      });
    } else {
      logger.log('Ack management not activated');
      session.channel.socket.emit('IMMessage', msgString);
    }

    if (this.conversation !== null) {
      messageText.innerHTML = '<b>me :</b> ' + data + '<br>';
      this.conversation.appendChild(messageText);
      this.conversation.scrollTop = this.conversation.scrollHeight;
    }

    return cSeq;
  };

  this.newConversationCreated = function (msg) {
    logger.debug('newConversationCreated :' + msg);
    logger.log('msg.dstRoomId :' + msg.dstRoomId);
    logger.log('msg.IMId :' + msg.IMId); //This is a new conversation

    var IMConv = {
      dest_roomId: msg.dstRoomId,
      IMId: msg.IMId
    };
    this.addInConvTable(IMConv);
  };

  this.receiveMessage = function (msg) {
    logger.info('Call receiveMessage message :' + msg);
    var messageText = null,
        IMConv = null; //Update of convTable

    IMConv = {
      dest_roomId: msg.senderId,
      IMId: msg.IMId
    };
    this.addInConvTable(IMConv);

    if (this.conversation !== null) {
      messageText = document.createElement('message');
      messageText.innerHTML = '<b>' + msg.nickname + ':</b> ' + msg.data + '<br>';
      this.conversation.appendChild(messageText);
      this.conversation.scrollTop = this.conversation.scrollHeight;
    } //Sending Ack on IMMessage
    //this.myWebRTC_Stack.sendAck('IMMessage', msg.cSeq, msg.senderId);
    //ReceiveIMMessageEvent


    this.myWebRTC_Event.createReceiveIMMessageEvent(msg.senderId, msg.nickname, msg.photoURL, msg.data, msg.UUCSeq, msg.IMId);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to create a group chat</p>
   * <b>Associated events :</b>
   * <li>groupChatCreation</li>
   * @method createGroupChat
   * @param {String} initialDestId initial contact Id in the group chat
   * @param {String} newContactId new contact Id in the group chat
   **/


  this.createGroupChat = function (initialDestId, newContactId) {
    logger.info('createGroupChat with contacts : ' + initialDestId + ',' + newContactId);
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'createGroupChat',
      nickname: this.nickname,
      photoURL: this.photoURL,
      contactId1: initialDestId,
      contactId2: newContactId
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    session.channel.socket.emit('createGroupChat', msgString); //this.socket.emit('createGroupChat', msgString);
  }; //TODO : Use RoomManager for GroupChat : ApiRTC + server side


  this.groupChatCreation = function (msg) {
    logger.debug('groupChatCreation');
    this.myWebRTC_Event.createGroupChatCreationEvent(msg.status, msg.groupChatId, msg.contactId1, msg.invitationSendedToInitialDestId, msg.contactId2, msg.invitationSendedToNewContactId);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to join a group chat</p>
   * @method joinGroupChat
   * @param {String} groupChatId Id of the groupChat you want to connect
   * @param {object} options
   * @param {object} options.convId - Optional Cloud Conversation ID.
   **/


  this.joinGroupChat = function (groupChatId) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    logger.debug('joinGroupChat : ' + groupChatId);
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'joinGroupChat',
      groupChatId: groupChatId
    };

    if (options.convId) {
      messageToSend.data = {};
      messageToSend.data.cloudConvId = options.convId;
    }

    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    session.channel.socket.emit('joinGroupChat', msgString);
  };

  this.groupChatInvitation = function (msg) {
    logger.debug('groupChatInvitation');
    this.myWebRTC_Event.createGroupChatInvitationEvent(msg.groupChatId, msg.senderId, msg.senderNickname, msg.senderPhotoURL, msg.contactList);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to answer to a group chat invitation</p>
   * @method answerToGroupChatInvitation
   * @param {String} groupChatId Id of the group chat
   * @param {Boolean} accept true if user agreed to join the group chat
   **/


  this.answerToGroupChatInvitation = function (groupChatId, accept) {
    logger.debug('answerToGroupChatInvitation: ' + groupChatId + ' : ' + accept);

    if (accept === true || accept === false) {
      var messageToSend = null,
          msgString = null;
      messageToSend = {
        type: 'groupChatInvitationAnswer',
        groupChatId: groupChatId,
        senderId: session.apiCCId,
        nickname: this.nickname,
        photoURL: this.photoURL,
        accept: accept
      };
      msgString = JSON.stringify(messageToSend);
      logger.log('C->S: ' + msgString); //this.socket.emit('groupChatInvitationAnswer', msgString);

      session.channel.socket.emit('groupChatInvitationAnswer', msgString);
    } else {
      logger.log('accept value is not correct');
    }
  };

  this.groupChatMemberUpdate = function (msg) {
    logger.info('groupChatMemberUpdate');
    this.myWebRTC_Event.createGroupChatMemberUpdateEvent(msg.groupChatId, msg.contactList, msg.status);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to add user in group chat</p>
   * @method addUserInGroupChat
   * @param {String} groupChatId Id of the group chat
   * @param {String} contactId of the contact to add in group chat
   **/


  this.addUserInGroupChat = function (groupChatId, contactId) {
    logger.debug('addUser : ' + contactId + 'in Group Chat with Id :' + groupChatId);
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'addUserInGroupChat',
      groupChatId: groupChatId,
      nickname: this.nickname,
      photoURL: this.photoURL,
      contactId: contactId
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString); //this.socket.emit('addUserInGroupChat', msgString);

    session.channel.socket.emit('addUserInGroupChat', msgString);
  };

  this.addUserInGroupChatAnswer = function (msg) {
    logger.info('addUserInGroupChatAnswer');
    this.myWebRTC_Event.createAddUserInGroupChatEvent(msg.invitationSended, msg.groupChatId, msg.contactId);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to leave the group chat</p>
   * @method leaveGroupChat
   * @param {String} groupChatId Id of the group chat
   **/


  this.leaveGroupChat = function (groupChatId) {
    logger.info('Leave Group Chat with Id :' + groupChatId);
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'leaveGroupChat',
      groupChatId: groupChatId,
      nickname: this.nickname,
      photoURL: this.photoURL
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString); //this.socket.emit('leaveGroupChat', msgString);

    session.channel.socket.emit('leaveGroupChat', msgString);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to send text message to group chat</p>
   * @method sendMessageToGroupChat
   * @param {String} groupChatId - Id of the group chat
   * @param {String} data - sended text message
   * @param {function} callback - optional callback
   * @param {Object} options
   * @param {Object} options.metadata - Optional user metadata.
   */


  this.sendMessageToGroupChat = function (groupChatId, data, callback) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    logger.info('Call sending message to Group Chat .... from :' + this.nickname + ' message :' + data); //TODO: vrifier que le groupChat existe avant envoi message???

    var messageToSend = null,
        msgString = null,
        cSeq = apiCC.session.channel.getNewCSeq();
    messageToSend = {
      type: 'groupChatMessage',
      groupChatId: groupChatId,
      senderId: session.apiCCId,
      nickname: this.nickname,
      cSeq: cSeq,
      data: data
    };

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isTypeof)(options, 'metadata', 'object')) {
      messageToSend.metadata = options.metadata;
    }

    msgString = JSON.stringify(messageToSend);

    if (callback !== null && typeof callback === 'function') {
      apiCC.session.messageTimeOutTable[cSeq] = setTimeout(function () {
        callback({
          reason: 'timeoutReached',
          cSeq: cSeq
        });

        if (apiCC.session !== null && apiCC.session !== undefined) {
          delete apiCC.session.messageTimeOutTable[cSeq];
        }
      }, apiCC.session.messageTimeOutTimer);
      logger.log('C->S: ' + msgString);
      session.channel.socket.emit('groupChatMessage', msgString, function (data) {
        clearTimeout(apiCC.session.messageTimeOutTable[data.cSeq]);

        if (apiCC.session !== null && apiCC.session !== undefined) {
          delete apiCC.session.messageTimeOutTable[data.cSeq];
        }

        callback(data);
      });
    } else {
      logger.log('C->S: ' + msgString);
      session.channel.socket.emit('groupChatMessage', msgString);
    }
  };

  this.receiveGroupChatMessage = function (msg) {
    logger.info('receiveGroupChatMessage');
    this.myWebRTC_Event.createReceiveGroupChatMessageEvent(msg.groupChatId, msg.senderId, msg.nickname, msg.data, msg.metadata);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to get the conversation message list</p>
   * @method getConversationHistory
   * @param {String} conversationId - Identifier of the conversation for which we ask the messages history.
   **/


  this.getConversationHistory = function (convId) {
    logger.debug('getConversationHistory');
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'getConversationHistory',
      convId: convId
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    session.channel.socket.emit('getConversationHistory', msgString);
  };

  this.receiveConversationHistory = function (msg) {
    logger.debug('receiveConversationHistory');
    logger.log('msg.convId :' + msg.convId);
    var i,
        length = 0,
        listInJSON = [],
        entry = null;

    if (msg.convHistory !== null) {
      logger.log('msg.convHistory.length :' + msg.convHistory.length);
      length = msg.convHistory.length; //Conversion du tableau en tableau de JSON

      listInJSON = [];

      for (i = 0; i < length; i += 1) {
        //logger.log('i =' + i);
        entry = JSON.parse(msg.convHistory[i]);
        listInJSON.push(entry);
      }
    }

    this.myWebRTC_Event.createReceiveConversationHistoryEvent(msg.convId, listInJSON, msg.status);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you set some user data on server</p>
   * @method setUserData
   * @param {String} JSON data that describe the user. {photoURL : 'http://URL-Of-Photo'}
   **/


  this.setUserData = function (data) {
    logger.info('setUserData');
    this.photoURL = data.photoURL;
    session.photoURL = data.photoURL;
    logger.log('photoURL :' + this.photoURL);
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'setUserData',
      nickname: this.nickname,
      photoURL: this.photoURL
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    session.channel.socket.emit('setUserData', msgString);
    this.userDataSetted = true;
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to get some user data from server</p>
   * <b>Associated events :</b>
   * <li>receiveUserDataAnswer</li>
   * @method getUserData
   * @param {String} contactId Id of the user from which you want to get data (nickname / photoURL)
   **/


  this.getUserData = function (contactId) {
    logger.info('getUserData');
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'getUserData',
      contactId: contactId
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    session.channel.socket.emit('getUserData', msgString);
  };

  this.receiveUserDataAnswer = function (msg) {
    logger.info('receiveUserDataAnswer');
    this.myWebRTC_Event.createUserDataAnswerEvent(msg.userFound, msg.contactId, msg.nickname, msg.photoURL);
  };

  this.receiveFetchUserDataAnswer = function (msg) {
    logger.info('receiveFetchUserDataAnswer');
    this.myWebRTC_Event.createFetchUserDataAnswerEvent(msg);
  };

  this.initialize = function (conversationElementId) {
    var messageToSend = null,
        msgString = null; //logger.log('conversationElementId :' + conversationElementId);

    this.conversation = document.getElementById(conversationElementId);

    if (this.conversation === null) {
      logger.log("conversationElementId Div Name is not correct : INCORRECT_DIV_NAME_CONVERSATION"); //this.myWebRTC_Event.createErrorEvent('conversationElementId Div Name is not correct', 'INCORRECT_DIV_NAME_CONVERSATION');
      //TODO voir pas forcment erreur car peut tre normal  : faire un createWarningEvent ?

      logger.log('conversationElementId is null');
    }

    messageToSend = {
      type: 'registerIM',
      username: this.nickname
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    session.channel.socket.emit('registerIM', msgString); //this.socket.emit('registerIM', msgString);
  };

  this.initialize(conversationElementId);
}; //End IMClient class

/**
 * Fired on IM Message reception : an instant messaging message has been received
 * @event receiveIMMessage
 * @param {String} e.detail.eventType 'receiveIMMessage'
 * @param {String} e.detail.time Date
 * @param {String} e.detail.senderId Identifier of the message sender
 * @param {String} e.detail.senderNickname Nickname of the message sender
 * @param {String} e.detail.senderPhotoURL Photo URL of the sender
 * @param {String} e.detail.message received instant messaging message
 * @param {String} e.detail.UUCSeq Incremented Identifier for instant messaging. Unique Id
 **/

/**
 * Fired on group Chat creation answer
 * @event groupChatCreation
 * @param {String} e.detail.eventType 'groupChatCreation'
 * @param {String} e.detail.time Date
 * @param {String} e.detail.status 'groupChatCreated'
 * @param {String} e.detail.groupChatId Id of the group chat
 * @param {String} e.detail.initialDestId Id of the initial contact
 * @param {Boolean} e.detail.invitationSendedToInitialDestId true if invitation has been sended to contact
 * @param {String} e.detail.newContactId newContactId
 * @param {Boolean} e.detail.invitationSendedToNewContactId true if invitation has been sended to contact
 **/

/**
 * Fired when a group Chat invitation is received
 * @event groupChatInvitation
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'groupChatInvitation'
 * @param {String} e.detail.groupChatId Id of the group chat
 * @param {String} e.detail.contactList List of contacts already present in the group chat
 * @param {String} e.detail.senderId Id of the invitation sender
 * @param {String} e.detail.senderNickname Nickname of the invitation sender
 * @param {String} e.detail.senderPhotoURL PhotoURL of the invitation sender
 **/

/**
 * Fired when there is an  update on group chat menbers (online/offline)
 * @event groupChatMemberUpdate
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'groupChatMemberUpdate'
 * @param {String} e.detail.groupChatId Id of the group chat
 * @param {String} e.detail.contactList List of JSON object describing the updated contact, format of the JSON Object is
 * {contactId : Id, contactNickname : nickname, contactPhotoURL : URL}
 * @param {String} e.detail.status updated status of contact : offline / online
 **/

/**
 * Fired on AddUserInGroupChat answer
 * @event addUserInGroupChat
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'addUserInGroupChatAnswer'
 * @param {String} e.detail.invitationSended true if invitation has been sended to the contact
 * @param {String} e.detail.groupChatId Id of the group chat
 **/

/**
 * Fired when a group chat message is received
 * @event receiveGroupChatMessage
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'receiveGroupChatMessage'
 * @param {String} e.detail.groupChatId Id of the group chat
 * @param {String} e.detail.senderId Id of the message sender
 * @param {String} e.detail.senderNickname nickname of the message sender
 * @param {String} e.detail.message message received
 * @param {String} e.detail.metadata optional metadata
 **/

/**
 * Fired when a conversation History answer is received
 * @event receiveConversationHistory
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'receiveConversationHistory'
 * @param {String} e.detail.convHistory History of the conversation (value may be "undefined", if no history available)
 * @param {String} e.detail.status OK / NOT_ALLOWED if the user is not allowed to get the message history, conversation is not a user's conversation
 NOT_FOUND if conversation is not found
**/

/**
 * Fired when a user data answer is received
 * @event userDataAnswer
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'userDataAnswer'
 * @param {Boolean} e.detail.userFound true if user has been found
 * @param {String} e.detail.contactId Id of the user
 * @param {String} e.detail.nickname nickname of the user
 * @param {String} e.detail.photoURL photo URL of the user
 **/




/***/ }),

/***/ "./src/Core/ApiCCMCUClient.js":
/*!************************************!*\
  !*** ./src/Core/ApiCCMCUClient.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiCCMCUClient": () => (/* binding */ ApiCCMCUClient)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* harmony import */ var _utils_Future__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Future */ "./src/utils/Future.js");
/* harmony import */ var _WebRTC_Call__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WebRTC_Call */ "./src/Core/WebRTC_Call.js");
/* harmony import */ var _WebRTC_UserMedia__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WebRTC_UserMedia */ "./src/Core/WebRTC_UserMedia.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ApiCCMCUClient');





var myWebRTC_Event = apiCC.myWebRTC_Event;
var SUBSCRIBE_SETUP_TIMEOUT_MS = 15000;
var DISPUTABLE_STREAM_LIST_ENTRY_TIMEOUT_MS = 30000;
var SESSION_MODE_TRANSITION_TIMEOUT_MS = 30000;
var INVITE_VOIP_DELAY_MS = 10000;
/*
 * <p>This is the ApiMCU.</p>
 * <p>This class enables you to manage video conferencing communications</p>
 *
 * @module ApiMCU
 */

var ApiCCMCUClient = function ApiCCMCUClient(webRTCClient, clientId) {
  logger.debug('ApiCCMCUClient creation');
  this.pubConnector = 'janusConnector';
  this.meshModeEnabled = false; // Handles all rooms.

  this.sessionMCUs = []; // Contains the descriptors of distant calls. Like subscriptions to local streams.

  this.distantCalls = []; // Contains the descriptors of all the streams available for subscription.

  this.streamList = []; // Contains duplicate entries of streamList for entries temporarily not available (publish call restarting).

  this.disputableStreamList = [];
  this.publishCallId = null; // Used to handle joinSession and joinSessionAnswer messages.

  this.joinSessionReqs = []; // Number of ongoing transitions.

  this.transitionCount = 0; // List of things we are able to do. Sends to CCS along with joinSession and invite messages.

  this.browserCapabilities = {
    updateStream: true,
    // able to renegotiate calls when CCS asks us.
    mesh2janusTransition: true,
    // able to handle (smooth) mesh2janus mode transition.
    checkCallStatus: true // able to handle periodic check call status messages.

  };

  this.receiveSessionId = function (msg) {
    logger.debug('receiveSessionId()');
    myWebRTC_Event.createMCUSessionCreationEvent(msg.sessionId, msg.token); //Publishing local stream on session creation

    this.publish(msg.sessionId, msg.token);
  };
  /*
   * @typedef {object} SessionMCU
   * @property {string} roomID - Room ID or session ID.
   * @property {string} roomName - Room ID.
   * @property {string} [convId] - Cloud conversation ID.
   * @property {object} joinSessionAnswer
   * @property {boolean} joinSessionAnswer.failed
   * @property {string} joinSessionAnswer.reason - Failure reason.
   * @property {string} [roomMode] - Either 'mesh' or nothing.
   */

  /*
   * <b>Description</b>
   * <p>This method enables you to invite a remote party to the MCU session</p>
   *
   * @method sendSessionInvitation
   * @param {String} destId Id of the contact to invite
   * @param {String} sessionId Id of the MCU session
   * @param {String} groupChatId Id of the groupChat
   */


  this.sendSessionInvitation = function (destId, sessionId, groupChatId) {
    logger.debug('sendSessionInvitation()');

    if (sessionId !== null && sessionId !== undefined) {
      var messageToSend = null,
          msgString = null;

      if (groupChatId === undefined) {
        groupChatId = 0;
      }

      messageToSend = {
        type: 'MCUSessionInvitation',
        srcId: clientId,
        destId: destId,
        sessionId: sessionId,
        groupChatId: groupChatId
      };
      msgString = JSON.stringify(messageToSend);
      logger.log('C->S: ' + msgString);
      apiCC.session.channel.socket.emit('MCUSessionInvitation', msgString);
    } else {
      logger.log('Session is null or undefined, MCU Session invitation is not sended');
    }
  };
  /*
   * <b>Description</b>
   * <p>This method enables you to invite all users that are connected to a group Chat for an MCU session</p>
   *
   * @method sendSessionInvitationToGroupChat
   * @param {String} groupChatId Id of the groupChat
   * @param {String} sessionId Id of the MCU session
   */


  this.sendSessionInvitationToGroupChat = function (groupChatId, sessionId) {
    logger.debug('sendSessionInvitationToGroupChat()');

    if (groupChatId !== null && groupChatId !== undefined) {
      if (sessionId !== null && sessionId !== undefined) {
        var messageToSend = null,
            msgString = null;
        messageToSend = {
          type: 'MCUSessionInvitationToGroupChat',
          srcId: clientId,
          groupChatId: groupChatId,
          sessionId: sessionId
        };
        msgString = JSON.stringify(messageToSend);
        logger.log('C->S: ' + msgString);
        apiCC.session.channel.socket.emit('MCUSessionInvitationToGroupChat', msgString);
      } else {
        logger.log('Session is null or undefined, MCU Session invitation is not sended');
      }
    } else {
      logger.log('groupChatId is null or undefined, MCU Session invitation is not sended');
    }
  };

  this.receiveSessionInvitation = function (msg) {
    logger.debug('receiveSessionInvitation()');
    logger.log('msg.sessionId :' + msg.sessionId);
    logger.log('msg.token :' + msg.token);
    logger.log('msg.groupChatId :' + msg.groupChatId);
    myWebRTC_Event.createReceiveMCUSessionInvitationEvent(msg.sessionId, msg.token, msg.groupChatId, msg.srcId);
  };
  /*
   * <b>Description</b>
   * <p>This method enables you to accept an MCU session invitation</p>
   *
   * @method acceptSessionInvitation
   * @param {String} sessionId Id of the MCU session
   * @param {String} token token to join the MCU session
   */


  this.acceptSessionInvitation = function (sessionId, token) {
    logger.debug('acceptSessionInvitation()');
    logger.log('sessionId :' + sessionId);
    logger.log('token :' + token); //Publish local stream on invitation accept

    this.publish(sessionId, token);
  };
  /*
   * <b>Description</b>
   * <p>This method enables you to leave an MCU session</p>
   * @ignore
   * @method leaveSession
   * @param roomId {string} Room ID (optional).
   * @param opts {object}
   * @param opts.noHangup {boolean}
   * @return {string} - 'OK' on success, Error otherwise.
   */


  this.leaveSession = function (roomId) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    logger.info('leaveSession()');
    var messageToSend = null;
    var msgString = null;
    var sessionMCU = null;

    if (!roomId) {
      sessionMCU = this.getSessionMCU(null, {
        first: true
      });
    } else {
      sessionMCU = this.getSessionMCU(roomId);
    }

    if (!sessionMCU) {
      return new Error('leaveSession: session not set');
    }

    if (opts.noHangup !== true) {
      //Hangup all established calls in the room
      apiCC.session.apiCCWebRTCClient.webRTCClient.removeAllCallsFromRoom(sessionMCU.roomName, 'leaveSession');
      this.meshOnHangup(null, null, {
        roomId: sessionMCU.roomName
      });
    } //Leaving and unsubscribing to presence group for the room


    var groupArray = [];
    var options = {};
    groupArray.push(sessionMCU.roomName);
    options.doneByApiRTC = true;
    apiCC.session.leavePresenceGroup(groupArray, options);
    apiCC.session.unsubscribePresenceGroup(groupArray, options);
    messageToSend = {
      type: 'leaveSession',
      roomId: sessionMCU.roomName,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      data: {
        pubSub: this.pubConnector
      }
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('leaveSession', msgString);
    logger.debug('leaveSession: distant call clean up');

    for (var idx = this.distantCalls.length; --idx >= 0;) {
      if (this.distantCalls[idx].roomId === sessionMCU.roomName) {
        logger.debug('leaveSession: remove distant call descriptor', this.distantCalls[idx]);
        this.distantCalls.splice(idx, 1);
      }
    } // for


    apiCC.session.apiCCWebRTCClient.webRTCClient.destroyCallControl({
      multi: true,
      roomName: sessionMCU.roomName
    });

    for (var _idx = this.streamList.length; --_idx >= 0;) {
      if (this.streamList[_idx].roomId === sessionMCU.roomName) {
        this.streamList.splice(_idx, 1);
      }
    }

    this.removeSessionMCU(sessionMCU);
    return 'OK';
  };
  /* Creates a joinSession message.
   * @ignore
   * @param {string} roomId - roomId
   * @param {object} options - Options.
   * @param {string} options.transactionId - Transaction ID.
   * @param {string} options.sessionMCU - The sessionMCU if roomId is null.
   * @param {string} options.convId - Cloud conversation ID.
   * @param {boolean} options.meshModeEnabled - Whether the mesh mode is enabled.
   * @param {boolean} options.meshOnlyEnabled - Whether the mesh mode is the only mode allowed, i.e. no transition to another will occur.
   * @param {boolean} options.moderationEnabled - Whether the moderation is enabled.
   * @param {boolean} options.moderator - Whether the user is moderator.
   * @paran {(string[]|object[])} options.supportedVideoCodecs - Preferred video codecs.
   * @param {boolean} options.qualityAdaptationEnabled - Whether quality adaptation shall be used instead of slow link adaptation.
   * @return {object} The joinSession message.
   */


  this.createJoinSessionMessage = function (roomId) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var sessionMCU = null;

    if (!roomId) {
      if (options.hasOwnProperty('sessionMCU')) {
        sessionMCU = options.sessionMCU;
      } else {
        sessionMCU = this.getSessionMCU(null, {
          first: true
        });
      }

      if (sessionMCU) {
        roomId = sessionMCU.roomName;
      }
    }

    var meshModeEnabled = sessionMCU && sessionMCU.roomMode === 'mesh' || this.meshModeEnabled === true || options.meshModeEnabled === true;
    var meshOnlyEnabled = sessionMCU && sessionMCU.meshOnly === true || options.meshOnlyEnabled === true;
    var messageToSend = {
      type: 'joinSession',
      roomId: roomId,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      data: {
        pubSub: this.pubConnector,
        meshModeEnabled: meshModeEnabled,
        meshOnlyEnabled: meshOnlyEnabled,
        videoBandwidthSettings: apiCC.session.apiCCWebRTCClient.webRTCClient.videoBandwidthSettings,
        browserInfo: {
          browserAbout: '' + _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser + ' ' + _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version,
          browserType: _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type,
          browserVersion: _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version,
          osName: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osName,
          osVersion: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osVersion,
          deviceType: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.deviceType
        }
      }
    };

    if (options.hasOwnProperty('transactionId')) {
      messageToSend.transactionId = options.transactionId;
    }

    if (options.hasOwnProperty('convId')) {
      messageToSend.data.convId = options.convId;
    } else if (sessionMCU && sessionMCU.hasOwnProperty('convId')) {
      messageToSend.data.convId = sessionMCU.convId;
    }

    if (options.moderationEnabled) {
      messageToSend.data.moderationEnabled = true;
    }

    if (options.moderator) {
      messageToSend.data.moderator = true;
    } // quality adaptation


    if (options.qualityAdaptationEnabled) {
      messageToSend.data.qualityAdaptationEnabled = true;
    } // Supported codecs.


    if (Array.isArray(options.supportedVideoCodecs)) {
      messageToSend.data.supportedVideoCodecs = [];

      var _iterator = _createForOfIteratorHelper(options.supportedVideoCodecs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var codec = _step.value;

          if (codec === 'h264') {
            messageToSend.data.supportedVideoCodecs.push({
              codec: 'h264',
              profilelevelid: '42e01f'
            });
          } else if (typeof codec === 'string') {
            messageToSend.data.supportedVideoCodecs.push({
              codec: codec
            });
          } else {
            messageToSend.data.supportedVideoCodecs.push(codec);
          }
        } // for

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'safari') {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Safari" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version < 12.1 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Mobile Safari" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version < 12.1) {
        messageToSend.data.supportedVideoCodecs = [{
          codec: 'h264',
          profilelevelid: '42e01f'
        }];
      }
    }
    /*
            //Modif to force H264 on Chrome/iOS : [!]issue to retrieve candidates APIRTC-116
            } elseif(apiRTC.osName==='iOS'&&browser==="Chrome"){
    messageToSend.data.supportedVideoCodecs=[
    {'codec':'h264','profilelevelid':'42e01f'}
    ];
    }
    */
    // Capabilities.


    messageToSend.data.capabilities = this.browserCapabilities;
    return messageToSend;
  };
  /*
   * Creates a session descriptor.
   */


  this.createSessionDescriptor = function (sessionMCU) {
    var desc = {
      roomId: sessionMCU.roomName
    };

    if (sessionMCU.convId) {
      desc.convId = sessionMCU.convId;
    }

    if (sessionMCU.roomMode) {
      desc.roomMode = sessionMCU.roomMode;
    }

    if (sessionMCU.modeChangeKind) {
      desc.modeChangeKind = sessionMCU.modeChangeKind;
    }

    return desc;
  };
  /*
   * <b>Description</b>
   * <p>This method enables you to join an MCU session using a roomId. If room doesn't exist, it will be created</p>
   * <b>Associated events :</b>
   * <li>JoinMCUSessionAnswer</li>
   *
   * @method joinSession
   * @param {string} roomId
   * @param {object} options
   * @param {boolean} options.meshModeEnabled
   * @param {boolean} options.meshOnlyEnabled
   * @param {boolean} options.moderationEnabled - Whether the moderation is enabled.
   * @param {boolean} options.moderator - Whether the user is moderator.
   * @param {boolean} options.qualityAdaptationEnabled
   * @param {boolean} options.supportedVideoCodecs
   * @return {string} 'OK' on success, an Error otherwise.
   */


  this.joinSession = function (roomId) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (this.getSessionMCU(roomId)) {
      logger.warn('joinSession: session already set');
      return new Error('joinSession: session already set');
    }

    if (this.getJoinSessionReq(roomId)) {
      logger.warn('joinSession: session already requested');
      return new Error('joinSession: session already requested');
    }

    var newReq = {};
    newReq.roomId = roomId;
    newReq.transactionId = apiCC.randomString(12);
    this.joinSessionReqs.push(newReq);
    var opts = Object.assign({}, options);
    opts.transactionId = newReq.transactionId;
    logger.info('joinSession() on ApiRTC MCU with roomId:', roomId);
    var messageToSend = this.createJoinSessionMessage(roomId, opts);
    var msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('joinSession', msgString);
    return 'OK';
  };
  /**
   * Handles a 'joinSessionAnswer' message from CCS/janusConnector.
   */


  this.joinSessionAnswer = function (msg) {
    logger.debug('joinSessionAnswer()');

    if (this.getSessionMCU(msg.roomName)) {
      logger.warn('joinSessionAnswer: session already set');
      return;
    }

    var joinSessionReq = null;

    if (msg.hasOwnProperty('transactionId')) {
      joinSessionReq = this.getJoinSessionReq(null, {
        transactionId: msg.transactionId
      });
    }

    if (!joinSessionReq) {
      joinSessionReq = this.getJoinSessionReq(msg.roomName);
    }

    if (!joinSessionReq) {
      logger.debug('joinSessionAnswer: no joinSession requested');
      return;
    } // Clear joinSession request.


    this.removeJoinSessionReq(joinSessionReq);
    var newSessionMCU = {};
    newSessionMCU.roomID = msg.sessionId;
    newSessionMCU.roomName = msg.roomName;

    if (msg.hasOwnProperty('convId')) {
      newSessionMCU.convId = msg.convId;
    }

    newSessionMCU.joinSessionAnswer = {}; // Whether the mode is mentioned.

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(msg, 'data', 'object')) {
      if (msg.data.failed === true) {
        newSessionMCU.joinSessionAnswer.failed = true;
        newSessionMCU.joinSessionAnswer.reason = msg.data.reason;
      } else {
        newSessionMCU.joinSessionAnswer.failed = false;
      }

      if (msg.data.mode && typeof msg.data.mode === 'string') {
        newSessionMCU.roomMode = msg.data.mode;
        logger.debug('session joined with mode; roomMode: ' + newSessionMCU.roomMode);
      }

      if (newSessionMCU.roomMode === 'mesh' && msg.data.meshOnly === true) {
        newSessionMCU.meshOnly = true;
        logger.debug('meshOnly');
      }
    } else {
      newSessionMCU.joinSessionAnswer.failed = false;
    }

    this.sessionMCUs.push(newSessionMCU);

    if (!newSessionMCU.joinSessionAnswer.failed) {
      // Join and subscribe to presence group for the room.
      var groupArray = [];
      var options = {};
      groupArray.push(msg.roomName);
      options.doneByApiRTC = true;
      apiCC.session.joinPresenceGroup(groupArray, options);
      apiCC.session.subscribePresenceGroup(groupArray, options);
    }

    myWebRTC_Event.createJoinMCUSessionAnswerEvent(msg.sessionId, msg.token, msg.groupChatId, msg.initiator, newSessionMCU);
  };
  /*
   * Changes the mode of a given session.
   * @ignore
   * @method changeSessionMode
   * @param {object} msg
   * @param {string} msg.roomName
   * @param {string} msg.convId
   * @param {object} msg.data
   * @param {string} transition
   */


  this.changeSessionMode = function (msg, transition) {
    var oldSessionMCU = this.getSessionMCU(msg.roomName);

    if (!oldSessionMCU) {
      logger.warn('changeSessionMode: no session');
      return;
    }

    if (oldSessionMCU.roomMode !== 'mesh') {
      logger.warn('changeSessionMode: session not using mesh mode');
      return;
    } // Gather distant calls related to each userMedia entry.


    var userMediaCnt = 0;

    for (var uIdx = webRTCClient.userMediaTable.length; --uIdx >= 0;) {
      if (webRTCClient.userMediaTable[uIdx].sessionMCU === oldSessionMCU) {
        logger.debug('changeSessionMode: userMedia', webRTCClient.userMediaTable[uIdx]);
        webRTCClient.userMediaTable[uIdx].distantCalls = [];
        userMediaCnt += 1;

        for (var dIdx = this.distantCalls.length; --dIdx >= 0;) {
          logger.debug('changeSessionMode: distantCall', this.distantCalls[dIdx]);

          if (this.distantCalls[dIdx].callMode === 'mesh' && this.distantCalls[dIdx].callFeed.callId === webRTCClient.userMediaTable[uIdx].userMediaId) {
            logger.debug('changeSessionMode: match');
            webRTCClient.userMediaTable[uIdx].distantCalls.push(this.distantCalls[dIdx]);
          }
        } // for

      }
    } // for


    var subCnt = 0;

    for (var ccIdx = webRTCClient.callControlTable.length; --ccIdx >= 0;) {
      if (webRTCClient.callControlTable[ccIdx].type === 'subscribe' && webRTCClient.callControlTable[ccIdx].roomName === oldSessionMCU.roomName) {
        subCnt += 1; // Authorize temporary duplicate subscribe call.

        webRTCClient.callControlTable[ccIdx].autoRestart.force = true;
      }
    } // for
    // Fire MCURoomModeChanged event.


    myWebRTC_Event.createMCURoomModeChangedEvent(oldSessionMCU.roomName, 'mesh', 'sfu', 'ongoing');

    if (userMediaCnt === 0 && subCnt === 0) {
      delete oldSessionMCU.roomMode; // No distant call to replaced, declare transition finished.

      myWebRTC_Event.createMCURoomModeChangedEvent(oldSessionMCU.roomName, 'mesh', 'sfu', 'complete');
    } else {
      // Duplicate session.
      oldSessionMCU.modeChangeKind = 'old';
      var newSessionMCU = {};
      newSessionMCU.roomID = msg.roomName;
      newSessionMCU.roomName = msg.roomName;

      if (msg.hasOwnProperty('convId')) {
        newSessionMCU.convId = msg.convId;
      }

      newSessionMCU.joinSessionAnswer = {
        failed: false
      };
      newSessionMCU.modeChangeKind = 'new';
      newSessionMCU.transitionTimeoutId = setTimeout(function (oldSessionMCU, newSessionMCU) {
        delete newSessionMCU.transitionTimeoutId;
        webRTCClient.finalizeMeshToJanusTransition(oldSessionMCU, newSessionMCU, {
          force: true
        });
      }.bind(this, oldSessionMCU, newSessionMCU), SESSION_MODE_TRANSITION_TIMEOUT_MS);
      this.sessionMCUs.push(newSessionMCU);
      this.transitionCount += 1;
    }
  };
  /*
   * Refreshes stream status after a channel reconnection for example.
   * @ignore
   * @method updateSessionAnswer
   * @param {object} msg
   * @param {string} msg.roomName
   * @param {string} msg.convId
   * @param {object} msg.data
   * @param {string} msg.data.mode - 'mesh' (optional).
   * @param {array} msg.availableStreams
   * @param {array} msg.availableComposite
   * @param {array} msg.availableReplay
   * @param {object} options
   * @param {boolean} options.createSession - Creates the session if none exists.
   * @param {boolean} options.changeMode - 'mesh2janus'.
   * @param {boolean} options.updateCalls - Whether to update calls after the session.
   */


  this.updateSessionAnswer = function (msg) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    logger.debug('updateSessionAnswer');
    var sessionMCU = this.getSessionMCU(msg.roomName);

    if (!sessionMCU) {
      // Session does not exist.
      if (!options.createSession) {
        logger.warn('updateSessionAnswer: no such session', msg.roomName);
        return;
      } // Force creation of session.
      // Useful for recorded call.


      logger.debug('force session creation; roomName: ' + msg.roomName);
      sessionMCU = {};
      sessionMCU.roomID = msg.roomName;
      sessionMCU.roomName = msg.roomName;

      if (msg.hasOwnProperty('convId')) {
        sessionMCU.convId = msg.convId;
      }

      sessionMCU.joinSessionAnswer = {
        failed: false
      };
      this.sessionMCUs.push(sessionMCU); // Set the sessionMCU to ongoing calls (1-to-1 recorded calls).

      for (var idx = apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable.length; --idx >= 0;) {
        var call = apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable[idx];

        if (call.data && (call.data.MCUType === 'MCU-Caller' || call.data.MCUType === 'MCU-Callee') && call.data.confId === sessionMCU.roomName) {
          call.sessionMCU = sessionMCU;
        }
      } // for
      // fall-through

    } // Handle mode.


    var modeChanged = false;

    if (msg.data && msg.data.mode === 'mesh') {
      // Mode: MESH.
      sessionMCU.roomMode = 'mesh';

      if (msg.data.meshOnly === true) {
        sessionMCU.meshOnly = true;
      }
    } else {
      // Mode: JANUS.
      if (sessionMCU.roomMode === 'mesh') {
        // Previous mode was MESH.
        modeChanged = true;
      }

      delete sessionMCU.roomMode;
    }

    if (sessionMCU.modeChangeKind === 'new') {
      // Transition already ongoing.
      logger.debug('transition already ongoing');
      var oldSessionMCU = this.getSessionMCU(null, {
        callback: function callback(entry) {
          return entry.roomName === sessionMCU.roomName && entry.modeChangeKind === 'old';
        }
      });

      if (oldSessionMCU) {
        // Force end of transition.
        webRTCClient.finalizeMeshToJanusTransition(oldSessionMCU, sessionMCU, {
          force: true
        });
      }
    } else if (modeChanged) {
      // Transition NOT ongoing but should be.
      logger.debug('transition NOT ongoing but should be');
      myWebRTC_Event.createMCURoomModeChangedEvent(sessionMCU.roomName, 'mesh', 'sfu', 'ongoing');
      sessionMCU.modeChangeKind = 'old';
      var newSessionMCU = {};
      newSessionMCU.roomID = sessionMCU.roomID;
      newSessionMCU.roomName = sessionMCU.roomName;

      if (sessionMCU.hasOwnProperty('convId')) {
        newSessionMCU.convId = sessionMCU.convId;
      }

      newSessionMCU.joinSessionAnswer = {
        failed: false
      };
      newSessionMCU.modeChangeKind = 'new';
      this.sessionMCUs.push(newSessionMCU);
      this.transitionCount += 1;
      webRTCClient.finalizeMeshToJanusTransition(sessionMCU, newSessionMCU, {
        force: true
      });
    }

    if (options.updateCalls) {
      // Update stream list.
      logger.debug('update stream list (prune)');
      this.updateStreamList(msg, {
        prune: true
      });

      if (sessionMCU.roomMode === 'mesh') {
        // Restart every WebRTC_UserMedia.
        logger.debug('restart publish/shareScreen calls');
        var userMediaList = webRTCClient.userMediaTable.slice();

        for (var umIdx = userMediaList.length; --umIdx >= 0;) {
          var userMedia = userMediaList[umIdx];

          if (userMedia.sessionMCU !== sessionMCU) {
            continue;
          } // Restart.


          webRTCClient.onHangup(userMedia.userMediaId, 'disconnected');
        } // for

      } else {
        // Restart publish/shareScreen calls with no PeerConnection.
        logger.debug('restart publish/shareScreen calls with no PeerConnection');
        var calls = webRTCClient.callsTable.slice();

        for (var callIdx = calls.length; --callIdx >= 0;) {
          var _call = calls[callIdx];

          if (_call.sessionMCU !== sessionMCU) {
            continue;
          }

          if ((_call.settingUpType === 'publish' || _call.settingUpType === 'shareScreen') && (!_call.data || !_call.data.mesh) && !_call.pc) {
            // Restart.
            webRTCClient.onHangup(_call.callId, 'disconnected');
          }
        } // for

      }
    }
  };

  this.processCheckCallStatus = function (msg) {
    // update stream list
    this.updateStreamList(msg);
  };
  /*
   * Updates stream list.
   * @ignore
   * @method updateStreamList
   * @param {object} msg
   * @param {array} msg.availableStreams
   * @param {array} msg.availableComposite
   * @param {array} msg.availableReplay
   * @param {object} options
   * @param {boolean} options.prune - Whether to clean the stream list right away.
   */


  this.updateStreamList = function (msg) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var regularStreams = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(msg, 'availableStreams', 'array') ? msg.availableStreams.slice() : null;
    var compositeStreams = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(msg, 'availableComposite', 'array') ? msg.availableComposite.slice() : null;
    var replayStreams = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(msg, 'availableReplay', 'array') ? msg.availableReplay.slice() : null; // (1of2) What is gone.

    for (var li = this.streamList.length; --li >= 0;) {
      var localStream = this.streamList[li];

      if (localStream.type === 'regular') {
        if (!regularStreams) {
          continue;
        } // Look for stream in new list.
        // Remove stream from new list if found.


        var ri = regularStreams.length;

        while (--ri >= 0) {
          if (regularStreams[ri].id === localStream.streamInfo.id) {
            break;
          }
        } // while


        if (ri >= 0) {
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(localStream, 'clearDisputableEntry', 'function')) {
            // Stream was not available, now it is.
            localStream.clearDisputableEntry();
          }

          regularStreams.splice(ri, 1);
          continue;
        } // Stream currently not available.


        if (options.prune === true) {
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(localStream, 'clearDisputableEntry', 'function')) {
            localStream.clearDisputableEntry();
          }

          apiCC.session.apiCCWebRTCClient.webRTCClient.destroyCallControl({
            type: 'subscribe',
            stream: localStream.streamInfo
          });
          myWebRTC_Event.createMCURemovedStreamEvent(localStream.streamInfo.id);
          this.streamList.splice(li, 1);
        } else if (!localStream.disputableTimeoutId) {
          // Timeout to handle the absence of availableStreams message.
          localStream.disputableTimeoutId = setTimeout(disputableEntryTimeout.bind(this, localStream.streamInfo.id), DISPUTABLE_STREAM_LIST_ENTRY_TIMEOUT_MS); // Function to remove entry from disputableStreamList and
          // to clear the associated timeout.

          localStream.clearDisputableEntry = clearDisputableEntry.bind(this, localStream.streamInfo.id); // Add a duplicate of the streamList entry

          this.disputableStreamList.push(localStream);
        }
      } else if (localStream.type === 'composite') {
        if (!compositeStreams) {
          continue;
        } // Look for stream in new list.
        // Remove stream from new list if found.


        var _ri = compositeStreams.length;

        while (--_ri >= 0) {
          if (compositeStreams[_ri].id === localStream.streamInfo.id) {
            break;
          }
        } // while


        if (_ri >= 0) {
          compositeStreams.splice(_ri, 1);
          continue;
        } // Composite currently not available.


        apiCC.session.apiCCWebRTCClient.webRTCClient.destroyCallControl({
          type: 'subscribe',
          stream: localStream.streamInfo
        });
        myWebRTC_Event.createMCURemovedStreamEvent(localStream.streamInfo.id);
        this.streamList.splice(li, 1);
      } else if (localStream.type === 'replay') {
        if (!replayStreams) {
          continue;
        } // Look for stream in new list.
        // Remove stream from new list if found.


        var _ri2 = replayStreams.length;

        while (--_ri2 >= 0) {
          if (replayStreams[_ri2].id === localStream.streamInfo.id) {
            break;
          }
        } // while


        if (_ri2 >= 0) {
          replayStreams.splice(_ri2, 1);
        }
      }
    } // for
    // (2of2) What is new.


    if (regularStreams) {
      for (var _ri3 = 0; _ri3 < regularStreams.length; _ri3 += 1) {
        // Stream is not known.
        var newStreamList = [];
        newStreamList.push(regularStreams[_ri3]);
        var isRemoteStream = this.newAvailableStream(newStreamList, 'regular');
        myWebRTC_Event.createMCUAvailableStreamEvent(newStreamList, isRemoteStream);
      } // for

    }

    if (compositeStreams) {
      for (var _ri4 = 0; _ri4 < compositeStreams.length; _ri4 += 1) {
        // Stream is not known.
        var _newStreamList = [];

        _newStreamList.push(compositeStreams[_ri4]);

        var _isRemoteStream = this.newAvailableStream(_newStreamList, 'composite');

        myWebRTC_Event.createMCUAvailableCompositeEvent(_newStreamList, _isRemoteStream);
      } // for

    }

    if (replayStreams) {
      for (var _ri5 = 0; _ri5 < replayStreams.length; _ri5 += 1) {
        var _newStreamList2 = [];

        _newStreamList2.push(replayStreams[_ri5]);

        var _isRemoteStream2 = this.newAvailableReplay(_newStreamList2);

        myWebRTC_Event.createMCUAvailableReplayEvent(_newStreamList2, _isRemoteStream2);
      } // for

    }
  };
  /*
  * <b>Description</b>
  * <p>This method enables you to takeSnapshot on MCU session video. If remoteId = 0, it take a local snapshot</p>
  *
  * @method takeSnapshot
  */

  /*
      this.takeSnapshot = function (remoteId) {
  
  //TODO add checking that session exist : this.publisher not null ...
  
          var imgData = null,
              length = 0,
              subscriber = null,
              i = 0;
  
          if (remoteId === 0) {
  
              imgData = this.publisher.getImgData();
  
          } else {
              //getting subObj from subIdTable
  
              length = this.subIdTable.length;
              subscriber = null;
  
              for (i = 0; i < length; i += 1) {
                  logger.debug("this.subIdTable[i].subDivId :" + this.subIdTable[i].subDivId);
                  logger.debug("remoteId :" + remoteId);
  
                  if (this.subIdTable[i].subDivId == remoteId) {
  
                      logger.log("subscriber found");
                      subscriber = this.subIdTable[i].subObj;
                      imgData = subscriber.getImgData();
                  }
              }
          }
          return imgData;
      };
  */


  this.getStreamList = function () {
    logger.debug("getStreamList :", this.streamList);
    return this.streamList;
  };

  this.getStreamFromList = function (streamId) {
    logger.debug('getStreamFromList() with Id :', streamId);
    var i;
    logger.log('this.streamList :', this.streamList);

    for (i = 0; i < this.streamList.length; i += 1) {
      if (this.streamList[i].streamInfo.id === streamId) {
        logger.log("stream found", this.streamList[i].streamInfo);
        return this.streamList[i].streamInfo;
      } else {
        logger.log("not the same stream", streamId);
      }
    }

    return null;
  };

  this.getStreamIdOfUser = function (userId) {
    logger.debug('getStreamIdOfUser() with Id :', userId);
    var i;
    logger.log('this.streamList :', this.streamList);

    for (i = 0; i < this.streamList.length; i += 1) {
      if (this.streamList[i].type === 'replay') {
        continue;
      }

      if (this.streamList[i].userId === userId) {
        logger.log("stream found", this.streamList[i].streamInfo);
        return this.streamList[i].streamInfo.id;
      } else {
        logger.log("not the same userId", userId);
      }
    }

    return null;
  };
  /*
   * Returns a stream descriptor for a given user id and a given call id.
   * By default, replay stream descriptors are not considered.
   *
   * @param {string} userId - User id.
   * @param {string} callId - Call id.
   * @param {object} options - Options.
   * @param {string} options.replay - Whether a replay stream descriptor is expected.
   *
   * @return {object} A stream descriptor.
   */


  this.getStreamOfUserCall = function (userId, callId) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var i = this.streamList.length,
        replay = false;

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(options, 'replay', 'boolean') && options.replay === true) {
      replay = true;
    }

    while (--i >= 0) {
      if (replay === true) {
        if (this.streamList[i].type !== 'replay') {
          continue;
        }
      } else {
        if (this.streamList[i].type === 'replay') {
          continue;
        }
      }

      if (this.streamList[i].userId === userId && this.streamList[i].streamInfo.attributes.callId === callId) {
        return this.streamList[i].streamInfo;
      }
    }

    return null;
  };
  /* Adds new stream descriptors.
   * @method newAvailableStream
   * @param {object} streams - an array of stream descriptors.
   * @param {string} type - type of stream (either regular or composite).
   * @param {function} callback - (isRemoteStream:boolean, stream:object, type:string).
   * @return {boolean} whether the streams are remote (not published by us).
   */


  this.newAvailableStream = function (streams, type, callback) {
    logger.debug('newAvailableStream():', streams);
    var isRemoteStream = false;
    var alreadyExists = false;
    var sessionMCU = this.getSessionMCU(streams[0].room);

    if (!sessionMCU) {
      logger.debug('newAvailableStream() but client is not in session');
      return;
    } //Checking ID of the first stream in array, remote and local streams are always separated


    if (streams[0].attributes.callerId !== clientId) {
      isRemoteStream = true;
    } // CallControls for everything we are sending.


    var publishCallControls = webRTCClient.getCallControls(['publish', 'shareScreen'], {
      addUserMedia: true
    });

    for (var ri = 0; ri < streams.length; ri += 1) {
      // Search for a matching entry to avoid duplicate.
      var li = this.streamList.length;

      while (--li >= 0) {
        if (this.streamList[li].type !== 'regular') {
          continue;
        }

        if (streams[ri].id === this.streamList[li].streamInfo.id) {
          break;
        }
      }

      if (li >= 0) {
        alreadyExists = true; // Test for disputable entry to clear its reference and its associated timeout.

        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.streamList[li], 'clearDisputableEntry', 'function')) {
          this.streamList[li].clearDisputableEntry();
        } else {
          logger.debug('clearDisputableEntry is not set');
        }
      } else {
        logger.debug('streamList is empty');
      }

      isRemoteStream = !Object.prototype.hasOwnProperty.call(publishCallControls, streams[ri].attributes.callId);
      var streamListEntry = {
        type: type,
        userId: streams[ri].attributes.callerId,
        roomId: sessionMCU.roomName,
        isRemoteStream: isRemoteStream,
        streamInfo: streams[ri]
      }; //Modif_Fred TODO rendre accessible streamId par API

      if (alreadyExists === true) {
        this.streamList[li] = streamListEntry;
      } else {
        this.streamList.push(streamListEntry);
      }

      logger.log("this.streamList :", this.streamList);

      if (isRemoteStream !== true) {
        if (sessionMCU.roomMode === 'mesh') {
          var userMedia = webRTCClient.findUserMediaById(streams[ri].attributes.callId);

          if (userMedia && userMedia.addAck === true) {
            delete userMedia.addAck;
            clearTimeout(userMedia.addTimeoutId);
            delete userMedia.addTimeoutId; // Mesh publish call is ok.

            myWebRTC_Event.createCallEstablishedEvent(sessionMCU.roomName, userMedia.callType, userMedia.userMediaId, 'none');
          }
        }
      } // Whether an auto subscription exists for this stream.


      var callControl = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallControl({
        type: 'subscribe',
        stream: streams[ri]
      });

      if (callControl && !callControl.autoRestart.pending) {
        // the remote stream should be subscribed to
        logger.info('[newAvailableStream] auto subscribing to stream');
        var force = !!callControl.autoRestart.force;
        delete callControl.autoRestart.force;
        var oldCallId = callControl.callId;
        var newCallIds = this.subscribeToStreams([streams[ri]], callControl.mediaType, callControl.data, callControl.callConfiguration, {
          noStreamCheck: true,
          force: force
        });

        if (oldCallId && newCallIds[0]) {
          myWebRTC_Event.createCallRestartingEvent(callControl.callType, callControl.audioOnly, oldCallId, newCallIds[0], 'subscribe', apiCC.session.apiCCWebRTCClient.webRTCClient.clientId, callControl.roomName, callControl.roomName, streams[ri].id);
        }
      }

      if (alreadyExists !== true && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callback, 'function')) {
        callback(isRemoteStream, streams[ri], type);
      }
    } // for
    //myWebRTC_Event.createMCUAvailableStreamEvent(streams, isRemoteStream);


    return isRemoteStream;
  };
  /* Updates stream descriptor.
   * @method updateAvailableStream
   * @param {object} streams - an array of stream descriptors.
   * @param {string} type - type of stream (either regular or composite).
   * @param {function} callback - (isRemoteStream:boolean, stream:object, type:string, changes:array).
   * @return {boolean} whether the streams are remote (not published by us).
   */


  this.updateAvailableStream = function (streams, type, callback) {
    logger.info('updateAvailableStream():', streams);
    var isRemoteStream = false;
    var sessionMCU = this.getSessionMCU(streams[0].room);

    if (!sessionMCU) {
      logger.log('updateAvailableStream() but client is not in session');
      return;
    } //Checking ID of the first stream in array, remote and local streams are always separated


    if (streams[0].attributes.callerId !== clientId) {
      isRemoteStream = true;
    }

    for (var i = 0; i < streams.length; i += 1) {
      for (var j = this.streamList.length; --j >= 0;) {
        if (this.streamList[j].streamInfo.id === streams[i].id) {
          var changes = [];

          for (var _i = 0, _arr = ['audio', 'audioMuted', 'video', 'videoMuted']; _i < _arr.length; _i++) {
            var field = _arr[_i];

            if (this.streamList[j].streamInfo[field] !== streams[i][field]) {
              this.streamList[j].streamInfo[field] = streams[i][field];
              changes.push(field);
            }
          } // for


          if (this.streamList[j].streamInfo.attributes.callType !== streams[i].attributes.callType) {
            this.streamList[j].streamInfo.attributes.callType = streams[i].attributes.callType;
            changes.push('callType');
          }

          if (this.streamList[j].streamInfo.attributes.descriptor && streams[i].attributes.descriptor) {
            if (this.streamList[j].streamInfo.attributes.descriptor.priority !== streams[i].attributes.descriptor.priority) {
              this.streamList[j].streamInfo.attributes.descriptor.priority = streams[i].attributes.descriptor.priority;
              changes.push('priority');
            }
          }

          if (changes.length > 0 && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callback, 'function')) {
            callback(isRemoteStream, streams[i], type, changes);
          }

          break;
        }
      } // for

    } // for


    return isRemoteStream;
  };

  this.newAvailableReplay = function (streams) {
    logger.info('newAvailableReplay() :', streams);
    var isRemoteStream = false;
    var sessionMCU = this.getSessionMCU(streams[0].room);

    if (!sessionMCU) {
      logger.log('newAvailableReplay() but client is not in session');
      return;
    } // Checking ID of the first stream in array, remote and local streams are always separated.


    if (streams[0].attributes.callerId !== clientId) {
      isRemoteStream = true;
    }

    for (var i = 0; i < streams.length; i += 1) {
      var streamListEntry = {
        type: 'replay',
        userId: streams[i].attributes.callerId,
        roomId: sessionMCU.roomName,
        isRemoteStream: isRemoteStream,
        streamInfo: streams[i]
      };
      this.streamList.push(streamListEntry);
    } // for


    return isRemoteStream;
  };
  /*
   * Subscribes to a given list of streams.
   * @ignore
   * @param {array<FeedDescriptor>} streams
   * @param {string} mediaType
   * @param {object} data
   * @param {object} callConfiguration
   * @param {object} callConfiguration.qos
   * @param {boolean} callConfiguration.qos.videoForbidInactive - Whether audio-only downgrade is forbidden.
   * @param {object} callConfiguration.simulcast - Simulcast preferences.
   * @param {object} callConfiguration.simulcast.streamQuality - Select a specific substream. Either 'high', 'medium' or 'low'. Default is 'high'.
   * @param {object} callConfiguration.simulcast.streamFrameRate - Select a specific temporal layer. Either 'high', 'medium' or 'low'. Default is 'high'.
   * @param {object} options
   * @param {object} options.autoRestart - Auto restart descriptor.
   * @param {string} options.oldCallId
   * @param {boolean} options.noStreamCheck - Whether not to check stream availability.
   * @param {boolean} options.autoSub - Enables the auto subscription when stream is temporarily not available.
   * @param {boolean} options.force - Forces subscription even if given streams are already subscribed to.
   * @return {array<string>}
   */


  this.subscribeToStreams = function (streams, mediaType, data, callConfiguration) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    logger.info('subscribeToStreams():', streams);
    var stream,
        callIds = [],
        call = null,
        callControl = null,
        index = null,
        si;

    var createTimeoutCall = function createTimeoutCall(callId) {
      return setTimeout(function () {
        // Restart call.
        logger.warn('invite + SDP offer not received -> restart call');
        webRTCClient.onHangup(callId, 'disconnected');
      }, SUBSCRIBE_SETUP_TIMEOUT_MS);
    };

    for (index in streams) {
      stream = streams[index];

      if (apiCC.session === null || apiCC.session === undefined) {
        logger.debug('no session, leaving subscribeToStreams()');
        return callIds;
      }

      call = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallWithStreamId(stream.id, {
        ignoreModeChangeKindOld: true
      });

      if (call !== null) {
        logger.debug('call already exists');

        if (options.force !== true) {
          callIds[index] = call.callId;
          continue;
        } else {
          logger.debug('Force is true');
        }
      } else {
        logger.debug('call does not exist');
      } // Make sure the given stream is still available.


      si = this.streamList.length;

      while (--si >= 0) {
        if (this.streamList[si].streamInfo.id === stream.id) {
          break;
        }
      } // while


      if (si >= 0) {
        logger.debug('stream exists');

        if (this.streamList[si].disputableTimeoutId) {
          // The given stream is temporarily not available.
          logger.debug('stream temporarily not available');
          callIds[index] = null;

          if (options.autoSub === true) {
            // Get or create the associated call control.
            callControl = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallControl({
              type: 'subscribe',
              stream: stream
            });

            if (!callControl) {
              apiCC.session.apiCCWebRTCClient.webRTCClient.createCallControl({
                type: 'subscribe',
                roomName: stream.room,
                mediaType: mediaType,
                callConfiguration: callConfiguration,
                data: data,
                stream: stream
              });
            }
          }

          continue;
        }
      } else {
        // The given stream is not available.
        logger.debug('stream does not exist');

        if (options.noStreamCheck !== true) {
          callIds[index] = null;
          myWebRTC_Event.createErrorEvent('stream not available', 'STREAM_NOT_AVAILABLE', null, stream.room, null, {
            stream: stream
          });
          continue;
        }
      }

      logger.info('stream:', stream);
      var sessionMCU = this.getSessionMCU(stream.room);

      if (!sessionMCU) {
        continue;
      } // Get or create the associated call control.


      callControl = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallControl({
        type: 'subscribe',
        stream: stream
      });

      if (!callControl) {
        callControl = apiCC.session.apiCCWebRTCClient.webRTCClient.createCallControl({
          type: 'subscribe',
          roomName: sessionMCU.roomName,
          mediaType: mediaType,
          callConfiguration: callConfiguration,
          data: data,
          stream: stream
        });
      } // When using janusConnector and for non-composite streams, the call is set up by
      // the connector because the SDP offer must come from the janus gateway.


      if (stream.attributes.callType !== 'COMPOSITE' && this.pubConnector === "janusConnector") {
        if (data === undefined) {
          data = {};
        }

        if (data.mesh) {
          delete data.mesh;
        } // QoS preferences.


        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'qos', 'object')) {
          // QoS preferences is given.
          data.qos = {};

          if (callConfiguration.qos.videoForbidInactive === false) {
            data.qos.videoForbidInactive = false;
          } else {
            //Setting videoForbidInactive as default value
            data.qos.videoForbidInactive = true;
          }
        } else {
          //Setting videoForbidInactive as default value
          data.qos = {};
          data.qos.videoForbidInactive = true;
        } // Simulcast


        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'simulcast', 'object')) {
          // Simulcast preferences is given.
          data.simulcast = {};

          if (callConfiguration.simulcast.streamQuality) {
            if (callConfiguration.simulcast.streamQuality === 'high') {
              data.simulcast.substream = 2;
            } else if (callConfiguration.simulcast.streamQuality === 'medium') {
              data.simulcast.substream = 1;
            } else if (callConfiguration.simulcast.streamQuality === 'low') {
              data.simulcast.substream = 0;
            }
          }

          if (callConfiguration.simulcast.streamFrameRate) {
            if (callConfiguration.simulcast.streamFrameRate === 'high') {
              data.simulcast.temporal = 2;
            } else if (callConfiguration.simulcast.streamFrameRate === 'medium') {
              data.simulcast.temporal = 1;
            } else if (callConfiguration.simulcast.streamFrameRate === 'low') {
              data.simulcast.temporal = 0;
            }
          }
        } // Registering local call.


        call = new _WebRTC_Call__WEBPACK_IMPORTED_MODULE_4__.WebRTC_Call(apiCC.session.apiCCWebRTCClient.webRTCClient);
        call.instanceId = apiCC.generateInstanceId();
        call.callControl = callControl;

        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(call.callControl.autoRestart, 'counter', 'number')) {
          call.callControl.autoRestart.counter += 1;
          call.restarted = true;
        } else {
          call.callControl.autoRestart.counter = 0;
        }

        call.settingUpType = 'subscribe'; // Set timeout to handle a message loss (due to CCS disconnection).

        call.setupTimeoutId = createTimeoutCall(call.callId);

        if (callConfiguration !== null && callConfiguration !== undefined) {
          if (callConfiguration.turnServerAddress !== undefined && callConfiguration.turnServerAddress !== null) {
            call.setCallTurnServer(callConfiguration.turnServerAddress);
          }
        }

        call.generateCallId();
        callControl.callId = call.callId;
        call.callerId = sessionMCU.roomName;
        call.calleeId = apiCC.session.apiCCWebRTCClient.webRTCClient.clientId;
        call.callee = true;
        call.mcuRemoteStream = stream;
        call.dest_roomId = sessionMCU.roomName;
        call.callType = stream.attributes.callType;
        call.callControl.callType = stream.attributes.callType;

        if (stream.attributes.callType === 'audio' || mediaType === 'AUDIOONLY') {
          call.audioOnly = true;
          call.callControl.audioOnly = true;
        }

        call.remoteId = stream.attributes.callerId;
        call.remoteMailAddress = stream.attributes.mailAddress;
        call.streamId = stream.id;
        call.mediaType = mediaType;
        call.sessionMCU = sessionMCU;
        logger.log('call.streamId: ' + call.streamId);

        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'object')) {
          call.data = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.assignObject)({}, data);
        } else {
          call.data = {};
        }

        call.data.pubSub = 'janusConnector';
        call.data.type = 'subscribe';
        call.data.mode = 'passive';
        call.data.mediaType = mediaType;
        call.data.capabilities = this.browserCapabilities;
        call.data.cloudConvId = sessionMCU.convId;
        call.data.instanceId = call.instanceId;
        apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable.push(call);
        callIds[index] = call.callId;
        call.myWebRTC_Stack.sendInvite(call.callId, apiCC.session.apiCCWebRTCClient.webRTCClient.clientId, apiCC.session.apiCCWebRTCClient.webRTCClient.clientId, sessionMCU.roomName, sessionMCU.roomName, stream.attributes.callType, {
          mode: 'passive',
          data: call.data,
          stream: stream,
          "volatile": !!call.restarted
        });
      } else {
        call = new _WebRTC_Call__WEBPACK_IMPORTED_MODULE_4__.WebRTC_Call(apiCC.session.apiCCWebRTCClient.webRTCClient);
        call.instanceId = apiCC.generateInstanceId();
        call.callControl = callControl;

        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(call.callControl.autoRestart, 'counter', 'number')) {
          call.callControl.autoRestart.counter += 1;
          call.restarted = true;
        } else {
          call.callControl.autoRestart.counter = 0;
        }

        call.settingUpType = 'subscribe';

        if (callConfiguration !== null && callConfiguration !== undefined) {
          if (callConfiguration.turnServerAddress !== undefined && callConfiguration.turnServerAddress !== null) {
            call.setCallTurnServer(callConfiguration.turnServerAddress);
          }
        }

        if (data === undefined) {
          data = {};
        }

        call.data = data;
        call.data.pubSub = this.pubConnector;
        call.data.type = 'subscribe';
        call.data.capabilities = this.browserCapabilities;
        call.data.cloudConvId = sessionMCU.convId;
        call.data.instanceId = call.instanceId;
        logger.log("mediaType: ", mediaType);
        logger.log("stream.attributes.callType: ", stream.attributes.callType);
        call.callType = stream.attributes.callType;
        call.callControl.callType = stream.attributes.callType;

        if (stream.attributes.callType === 'COMPOSITE' && this.pubConnector === "janusConnector" || stream.attributes.callType === 'audio' || mediaType === 'AUDIOONLY') {
          logger.log("Setting call as audioOnly");
          call.audioOnly = true;
          call.callControl.audioOnly = true; //Activating stripVideoSDP for audio only call with MCU

          call.stripVideoSDPActivated = true;
        } else if (mediaType === 'VIDEOONLY') {
          //Activating stripVideoSDP for audio only call with MCU
          call.stripAudioSDPActivated = true;
          call.callType = 'videoOnly';
          call.callControl.callType = 'videoOnly';
        }

        call.mcuRemoteStream = stream;
        call.dest_roomId = sessionMCU.roomName;
        call.calleeId = sessionMCU.roomName;
        call.generateCallId();
        callControl.callId = call.callId;
        call.callerId = apiCC.session.apiCCWebRTCClient.webRTCClient.clientId;
        call.sessionMCU = sessionMCU;
        apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable.push(call);
        call.createPeerConnection();
        call.doCall();
        call.started = true;
        call.callType = stream.attributes.callType;
        call.remoteId = stream.attributes.callerId;
        call.remoteMailAddress = stream.attributes.mailAddress;

        if (stream.audio === true) {
          if (stream.video === true) {
            //AUDIO true
            //VIDEO true
            call.destCallType = 'media';
          } else {
            //AUDIO true
            //VIDEO false
            call.destCallType = "audio";
          }
        } else {
          if (stream.video === true) {
            //AUDIO false
            //VIDEO true
            call.destCallType = "videoOnly";
          } //else {
          //AUDIO false
          //VIDEO false
          //Not a case as there is no stream in this case
          //}

        }

        if (stream.id === undefined) {
          logger.log("stream.id is undefined :", stream);
        }

        call.streamId = stream.id;
        call.mediaType = mediaType;
        logger.log('stream.attributes.callType: ', stream.attributes.callType);
        callIds[index] = call.callId;
      } //setting asyncCallbacks subscribe


      call.asyncCallbacks = {};
      call.asyncCallbacks.type = 'subscribe';
    }

    return callIds;
  };

  this.unsubscribe = function (streamId) {
    logger.info('unsubscribe() :', streamId);
    var call = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallWithStreamId(streamId);

    if (call === null) {
      logger.log("error call not found on unsubscribe");
    } else {
      if (call.callId !== undefined) {
        apiCC.session.apiCCWebRTCClient.webRTCClient.onHangup(call.callId);
      }
    }
  };
  /*
   * @ignore
   * @method publish
   * @param {string} roomName
   * @param {string} sessionId
   * @param {string} token
   * @param {object} callConfiguration
   * @param {boolean} callConfiguration.audioOnly
   * @param {boolean} callConfiguration.videoOnly
   * @param {any} callConfiguration.record
   * @param {any} callConfiguration.private
   * @param {object} callConfiguration.qos - At most one of videoMinBitrate or videoMinQuality. At most one of videoStartBitrate or videoStartQuality.
   * @param {number} callConfiguration.qos.videoMinBitrate
   * @param {string} callConfiguration.qos.videoMinQuality - Either 'excellent', 'good', 'medium' or 'bad'.
   * @param {number} callConfiguration.qos.videoStartBitrate
   * @param {string} callConfiguration.qos.videoStartQuality - Either 'upper', 'excellent', 'good', 'medium' or 'bad'.
   * @param {boolean} callConfiguration.qos.videoForbidInactive - Whether audio-only downgrade is forbidden.
   * @param {array<string>} callConfiguration.audioLabels - For recording.
   * @param {array<string>} callConfiguration.videoLabels - For recording.
   * @param {string} callConfiguration.mediaType
   * @param {number} callConfiguration.priority
   * @param {array<object>} callConfiguration.downgradeProfileList
   * @param {object} callConfiguration.context - User defined context.
   * @param {boolean} callConfiguration.distributedBroadcastEnabled - Whether the broadcast of stream can be distributed on multiple conference servers.
   * @param {object} callConfiguration.simulcast - Whether simulcasting is enabled.
   * @param {object} callConfiguration.simulcast.mode - Preferred simulcasting mode. Either 'RID', 'SDP' or undefined.
   * @param {object} callConfiguration.simulcast.maxBitrate - The encodings max bitrate. May be undefined.
   * @param {object} callConfiguration.simulcast.encodings - The detailed encodings. Only if maxBitrate is undefined. May be undefined.
   * @param {object} callConfiguration.simulcast.encodings.high - The encoding for the high substream.
   * @param {number} callConfiguration.simulcast.encodings.high.maxBitrate
   * @param {object} callConfiguration.simulcast.encodings.medium - The encoding for the medium substream.
   * @param {number} callConfiguration.simulcast.encodings.medium.maxBitrate
   * @param {number} callConfiguration.simulcast.encodings.medium.scaleResolutionDownBy
   * @param {object} callConfiguration.simulcast.encodings.low - The encoding for the low substream.
   * @param {number} callConfiguration.simulcast.encodings.low.maxBitrate
   * @param {number} callConfiguration.simulcast.encodings.low.scaleResolutionDownBy
   * @param {object} data
   * @param {object} options
   * @return {string} The callId on success, null otherwise.
   */


  this.publish = function (roomName, sessionId, token, callConfiguration, data, options) {
    //TODO Voir usage de sessionId, token
    logger.info("publish roomName :", roomName);
    logger.log("publish sessionId :", sessionId);
    logger.log("publish token :", token);
    logger.log("publish callConfiguration :", callConfiguration);
    var call = null;
    var audioOnly = false;
    var videoOnly = false;
    var userMedia = null;
    var userMediaStream = null;
    var sessionMCU = this.getSessionMCU(roomName);

    if (!sessionMCU) {
      logger.error('roomName does not match any sessionMCU');
      return null;
    }

    if (data === null || _typeof(data) !== 'object') {
      data = {};
    }

    if (this.pubConnector === 'janusConnector' && !data.mesh && options && options.callControl && options.callControl.callId) {
      if (apiCC.session.apiCCWebRTCClient.webRTCClient.findCallWithCallId(options.callControl.callId)) {
        // call already exists
        logger.debug('call already exists', options.callControl.callId);
        return options.callControl.callId;
      }
    }

    if (callConfiguration === true || callConfiguration === 'true') {
      logger.log("DEPRECATED ... please use callConfiguration JSON parameter : callConfiguration.audioOnly instead of audioOnly");
      audioOnly = true;
      callConfiguration = {};
    } else if (callConfiguration === false || callConfiguration === 'false') {
      logger.log("DEPRECATED ... please use callConfiguration JSON parameter : callConfiguration.audioOnly instead of audioOnly"); //audioOnly = false;

      callConfiguration = {};
    } else if (callConfiguration === null || _typeof(callConfiguration) !== 'object') {
      callConfiguration = {};
    }

    if (callConfiguration.audioOnly === true && callConfiguration.videoOnly === true) {
      myWebRTC_Event.createErrorEvent('Cannot publish without audio nor video', 'PUBLISH_FAILURE', null, roomName);
      return null;
    }

    if (callConfiguration.audioOnly === true) {
      audioOnly = true;
    }

    if (callConfiguration.videoOnly === true) {
      videoOnly = true;
    }

    ['audioOnly', 'videoOnly', 'record', 'private'].forEach(function (item) {
      if (callConfiguration.hasOwnProperty(item)) {
        if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(data, 'callConfiguration', 'object')) {
          data.callConfiguration = {};
        }

        data.callConfiguration[item] = callConfiguration[item];
      }
    }); // Cloud conversation ID (cloudConvId).

    if (sessionMCU.convId) {
      data.cloudConvId = sessionMCU.convId;
    } // QoS preferences.


    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'qos', 'object')) {
      // QoS preferences is given.
      data.qos = {};

      if (callConfiguration.qos.videoMinBitrate) {
        data.qos.videoMinBitrate = callConfiguration.qos.videoMinBitrate;
      } else if (callConfiguration.qos.videoMinQuality && ['excellent', 'good', 'medium', 'bad'].indexOf(callConfiguration.qos.videoMinQuality) >= 0) {
        data.qos.videoMinQuality = callConfiguration.qos.videoMinQuality;
      } else {
        data.qos.videoMinQuality = 'bad';
      }

      if (callConfiguration.qos.videoStartBitrate) {
        data.qos.videoStartBitrate = callConfiguration.qos.videoStartBitrate;
      } else if (callConfiguration.qos.videoStartQuality && ['upper', 'excellent', 'good', 'medium', 'bad'].indexOf(callConfiguration.qos.videoStartQuality) >= 0) {
        data.qos.videoStartQuality = callConfiguration.qos.videoStartQuality;
      }

      if (callConfiguration.qos.videoForbidInactive === false) {
        data.qos.videoForbidInactive = false;
      } else {
        //Setting videoForbidInactive as default value
        data.qos.videoForbidInactive = true;
      }
    } else {
      // Default QoS preferences.
      data.qos = {
        'videoMinQuality': 'bad',
        'videoForbidInactive': true
      };
    } // Simulcast precondition.
    // The possibity of simulcasting may depend on the stream settings.


    if (callConfiguration.simulcast) {
      if (callConfiguration.userMediaStreamId) {
        userMediaStream = apiCC.getUserMediaStream(callConfiguration.userMediaStreamId);

        if (!userMediaStream || !userMediaStream.isSimulcastCompliant()) {
          delete callConfiguration.simulcast;
        }
      } else {
        delete callConfiguration.simulcast;
      }
    } // Prepare simulcasting.


    prepareSimulcastConfiguration(callConfiguration);

    if (callConfiguration.distributedBroadcastEnabled && !callConfiguration.simulcast) {
      // The distributedBroadcast and simulcast features are not compatible.
      data.distributedBroadcastEnabled = true;
    } // audioLabels and videoLabels.


    ['audioLabels', 'videoLabels'].forEach(function (item) {
      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration[item], 'array')) {
        data[item] = [];
        callConfiguration[item].forEach(function (l) {
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(l, 'string')) {
            data[item].push(l);
          }
        });
      }
    }); // User defined context.

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'context', 'object')) {
      try {
        JSON.stringify(callConfiguration.context);
        data.context = callConfiguration.context;
      } catch (e) {}
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'profileType', 'string')) {
      data.profileType = callConfiguration.profileType;
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'priority', 'number') && callConfiguration.priority >= 0) {
      data.priority = callConfiguration.priority;
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'downgradeProfileList', 'array')) {
      data.downgradeProfileList = callConfiguration.downgradeProfileList;
    }

    logger.debug('callConfiguration; audioOnly: ' + audioOnly + ', videoOnly: ' + videoOnly);

    if (options && options.forceScreenSharingCallType === true) {
      // screenSharing
      logger.debug("publish screenSharing");
    } else if (apiCC.mediaDeviceMgr.videoDevicePresent === false) {
      if (apiCC.mediaDeviceMgr.audioDevicePresent === false) {
        logger.debug("publish without any device, leaving publish ..."); // Adding info on publishWithoutMediaDeviceDetected in userData / presence.

        data.publishWithoutMediaDeviceDetected = true;
        apiCC.session.setUserData(data);
        myWebRTC_Event.createErrorEvent('Cannot publish without audio nor video', 'PUBLISH_FAILURE', null, roomName);
        return null;
      } else {
        // No camera present.
        if (audioOnly !== true) {
          logger.debug("publish video, but no webcam present, forcing callType to audio");
          audioOnly = true;
        }
      }
    } else if (apiCC.mediaDeviceMgr.audioDevicePresent === false) {
      // No microphone present.
      if (videoOnly !== true) {
        logger.debug("publish video, but no microphone present, forcing callType to videoOnly");
        videoOnly = true;
      }
    }

    call = new _WebRTC_Call__WEBPACK_IMPORTED_MODULE_4__.WebRTC_Call(apiCC.session.apiCCWebRTCClient.webRTCClient); //If mesh data we re-use same instanceId

    if (data.mesh !== undefined && data.instanceId !== undefined) {
      logger.debug("keeping instanceId ");
      call.instanceId = data.instanceId;
    } else {
      call.instanceId = apiCC.generateInstanceId();
    } // Support for auto restart. This block will set the callId; either generated or
    // inferred from previous call.


    if (this.pubConnector === 'janusConnector' && !data.mesh) {
      call.settingUpType = 'publish';

      if (options && options.callControl) {
        // call restart
        call.callControl = options.callControl;
        call.callControl.autoRestart.counter += 1;
        call.callId = call.callControl.callId;
        call.restarted = true;
      } else {
        // initial call
        call.callControl = apiCC.session.apiCCWebRTCClient.webRTCClient.createCallControl({
          type: 'publish',
          roomName: roomName,
          callConfiguration: callConfiguration,
          data: data
        });
        call.callControl.sessionId = sessionId;
        call.callControl.token = token;
        call.callControl.autoRestart.counter = 0;
        call.generateCallId();
        call.callControl.callId = call.callId;
      }
    } else {
      call.settingUpType = 'publish';
      call.generateCallId();
    }

    if (callConfiguration !== null && callConfiguration !== undefined) {
      if (callConfiguration.turnServerAddress !== undefined && callConfiguration.turnServerAddress !== null) {
        call.setCallTurnServer(callConfiguration.turnServerAddress);
      }
    }

    if (callConfiguration.userMediaStreamId) {
      // Inheriting callType from given stream.
      userMediaStream = apiCC.getUserMediaStream(callConfiguration.userMediaStreamId);

      if (userMediaStream) {
        call.callType = userMediaStream.callType;
        logger.debug('Setting callType to ' + call.callType);

        if (call.callType === "screenSharing") {
          call.screenSharing = true;
        }
      } else {
        logger.debug('callConfiguration.userMediaStreamId is setted but stream is not present');
        delete callConfiguration.userMediaStreamId;
      }
    }

    call.data = data;
    call.data.instanceId = call.instanceId; //Modif_Fred TODO Voir usage de sessionId pour passage info call restarted

    if (sessionId === 'restarted') {
      call.restarted = true;
    }

    call.mediaTypeForIncomingCall = 'NONE';

    if (audioOnly === true) {
      logger.log('Setting call as audioOnly');
      call.audioOnly = true;
      call.callType = 'audio'; //Activating stripVideoSDP for audio only call with MCU

      call.mediaTypeForOutgoingCall = 'AUDIO';
    } else if (videoOnly === true) {
      logger.log('Setting call as videoOnly');
      call.callType = 'videoOnly';
      call.mediaTypeForOutgoingCall = 'VIDEOONLY';
    } else {
      logger.log('Not Setting call as audioOnly nor videoOnly');
    }

    call.dest_roomId = sessionMCU.roomName;
    call.calleeId = sessionMCU.roomName;
    call.data.pubSub = this.pubConnector;
    call.data.type = 'publish';
    call.data.capabilities = this.browserCapabilities;
    call.data.cloudConvId = sessionMCU.convId;
    call.callConfiguration = callConfiguration;
    call.sessionMCU = sessionMCU; // Set mediaConstraints to have a sendOnly offer.

    call.setMediaConstraintsToSendOnlyOffer();
    call.callerId = apiCC.session.apiCCWebRTCClient.webRTCClient.clientId; // Simulcast

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'simulcast', 'object')) {
      var profile = null;

      if (userMediaStream) {
        profile = userMediaStream.getSimulcastProfile();
      }

      if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 78 && callConfiguration.simulcast.mode !== 'SDP') {
        logger.debug('simulcast chrome 78+ -> RID', callConfiguration.simulcast);
        call.simulcast = 'RID';
        call.data.simulcast = {
          enabled: true,
          mode: 'RID'
        };
        call.data.simulcast.encodings = Object.assign({}, callConfiguration.simulcast.encodings);

        if (profile) {
          call.data.simulcast.profile = profile;
        }
      } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome') {
        logger.debug('simulcast chrome -> SDP', callConfiguration.simulcast);
        call.simulcast = 'SDP';
        call.data.simulcast = {
          enabled: true,
          mode: 'SDP'
        };
      } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
        logger.debug('simulcast firefox -> RID', callConfiguration.simulcast);
        call.simulcast = 'RID';
        call.data.simulcast = {
          enabled: true,
          mode: 'RID'
        };
        call.data.simulcast.encodings = Object.assign({}, callConfiguration.simulcast.encodings);

        if (profile) {
          call.data.simulcast.profile = profile;
        }
      } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'safari') {
        logger.debug('simulcast safari -> SDP', callConfiguration.simulcast);
        call.simulcast = 'SDP';
        call.data.simulcast = {
          enabled: true,
          mode: 'SDP'
        };
      }
    }

    logger.log("webRTCClient.accessToLocalMedia :", webRTCClient.accessToLocalMedia);
    apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable.push(call); // For recording, streaming, etc.

    this.publishCallId = call.callId;

    if (call.callControl && call.callControl.autoRestart.stream) {
      logger.debug('call.callControl.autoRestart.stream.active :', call.callControl.autoRestart.stream.active);
    }

    if (this.pubConnector === 'janusConnector' && call.callControl && call.callControl.autoRestart.stream && call.callControl.autoRestart.stream.active) {
      // Setting stream for call
      apiCC.session.apiCCWebRTCClient.webRTCClient.accessToLocalMedia = true;
      call.callLocalStream = call.callControl.autoRestart.stream;
      call.establishCall();
      return call.callId;
    } // Testing whether the desired published stream is given


    if (data.mesh !== undefined && (userMedia = apiCC.session.apiCCWebRTCClient.webRTCClient.findUserMediaById(data.mesh.calleeCallId)) !== null && userMedia.callConfiguration && userMedia.callConfiguration.userMediaStreamId) {
      call.callType = userMedia.callType;
      callConfiguration.userMediaStreamId = userMedia.callConfiguration.userMediaStreamId; // Falling through next condition.
    }

    if (callConfiguration.userMediaStreamId) {
      // Call configuration is mentioning the stream to use.
      userMediaStream = apiCC.getUserMediaStream(callConfiguration.userMediaStreamId);
      userMediaStream.addCallInfo(call.callId);
      apiCC.session.apiCCWebRTCClient.webRTCClient.accessToLocalMedia = true;

      if (this.pubConnector === 'janusConnector' && call.callControl) {
        // Setting stream for auto restart.
        call.callControl.autoRestart.stream = userMediaStream.stream;
      }

      call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
      call.callLocalStream = userMediaStream.stream;
      call.establishCall();
      return call.callId;
    }

    if (apiCC.userMediaStreamTable.length > 0) {
      userMediaStream = apiCC.userMediaStreamTable[0];
      userMediaStream.addCallInfo(call.callId);
      apiCC.session.apiCCWebRTCClient.webRTCClient.accessToLocalMedia = true;

      if (this.pubConnector === 'janusConnector' && call.callControl) {
        // Setting stream for auto restart.
        call.callControl.autoRestart.stream = userMediaStream.stream;
      }

      call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
      call.callLocalStream = userMediaStream.stream;
      call.establishCall();
      return call.callId;
    } // no stream, getting one!


    apiCC.createUserMediaStream({
      'callId': call.callId,
      // Linking getUserMedia to this call.
      'type': call.callType,
      'audioSourceId': webRTCClient.audioSourceId,
      'videoSourceId': webRTCClient.videoSourceId,
      'success': function success(userMediaStream) {
        logger.debug('[publish] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
        apiCC.session.apiCCWebRTCClient.webRTCClient.accessToLocalMedia = true;

        if (apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.pubConnector === 'janusConnector' && call.callControl) {
          // Setting stream for auto restart.
          call.callControl.autoRestart.stream = userMediaStream.stream;
        }

        call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
        call.callLocalStream = userMediaStream.stream;
        call.establishCall();
      }
    });
    return call.callId;
  };

  this.publishScreen = function (roomId, data, callConfiguration, captureSourceType) {
    logger.info('publishScreen()');
    var sessionMCU = this.getSessionMCU(roomId);

    if (!sessionMCU) {
      logger.error('roomId does not match any sessionMCU');
      return null;
    }

    if (data === undefined || data === null) {
      data = {};
    }

    if (callConfiguration === undefined || callConfiguration === null) {
      callConfiguration = {};
    }

    if (callConfiguration.record !== undefined) {
      if (data.callConfiguration !== undefined) {
        data.callConfiguration.record = callConfiguration.record;
      } else {
        data.callConfiguration = {};
        data.callConfiguration.record = callConfiguration.record;
      }
    }

    if (callConfiguration["private"] !== undefined) {
      if (data.callConfiguration !== undefined) {
        data.callConfiguration["private"] = callConfiguration["private"];
      } else {
        data.callConfiguration = {};
        data.callConfiguration["private"] = callConfiguration["private"];
      }
    }

    data.pubSub = this.pubConnector;
    data.type = 'publish';
    return apiCC.session.apiCCWebRTCClient.webRTCClient.shareScreen(sessionMCU.roomName, data, captureSourceType, callConfiguration);
  };

  this.unpublish = function (callId) {
    logger.info('unpublish call with callId :', callId);
    apiCC.session.apiCCWebRTCClient.webRTCClient.onHangup(callId);
    this.publishCallId = null;
  };
  /*
   * Called upon reception of onRemoveStream from CCS.
   * @ignore
   * @method removeMCUStream
   * @param {string}callId - Optional call ID.
   * @param {number}streamId - Stream ID
   * @param {string}reason - The reason of the associated bye message (optional).
   */


  this.removeMCUStream = function (callId, streamId, reason) {
    var i;
    var quiet = false;

    if (reason === 'Broken_by_MCU' || reason === 'disconnected') {
      quiet = true;
    } //Removing stream from streamList


    logger.debug("streamId:", streamId);
    logger.debug("reason:", reason);
    logger.debug("quiet:", quiet);

    for (i = 0; i < this.streamList.length; i += 1) {
      logger.log("this.streamList[i].streamInfo.id :", this.streamList[i].streamInfo.id);

      if (this.streamList[i].streamInfo.id === streamId) {
        if (quiet === true) {
          logger.debug('add stream into disputableStreamList: ', streamId); // Timeout to handle the absence of availableStreams message.

          this.streamList[i].disputableTimeoutId = setTimeout(disputableEntryTimeout.bind(this, this.streamList[i].streamInfo.id), DISPUTABLE_STREAM_LIST_ENTRY_TIMEOUT_MS); // Function to remove entry from disputableStreamList and
          // to clear the associated timeout.

          this.streamList[i].clearDisputableEntry = clearDisputableEntry.bind(this, this.streamList[i].streamInfo.id); // Add a duplicate of the streamList entry

          this.disputableStreamList.push(this.streamList[i]);
        } else {
          logger.debug("remove stream from streamList:", streamId);
          apiCC.session.apiCCWebRTCClient.webRTCClient.destroyCallControl({
            type: 'subscribe',
            stream: this.streamList[i].streamInfo
          });
          this.streamList.splice(i, 1);
        }

        break;
      }
    } // for


    if (callId !== undefined) {
      apiCC.session.apiCCWebRTCClient.webRTCClient.onHangup(callId);
    } //TODO verif que l'on a hangup sur publish


    if (quiet !== true) {
      myWebRTC_Event.createMCURemovedStreamEvent(streamId);
    } //TODO ajouter un event streamRemoved

  };
  /*
   * @ignore
   * @return {boolean} true if the signaling message has been sent, false otherwise.
   */


  this.startStreaming = function (service, server, streamKey, callIdToStream) {
    logger.info("startStreaming");
    var messageToSend = null;
    var msgString = null;
    var serviceGiven = service !== undefined && service !== null && service.length > 0;
    var serverGiven = server !== undefined && server !== null && server.length > 0;
    var data = {}; // Either service or server must be provided.

    if (!serviceGiven && !serverGiven) {
      return false;
    } // Stream key must be provided


    if (streamKey === undefined || streamKey === null || streamKey.length === 0) {
      return false;
    }

    if (callIdToStream === undefined) {
      if (this.publishCallId === null) {
        logger.log("Cannot start streaming as no stream is published");
        return false;
      }

      callIdToStream = this.publishCallId;
    }

    var call = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallWithCallId(callIdToStream);

    if (!call) {
      // Not a regular call, maybe a mesh publish
      call = apiCC.session.apiCCWebRTCClient.webRTCClient.findUserMediaById(callIdToStream);

      if (!call) {
        logger.error('callIdToStream does not match any call');
        return false;
      }
    }

    if (!call.sessionMCU) {
      logger.error('no such sessionMCU');
      return false;
    }

    if (!serviceGiven) {
      service = "custom";
    }

    data.pubSub = this.pubConnector;
    data.service = service;

    if (serverGiven) {
      data.server = server;
    }

    data.streamKey = streamKey;
    logger.log('startStreaming() on ApiRTC MCU with roomId:', call.sessionMCU.roomName);
    messageToSend = {
      type: 'startStreaming',
      roomId: call.sessionMCU.roomName,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      callId: callIdToStream,
      data: data
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('startStreaming', msgString);
    return true;
  };
  /*
   * @ignore
   * @return {boolean} true if the signaling message has been sent, false otherwise.
   */


  this.stopStreaming = function (callIdToStream) {
    logger.info("stopStreaming");
    var messageToSend = null;
    var msgString = null;

    if (callIdToStream === undefined) {
      if (this.publishCallId === null) {
        logger.log("Cannot stop streaming as no stream is published");
        return false;
      }

      callIdToStream = this.publishCallId;
    }

    var call = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallWithCallId(callIdToStream);

    if (!call) {
      logger.error('callIdToStream does not match any call');
      return false;
    }

    var sessionMCU = this.getSessionMCU(call.dest_roomId);

    if (!sessionMCU) {
      logger.error('dest_roomId does not match any sessionMCU');
      return false;
    }

    logger.log('stopStreaming() on ApiRTC MCU with roomId:', sessionMCU.roomName);
    messageToSend = {
      type: 'stopStreaming',
      roomId: sessionMCU.roomName,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      callId: callIdToStream,
      data: {
        pubSub: this.pubConnector
      }
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('stopStreaming', msgString);
    return true;
  };

  this.startRecording = function (mediaType, customIdInFilename, convId, callIdToRecord, data) {
    logger.info("startRecording");
    var messageToSend = null;
    var msgString = null;

    if (callIdToRecord === undefined || callIdToRecord === null) {
      if (this.publishCallId === null) {
        //TODO Fred ongoing Envoyer un event call recording not started
        logger.log("Call recording can not start as stream is not published");
        return;
      }

      callIdToRecord = this.publishCallId;
    }

    var call = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallWithCallId(callIdToRecord);

    if (!call) {
      // Not a regular call, maybe a mesh publish
      call = apiCC.session.apiCCWebRTCClient.webRTCClient.findUserMediaById(callIdToRecord);

      if (!call) {
        logger.error('callIdToRecord does not match any call');
        return false;
      }
    }

    if (!call.sessionMCU) {
      logger.error('no such sessionMCU');
      return false;
    }

    if (mediaType !== 'AUDIO-ONLY' && mediaType !== 'VIDEO-ONLY') {
      mediaType = "AUDIO-VIDEO";
    }

    if (data === undefined || data === null) {
      data = {};
    }

    data.pubSub = this.pubConnector;
    logger.log('startRecording() on ApiRTC MCU with roomId :', call.sessionMCU.roomName);
    messageToSend = {
      type: 'startRecording',
      roomId: call.sessionMCU.roomName,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      callId: callIdToRecord,
      data: data,
      customIdInFilename: customIdInFilename,
      mediaType: mediaType,
      convId: convId
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('startRecording', msgString);
  };

  this.stopRecording = function (callIdToRecord) {
    logger.info("stopRecording");
    var messageToSend = null;
    var msgString = null; //TODO Fred ongoing vrifier que l'on est en record avant de stopRecording ?

    if (callIdToRecord === undefined) {
      if (this.publishCallId === null) {
        //TODO Fred ongoing Envoyer un event call recording not started
        logger.log("Call recording can not stop as stream is not published");
        return;
      }

      callIdToRecord = this.publishCallId;
    }

    var call = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallWithCallId(callIdToRecord);

    if (!call) {
      logger.error('callIdToRecord does not match any call');
      return false;
    }

    var sessionMCU = this.getSessionMCU(call.dest_roomId);

    if (!sessionMCU) {
      logger.error('dest_roomId does not match any sessionMCU');
      return false;
    }

    logger.log('stopRecording() on ApiRTC MCU with roomId :', sessionMCU.roomName);
    messageToSend = {
      type: 'stopRecording',
      roomId: sessionMCU.roomName,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      callId: callIdToRecord,
      data: {
        pubSub: this.pubConnector
      }
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('stopRecording', msgString);
  };

  this.recordingStarted = function (msg) {
    logger.info("recordingStarted:", msg); //Recorded Call : firing an event

    myWebRTC_Event.createMCURecordingStartedEvent(msg.roomName, msg.callId, msg.clientId, msg.recordType, msg.time, msg.convId, msg.mediaId, msg.mediaURL, msg.remoteId, msg.recordedFileName, msg.mediaType, msg.descriptor);
  };

  this.recordingStopped = function (msg) {
    logger.info("recordingStopped:", msg); //Recorded Call : firing an event

    myWebRTC_Event.createMCURecordingStoppedEvent(msg.roomName, msg.callId, msg.clientId, msg.recordType, msg.time, msg.convId, msg.mediaId, msg.mediaURL, msg.remoteId, msg.recordedFileName, msg.mediaType, msg.descriptor);
  };

  this.recordingStreamAvailable = function (msg) {
    logger.info("recordingStreamAvailable :", msg); //Recorded Call : firing an event

    myWebRTC_Event.createMCURecordedStreamsAvailableEvent(msg.roomName, msg.callId, msg.clientId, msg.recordedFileName, msg.convId, msg.mediaId, msg.mediaURL, msg.recordType, msg.remoteId, msg.mediaType, msg.descriptor);

    if (this.pubConnector === 'janusConnector') {
      if (msg.hasOwnProperty('confId') && msg.hasOwnProperty('remoteId')) {
        myWebRTC_Event.createRecordedStreamsAvailableEvent(msg.confId, msg.clientId, msg.remoteId, msg.callId, msg.convId, msg.mediaId, msg.mediaURL);
      }
    }
  };

  this.streamingStarted = function (msg) {
    logger.info("streamingStarted: ", msg);
    myWebRTC_Event.createMCUStreamingStartedEvent(msg.roomName, msg.callId, msg.clientId, msg.time);
  };

  this.streamingStopped = function (msg) {
    logger.info("streamingStopped: ", msg);
    myWebRTC_Event.createMCUStreamingStoppedEvent(msg.roomName, msg.callId, msg.clientId, msg.time);
  };

  this.startComposite = function (roomId) {
    var messageToSend = null;
    var msgString = null;
    var sessionMCU = null;

    if (!roomId) {
      sessionMCU = this.getSessionMCU(null, {
        first: true
      });
    } else {
      sessionMCU = this.getSessionMCU(roomId);
    }

    if (!sessionMCU) {
      logger.log('startComposite() but client is not in session');
      return;
    }

    logger.log('startComposite() on ApiRTC MCU with roomId :', sessionMCU.roomName);
    messageToSend = {
      type: 'startComposite',
      roomId: sessionMCU.roomName,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      data: {
        pubSub: this.pubConnector
      }
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('startComposite', msgString);
  };

  this.stopComposite = function (roomId) {
    var messageToSend = null;
    var msgString = null;
    var sessionMCU = null;

    if (!roomId) {
      sessionMCU = this.getSessionMCU(null, {
        first: true
      });
    } else {
      sessionMCU = this.getSessionMCU(roomId);
    }

    if (!sessionMCU) {
      logger.log('stopComposite() but client is not in session');
      return;
    }

    logger.log('stopComposite() on ApiRTC MCU with roomId :', sessionMCU.roomName);
    messageToSend = {
      type: 'stopComposite',
      roomId: sessionMCU.roomName,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      data: {
        pubSub: this.pubConnector
      }
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('stopComposite', msgString);
  };

  this.startCompositeRecording = function (mediaType, customIdInFilename, convId, data, roomId) {
    logger.info("startCompositeRecording with convId :", convId);
    var messageToSend = null;
    var msgString = null;
    var sessionMCU = null;

    if (!roomId) {
      sessionMCU = this.getSessionMCU(null, {
        first: true
      });
    } else {
      sessionMCU = this.getSessionMCU(roomId);
    }

    if (!sessionMCU) {
      logger.log('startCompositeRecording() but client is not in session');
      return;
    }

    if (mediaType !== 'AUDIO-ONLY' && mediaType !== 'VIDEO-ONLY') {
      mediaType = "AUDIO-VIDEO";
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'object')) {
      data = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.assignObject)({}, data);
    } else {
      data = {};
    }

    data.pubSub = this.pubConnector;

    if (['complete', 'efficient', 'audioOnly'].indexOf(data.mode) < 0) {
      data.mode = 'complete';
    }

    data.labelEnabled = data.labelEnabled === true;

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'labels', 'array')) {
      data.labels = ['microphone', 'camera', 'screenSharing', 'sip'];
    }

    logger.log('startRecording() on ApiRTC MCU with roomId :', sessionMCU.roomName);
    messageToSend = {
      type: 'startRecording',
      roomId: sessionMCU.roomName,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      callId: 'COMPOSITE',
      data: data,
      customIdInFilename: customIdInFilename,
      mediaType: mediaType,
      convId: convId
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('startRecording', msgString);
  };

  this.stopCompositeRecording = function (roomId) {
    logger.info("stopCompositeRecording");
    var messageToSend = null;
    var msgString = null;
    var sessionMCU = null;

    if (!roomId) {
      sessionMCU = this.getSessionMCU(null, {
        first: true
      });
    } else {
      sessionMCU = this.getSessionMCU(roomId);
    }

    if (!sessionMCU) {
      logger.log('stopCompositeRecording() but client is not in session');
      return;
    }

    logger.log('stopRecording() on ApiRTC MCU with roomId :', sessionMCU.roomName);
    messageToSend = {
      type: 'stopRecording',
      roomId: sessionMCU.roomName,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      callId: 'COMPOSITE',
      data: {
        pubSub: this.pubConnector
      }
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('stopRecording', msgString);
  };
  /**
   * Invites a given phoneNumber to join a room.
   * @param {string} roomId
   * @param {string} convId - Cloud conversation ID.
   * @param {string} phoneNumber - The phoneNumber to invite.
   * @return {Promise<void>}
   */


  this.inviteVoIP = function (roomId, convId, phoneNumber) {
    var _this = this;

    return new Promise(function (resolve, reject) {
      if (!roomId || typeof roomId !== 'string') {
        return reject(new Error('wrong roomId'));
      }

      var sessionMCU = _this.getSessionMCU(roomId);

      if (!sessionMCU) {
        return reject(new Error('no such session'));
      }

      if (!convId || typeof convId !== 'string') {
        return reject(new Error('wrong convId'));
      }

      if (!phoneNumber || typeof phoneNumber !== 'string') {
        return reject(new Error('wrong phoneNumber'));
      }

      var receiptId = 'inviteVoIP-' + phoneNumber;

      try {
        if (webRTCClient.hasReceiptHook(receiptId)) {
          return reject(new Error('busy'));
        }

        var fut = new _utils_Future__WEBPACK_IMPORTED_MODULE_3__.Future();
        fut.onSuccess(function () {
          return resolve();
        });
        fut.onFailure(function (err) {
          return reject(err);
        });
        fut.setTimeout(INVITE_VOIP_DELAY_MS, 'timeout');
        webRTCClient.createReceiptHook(receiptId, fut);
      } catch (e) {
        logger.debug('inviteVoIP: createReceiptHook', e);
        return reject(new Error('internal error'));
      }

      var messageToSend = {
        type: 'inviteVoIP',
        clientId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
        roomId: roomId,
        convId: convId,
        phoneNumber: phoneNumber,
        receiptId: receiptId,
        data: {
          pubSub: 'sipConnector'
        }
      };
      var msgString = JSON.stringify(messageToSend);
      logger.debug('C->S:', msgString);
      apiCC.session.channel.socket.emit('inviteVoIP', msgString);
    });
  };

  this.enforceMCU = function (roomId) {
    var sessionMCU = null;

    if (!roomId) {
      sessionMCU = this.getSessionMCU(null, {
        first: true
      });
    } else {
      sessionMCU = this.getSessionMCU(roomId);
    }

    if (!sessionMCU) {
      logger.log('enforceMCU() but client is not in session');
      return;
    }

    var messageToSend = {
      type: 'info',
      infoType: 'enforceMCU',
      data: {
        clientId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
        roomId: sessionMCU.roomName,
        pubSub: this.pubConnector
      }
    };
    var msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('info', msgString);
  };

  this.meshPublish = function (roomId, sessionId, token, callConfiguration, data, options) {
    var audioOnly = false;
    var newUserMedia = null;
    var userMediaStream = null;
    var sessionMCU = this.getSessionMCU(roomId);

    if (!sessionMCU) {
      logger.error('meshPublish() - missing sessionMCU');
      return null;
    }

    if (callConfiguration === true || callConfiguration === false || callConfiguration === 'true' || callConfiguration === 'false') {
      logger.log("DEPRECATED ... please use callConfiguration JSON parameter : callConfiguration.audioOnly instead of audioOnly");
      audioOnly = callConfiguration;
      callConfiguration = {};
    } else if (callConfiguration === null || _typeof(callConfiguration) !== 'object') {
      callConfiguration = {};
    }

    if (data === null || _typeof(data) !== 'object') {
      data = {};
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'profileType', 'string')) {
      data.profileType = callConfiguration.profileType;
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'priority', 'number') && callConfiguration.priority >= 0) {
      data.priority = callConfiguration.priority;
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'downgradeProfileList', 'array')) {
      data.downgradeProfileList = callConfiguration.downgradeProfileList;
    }

    if (callConfiguration.audioOnly !== undefined) {
      audioOnly = callConfiguration.audioOnly;

      if (data.callConfiguration !== undefined) {
        data.callConfiguration.audioOnly = callConfiguration.audioOnly;
      } else {
        data.callConfiguration = {};
        data.callConfiguration.audioOnly = callConfiguration.audioOnly;
      }
    } // User defined context.


    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'context', 'object')) {
      try {
        JSON.stringify(callConfiguration.context);
        data.context = callConfiguration.context;
      } catch (e) {}
    }

    newUserMedia = new _WebRTC_UserMedia__WEBPACK_IMPORTED_MODULE_5__.WebRTC_UserMedia(apiCC.session.apiCCWebRTCClient.webRTCClient);

    if (audioOnly === true || audioOnly === 'true') {
      logger.log('Setting call as audioOnly');
      newUserMedia.callType = 'audio';
    }

    newUserMedia.roomId = roomId;
    newUserMedia.sessionId = sessionId;
    newUserMedia.token = token;
    newUserMedia.callConfiguration = callConfiguration;
    newUserMedia.data = data;
    newUserMedia.options = options;
    newUserMedia.sessionMCU = sessionMCU;
    apiCC.session.apiCCWebRTCClient.webRTCClient.userMediaTable.push(newUserMedia);

    if (callConfiguration.userMediaStreamId) {
      userMediaStream = apiCC.getUserMediaStream(callConfiguration.userMediaStreamId);
      userMediaStream.addCallInfo(newUserMedia.userMediaId, 'userMedia');
      newUserMedia.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
      newUserMedia.callType = userMediaStream.callType;
      newUserMedia.audio = userMediaStream.audio;
      newUserMedia.video = userMediaStream.video;
      newUserMedia.audioMuted = userMediaStream.audioMuted;
      newUserMedia.videoMuted = userMediaStream.videoMuted;
      apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.meshOnUserMediaSuccess(newUserMedia);
      apiCC.checkMutingStateForUserMedia(callConfiguration, userMediaStream);
    } else {
      apiCC.createUserMediaStream({
        'callId': newUserMedia.userMediaId,
        // Linking getUserMedia to this call.
        'callFlavor': 'userMedia',
        'type': newUserMedia.callType,
        'audioSourceId': apiCC.session.apiCCWebRTCClient.webRTCClient.audioSourceId,
        'videoSourceId': apiCC.session.apiCCWebRTCClient.webRTCClient.videoSourceId,
        'success': function success(userMediaStream) {
          logger.debug('[meshPublish] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
          newUserMedia.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
          newUserMedia.callType = userMediaStream.callType;
          newUserMedia.audio = userMediaStream.audio;
          newUserMedia.video = userMediaStream.video;
          newUserMedia.audioMuted = userMediaStream.audioMuted;
          newUserMedia.videoMuted = userMediaStream.videoMuted;
          apiCC.session.apiCCWebRTCClient.webRTCClient.accessToLocalMedia = true;
          apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.meshOnUserMediaSuccess(newUserMedia);
          apiCC.checkMutingStateForUserMedia(callConfiguration, userMediaStream);
        }
      });
    }

    return newUserMedia.userMediaId;
  };
  /*
   * Sends a streamStatusChanged message to CCS to declare the mesh publish call.
   *
   * @method meshOnUserMediaSuccess
   * @param {WebRTC_UserMedia} userMedia
   * @param {boolean} update - whether this is just an update of a previous mesh publish call.
   */


  this.meshOnUserMediaSuccess = function (userMedia) {
    var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var messageToSend = null;
    var msgString = null;

    if (update === true) {
      // Update media of existing stream.
      // Notifying CCS about that.
      messageToSend = {};
      messageToSend.type = 'streamStatusChanged';
      messageToSend.callerId = webRTCClient.clientId;
      messageToSend.roomId = userMedia.roomId;
      messageToSend.streams = {};
      messageToSend.streams[userMedia.userMediaId] = {
        'eventType': 'modify',
        'callId': userMedia.userMediaId,
        'callType': userMedia.callType,
        'audio': userMedia.audio,
        'video': userMedia.video,
        'audioMuted': userMedia.audioMuted,
        'videoMuted': userMedia.videoMuted
      };
      messageToSend.data = {};
      messageToSend.data.meshPublish = true;
      messageToSend.data.pubSub = this.pubConnector;
      msgString = JSON.stringify(messageToSend);
      logger.log('C->S: ' + msgString);
      apiCC.session.channel.socket.emit('streamStatusChanged', msgString);
    } else {
      // For recording, streaming...
      this.publishCallId = userMedia.userMediaId; // Marking the following request.
      // The timeout will be clear upon receipt of availableStreams message from CCS.

      userMedia.addAck = true;
      userMedia.addTimeoutId = setTimeout(function () {
        // Notifying the end user about an issue.
        webRTCClient.onRemoteHangup(userMedia.userMediaId, webRTCClient.clientId, userMedia.roomId, 'Unable_to_establish', null, null);
      }, userMedia.disconnectionTimer); // Notifying CCS about that.

      messageToSend = {};
      messageToSend.type = 'streamStatusChanged';
      messageToSend.callerId = webRTCClient.clientId;
      messageToSend.roomId = userMedia.roomId;
      messageToSend.streams = {};
      messageToSend.streams[userMedia.userMediaId] = {
        'eventType': 'add',
        'callId': userMedia.userMediaId,
        'callType': userMedia.callType,
        'audio': userMedia.audio,
        'video': userMedia.video,
        'audioMuted': userMedia.audioMuted,
        'videoMuted': userMedia.videoMuted
      }; //messageToSend.data = {};

      messageToSend.data = userMedia.data;
      messageToSend.data.meshPublish = true;
      messageToSend.data.pubSub = this.pubConnector;
      msgString = JSON.stringify(messageToSend);
      logger.log('C->S: ' + msgString);
      apiCC.session.channel.socket.emit('streamStatusChanged', msgString);
    }
  };

  this.meshPublishScreen = function (roomId, data, callConfiguration, captureSourceType, options) {
    var newUserMedia = null;
    var userMediaStream = null;
    var sessionMCU = this.getSessionMCU(roomId);

    if (!sessionMCU) {
      logger.error('meshPublishScreen() - missing sessionMCU');
      return null;
    }

    if (callConfiguration === null || _typeof(callConfiguration) !== 'object') {
      callConfiguration = {};
    }

    newUserMedia = new _WebRTC_UserMedia__WEBPACK_IMPORTED_MODULE_5__.WebRTC_UserMedia(apiCC.session.apiCCWebRTCClient.webRTCClient);
    newUserMedia.roomId = roomId;
    newUserMedia.data = data;
    newUserMedia.callConfiguration = callConfiguration;
    newUserMedia.captureSourceType = captureSourceType;
    newUserMedia.sessionMCU = sessionMCU;
    apiCC.session.apiCCWebRTCClient.webRTCClient.userMediaTable.push(newUserMedia);

    if (callConfiguration.userMediaStreamId) {
      userMediaStream = apiCC.getUserMediaStream(callConfiguration.userMediaStreamId);
      userMediaStream.addCallInfo(newUserMedia.userMediaId, 'userMedia');
      newUserMedia.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
      newUserMedia.callType = userMediaStream.callType;
      newUserMedia.audio = userMediaStream.audio;
      newUserMedia.video = userMediaStream.video;
      newUserMedia.audioMuted = userMediaStream.audioMuted;
      newUserMedia.videoMuted = userMediaStream.videoMuted;
      apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.meshOnUserMediaSuccess(newUserMedia);
    } else {
      apiCC.createUserMediaStream({
        'callId': newUserMedia.userMediaId,
        // Linking getUserMedia to this call.
        'callFlavor': 'userMedia',
        'type': 'screenSharing',
        'captureSourceType': captureSourceType,
        'success': function success(userMediaStream) {
          logger.debug('[meshPublishScreen] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
          newUserMedia.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
          newUserMedia.callType = userMediaStream.callType;
          newUserMedia.audio = userMediaStream.audio;
          newUserMedia.video = userMediaStream.video;
          newUserMedia.audioMuted = userMediaStream.audioMuted;
          newUserMedia.videoMuted = userMediaStream.videoMuted;
          apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.meshOnScreenMediaSuccess(newUserMedia);
        }
      });
    }

    return newUserMedia.userMediaId;
  };
  /*
   * Sends a streamStatusChanged message to CCS to declare the mesh publish call.
   *
   * @method meshOnScreenMediaSuccess
   * @param {WebRTC_UserMedia} userMedia
   */


  this.meshOnScreenMediaSuccess = function (userMedia) {
    var messageToSend = null;
    var msgString = null; // Marking the following request.
    // The timeout will be clear upon receipt of availableStreams message from CCS.

    userMedia.addAck = true;
    userMedia.addTimeoutId = setTimeout(function () {
      // Notifying the end user about an issue.
      webRTCClient.onRemoteHangup(userMedia.userMediaId, webRTCClient.clientId, userMedia.roomId, 'Unable_to_establish', null, null);
    }, userMedia.disconnectionTimer); // Notifying CCS about that.

    messageToSend = {};
    messageToSend.type = 'streamStatusChanged';
    messageToSend.callerId = webRTCClient.clientId;
    messageToSend.roomId = userMedia.roomId;
    messageToSend.streams = {};
    messageToSend.streams[userMedia.userMediaId] = {
      'eventType': 'add',
      'callId': userMedia.userMediaId,
      'callType': userMedia.callType,
      'audio': userMedia.audio,
      'video': userMedia.video,
      'audioMuted': userMedia.audioMuted,
      'videoMuted': userMedia.videoMuted
    };
    messageToSend.data = {};
    messageToSend.data.pubSub = this.pubConnector;
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('streamStatusChanged', msgString);
  };
  /* Hangs up a given mesh publish.
   * @ignore
   * @param {string} userMediaId
   * @param {object} data
   * @param {object} opts
   * @param {string} opts.roomId
   * @param {string} opts.restart - Whether the WebRTC_UserMedia is restarting.
   */


  this.meshOnHangup = function (userMediaId, data) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var idx = 0,
        userMedia = null,
        messageToSend = null,
        msgString = null;

    if (data === null || _typeof(data) !== 'object') {
      data = {};
    }

    if (!userMediaId) {
      // userMediaId is undefined, closing everything.
      for (idx = webRTCClient.userMediaTable.length; --idx >= 0;) {
        userMedia = webRTCClient.userMediaTable[idx];

        if (opts.hasOwnProperty('roomId') && userMedia.sessionMCU.roomName !== opts.roomId) {
          // room does not match
          continue;
        }

        webRTCClient.myWebRTC_Event.createHangupEvent('local', webRTCClient.clientId, 0, true, null, userMedia.userMediaId, userMedia.callType);
        userMedia.close();
        userMedia.releaseUserMediaStream();
        messageToSend = {};
        messageToSend.type = 'streamStatusChanged';
        messageToSend.callerId = webRTCClient.clientId;
        messageToSend.roomId = userMedia.roomId;
        messageToSend.streams = {};
        messageToSend.streams[userMedia.userMediaId] = {
          'eventType': 'remove',
          'callId': userMedia.userMediaId,
          'callType': userMedia.callType
        };
        messageToSend.data = {};
        messageToSend.data.pubSub = this.pubConnector;
        msgString = JSON.stringify(messageToSend);
        logger.log('C->S: ' + msgString);
        apiCC.session.channel.socket.emit('streamStatusChanged', msgString);
        webRTCClient.userMediaTable.splice(idx, 1);
      } // for

    } else if ((userMedia = webRTCClient.findUserMediaById(userMediaId)) !== null) {
      // userMediaId is defined.
      userMedia.close();

      if (userMedia.streamStolen !== true) {
        // Stream is not used for something else.
        webRTCClient.myWebRTC_Event.createHangupEvent('local', webRTCClient.clientId, 0, true, null, userMedia.userMediaId, userMedia.callType);
        userMedia.releaseUserMediaStream();
      }

      messageToSend = {};
      messageToSend.type = 'streamStatusChanged';
      messageToSend.callerId = webRTCClient.clientId;
      messageToSend.roomId = userMedia.roomId;
      messageToSend.streams = {};
      messageToSend.streams[userMedia.userMediaId] = {
        'eventType': 'remove',
        'callId': userMedia.userMediaId,
        'callType': userMedia.callType
      };

      if (opts.restart) {
        messageToSend.streams[userMedia.userMediaId].restart = true;
      }

      messageToSend.data = {};
      messageToSend.data.pubSub = this.pubConnector;
      msgString = JSON.stringify(messageToSend);
      logger.log('C->S: ' + msgString);
      apiCC.session.channel.socket.emit('streamStatusChanged', msgString); // Removing given userMedia from the list.

      for (idx = webRTCClient.userMediaTable.length; --idx >= 0;) {
        if (webRTCClient.userMediaTable[idx] === userMedia) {
          webRTCClient.userMediaTable.splice(idx, 1);
          break;
        }
      }
    }
  };
  /*
   * When a participant has been ejected from the current MCU session.
   * @ignore
   * @param {object} msg
   * @param {string} msg.roomId
   * @param {object} msg.data
   * @param {string} msg.data.clientId
   * @param {object} msg.data.info
   */


  this.participantEjected = function (msg) {
    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(msg.data, 'clientId', 'string')) {
      webRTCClient.myWebRTC_Event.createMCUParticipantEjectedEvent(msg.roomId, msg.data.clientId, msg.data.info);
    }
  };
  /*
   * Ejects another participant from the current MCU session.
   * @ignore
   * @param {string} userId
   * @param {object} data
   * @param {string} roomId
   */


  this.ejectParticipant = function (userId, data, roomId) {
    var sessionMCU = null;

    if (!roomId) {
      sessionMCU = this.getSessionMCU(null, {
        first: true
      });
    } else {
      sessionMCU = this.getSessionMCU(roomId);
    }

    if (!sessionMCU) {
      logger.debug('ejectParticipant() - missing sessionMCU');
      return;
    }

    var messageToSend = {
      type: 'ejectParticipant',
      roomId: sessionMCU.roomName,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      data: {
        pubSub: this.pubConnector,
        clientId: userId
      }
    };

    if (data) {
      // Add optional user data.
      messageToSend.data.info = data;
    }

    var msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('ejectParticipant', msgString);
  };
  /*
   * Gets a joinSessionReq for a given roomId.
   * @ignore
   * @param {string} roomId
   * @param {object} opts
   * @param {string} opts.transactionId
   * @return {object} A joinSessionReq on success, null otherwise.
   */


  this.getJoinSessionReq = function (roomId) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var ret = null;

    if (!roomId) {
      // No roomId given.
      if (opts.hasOwnProperty('transactionId')) {
        // transactionId given.
        for (var idx = this.joinSessionReqs.length; --idx >= 0;) {
          if (this.joinSessionReqs[idx].transactionId === opts.transactionId) {
            ret = this.joinSessionReqs[idx];
            break;
          }
        }

        return ret;
      }

      return null;
    }

    for (var _idx2 = this.joinSessionReqs.length; --_idx2 >= 0;) {
      if (this.joinSessionReqs[_idx2].roomId === roomId) {
        ret = this.joinSessionReqs[_idx2];
        break;
      }
    }

    return ret;
  };
  /*
   * Removes a given joinSessionReq (or the one matching a given roomId).
   * @ignore
   * @param {object} joinSessionReq - The joinSessionReq to remove, null to use the roomId to find it.
   * @param {object} opts
   * @param {boolean} opts.all - Whether all joinSessionReqs must be removed.
   * @param {string} opts.roomId - The roomId of a the joinSessionReq to remove.
   * @return {boolean} True if the entry has been removed successfully, false otherwise.
   */


  this.removeJoinSessionReq = function (joinSessionReq) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!joinSessionReq) {
      if (opts.all === true) {
        this.joinSessionReqs.splice(0, this.joinSessionReqs.length);
        return true;
      }

      if (opts.hasOwnProperty('roomId')) {
        joinSessionReq = this.getJoinSessionReq(opts.roomId);
      }
    }

    if (!joinSessionReq) {
      return false;
    }

    var idx = this.joinSessionReqs.length;

    while (--idx >= 0) {
      if (this.joinSessionReqs[idx] === joinSessionReq) {
        break;
      }
    }

    if (idx >= 0) {
      this.joinSessionReqs.splice(idx, 1);
      return true;
    }

    return false;
  };
  /*
   * Gets a sessionMCU for a given roomId.
   * @ignore
   * @param {string} roomId
   * @param {object} opts
   * @param {boolean} opts.first - Returns the first entry (roomId must be null).
   * @param {boolean} opts.callback - Filter by callback (roomId must be null).
   * @return {object} A sessionMCU on success, null otherwise.
   */


  this.getSessionMCU = function (roomId) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var ret = null;

    if (!roomId) {
      // No roomId given.
      if (opts.first === true) {
        return this.sessionMCUs[0];
      }

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(opts.callback, 'function')) {
        // Filter by callback.
        logger.debug('getSessionMCU callback');

        for (var idx = this.sessionMCUs.length; --idx >= 0;) {
          if (opts.callback(this.sessionMCUs[idx])) {
            ret = this.sessionMCUs[idx];
            break;
          }
        } // for

      }

      return ret;
    }

    for (var _idx3 = this.sessionMCUs.length; --_idx3 >= 0;) {
      if (this.sessionMCUs[_idx3].roomName === roomId) {
        ret = this.sessionMCUs[_idx3];
        break;
      }
    } // for


    return ret;
  };
  /*
   * Removes a given sessionMCU.
   * @ignore
   * @param {object} sessionMCU - The sessionMCU to remove.
   * @param {object} opts
   * @param {boolean} opts.all - Whether all sessionMCUs must be removed.
   * @return {boolean} True if the entry has been removed successfully, false otherwise.
   */


  this.removeSessionMCU = function (sessionMCU) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!sessionMCU) {
      if (opts.all === true) {
        this.sessionMCUs.splice(0, this.sessionMCUs.length);
        return true;
      }
    }

    if (!sessionMCU) {
      return false;
    }

    var idx = this.sessionMCUs.length;

    while (--idx >= 0) {
      if (this.sessionMCUs[idx] === sessionMCU) {
        break;
      }
    }

    if (idx >= 0) {
      this.sessionMCUs.splice(idx, 1);
      return true;
    }

    return false;
  };

  this.callback = function (that, fnct) {
    this.closureHandler = function (e) {
      return that[fnct](e);
    };

    return this.closureHandler;
  };
};
/*
 * Used in a setTimeout as a failsafe when a stream does not reappear.
 */


function disputableEntryTimeout(streamId) {
  logger.debug('disputableEntryTimeout', streamId);
  var webRTCClient = apiCC.session.apiCCWebRTCClient.webRTCClient; // Clear from disputableStreamList.

  for (var i = this.disputableStreamList.length; --i >= 0;) {
    if (this.disputableStreamList[i].streamInfo.id === streamId) {
      this.disputableStreamList.splice(i, 1);
      break;
    }
  } // for
  // Clear from streamList.


  var callControl = null;

  for (var _i2 = this.streamList.length; --_i2 >= 0;) {
    if (this.streamList[_i2].streamInfo.id === streamId) {
      callControl = webRTCClient.destroyCallControl({
        type: 'subscribe',
        stream: this.streamList[_i2].streamInfo
      });
      this.streamList.splice(_i2, 1);
      break;
    }
  } // for
  // Notify about hangup.


  if (callControl && callControl.callId) {
    myWebRTC_Event.createHangupEvent('remote', webRTCClient.clientId, callControl.roomName, false, 'Hangup_From_Callee', callControl.callId, callControl.callType);
  } // Notify about stream removed.


  myWebRTC_Event.createMCURemovedStreamEvent(streamId);
}
/*
 * Set alongside disputableEntryTimeout. Clears the said timeout, clears the entry from
 * the disputableStreamList, deletes itself.
 * @ignore
 * @method clearDisputableEntry
 */


function clearDisputableEntry(streamId) {
  logger.debug('clearDisputableEntry', streamId);

  for (var i = this.disputableStreamList.length; --i >= 0;) {
    if (this.disputableStreamList[i].streamInfo.id === streamId) {
      this.disputableStreamList.splice(i, 1);
      break;
    }
  } // for


  for (var _i3 = this.streamList.length; --_i3 >= 0;) {
    if (this.streamList[_i3].streamInfo.id === streamId) {
      if (this.streamList[_i3].disputableTimeoutId) {
        clearTimeout(this.streamList[_i3].disputableTimeoutId);
        delete this.streamList[_i3].disputableTimeoutId;
      }

      delete this.streamList[_i3].clearDisputableEntry;
      break;
    }
  } // for

}
/*
 * Returns a sanitized version of a given encoding object (high, medium, low).
 * Encodings must be sanitized because they are given by the application (which
 * we don't trust) and sent to janusConnector.
 * @ignore
 * @method sanitizeSimulcastEncoding
 * @param {object} encoding
 * @return {object}
 */


function sanitizeSimulcastEncoding(encoding) {
  var ret = {};

  if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(encoding, 'maxBitrate', 'number')) {
    ret.maxBitrate = encoding.maxBitrate;
  }

  if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(encoding, 'scaleResolutionDownBy', 'number')) {
    ret.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
  }

  return ret;
}
/*
 * Returns the default simulcast encodings object.
 * @ignore
 * @method defaultSimulcastEncodings
 * @return {object}
 */


function defaultSimulcastEncodings() {
  return {
    high: {
      maxBitrate: 900
    },
    medium: {
      maxBitrate: 300,
      scaleResolutionDownBy: 2
    },
    low: {
      maxBitrate: 100,
      scaleResolutionDownBy: 4
    }
  };
}
/*
 * Creates the simulcast sendEncodings array from the encodings object.
 * @ignore
 * @method applySimulcastEncodings
 * @param {object} context
 * @param {object} context.encodings
 * @param {object} context.encodings.high
 * @param {number} context.encodings.high.maxBitrate - kbps.
 * @param {object} context.encodings.medium
 * @param {number} context.encodings.medium.maxBitrate - kbps.
 * @param {number} context.encodings.medium.scaleResolutionDownBy
 * @param {object} context.encodings.low
 * @param {number} context.encodings.low.maxBitrate - kbps.
 * @param {number} context.encodings.low.scaleResolutionDownBy
 * @return {boolean} true on success, false otherwise.
 */


function applySimulcastEncodings(context) {
  if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(context.encodings, 'object')) {
    logger.warn('no such encodings');
    return false;
  }

  if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(context.encodings.high, 'maxBitrate', 'number') || !(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(context.encodings.medium, 'maxBitrate', 'number') || !(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(context.encodings.low, 'maxBitrate', 'number')) {
    // All 3 categories are mandatory: high, medium, low.
    // maxBitrate is mandatory for all 3 categories.
    logger.warn('no such maxBitrate');
    return false;
  } // Add active fields, in first position (not essential) but simple enough.
  // The active fields are useful to handle substream (high or medium)
  // deactivation. The encodings object is sent to janusConnector after an
  // update (substream activation/deactivation).


  context.encodings.high = Object.assign({
    active: true
  }, sanitizeSimulcastEncoding(context.encodings.high));
  context.encodings.medium = Object.assign({
    active: true
  }, sanitizeSimulcastEncoding(context.encodings.medium));
  context.encodings.low = Object.assign({
    active: true
  }, sanitizeSimulcastEncoding(context.encodings.low));
  context.sendEncodings = [{
    rid: 'h',
    active: true
  }, {
    rid: 'm',
    active: true
  }, {
    rid: 'l',
    active: true
  }];
  context.sendEncodings[0].maxBitrate = context.encodings.high.maxBitrate * 1000;
  context.sendEncodings[1].maxBitrate = context.encodings.medium.maxBitrate * 1000;
  context.sendEncodings[2].maxBitrate = context.encodings.low.maxBitrate * 1000;

  if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(context.encodings.medium, 'scaleResolutionDownBy', 'number')) {
    context.sendEncodings[1].scaleResolutionDownBy = context.encodings.medium.scaleResolutionDownBy;
  }

  if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(context.encodings.low, 'scaleResolutionDownBy', 'number')) {
    context.sendEncodings[2].scaleResolutionDownBy = context.encodings.low.scaleResolutionDownBy;
  }

  return true;
}
/*
 * Creates the simulcast encodings object and the simulcast sendEncodings array, for a given bitrate.
 * @ignore
 * @method applySimulcastEncodingsBitrate
 * @param {object} context
 * @param {number} bitrate - kbps.
 * @return {boolean} true on success, false otherwise.
 */


function applySimulcastEncodingsBitrate(context, bitrate) {
  // Distribution:
  // - 9/13 for the high substream,
  // - 3/13 for the medium substream,
  // - 1/13 for the low substream.
  if (bitrate < 650) {
    // 650 kbps means 50 kbps for the low substream, below that it is not worth it.
    return false;
  }

  var h = Math.floor(bitrate * 9 / 13);
  var m = Math.floor(bitrate * 3 / 13);
  var l = bitrate - h - m;
  context.encodings = {
    high: {
      maxBitrate: h
    },
    medium: {
      maxBitrate: m,
      scaleResolutionDownBy: 2
    },
    low: {
      maxBitrate: l,
      scaleResolutionDownBy: 4
    }
  };
  return applySimulcastEncodings(context);
}
/*
 * Prepares the simulcast configuration during a publish call establishment.
 * @ignore
 * @method prepareSimulcastConfiguration
 * @param {object} callConfiguration
 * @param {object} callConfiguration.simulcast
 * @param {string} callConfiguration.simulcast.mode - Either 'RID', 'SDP' or undefined.
 * @param {number} callConfiguration.simulcast.maxBitrate
 * @param {object} callConfiguration.simulcast.encodings
 * @return {boolean} true if simulcasting is enabled, false otherwise.
 */


function prepareSimulcastConfiguration(callConfiguration) {
  if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(callConfiguration, 'simulcast', 'object')) {
    // simulcast must be an object.
    // Simulcasting disabled.
    delete callConfiguration.simulcast;
    return false;
  }

  if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'safari' && callConfiguration.simulcast.mode !== 'SDP') {
    // Only accept simulcast for safari if the mode is mentioned.
    delete callConfiguration.simulcast;
    return false;
  } // Simulcasting enabled.


  delete callConfiguration.simulcast.sendEncodings;

  if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(callConfiguration.simulcast, 'maxBitrate', 'number')) {
    // maxBitrate specified.
    if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 78 && callConfiguration.simulcast.mode !== 'SDP') {
      logger.debug('configure simulcast RID chrome maxBitrate');

      if (!applySimulcastEncodingsBitrate(callConfiguration.simulcast, callConfiguration.simulcast.maxBitrate)) {
        logger.warn('cannot configure simulcast');
        delete callConfiguration.simulcast;
        return false;
      }
    } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
      logger.debug('configure simulcast RID firefox maxBitrate');

      if (!applySimulcastEncodingsBitrate(callConfiguration.simulcast, callConfiguration.simulcast.maxBitrate)) {
        logger.warn('cannot configure simulcast');
        delete callConfiguration.simulcast;
        return false;
      }
    } else {
      // No encodings necessary (SDP).
      delete callConfiguration.simulcast.encodings;
    }
  } else if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(callConfiguration.simulcast, 'encodings', 'object')) {
    // encodings specified.
    if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 78 && callConfiguration.simulcast.mode !== 'SDP') {
      logger.debug('configure simulcast RID chrome encodings');

      if (!applySimulcastEncodings(callConfiguration.simulcast)) {
        logger.warn('cannot configure simulcast');
        delete callConfiguration.simulcast;
        return false;
      }
    } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
      logger.debug('configure simulcast RID firefox encodings');

      if (!applySimulcastEncodings(callConfiguration.simulcast)) {
        logger.warn('cannot configure simulcast');
        delete callConfiguration.simulcast;
        return false;
      }
    } else {
      // No encodings necessary (SDP).
      delete callConfiguration.simulcast.encodings;
    }
  } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 78 && callConfiguration.simulcast.mode !== 'SDP') {
    // No maxBitrate, nor encodings specified.
    logger.debug('configure simulcast RID chrome default');
    callConfiguration.simulcast.encodings = defaultSimulcastEncodings();

    if (!applySimulcastEncodings(callConfiguration.simulcast)) {
      delete callConfiguration.simulcast;
      return false;
    }
  } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
    // No maxBitrate, nor encodings specified.
    logger.debug('configure simulcast RID firefox default');
    callConfiguration.simulcast.encodings = defaultSimulcastEncodings();

    if (!applySimulcastEncodings(callConfiguration.simulcast)) {
      delete callConfiguration.simulcast;
      return false;
    }
  }

  return true;
}



/***/ }),

/***/ "./src/Core/ApiCCPointerSharingClient.js":
/*!***********************************************!*\
  !*** ./src/Core/ApiCCPointerSharingClient.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiCCPointerSharingClient": () => (/* binding */ ApiCCPointerSharingClient)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ApiCCPointerSharingClient');

var JOIN_ROOM_TIMEOUT = 15000;
/**
 * <p>This is the ApiCCPointerSharingClient.</p>
 * <p>This class enables you to share pointer location between clients.</p>
 *
 * @module ApiCCPointerSharingClient
 */

var ApiCCPointerSharingClient = function ApiCCPointerSharingClient(session) {
  this.roomTable = {};
  /**
   * <b>Description</b>
   * <p>Joins a given room.</p>
   * @method getRoomIds
   * @param {object} an array of roomId(s).
   */

  this.getRoomIds = function () {
    var ret = [],
        roomId = null;

    for (roomId in this.roomTable) {
      ret.push(roomId);
    }

    return ret;
  };
  /**
   * <b>Description</b>
   * <p>Tests whether a given room exists.</p>
   * @method roomExists
   * @param {string} roomId - roomId.
   * @return {boolean} True if room exists, false otherwise.
   */


  this.roomExists = function (roomId) {
    return this.roomTable.hasOwnProperty(roomId);
  };
  /**
   * <b>Description</b>
   * <p>Tests whether a given room exists and is active (joined).</p>
   * @method
   * @param {string} roomId - roomId.
   * @return {boolean} True if room is active, false otherwise.
   */


  this.roomActive = function (roomId) {
    return this.roomTable.hasOwnProperty(roomId) && this.roomTable[roomId].state === ApiCCPointerSharingClient.STATE_ACTIVE;
  };
  /**
   * <b>Description</b>
   * <p>Joins a given room.</p>
   * @method joinRoom
   * @param {string} roomId - roomId.
   * @param {object} callbacks - optional result callbacks.
   * @param {function} callbacks.success - called on success.
   * @param {function} callbacks.failure - called on failure.
   */


  this.joinRoom = function (roomId, callbacks) {
    var _this = this;

    logger.info('ApiCCPointerSharingClient::joinRoom()');

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isTypeof)(callbacks, 'object')) {
      callbacks = {};
    }

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isPropertyTypeof)(callbacks, 'success', 'function')) {
      callbacks.success = function () {};
    }

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isPropertyTypeof)(callbacks, 'failure', 'function')) {
      callbacks.failure = function () {};
    }

    if (!this.roomTable.hasOwnProperty(roomId)) {
      this.roomTable[roomId] = {
        roomId: roomId,
        state: ApiCCPointerSharingClient.STATE_JOINING,
        joinRoomCallbacks: callbacks
      };
      this.roomTable[roomId].joinRoomTimeoutId = setTimeout(function () {
        delete _this.roomTable[roomId];
        callbacks.failure('timeout', roomId);
      }, JOIN_ROOM_TIMEOUT);
      apiCC.session.roomMgr.joinRoom(roomId, 'pointerSharing');
    } else {
      callbacks.failure('room already joined', roomId);
    }
  };
  /**
   * <b>Description</b>
   * <p>Leaves a given room.</p>
   * @method leaveRoom
   * @param {string} roomId - roomId.
   */


  this.leaveRoom = function (roomId) {
    if (this.roomTable.hasOwnProperty(roomId)) {
      delete this.roomTable[roomId];
    }

    apiCC.session.roomMgr.leaveRoom(roomId, 'pointerSharing');
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to invite a contact to the pointer sharing session.</p>
   * @method inviteInRoom
   * @param {string} roomId - roomId.
   * @param {string} destId - clientId of the contact to invite.
   * @param {object} context - Context to send to invited user.
   */


  this.inviteInRoom = function (roomId, destId, context) {
    logger.info('ApiCCPointerSharingClient::inviteInRoom()');
    apiCC.session.roomMgr.inviteInRoom(roomId, destId, 'pointerSharing', context);
  };
  /**
   * <b>Description</b>
   * <p>Sends a given pointer location to every other participant in a given room.</p>
   * @method sendPointerLocation
   * @param {string} roomId - roomId.
   * @param {object} source - Used to identify pointer source.
   * @param {number} x - The X coordinate of the mouse pointer in source coordinates.
   * @param {number} y - The Y coordinate of the mouse pointer in source coordinates.
   * @param {object} data - Optional data to send with.
   * @return {boolean} True on success, false otherwise.
   */


  this.sendPointerLocation = function (roomId, source, x, y, data) {
    var dataBundle;

    if (this.roomTable.hasOwnProperty(roomId) && this.roomTable[roomId].state === ApiCCPointerSharingClient.STATE_ACTIVE) {
      dataBundle = {
        type: 'pointerLocation',
        source: source,
        x: x,
        y: y
      };

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isTypeof)(data, 'object')) {
        dataBundle.data = data;
      }

      apiCC.session.roomMgr.sendMessageToRoom(roomId, 'pointerSharing', dataBundle);
      return true;
    }

    return false;
  };

  this.processMessageRoomJoin = function (msg) {
    /* message:{
     *   "type":"joinRoom",
     *   "roomId":"charlie",
     *   "nickname":"478266",
     *   "photoURL":null,
     *   "roomType":"pointerSharing"
     * } */
    if (this.roomTable.hasOwnProperty(msg.roomId)) {
      if (this.roomTable[msg.roomId].state === ApiCCPointerSharingClient.STATE_JOINING) {
        clearTimeout(this.roomTable[msg.roomId].joinRoomTimeoutId);
        delete this.roomTable[msg.roomId].joinRoomTimeoutId;
        this.roomTable[msg.roomId].state = ApiCCPointerSharingClient.STATE_ACTIVE;
        this.roomTable[msg.roomId].joinRoomCallbacks.success(msg.roomId);
        delete this.roomTable[msg.roomId].joinRoomCallbacks;
      }
    }
  };
  /**
   * <b>Description</b>
   * <p>Leaves every room.</p>
   * @method stop
   */


  this.stop = function () {
    var roomIds = this.getRoomIds(),
        idx = roomIds.length;

    while (--idx >= 0) {
      this.leaveRoom(roomIds[idx]);
    }
  };
};

ApiCCPointerSharingClient.STATE_IDLE = Symbol('idle');
ApiCCPointerSharingClient.STATE_JOINING = Symbol('joining');
ApiCCPointerSharingClient.STATE_ACTIVE = Symbol('active');
ApiCCPointerSharingClient.STATE_ERROR = Symbol('error');

/**
 * Fired when a room is joined.
 * @event roomJoined
 * @param {Date} e.detail.time - Date.
 * @param {string} e.detail.eventType - set to roomJoined.
 * @param {string} e.detail.status - set to roomJoined.
 * @param {string} e.detail.roomId - roomId.
 * @param {string] e.detail.roomType - set to pointerSharing.
 */

/**
 * Fired when a room invitation is received.
 * @event roomInvitation
 * @param {Date} e.detail.time - Date.
 * @param {string} e.detail.eventType - set to roomInvitation.
 * @param {string} e.detail.roomId - Id of the room.
 * @param {string} e.detail.contactList - List of contacts already present in the room.
 * @param {string} e.detail.senderId - Id of the invitation sender.
 * @param {string} e.detail.senderNickname - Nickname of the invitation sender.
 * @param {string} e.detail.senderPhotoURL - PhotoURL of the invitation sender.
 * @param {string} e.detail.roomType - set to pointerSharing.
 */

/**
 * Fired when a room message is received.
 * @event receiveRoomMessage
 * @param {Date} e.detail.time - Date.
 * @param {string} e.detail.roomId - Id of the room.
 * @param {string} e.detail.roomType - set to pointerSharing.
 * @param {string} e.detail.senderId - Id of the invitation sender.
 * @param {string} e.detail.senderNickname - Nickname of the invitation sender.
 * @param {string} e.detail.message.type - set to pointerLocation for a pointer location.
 * @param {object} e.detail.message.source - source identifier.
 * @param {number} e.detail.message.x - The X coordinate of the mouse pointer in source coordinates.
 * @param {number} e.detail.message.y - The Y coordinate of the mouse pointer in source coordinates.
 * @param {object} e.detail.message.data - Optional data.
 */

/***/ }),

/***/ "./src/Core/ApiCCSession.js":
/*!**********************************!*\
  !*** ./src/Core/ApiCCSession.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiCCSession": () => (/* binding */ ApiCCSession)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _RoomManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RoomManager */ "./src/Core/RoomManager.js");
/* harmony import */ var _ApiCC_Channel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ApiCC_Channel */ "./src/Core/ApiCC_Channel.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* harmony import */ var _WebRTC_Stack__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WebRTC_Stack */ "./src/Core/WebRTC_Stack.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/* globals apiCC, apiDB, alert*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ApiCCSession');





var myWebRTC_Event = apiCC.myWebRTC_Event;
var DEFAULT_ID_PERSISTENCE_DELAY = 5000;
/**
 * <p>This is the ApiRTCSession.</p>
 * <p>This class enables you to manage your session and the applications that you want to add on your client (WebRTC, Instant messaging, cobrowsing, ...)</p>
 *
 * @module ApiRTCSession
 */

var ApiCCSession = function ApiCCSession(params) {
  var _this5 = this;

  /**
   * Session Identifier
   *
   * @property apiCCId
   * @type String
   */
  this.apiCCId = null;
  this.apiCCSessionId = apiCC.randomString(22); // this value must be random and NOT cached

  this.apiKey = null;
  this.nickname = null;
  this.photoURL = null;
  this.apiCCWebRTCClient = null;
  this.apiCCIMClient = null;
  this.apiCCDataClient = null;
  this.apiCCIDSessionStorage = null;
  this.apiKeySessionStorage = null;
  this.apiCCIdPersistenceTimeout = DEFAULT_ID_PERSISTENCE_DELAY;
  this.channel = null;
  this.recordActivated = params.recordActivated;
  this.sessionId = null;
  this.apiCCPointerSharingClient = null;
  this.apiCCWhiteBoardClient = null;
  this.ccsServer = params.ccsServer;
  this.userData = params.userData;
  this.apiDBActivated = true; //params.ApiDBActivated;  apiDBActivated is now activated by default

  params.ApiDBActivated = true; //apiDBActivated is now activated by default

  this.webRTCPluginActivated = params.webRTCPluginActivated;
  this.token = params.token;
  this.JWTApzToken = null; //JWT Token used to discuss with cloud

  this.JWTApzTokenRefreshTimer = 39600000; //11h - expire is set to 1d on CCS and Cloud

  this.JWTApzTokentimeOutId = -1;
  this.conversationSpace = params.conversationSpace;
  this.tryAudioCallAfterUserMediaError = params.tryAudioCallAfterUserMediaError;
  this.deactivateReloadOnCancel = params.deactivateReloadOnCancel;
  this.connectedUsersList = []; //list of id of connected users

  this.messageTimeOutTable = []; //Table to manage timeout on messages

  this.ccsConnectionRetryNb = params.ccsConnectionRetryNb;
  this.ccsConnectionRetryDelay = params.ccsConnectionRetryDelay;
  this.sequentialMessagesStorage = {};
  this.cloudIsSecured = params.cloudIsSecured;

  if (params.messageTimeOutTimer !== undefined) {
    this.messageTimeOutTimer = params.messageTimeOutTimer;
  } else {
    this.messageTimeOutTimer = 10000; //Default value for timeout on message
  }

  logger.log("messageTimeOutTimer set to : " + this.messageTimeOutTimer);

  if (params.presenceGroup !== undefined) {
    this.presenceGroup = params.presenceGroup;
  } else {
    this.presenceGroup = ["default"];
  }

  if (params.subscribeToPresenceGroup !== undefined) {
    this.subscribeToPresenceGroup = params.subscribeToPresenceGroup;
  } else {
    this.subscribeToPresenceGroup = ["default"];
  }

  this.presenceGroupAddedByApiRTC = [];
  this.subscribeToPresenceGroupAddedByApiRTC = [];

  this.isDeviceWebRTCCompliant = function () {
    return apiCC.isWebRTCCompliant();
  };

  this.isDeviceDTLSCompliant = function () {
    var browserInfos = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.parser.getBrowser(),
        version = parseInt(browserInfos.version, 10);

    if (browserInfos.name === "Chrome" && version < 44) {
      logger.log("isDeviceDTLSCompliant FALSE : Chrome V < 44");
      return false;
    } //            if (browserInfos.name === "Firefox" && version < 36) {
    //                logger.log("isDeviceDTLSCompliant FALSE : Firefox V < 36");
    //                return false;
    //            }


    return true;
  };

  if (typeof this.userData === "undefined" || this.userData === null) {
    this.userData = {};
    this.userData.webRtcCompliant = apiCC.webRTCCompliant;
    this.userData.dtlsCompliant = this.isDeviceDTLSCompliant();
  } else if (typeof this.userData.webRtcCompliant === "undefined" || this.userData.webRtcCompliant === null) {
    this.userData.webRtcCompliant = apiCC.webRTCCompliant;
    this.userData.dtlsCompliant = this.isDeviceDTLSCompliant();
  } else {
    logger.log("userData webRtcCompliant set to :", this.userData.webRtcCompliant);
  }

  this.userData.osName = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.osName;
  this.userData.osVersion = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.osVersion;
  this.userData.browser = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser;
  this.userData.deviceType = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.deviceType;
  this.userData.deviceVendor = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.deviceVendor;
  this.userData.deviceModel = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.deviceModel;
  this.userData.browser_version = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser_version;
  this.userData.browser_major_version = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser_major_version;
  this.userData.apiRTCVersion = apiCC.version;
  this.userData.cpuArchitecture = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.cpuArchitecture;
  this.userData.engineName = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.engineName;
  this.userData.engineVersion = _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.engineVersion;

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.osName === 'Android' && typeof cordova !== 'undefined') {
    this.userData.platform = "Android";
  }

  if (typeof apiRTC_React !== 'undefined') {
    this.userData.react = true;
  }

  this.roomManagerEventHandler = function (msg) {
    logger.debug('roomManagerEventHandler, roomId :' + msg.roomId + ', type :' + msg.type + ', roomType :' + msg.roomType);

    if (msg.roomType === 'whiteBoard') {
      if (apiCC.myApiCCWhiteBoardClient === null || apiCC.myApiCCWhiteBoardClient === undefined) {
        logger.log('No whiteBoard created, leaving msg processing');
        return;
      }

      if (msg.type === "roomCreation") {
        logger.log('whiteBoard : roomCreation');
        apiCC.myApiCCWhiteBoardClient.roomId = msg.roomId; //Increasing paperSheetId for whiteboard creator in order for new users to get existing drawings

        apiCC.myApiCCWhiteBoardClient.paperSheetId++; //This is used to update papersheetId on CCS
        //request most recent whiteboard data
        //apiCC.myApiCCWhiteBoardClient.paperSheetId = 0;

        apiCC.myApiCCWhiteBoardClient.drawingId = 0; //this.roomId = apiCC.myApiCCWhiteBoardClient.roomId;

        apiCC.myApiCCWhiteBoardClient.sendDataToRoom({
          tool: 'void',
          needCatchUp: '*||-1'
        });
      }

      if (msg.type === "roomInvitation") {
        logger.log('whiteBoard : roomInvitation');
        apiCC.myApiCCWhiteBoardClient.roomId = msg.roomId;
      }

      if (msg.type === "roomMessage") {
        apiCC.myApiCCWhiteBoardClient.messageProcessing(msg.data);
      }

      if (msg.type === "roomJoin") {
        logger.log('whiteBoard : roomJoin');
        apiCC.myApiCCWhiteBoardClient.roomJoined = true;
        apiCC.myApiCCWhiteBoardClient.roomId = msg.roomId;
      }
    } else if (msg.roomType === 'pointerSharing') {
      if (apiCC.session.apiCCPointerSharingClient) {
        if (msg.type === "roomJoin") {
          apiCC.session.apiCCPointerSharingClient.processMessageRoomJoin(msg);
        }
      }
    } else if (msg.roomType === 'coBrowsing') {
      if (msg.type === "roomMessage") {
        logger.log('coBrowsing : roomMessage :' + msg);
      }
    } else {
      logger.log('roomManagerEventHandler for msg.roomType :' + msg.roomType);
    }
  };

  this.callback = function (that, fnct) {
    this.closureHandler = function (e) {
      return that[fnct](e);
    };

    return this.closureHandler;
  }; //TODO Fred avoir un tableau de roomManager


  this.roomMgr = new _RoomManager__WEBPACK_IMPORTED_MODULE_1__.RoomManager(this, this.callback(this, 'roomManagerEventHandler'));

  if (params.xhrPolling === true) {
    this.xhrPolling = true;
  } else {
    this.xhrPolling = false;
  }

  this.getSessionStorage = function (sName) {
    var storedObject = sessionStorage.getItem(sName);

    if (storedObject === null) {
      return null;
    }

    try {
      var parsedObject = JSON.parse(storedObject);
      var expiresAt = new Date(parsedObject.expiresAt);
      var now = new Date();

      if (now >= expiresAt) {
        sessionStorage.removeItem(sName);
        return null;
      } else {
        return parsedObject.value;
      }
    } catch (e) {
      logger.error("Something went wrong when parsing JSON from session storage values");
    }
  };

  this.generateApiCCID = function () {
    logger.debug('apiCCId is not defined by user, checking if apiCCId exist in sessionStorage');

    if (typeof apiRTC_React === 'undefined') {
      this.apiCCIDSessionStorage = this.getSessionStorage("apiCCId");
      this.apiKeySessionStorage = this.getSessionStorage("apiKey");
    }

    if (this.apiCCIDSessionStorage !== null) {
      logger.log('apiCCId exist in sessionStorage : ' + this.apiCCIDSessionStorage);

      if (this.apiKeySessionStorage !== null) {
        logger.log('apiKey exist in sessionStorage : ' + this.apiKeySessionStorage);

        if (this.apiKeySessionStorage === this.apiKey) {
          logger.log('apiKey is the same, keeping apiCCId');
          this.apiCCId = this.apiCCIDSessionStorage;
        } else {
          logger.log('apiKey is not the same, generating an  apiCCId');
          this.apiCCId = Math.floor(Math.random() * 1000001).toString();
          logger.log('Creation of new ApiRTC session with Id : ' + this.apiCCId);
        }
      } else {
        this.apiCCId = this.apiCCIDSessionStorage;
      }
    } else {
      logger.log(' No apiCCId found on sessionStorage : generating an apiCCId');
      this.apiCCId = String(100000 + Math.floor(Math.random() * 900000));
      logger.log('Creation of new ApiRTC session with Id : ' + this.apiCCId);
    }
  }; //http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/


  this.getNumericIdFromAlpha = function (e) {
    logger.log('getNumericIdFromAlpha new : ' + e);
    var hash = 0,
        i,
        charVar = null;

    if (e.length === 0) {
      return hash;
    }

    for (i = 0; i < e.length; i++) {
      charVar = e.charCodeAt(i);
      hash = (hash << 5) - hash + charVar;
      hash = hash & hash; // Convert to 32bit integer
    }

    logger.log('getNumericIdFromAlpha returned value: ' + (hash >>> 0));
    return hash >>> 0;
  };

  if (params.appId !== undefined) {
    this.appId = params.appId;
  }

  if (params.siteId !== undefined) {
    this.siteId = params.siteId;
  }

  if (params.apiKey === undefined) {
    //TODO send an Event error
    logger.error('Error : Initialisation parameters: "apikey" for session creation is not defined');
    return null;
  } else {
    logger.log('Session creation with apiKey : ' + params.apiKey);
    logger.log('Session creation with apiCCId : ' + params.apiCCId);
    this.apiKey = params.apiKey;

    if (params.onReady === undefined && typeof apiRTC_React === 'undefined') {
      //TODO send an Event error
      logger.error('Error : Initialisation parameters: "onReady" for session creation is not defined');
      return null;
    } else {
      apiCC.addEventListener("sessionReady", params.onReady);

      if (typeof apiRTC_React === 'undefined') {
        this.sessionId = this.getSessionStorage("sessionId");
      }

      if (params.apiCCId === undefined || params.apiCCId === "" || params.apiCCId === null) {
        this.generateApiCCID();
      } else {
        logger.log('Session creation with apiCCId defined by user : ' + params.apiCCId);
        logger.debug('params.idConversionActivated : ' + params.idConversionActivated);

        if (params.idConversionActivated === undefined || params.idConversionActivated === true) {
          //String ID Convertion is activated
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.is_numeric)(params.apiCCId)) {
            this.apiCCId = params.apiCCId.toString();
          } else {
            logger.log('Converting this Id in a numeric one');
            var convertId = this.getNumericIdFromAlpha(params.apiCCId);
            convertId = convertId + ""; // convertId is a string that contain "convertId"

            logger.log('Numeric Id is : ' + convertId);

            if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.is_numeric)(convertId)) {
              logger.warn('Id has been converted to a numeric one');
              this.apiCCId = convertId.toString();
            } else {
              //TODO send an Event error
              logger.warn('Error : Defined apiCCId :' + params.apiCCId + ' is not numeric. ApiCCID is generated');
              this.generateApiCCID();
            }
          }
        } else {
          logger.log('String id convertion is deactivated');
          this.apiCCId = params.apiCCId.toString();
        }
      }

      if (params.apiCCIdPersistenceTimeout !== null && typeof params.apiCCIdPersistenceTimeout === 'number' && params.apiCCIdPersistenceTimeout >= 0) {
        this.apiCCIdPersistenceTimeout = params.apiCCIdPersistenceTimeout;
      }

      if (this.channel !== null) {
        logger.log("this.channel is defined");
        delete this.channel;
      } //else {
      //    logger.log("this.channel === null");
      //}


      this.channel = new _ApiCC_Channel__WEBPACK_IMPORTED_MODULE_2__.ApiCC_Channel(this);
      this.channel.initialize();
    }
  }

  if (params.nickname !== null && params.nickname !== undefined) {
    logger.log('Nickname is defined :' + params.nickname);
    this.nickname = params.nickname;
  } else {
    logger.log('Nickname is not defined, setting to apiCCId value :' + this.apiCCId);
    this.nickname = this.apiCCId;
  }

  if (params.photoURL !== null && params.photoURL !== undefined) {
    logger.log('photoURL is defined :' + params.photoURL);
    this.photoURL = params.photoURL;
  } else {
    logger.log('photoURL is not defined');
    this.photoURL = null;
  }

  this.reOpenChannel = function (apiCCId, apiKey) {
    logger.info('reOpenChannel'); //Initialiser les valeurs session.apiCCID et session.apiKey

    this.apiCCId = apiCCId.toString();
    this.apiKey = apiKey; //Disconnecting

    if (this.channel.socket !== undefined && this.channel.socket !== null) {
      this.channel.socket.disconnect();
    } //Re-initialization


    this.channel.channelReady = false;
    this.channel.socket = null;
    this.channel.channelId = this.apiCCId; //New connection

    this.channel.initialize(); //RE-Init of webRTCClient.socket

    if (this.apiCCWebRTCClient !== null) {
      if (this.apiCCWebRTCClient.webRTCClient !== null) {
        this.apiCCWebRTCClient.webRTCClient.socket = this.channel.socket;
      }
    }
  };

  this.onChannelOpened = function () {
    logger.debug('ApiCCSession onChannelOpened'); //logger.log('params.ApiDBActivated :' + params.ApiDBActivated);

    if (params.ApiDBActivated !== false && params.ApiDBActivated !== undefined && params.ApiDBActivated !== null) {
      //if (params.ApiDBActivated === true) {
      //apiDB initialisation
      logger.log('apiDB initialisation');
      apiDB.init(this.channel.socket);
    }

    myWebRTC_Event.createSessionReadyEvent(apiCC.session.apiCCId); //SessionReadyEvent when channel is opened
  };
  /**
   * <b>Description</b>
   * <p>This method will create a WebRTC client on your application</p>
   * <b>Associated events :</b>
   * <li>incomingCall</li>
   * <li>callAttempt</li>
   * <li>callEstablished</li>
   * <li>remoteHangup</li>
   * <li>userMediaSuccess</li>
   * <li>userMediaError</li>
   * <li>error</li>
   * @method createWebRTCClient
   * @return {ApiCCWebRTCClient} ApiRTC WebRTCClient object
   **/


  this.createWebRTCClient = function (divElementIds) {
    logger.debug('createWebRTCClient');
    var devicePresentInfo = {};
    this.apiCCWebRTCClient = new apiCC.ApiCCWebRTCClient(this);
    apiCC.session.apiCCWebRTCClient.webRTCClient.setGumConfigWithDevicePresent(); //Adding device information presence in userData / presence

    devicePresentInfo.audioDevicePresent = apiCC.mediaDeviceMgr.audioDevicePresent;
    devicePresentInfo.videoDevicePresent = apiCC.mediaDeviceMgr.videoDevicePresent;
    apiCC.session.setUserData(devicePresentInfo);
    setTimeout(function () {
      myWebRTC_Event.createWebRTCClientCreatedEvent();
    }); // Checking user is already accessing local media.

    var userMediaStreamIds = apiCC.getUserMediaStreamIds(),
        idx = userMediaStreamIds.length;
    logger.debug('listing accessToLocalMedia ' + idx);

    while (--idx >= 0) {
      if (apiCC.getUserMediaStream(userMediaStreamIds[idx]).accessToLocalMedia()) {
        logger.debug('setting accessToLocalMedia to true');
        this.apiCCWebRTCClient.webRTCClient.accessToLocalMedia = true;
        break;
      }
    }

    return this.apiCCWebRTCClient;
  };
  /**
   * Creates a new pointer sharing client if none exists.
   * @return {ApiCCPointerSharingClient}
   */


  this.createPointerSharingClient = function () {
    if (this.apiCCPointerSharingClient === null) {
      this.apiCCPointerSharingClient = new apiCC.ApiCCPointerSharingClient(this);
    }

    return this.apiCCPointerSharingClient;
  };
  /**
   * Stops current pointer sharing client (leaves every room) and destroys it.
   */


  this.closePointerSharingClient = function () {
    if (this.apiCCPointerSharingClient !== null && this.apiCCPointerSharingClient instanceof apiCC.ApiCCPointerSharingClient) {
      this.apiCCPointerSharingClient.stop();
      this.apiCCPointerSharingClient = null;
    }
  };
  /**
   * <b>Description</b>
   * <p>This method will create a WhiteBoard client on your application</p>
   * @method createWhiteBoard
   * @param {String} paperDivId, Div Id of the paper
   * @param {String} userCursorColor cursor color for current user that will be seen for other participants,
   * @param {String} instructionsDivId,
   * @param {String} disconnectionTimer in millisecond (ms) : default value is 30000
   * @return {ApiCCWhiteBoardClient} ApiRTC WhiteBoard Client object
   **/


  this.createWhiteBoard = function (paperDivId, userCursorColor, instructionsDivId, disconnectionTimer) {
    logger.info('createWhiteBoard');
    this.apiCCWhiteBoardClient = apiCC.createWhiteBoard(paperDivId, userCursorColor, instructionsDivId, disconnectionTimer); //this.apiCCWhiteBoardClient is kept for retro Compatibility : apiCCWhiteBoardClient is now at apiCC level

    return this.apiCCWhiteBoardClient;
  };

  this.closeWhiteBoardClient = function (reason) {
    logger.info("closeWhiteBoardClient");
    apiCC.closeWhiteBoardClient(reason);
  };
  /**
   * <b>Description</b>
   * <p>This method will create an IM client on your application</p>
   * <b>Associated events :</b>
   * <li>error</li>
   * @method createIMClient
   * @param {String} conversationElementId, Div name for the instant message conversation
   * @return {ApiCCIMClient} ApiRTC IMClient object
   **/


  this.createIMClient = function (conversationElementId) {
    logger.debug('createIMClient');
    this.apiCCIMClient = new apiCC.ApiCCIMClient(this, conversationElementId);
    return this.apiCCIMClient;
  };
  /**
   * <b>Description</b>
   * <p>This method will create an Data client on your application</p>
   * <b>Associated events :</b>
   * <li>error</li>
   * @method createDataClient
   * @return {ApiCCDataClient} ApiRTC DataClient object
   **/


  this.createDataClient = function () {
    logger.info('createDataClient');
    this.apiCCDataClient = new apiCC.ApiCCDataClient(this);
    return this.apiCCDataClient;
  };

  this.updatingQuery = function (queryTobeUpdated) {
    logger.debug("updatingQuery");
    var queryStringParsed = null,
        stringUserData = null,
        stringUserDataEncoded = null,
        newQuery = null;
    queryStringParsed = (0,_Utils__WEBPACK_IMPORTED_MODULE_4__.parseQueryString)(queryTobeUpdated);

    if (this.userData !== undefined) {
      stringUserData = JSON.stringify(this.userData); //add encodeURIComponent to avoid issues on socket.io parameters if '=' is present

      stringUserDataEncoded = encodeURIComponent(stringUserData);
      queryStringParsed.userData = stringUserDataEncoded; //Rebuilding Query with the updated userData

      newQuery = (0,_Utils__WEBPACK_IMPORTED_MODULE_4__.jsonToQueryString)(queryStringParsed);
      return newQuery;
    }

    return queryTobeUpdated;
  };
  /**
   * <b>Description</b>
   * <p>This method setUserData on server, other presence subscribed users will receive information on an updatePresence event</p>
   * <b>Associated events :</b>
   * <li>error</li>
   * @method setUserData
   * @param {JSON} userData, user Data. UserData format is restricted to key/value {key1 : value1, key2 : value2}
   **/


  this.setUserData = function (userData, forceSendData) {
    logger.debug('setUserData in session :', userData);
    var messageToSend = null,
        msgString = null,
        i,
        list = [],
        actualUserData = this.userData; //Checking if userData is modified before processing
    //Merging the new user Data in session.userData

    if (this.userData !== undefined) {
      this.userData = (0,_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeJSON)(this.userData, userData);
      logger.debug('this.userData :', this.userData);
      logger.debug('actualUserData :', actualUserData);
      logger.debug('forceSendData :', forceSendData);

      if (forceSendData !== true) {
        if (JSON.stringify(this.userData) === JSON.stringify(actualUserData)) {
          logger.debug('userData is not changed, leaving userData processing');
          return;
        }
      }
    } else {
      this.userData = userData;
    }

    messageToSend = {
      type: 'setUserData',
      userData: userData
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    this.channel.socket.emit('setUserData', msgString);
    logger.log('socket.io 1.X : socket.io.opts.query :' + this.channel.socket.io.opts.query); //TODO this update is not working with socket.io 1.X

    this.channel.socket.io.opts.query = this.updatingQuery(this.channel.socket.io.opts.query);
    logger.log('socket.io 1.X : after update : socket.io.opts.query :' + this.channel.socket.io.opts.query); //Updating userdata in connectedUserList

    for (i = 0; i < this.connectedUsersList.length; i += 1) {
      if (this.apiCCId === this.connectedUsersList[i].userId) {
        //Updating UserInfo
        //this.connectedUsersList[i].userData = mergeJSON(this.connectedUsersList[i].userData, userData);
        this.connectedUsersList[i].userData = this.userData;
        list[0] = this.apiCCId;
        myWebRTC_Event.createConnectedUsersListUpdateEvent(this.connectedUsersList[i].group, list, 'userDataUpdate', 'userDataUpdate');
      }
    }
  };

  this.sendPresenceGroupManagementCommand = function (command, group) {
    logger.debug('sendPresenceGroupManagementCommand :' + command + " for group : " + group);
    var messageToSend = null,
        msgString = null,
        i,
        length = group.length;

    if (command === 'unsubscribe') {
      //Unsubscribe, we need to clean connectedUserList for the unsubscribed group as we will no more receive updatePresence
      for (i = 0; i < length; i += 1) {
        this.removeGroupDataFromConnectedUsersList(group[i]);
      }
    }

    if (length === 1 && group[0] === "deactivated") {
      //leave process as group is deactivated
      logger.debug('leaving sendPresenceGroupManagementCommand for group deactivated');
      return;
    }

    messageToSend = {
      type: 'presenceGroupManagement',
      command: command,
      group: group
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    this.channel.socket.emit('presenceGroupManagement', msgString);
  };

  this.sendConversationSpaceCommand = function (command, conversationSpace) {
    logger.debug('sendConversationSpaceCommand :' + command + " for conversationSpace : " + conversationSpace);
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'conversationSpaceManagement',
      command: command,
      conversationSpace: conversationSpace
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    this.channel.socket.emit('conversationSpaceManagement', msgString);
  }; //Function to test if JSON is an array


  function isArray(jsonToTest) {
    if (jsonToTest instanceof Array) {
      logger.log("data instanceof Array");
      return true;
    } else {
      logger.log("data not instanceof Array");
      return false;
    }
  }
  /**
   * <b>Description</b>
   * <p>This method enables to join presence group</p>
   * @method joinPresenceGroup
   * @param JSON Table group, group of presence to join
   * @param JSON options for joinPresenceGroup
   **/


  this.joinPresenceGroup = function (group, options) {
    var _this = this;

    if (!options) {
      options = {};
      options.doneByApiRTC = false;
    }

    logger.debug('joinPresenceGroup :' + group);

    if (isArray(group) === true) {
      this.sendPresenceGroupManagementCommand('join', group);
      group.forEach(function (element) {
        var index = _this.presenceGroupAddedByApiRTC.indexOf(element);

        if (_this.presenceGroup.indexOf(element) === -1) {
          _this.presenceGroup.push(element);

          if (options.doneByApiRTC && index === -1) {
            _this.presenceGroupAddedByApiRTC.push(element);
          }
        } //Check if element need to be removed from presenceGroupAddedByApiRTC


        if (options.doneByApiRTC === false && index !== -1) {
          _this.presenceGroupAddedByApiRTC.splice(index, 1);
        }
      });
    } else {
      logger.log("group parameter value is not correct, need to be a JSON array");
    }

    logger.debug('this.presenceGroup :' + this.presenceGroup);
  };
  /**
   * <b>Description</b>
   * <p>This method enables to leave presence group</p>
   * @method leavePresenceGroup
   * @param JSON Table group, group of presence to leave
   **/


  this.leavePresenceGroup = function (group, options) {
    var _this2 = this;

    if (!options) {
      options = {};
      options.doneByApiRTC = false;
    }

    logger.debug('leavePresenceGroup :' + group);

    if (isArray(group) === true) {
      group.forEach(function (element) {
        var index = _this2.presenceGroupAddedByApiRTC.indexOf(element);

        if (options.doneByApiRTC === false || options.doneByApiRTC === true && index !== -1) {
          var idx = _this2.presenceGroup.indexOf(element);

          if (idx !== -1) {
            _this2.presenceGroup.splice(idx, 1);
          }

          _this2.sendPresenceGroupManagementCommand('leave', element);
        }

        if (index !== -1) {
          _this2.presenceGroupAddedByApiRTC.splice(index, 1);
        }
      });
    } else {
      logger.log("group parameter value is not correct, need to be a JSON array");
    }

    logger.debug('this.presenceGroup :' + this.presenceGroup);
  };
  /**
   * <b>Description</b>
   * <p>This method enables to subscribe to a presence group</p>
   * @method subscribePresenceGroup
   * @param JSON Table group, group of presence to subscribe
   **/


  this.subscribePresenceGroup = function (group, options) {
    var _this3 = this;

    if (!options) {
      options = {};
      options.doneByApiRTC = false;
    }

    logger.debug('subscribePresenceGroup :' + group);

    if (isArray(group) === true) {
      this.sendPresenceGroupManagementCommand('subscribe', group);
      group.forEach(function (element) {
        var index = _this3.subscribeToPresenceGroupAddedByApiRTC.indexOf(element);

        if (_this3.subscribeToPresenceGroup.indexOf(element) === -1) {
          _this3.subscribeToPresenceGroup.push(element);

          if (options.doneByApiRTC && _this3.subscribeToPresenceGroupAddedByApiRTC.indexOf(element) === -1) {
            _this3.subscribeToPresenceGroupAddedByApiRTC.push(element);
          }
        } //Check if element need to be removed from subscribeToPresenceGroupAddedByApiRTC


        if (options.doneByApiRTC === false && index !== -1) {
          _this3.subscribeToPresenceGroupAddedByApiRTC.splice(index, 1);
        }
      });
    } else {
      logger.log("group parameter value is not correct, need to be a JSON array");
    }

    logger.debug('this.subscribeToPresenceGroup :' + this.subscribeToPresenceGroup);
  };
  /**
   * <b>Description</b>
   * <p>This method enables to unsubscribe to a presence group</p>
   * @method unsubscribePresenceGroup
   * @param JSON Table group, group of presence to unsubscribe
   **/


  this.unsubscribePresenceGroup = function (group, options) {
    var _this4 = this;

    if (!options) {
      options = {};
      options.doneByApiRTC = false;
    }

    logger.debug('unsubscribePresenceGroup :' + group);

    if (isArray(group) === true) {
      group.forEach(function (element) {
        var index = _this4.subscribeToPresenceGroupAddedByApiRTC.indexOf(element);

        if (options.doneByApiRTC === false || options.doneByApiRTC === true && index !== -1) {
          var idx = _this4.subscribeToPresenceGroup.indexOf(element);

          if (idx !== -1) {
            _this4.subscribeToPresenceGroup.splice(idx, 1);
          }

          _this4.sendPresenceGroupManagementCommand('unsubscribe', element);
        }

        if (index !== -1) {
          _this4.subscribeToPresenceGroupAddedByApiRTC.splice(index, 1);
        }
      });
    } else {
      logger.log("group parameter value is not correct, need to be a JSON array");
    }

    logger.debug('this.subscribeToPresenceGroup :' + this.subscribeToPresenceGroup);
  };
  /**
   * <b>Description</b>
   * <p>This method enables to join a conversation space</p>
   * @method joinConversationSpace
   * @param String conversationSpace, conversationSpace to join
   **/


  this.joinConversationSpace = function (conversationSpace) {
    logger.info('joinConversationSpace :' + conversationSpace);
    this.sendConversationSpaceCommand('join', conversationSpace);
    this.conversationSpace = conversationSpace;
  };
  /**
   * <b>Description</b>
   * <p>This method enables to leave a conversation space</p>
   * @method leaveConversationSpace
   * @param String conversationSpace, conversationSpace to leave
   **/


  this.leaveConversationSpace = function (conversationSpace) {
    logger.info('leaveConversationSpace :' + conversationSpace);

    if (conversationSpace !== null && conversationSpace !== undefined && this.conversationSpace === conversationSpace) {
      this.sendConversationSpaceCommand('leave', conversationSpace);
      this.conversationSpace = null;
    } else {
      logger.debug('socket is not in the conversationSpace, we request to leave');
    }
  };
  /**
   * <b>Description</b>
   * <p>Subscribes to a Cloud Event.</p>
   * @method subscribeToCloudEvent
   * @param {string} topic
   * @param {object} headers
   */


  this.subscribeToCloudEvent = function (topic, headers) {
    this.sendCloudEventsCommand('subscribe', topic, headers);
  };
  /**
   * <b>Description</b>
   * <p>Cancels the subscription to a Cloud Event.</p>
   * @method unsubscribeToCloudEvent
   * @param {string} topic
   * @param {object} headers
   */


  this.unsubscribeToCloudEvent = function (topic, headers) {
    this.sendCloudEventsCommand('unsubscribe', topic, headers);
  };

  this.sendCloudEventsCommand = function (command, topic, headers) {
    if (!['subscribe', 'unsubscribe'].includes(command)) {
      logger.error('wrong command');
      return;
    }

    if (!topic || typeof topic !== 'string') {
      logger.error('wrong topic format');
      return;
    }

    if (headers) {
      if (_typeof(headers) !== 'object') {
        logger.error('wrong headers format');
        return;
      }

      for (var _i = 0, _Object$values = Object.values(headers); _i < _Object$values.length; _i++) {
        var header = _Object$values[_i];

        if (!header || typeof header !== 'string') {
          logger.error('wrong headers format');
          return;
        }
      } // for

    }

    var messageToSend = {
      type: 'cloudEvents',
      command: command,
      topic: topic
    };

    if (headers) {
      messageToSend.headers = headers;
    }

    var msgString = JSON.stringify(messageToSend);
    logger.log('C->S:', msgString);
    this.channel.socket.emit('cloudEvents', msgString);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to get conversation list of the user from the server</p>
   * <b>Parameters</b>
   * [lastConversationNumber] "optional" - Number - Number of last conversation requested. If undefined, number is 50.
   * <b>Returns</b>
   * <p> conversation Entries have following format :
   * {
   *     convId:Identifier of the conversation,
   *     type: Values can be : call / chat / groupChat,
   *     destId: Identifier of the conversation destination,
   *     destNickname: Nickname of the conversation destination,
   *     isInitiator: Is the client the initiator of the conversation,
   *     status: Values can be : contacting, contacted, answered, ended, missed chat, new (groupChat), ongoing (groupChat)
   *     startTime: start time : number of milliseconds since midnight Jan 1, 1970 ,
   *     answeredTime: answered Time : number of milliseconds since midnight Jan 1, 1970,
   *     endTime: end Time : number of milliseconds since midnight Jan 1, 1970,
   *     reason:Hangup_From_Callee
   * }
   * </p>
   * <p>Table is classified using communication starting date. Last conversation is the first entry in the list</p>
   * <b>Associated events :</b>
   * <li>receiveConversationList</li>
   * @method getConversationList
   **/


  this.getConversationList = function (lastConversationNb) {
    logger.info('getConversationList request');
    var messageToSend = null,
        msgString = null;

    if (lastConversationNb !== undefined) {
      messageToSend = {
        type: 'getConversationList',
        lastConversationNb: lastConversationNb
      };
    } else {
      messageToSend = {
        type: 'getConversationList',
        lastConversationNb: 50
      };
    }

    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    this.channel.socket.emit('getConversationList', msgString);
  };

  this.receiveConversationListAnswer = function (msg) {
    logger.info('receiveConversationListAnswer');
    logger.log('msg.convList.length :' + msg.convList.length);
    var i,
        length = msg.convList.length,
        listInJSON = [],
        entry = null; //Conversion du tableau en tableau de JSON

    for (i = 0; i < length; i += 1) {
      logger.log('i =' + i);
      entry = JSON.parse(msg.convList[i]);
      listInJSON.push(entry);
    }

    myWebRTC_Event.createReceiveConversationListAnswerEvent(listInJSON);
  };
  /**
  <b>Description</b>
  <p>This method enables you to get contact occurrences number from user conversation list</p>
  <b>Parameters</b>
  [lastConversationNumber] "optional" - Number - Number of last conversation requested. If undefined, number is 50.
  <b>Returns</b>
  <p> conversation Entries have following format :
      {
          destId: identifier of the destination,
          nb: number of occurrences
      }
  </p>
  <p>Entries are classified using occurences numbers, first entry is the smallest</p>
  <b>Associated events :</b>
  <li>receiveContactOccurrencesFromConversationList</li>
  @method getContactOccurrencesFromConversationList
  **/


  this.getContactOccurrencesFromConversationList = function (lastConversationNb) {
    logger.info('getContactOccurrencesFromConversationList request');
    var messageToSend = null,
        msgString = null;

    if (lastConversationNb !== undefined) {
      messageToSend = {
        type: 'getContactOccurrencesFromConversationList',
        lastConversationNb: lastConversationNb
      };
    } else {
      messageToSend = {
        type: 'getContactOccurrencesFromConversationList',
        lastConversationNb: 50
      };
    }

    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    this.channel.socket.emit('getContactOccurrencesFromConversationList', msgString);
  };

  this.receiveContactOccurrencesFromConversationListAnswer = function (msg) {
    logger.info('receiveContactOccurrencesFromConversationListAnswer');
    logger.log('msg.contactOccurrencesTable.length :' + msg.contactOccurrencesTable.length);
    myWebRTC_Event.createReceiveContactOccurrencesFromConversationListAnswerEvent(msg.contactOccurrencesTable);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to get conversation detail report</p>
   * <b>Parameters</b>
   * [convId] String - Identifier of the conversation for which we ask the CDR.
   * <b>Returns</b>
   * <p>conversation detail report have following format :
   * {
   *     convId:Identifier of the conversation,
   *     type: Values can be : call / chat / groupChat,
   *     destId: Identifier of the conversation destination,
   *     destNickname: Nickname of the conversation destination,
   *     isInitiator: Is the client the initiator of the conversation,
   *     status: Values can be : contacting, contacted, answered, ended, missed chat, new (groupChat), ongoing (groupChat)
   *     startTime:start time : number of milliseconds since midnight Jan 1, 1970,
   *     answeredTime:answered time : number of milliseconds since midnight Jan 1, 1970,
   *     endTime:end time : number of milliseconds since midnight Jan 1, 1970,
   *     reason:reason of the conversation end
   * }
   * </p>
   * <b>Associated events :</b>
   * <li>receiveConversationDetailReport</li>
   * @method getConversationDetailReport
   **/


  this.getConversationDetailReport = function (convId) {
    logger.info('getConversationDetailReport for convId :' + convId);
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'getConversationDetailReport',
      convId: convId
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    this.channel.socket.emit('getConversationDetailReport', msgString);
  };

  this.receiveConversationDetailReportAnswer = function (msg) {
    logger.info('receiveConversationDetailReportAnswer');
    logger.log('msg.CDR :' + msg.CDR);
    myWebRTC_Event.createReceiveConversationDetailReportAnswerEvent(msg.CDR);
  };

  this.manageConnectedUsersList = function (msgConnectedUsersListWithStatus, state, group, msgConnectedUsersList) {
    logger.debug('manageConnectedUsersList');
    var i,
        j,
        k,
        userAlreadyInList = false,
        length = 0,
        updateEventToSend = false,
        updateReason = 'unset';
    logger.trace('manageConnectedUsersList.length :' + msgConnectedUsersListWithStatus.length);
    logger.trace('this.connectedUsersList.length :' + this.connectedUsersList.length);
    logger.log('state :' + state);
    logger.log('group :' + group); //Adding group in user info

    for (k = 0; k < msgConnectedUsersListWithStatus.length; k += 1) {
      msgConnectedUsersListWithStatus[k].group = group; //logger.log('msgConnectedUsersListWithStatus[k].group :' + msgConnectedUsersListWithStatus[k].group);
    }

    if (state === 'online') {
      logger.log('state : online');

      for (i = 0; i < msgConnectedUsersListWithStatus.length; i += 1) {
        logger.log('msgConnectedUsersListWithStatus  :' + i);
        userAlreadyInList = false; //Reinit userAlreadyInList

        if (this.connectedUsersList.length === 0) {
          logger.log('this.connectedUsersList is empty');
          this.connectedUsersList = msgConnectedUsersListWithStatus;
          logger.log('this.connectedUsersList[0].group :' + this.connectedUsersList[0].group);
          myWebRTC_Event.createConnectedUsersListUpdateEvent(group, msgConnectedUsersList, state, 'newConnectionState');
          break;
        } else {
          for (j = 0; j < this.connectedUsersList.length; j += 1) {
            /*
                                    logger.log('msgConnectedUsersListWithStatus[i].userId :', msgConnectedUsersListWithStatus[i].userId);
                                    logger.log('this.connectedUsersList[j].userId :', this.connectedUsersList[j].userId);
                                    logger.log('msgConnectedUsersListWithStatus[i].group :', msgConnectedUsersListWithStatus[i].group);
                                    logger.log('this.connectedUsersList[j].group :', this.connectedUsersList[j].group);
            */
            updateEventToSend = false;

            if (msgConnectedUsersListWithStatus[i].userId === this.connectedUsersList[j].userId && msgConnectedUsersListWithStatus[i].group === this.connectedUsersList[j].group) {
              userAlreadyInList = true; //Comparing both userData

              if (JSON.stringify(this.connectedUsersList[j].userData) !== JSON.stringify(msgConnectedUsersListWithStatus[i].userData)) {
                logger.log("userData is updated"); //Updating UserInfo

                this.connectedUsersList[j].userData = msgConnectedUsersListWithStatus[i].userData;
                updateEventToSend = true;
                updateReason = 'userDataUpdate';
              } //Comparing both callState


              if (this.connectedUsersList[j].callState !== msgConnectedUsersListWithStatus[i].callState) {
                logger.log("callState is updated"); //Updating UserInfo

                this.connectedUsersList[j].callState = msgConnectedUsersListWithStatus[i].callState;
                updateEventToSend = true;
                updateReason = 'callState';
              }

              if (updateEventToSend === true) {
                myWebRTC_Event.createConnectedUsersListUpdateEvent(group, msgConnectedUsersList, state, updateReason);
              }

              break;
            }
          }
        }

        if (userAlreadyInList === false) {
          logger.log('Adding user in connectedUsersList :' + msgConnectedUsersListWithStatus[i].userId);
          this.connectedUsersList.push(msgConnectedUsersListWithStatus[i]);
          var list = []; //Keep declaration here to avoid loosing context

          list[0] = msgConnectedUsersListWithStatus[i].userId;
          myWebRTC_Event.createConnectedUsersListUpdateEvent(group, list, state, 'newConnectionState');
        }
      }
    } else {
      logger.log('state : offline'); //logger.log('msgConnectedUsersListWithStatus :', msgConnectedUsersListWithStatus);
      //logger.log('this.connectedUsersList :', JSON.stringify(this.connectedUsersList));

      for (i = 0; i < msgConnectedUsersListWithStatus.length; i += 1) {
        logger.log('msgConnectedUsersListWithStatus  :' + i);
        length = this.connectedUsersList.length;

        for (j = 0; j < length; j += 1) {
          if (msgConnectedUsersListWithStatus[i].userId === this.connectedUsersList[j].userId && msgConnectedUsersListWithStatus[i].group === this.connectedUsersList[j].group) {
            //if (msgConnectedUsersListWithStatus[i].userId === this.connectedUsersList[j].userId) {
            logger.log('Removing user in connectedUsersList :' + msgConnectedUsersListWithStatus[i].userId);
            logger.log('... in group :' + msgConnectedUsersListWithStatus[i].group);
            this.connectedUsersList.splice(j, 1);
            myWebRTC_Event.createConnectedUsersListUpdateEvent(group, msgConnectedUsersList, state, 'newConnectionState');
            break;
          }
        }
      } //logger.log('msgConnectedUsersListWithStatus :', msgConnectedUsersListWithStatus);
      //logger.log('this.connectedUsersList :', JSON.stringify(this.connectedUsersList));

    }
  };

  this.removeGroupDataFromConnectedUsersList = function (group) {
    logger.debug('removeGroupDataFromConnectedUsersList for group :', group);
    var length = this.connectedUsersList.length,
        j,
        list = [],
        nbRemovedEntry = 0;
    logger.debug('this.connectedUsersList.length :', this.connectedUsersList.length); //logger.debug('this.connectedUsersList :', this.connectedUsersList);

    for (j = 0; j < length; j += 1) {
      logger.debug('this.connectedUsersList[j].group :', this.connectedUsersList[j - nbRemovedEntry].group);
      logger.debug('group :', group);

      if (this.connectedUsersList[j - nbRemovedEntry].group === group) {
        logger.log('Removing user in connectedUsersList :' + this.connectedUsersList[j - nbRemovedEntry].userId);
        list[0] = this.connectedUsersList[j - nbRemovedEntry].userId;
        this.connectedUsersList.splice(j - nbRemovedEntry, 1);
        nbRemovedEntry += 1;
        myWebRTC_Event.createConnectedUsersListUpdateEvent(group, list, 'offline', 'newConnectionState');
      }
    }
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to get connected Users List</p>
   * <b>Parameters</b>
   * [group] String - Group Identifier for which you want the connected user list. If group is not set, complete users list will be returned
   * <b>Returns</b>
   * <p>connected Users List : Information in list are : userId, callState, userData, group.
   * Note : you can have several entries with the same userId, if user belong to several groups</p>
   * <b>Associated events :</b>
   <li>connectedUsersListUpdate</li>
      * @method getConnectedUsersList
      **/


  this.getConnectedUsersList = function (group) {
    if (group !== undefined) {
      logger.log('getConnectedUsersList for group : ' + group);
    } else {
      logger.log('getConnectedUsersList : complete users list');
    }

    var i,
        filteredConnectedUserList = [];

    if (group === undefined || group === null) {
      //this.displayConnectedUsersList();
      return this.connectedUsersList;
    } else {
      logger.log('filtering list for group : ' + group);

      for (i = 0; i < this.connectedUsersList.length; i += 1) {
        if (this.connectedUsersList[i].group === group) {
          filteredConnectedUserList.push(this.connectedUsersList[i]);
        }
      }

      return filteredConnectedUserList;
    }
  };
  /**
   * <b>Description</b>
   * <p>This method test if one client have a webRtc compliant browser </p>
   * <b>Parameters</b>
   * [destId] String - client userId
   * <b>Returns</b>
   * <p>boolean : true if client browser is webRtc compliant or null if we don't have the information or if userID is not find into connectedUsersList.</p>
   * @method isClientWebRtcCompliant
   **/


  this.isClientWebRtcCompliant = function (destId) {
    var connectedUsersList,
        isCompliant = null,
        userData = null,
        i;

    if (typeof destId !== "undefined") {
      connectedUsersList = this.getConnectedUsersList();

      for (i = 0; i < connectedUsersList.length; i++) {
        if (connectedUsersList[i].userId === destId) {
          userData = connectedUsersList[i].userData;

          if (typeof userData !== "undefined" && userData !== null && typeof userData.webRtcCompliant !== "undefined") {
            isCompliant = userData.webRtcCompliant;
          }
        }
      }
    }

    return isCompliant;
  };
  /**
   * <b>Description</b>
   * <p>This method test if one client have a dtls compliant browser </p>
   * <b>Parameters</b>
   * [destId] String - client userId
   * <b>Returns</b>
   * <p>boolean : true if client browser is dtls compliant or if we don't have the information, false if browser is not compliant.</p>
   * @method isClientDTLSCompliant
   **/


  this.isClientDTLSCompliant = function (destId) {
    var connectedUsersList,
        isCompliant = true,
        userData = null,
        i;

    if (typeof destId !== "undefined") {
      connectedUsersList = this.getConnectedUsersList();

      for (i = 0; i < connectedUsersList.length; i++) {
        if (connectedUsersList[i].userId === destId) {
          userData = connectedUsersList[i].userData;
          logger.log("userData :", userData);

          if (typeof userData !== "undefined" && userData !== null && typeof userData.dtlsCompliant !== "undefined") {
            isCompliant = userData.dtlsCompliant;
          }
        }
      }
    }

    return isCompliant;
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to get connected UserIds List</p>
   * <b>Parameters</b>
   * [group] String - Group Identifier for which you want the connected user list. If group is not set, complete users list will be returned
   * <b>Associated events :</b>
   * <li>connectedUsersListUpdate</li>
   * @method getConnectedUserIdsList
   * @return
   * <p>connected UserIds List : Information in list are : userId, callState, userData</p>
   **/


  this.getConnectedUserIdsList = function (group) {
    logger.info('getConnectedUserIdsList, group :', group);
    var i,
        j,
        filteredConnectedUserList = [],
        userIsFound = false,
        tempCopy = {},
        groupfilteredConnectedUserList = [];

    if (group !== undefined) {
      logger.log('getConnectedUserIdsList for group : ' + group);
    } else {
      logger.log('getConnectedUserIdsList : complete users list');
    } //Filtering with group


    if (group === undefined || group === null) {
      //this.displayConnectedUsersList();
      //return this.connectedUsersList;
      //groupfilteredConnectedUserList = this.connectedUsersList.slice();
      groupfilteredConnectedUserList = JSON.parse(JSON.stringify(this.connectedUsersList));
    } else {
      //logger.log('filtering list for group : ' + group);
      for (i = 0; i < this.connectedUsersList.length; i += 1) {
        if (this.connectedUsersList[i].group === group) {
          groupfilteredConnectedUserList.push(this.connectedUsersList[i]);
        }
      }
    }

    for (i = 0; i < groupfilteredConnectedUserList.length; i += 1) {
      userIsFound = false;

      for (j = 0; j < filteredConnectedUserList.length; j++) {
        if (filteredConnectedUserList[j].userId === groupfilteredConnectedUserList[i].userId) {
          userIsFound = true;
          break;
        }
      }

      if (userIsFound === false) {
        //logger.log('User is not in filtered list, adding ...');
        //Removing group information as user may be in several group
        //Copying info to avoid group info to be deleted from connectedUsersList when deleting group
        tempCopy = {};
        tempCopy.userId = groupfilteredConnectedUserList[i].userId;
        tempCopy.callState = groupfilteredConnectedUserList[i].callState;
        tempCopy.userData = groupfilteredConnectedUserList[i].userData;
        filteredConnectedUserList.push(tempCopy);
      } //else {
      //logger.log('User is already in filtered list');
      //}

    }

    return filteredConnectedUserList;
  };

  this.getGroupsFromConnectedUsersList = function (userId) {
    logger.info('getGroupsFroConnectedUsersList');
    var i,
        groupTable = [],
        entryFound = false;

    for (i = 0; i < this.connectedUsersList.length; i += 1) {
      if (this.connectedUsersList[i].userId === userId) {
        logger.log('Matching Entry found :' + JSON.stringify(this.connectedUsersList[i].group));
        entryFound = true;
        groupTable.push(this.connectedUsersList[i].group);
      }
    }

    if (entryFound === true) {
      return JSON.stringify(groupTable);
    } else {
      return 'User_Not_Found';
    }
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to get user info</p>
   * <b>Associated events :</b>
   * <li>connectedUsersListUpdate</li>
   * @method getConnectedUserInfo
   * @param {String} userId, Id of the user for which you want to get Info
   * @param {String} infoType, Type of user info you want to get : value can be : 'all', 'callState', 'userData', 'groups'
   * @return 'User_Not_Found' if no user are connected with requested userId; JSON with all user info if infoType is 'all'; callState user info if infoType is 'callState'; userData user info if infoType is 'userData', groups list of user if infoType is 'groups'
   **/


  this.getConnectedUserInfo = function (userId, infoType) {
    logger.info('getConnectedUserInfo');
    logger.log('getConnectedUserInfo userId :', userId);
    logger.log('getConnectedUserInfo infoType :', infoType);
    var i,
        result = null,
        newArray = null;

    switch (infoType) {
      case 'all':
        logger.log('all');

        for (i = 0; i < this.connectedUsersList.length; i += 1) {
          //logger.log(JSON.stringify(this.connectedUsersList[i]));
          if (this.connectedUsersList[i].userId === userId) {
            logger.log('Matching Entry found :' + JSON.stringify(this.connectedUsersList[i])); //Getting user group list

            result = this.getGroupsFromConnectedUsersList(userId);
            newArray = JSON.parse(JSON.stringify(this.connectedUsersList[i]));
            newArray.groups = result; //removing group (complete group list is added)

            delete newArray.group;
            return JSON.stringify(newArray);
          }
        }

        break;

      case 'callState':
        logger.log('callState');

        for (i = 0; i < this.connectedUsersList.length; i += 1) {
          if (this.connectedUsersList[i].userId === userId) {
            logger.log('Matching Entry found :' + JSON.stringify(this.connectedUsersList[i].callState));
            return this.connectedUsersList[i].callState;
          }
        }

        break;

      case 'userData':
        logger.log('userData');

        for (i = 0; i < this.connectedUsersList.length; i += 1) {
          if (this.connectedUsersList[i].userId === userId) {
            logger.log('Matching Entry found :' + JSON.stringify(this.connectedUsersList[i].userData));
            return JSON.stringify(this.connectedUsersList[i].userData);
          }
        }

        break;

      case 'groups':
        logger.log('groups');
        result = this.getGroupsFromConnectedUsersList(userId);
        return result;

      default:
        logger.log('infoType not defined switch case : ' + infoType);
        break;
    }

    return 'User_Not_Found';
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to know if an user is connected</p>
   * <b>Associated events :</b>
   * <li>connectedUsersListUpdate</li>
   * @method isConnectedUser
   * @param {String} userId, Id of the user for which you want to know the connection status
   * @return boolean true / false
   **/


  this.isConnectedUser = function (userId) {
    logger.info('isConnectedUser');
    var i,
        isConnected = false;

    for (i = 0; i < this.connectedUsersList.length; i += 1) {
      logger.log(JSON.stringify(this.connectedUsersList[i]));

      if (this.connectedUsersList[i].userId === userId) {
        isConnected = true;
        logger.log('isConnected :' + isConnected);
        return isConnected;
      }
    }

    logger.log('isConnected :' + isConnected);
    return isConnected;
  };

  this.displayConnectedUsersList = function () {
    logger.debug('displayConnectedUsersList');
    var i;

    for (i = 0; i < this.connectedUsersList.length; i += 1) {
      logger.log('User :' + this.connectedUsersList[i].userId + " on group :" + this.connectedUsersList[i].group);
    }
  };

  this.updatePresence = function (message) {
    try {
      logger.debug('updatePresence : ', JSON.stringify(message));
    } catch (e) {
      logger.debug(e); // you can get error here
    }

    logger.log('updatePresence for group :' + message.group);
    this.manageConnectedUsersList(message.connectedUsersListWithStatus, message.state, message.group, message.connectedUsersList); //this.displayConnectedUsersList();

    myWebRTC_Event.createUpdatePresenceEvent(message.connectedUsersList, message.state, message.connectedUsersListWithStatus);
  };

  this.processCloudEventOccurred = function (message) {
    logger.debug('processCloudEventOccurred', message);
    myWebRTC_Event.createCloudEventOccurredEvent(message.event.type, message.event.target);
  };

  this.updateUserStatus = function (message) {
    logger.info('updateUserStatus' + message);
    myWebRTC_Event.createUpdateUserStatusEvent(message);
  };

  this.sendDebugCommand = function (command, apiKey, apiCCId) {
    logger.info('sendDebugCommand :' + command);
    var myWebRTC_Stack = new _WebRTC_Stack__WEBPACK_IMPORTED_MODULE_5__.WebRTC_Stack(this.channel.socket);
    myWebRTC_Stack.sendDebugCommand('getClientSocketsInfo', apiKey, apiCCId);
  };

  this.processSignalingMessage = function (msg) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var callId = null,
        call = null,
        isRemoteStream = false,
        callConfiguration = null,
        streams = null,
        found = false,
        idx = null;

    switch (msg.type) {
      case 'invite':
        if (this.apiCCWebRTCClient) {
          logger.log('this.webRTCPluginActivated =', this.webRTCPluginActivated);

          if ((_BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'IE' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser_major_version < 11) && this.webRTCPluginActivated === true) {
            logger.log("managing call with WebRTC Plugin");
            /*var callId = */

            apiCC.manageWebRTCPlugin(function () {
              logger.log("manageWebRTCPlugin cb on Invite");
              apiCC.session.apiCCWebRTCClient.webRTCClient.processInvite(msg);
            }, function () {
              logger.log("actionOnInstallationNeeded"); //TODO Sending a bye to caller

              logger.log("sending bye to be done");
              var myWebRTC_Stack = new _WebRTC_Stack__WEBPACK_IMPORTED_MODULE_5__.WebRTC_Stack(apiCC.session.channel.socket);
              myWebRTC_Stack.sendBye(msg.callId, msg.calleeId, msg.roomId, msg.callerId, 'WebRTC_Plugin_Installation_needed', msg.data);
            });
          } else {
            logger.log("managing call with browser");
            this.apiCCWebRTCClient.webRTCClient.processInvite(msg);
          }
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case '200OK':
        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.process200OK(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'candidate':
        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.processCandidate(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'bye':
        if (this.apiCCWebRTCClient) {
          logger.log('bye message from:' + msg.clientId + ' for callId : ' + msg.callId);
          this.apiCCWebRTCClient.webRTCClient.onRemoteHangup(msg.callId, msg.clientId, msg.roomId, msg.reason, msg.confId, msg.data);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'update':
        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.processUpdate(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case '200update':
        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.process200Update(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'newConversationCreated':
        if (this.apiCCIMClient) {
          this.apiCCIMClient.newConversationCreated(msg);
        } else {
          logger.warn('IMClient is not created');
        }

        break;

      case 'IMMessage':
        if (this.apiCCIMClient) {
          this.apiCCIMClient.receiveMessage(msg);
        } else {
          logger.warn('IMClient is not created');
        }

        break;

      case 'groupChatCreation':
        if (this.apiCCIMClient) {
          this.apiCCIMClient.groupChatCreation(msg);
        } else {
          logger.warn('IMClient is not created');
        }

        break;

      case 'groupChatInvitation':
        if (this.apiCCIMClient) {
          this.apiCCIMClient.groupChatInvitation(msg);
        } else {
          logger.warn('IMClient is not created');
        }

        break;

      case 'groupChatMemberUpdate':
        if (this.apiCCIMClient) {
          this.apiCCIMClient.groupChatMemberUpdate(msg);
        } else {
          logger.warn('IMClient is not created');
        }

        break;

      case 'addUserInGroupChatAnswer':
        if (this.apiCCIMClient) {
          this.apiCCIMClient.addUserInGroupChatAnswer(msg);
        } else {
          logger.warn('IMClient is not created');
        }

        break;

      case 'groupChatMessage':
        if (this.apiCCIMClient) {
          this.apiCCIMClient.receiveGroupChatMessage(msg);
        } else {
          logger.warn('IMClient is not created');
        }

        break;

      case 'conversationHistoryAnswer':
        if (this.apiCCIMClient) {
          this.apiCCIMClient.receiveConversationHistory(msg);
        } else {
          logger.warn('IMClient is not created');
        }

        break;

      case 'getUserDataAnswer':
        if (this.apiCCIMClient) {
          this.apiCCIMClient.receiveUserDataAnswer(msg);
        } else {
          logger.warn('IMClient is not created');
        }

        break;

      case 'fetchUserDataAnswer':
        if (this.apiCCIMClient) {
          this.apiCCIMClient.receiveFetchUserDataAnswer(msg);
        } else {
          logger.warn('IMClient is not created');
        }

        break;

      case 'dataMessage':
        if (this.apiCCDataClient) {
          this.apiCCDataClient.receiveData(msg);
        } else {
          logger.warn('DataClient is not created');
        }

        break;

      case 'dataAck':
        this.apiCCWebRTCClient.webRTCClient.processDataAck(msg);
        break;

      case 'dataEndAck':
        this.apiCCWebRTCClient.webRTCClient.processDataEndAck(msg);
        break;

      case 'updateVideoQuality':
        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.processUpdateVideoQuality(msg.callId, msg.profile);
        }

        break;

      case 'apiRTCDataMessage':
        if (!options.quiet) {
          logger.debug('apiRTCDataMessage:', msg);
        }

        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isTypeof)(msg.data, 'object')) {
          if (msg.data.type === 'joinSessionAnswer') {
            if (this.apiCCWebRTCClient) {
              // Setting MCU session
              var phonyMsg = {
                roomName: msg.data.roomId
              };

              if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isPropertyTypeof)(msg.data, 'convId', 'string')) {
                phonyMsg.convId = msg.data.convId;
              }

              if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isPropertyTypeof)(msg.data, ['data', 'mode'], 'string')) {
                phonyMsg.data = {
                  mode: msg.data.data.mode
                };
              }

              if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isPropertyTypeof)(msg.data, ['data', 'transition'], 'string') && msg.data.data.transition === 'mesh2janus') {
                this.apiCCWebRTCClient.webRTCClient.MCUClient.changeSessionMode(phonyMsg, 'mesh2janus');
              } else {
                this.apiCCWebRTCClient.webRTCClient.MCUClient.updateSessionAnswer(phonyMsg, {
                  createSession: true
                });
              }
            } else {
              logger.warn('WebRTCClient is not created');
            }
          } else if (msg.data.type === 'slowLink') {
            // a slow link has been detected by CCS.
            if (this.apiCCWebRTCClient) {
              var opts = {};

              if (msg.data.advice) {
                opts.advice = msg.data.advice;
              }

              this.apiCCWebRTCClient.webRTCClient.processSlowLink(msg.data.callId, opts);
            }
          } else if (msg.data.type === 'videoQualityChanged') {
            myWebRTC_Event.createVideoQualityChangedEvent(msg.data.callId, msg.data.roomId, msg.data.hint, msg.data.profile);
          } else if (msg.data.type === 'distantIceError') {
            if (this.apiCCWebRTCClient) {
              this.apiCCWebRTCClient.webRTCClient.processDistantIceError(msg.data);
            }
          } else if (msg.data.type === 'streamTrackChanged') {
            if (this.apiCCWebRTCClient) {
              if (msg.data.hasOwnProperty('mline') && msg.data.hasOwnProperty('muted')) {
                this.apiCCWebRTCClient.webRTCClient.processStreamTrackMuteChanged(msg.data.callId, msg.data.mline, msg.data.muted);
              }
            }
          } else if (msg.data.type === 'streamTrackStatusChanged') {
            if (this.apiCCWebRTCClient) {
              if (msg.data.hasOwnProperty('mline') && msg.data.hasOwnProperty('change') && msg.data.hasOwnProperty(msg.data.change)) {
                this.apiCCWebRTCClient.webRTCClient.processStreamTrackStatusChanged(msg.data.callId, msg.data.mline, msg.data[msg.data.change]);
              }
            }
          } else if (msg.data.type === 'configureEncodings') {
            if (this.apiCCWebRTCClient) {
              this.apiCCWebRTCClient.webRTCClient.processConfigureEncodings(msg.data);
            }
          } else if (msg.data.type === 'activeSpeaker') {
            // a change in the audio amplitude has been detected by CCS CCS.
            if (this.apiCCWebRTCClient) {
              this.apiCCWebRTCClient.webRTCClient.processAudioAmplitude(msg.data, true);
            }
          } else if (msg.data.type === 'stopSpeaking') {
            // a change in the audio amplitude has been detected by CCS CCS.
            if (this.apiCCWebRTCClient) {
              this.apiCCWebRTCClient.webRTCClient.processAudioAmplitude(msg.data, false);
            }
          } else if (msg.data.type === 'updateStream') {
            // CCS asking us to remove the video track of a given call.
            if (this.apiCCWebRTCClient) {
              if (msg.data.callId && msg.data.mline && msg.data.direction) {
                this.apiCCWebRTCClient.webRTCClient.processUpdateStream(msg.data.callId, msg.data.mline, msg.data.direction);
              }
            }
          } else if (msg.data.type === 'startRecording') {
            if (this.apiCCWebRTCClient) {
              // Starting recording.
              if (msg.data.callId === 'COMPOSITE') {
                // Starting composite recording.
                this.apiCCWebRTCClient.webRTCClient.MCUClient.startCompositeRecording(msg.data.mediaType, msg.data.customIdInFilename, msg.data.convId, msg.data.data);
              } else {
                // Starting simple/single recording.
                //found = false;
                for (idx = this.apiCCWebRTCClient.webRTCClient.callsTable.length; --idx >= 0;) {
                  if (this.apiCCWebRTCClient.webRTCClient.callsTable[idx].callId === msg.data.callId) {
                    found = true;
                    break;
                  }
                }

                if (found) {
                  this.apiCCWebRTCClient.webRTCClient.MCUClient.startRecording(msg.data.mediaType, msg.data.customIdInFilename, msg.data.convId, msg.data.callId, msg.data.data);
                } else {
                  logger.info('cannot start recording (call not found)');
                }
              }
            }
          } else if (msg.data.type === 'startStreaming') {
            if (this.apiCCWebRTCClient) {
              // Starting streaming.
              //found = false;
              for (idx = this.apiCCWebRTCClient.webRTCClient.callsTable.length; --idx >= 0;) {
                if (this.apiCCWebRTCClient.webRTCClient.callsTable[idx].callId === msg.data.callId) {
                  found = true;
                  break;
                }
              }

              if (found) {
                this.apiCCWebRTCClient.webRTCClient.MCUClient.startStreaming(msg.data.service, msg.data.server, msg.data.streamKey, msg.data.callId);
              } else {
                logger.info('cannot start streaming (call not found)');
              }
            }
          } else if (msg.data.type === 'startCallStatsMonitoring') {
            if (this.apiCCWebRTCClient) {
              logger.debug('startCallStatsMonitoring', msg.data.callId); // Look for call.

              for (idx = this.apiCCWebRTCClient.webRTCClient.callsTable.length; --idx >= 0;) {
                if (this.apiCCWebRTCClient.webRTCClient.callsTable[idx].callId === msg.data.callId) {
                  call = this.apiCCWebRTCClient.webRTCClient.callsTable[idx];
                  break;
                }
              }

              if (call) {
                // Start call stats monitoring.
                if (['chrome', 'firefox'].indexOf(_Utils__WEBPACK_IMPORTED_MODULE_4__.browserDetails.type) >= 0) {
                  if (!call.csmIntervalId) {
                    call.csmIntervalId = setInterval(call.callback(call, 'csmHandler'), call.csmIntervalMs);
                  } else {
                    logger.debug('call stats monitoring already started');
                  }
                } else {
                  logger.debug('call stats are only supported on chrome and firefox');
                }
              } else {
                logger.debug('no such call');
              }
            }
          } else if (msg.data.type === 'callOrder') {
            logger.log('callOrder received');

            if (this.apiCCWebRTCClient) {
              // Overriding pubConnector
              this.apiCCWebRTCClient.webRTCClient.MCUClient.pubConnector = msg.senderId;
              callId = this.apiCCWebRTCClient.webRTCClient.callWithNumber(msg.data.caller, true, {
                MCUType: 'MCU-Callee',
                confId: msg.data.confId,
                convId: msg.data.convId
              }, callConfiguration); //TODO Modif_Fred : voir pour passer les bon params

              this.apiCCWebRTCClient.webRTCClient.myWebRTC_Event.createIncomingCallEvent(this.clientId, msg.data.caller, msg.data.caller, callId, false, 1, false, 'video', true, 'web', 'media');
            } else {
              logger.warn('WebRTCClient is not created');
            }
          } else if (msg.data.type === 'subscribeOrder') {
            logger.log('subscribeOrder received');

            if (this.apiCCWebRTCClient) {
              // Overriding pubConnector
              this.apiCCWebRTCClient.webRTCClient.MCUClient.pubConnector = msg.senderId; // Marking as subscribeOrder to hide call from upper levels

              msg.data.data.subscribeOrder = true;
              streams = [];
              streams.push(msg.data.stream);
              this.apiCCWebRTCClient.webRTCClient.MCUClient.subscribeToStreams(streams, 'VIDEO', msg.data.data, callConfiguration, {
                noStreamCheck: true
              });
            } else {
              logger.warn('WebRTCClient is not created');
            }
          } else if (msg.data.type === 'distantCallEstablished') {
            if (this.apiCCWebRTCClient) {
              this.apiCCWebRTCClient.webRTCClient.processDistantCallEstablished(msg.data);
            }
          } else if (msg.data.type === 'simulcastFeedChanged') {
            if (this.apiCCWebRTCClient) {
              this.apiCCWebRTCClient.webRTCClient.processSimulcastFeedChanged(msg.data);
            }
          } else {
            logger.log('msg.data.type is not managed :' + msg.data.type);
          }
        } else {
          logger.log('msg.data === undefined');
        }

        break;

      case 'conversationListAnswer':
        this.receiveConversationListAnswer(msg);
        break;

      case 'contactOccurrencesFromConversationListAnswer':
        this.receiveContactOccurrencesFromConversationListAnswer(msg);
        break;

      case 'conversationDetailReport':
        this.receiveConversationDetailReportAnswer(msg);
        break;

      case 'updatePresence':
        logger.log('updatePresence');
        this.updatePresence(msg);
        break;

      case 'updateUserStatus':
        logger.log('updateUserStatus');
        this.updateUserStatus(msg);
        break;

      case 'receiveMCUSessionId':
        logger.log('receiveMCUSessionId');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.MCUClient.receiveSessionId(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'joinSessionAnswer':
        logger.log('joinSessionAnswer');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.MCUClient.joinSessionAnswer(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'updateSessionAnswer':
        logger.log('updateSessionAnswer');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.MCUClient.updateSessionAnswer(msg, {
            updateCalls: true
          });
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'availableStreams':
        if (this.apiCCWebRTCClient) {
          logger.log('message availableStreams received');

          if (this.apiCCWebRTCClient) {
            this.apiCCWebRTCClient.webRTCClient.MCUClient.newAvailableStream(msg.msg, 'regular', function (isRemoteStream, stream, type) {
              myWebRTC_Event.createMCUAvailableStreamEvent([stream], isRemoteStream);
            });
          } else {
            logger.warn('WebRTCClient is not created');
          }
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'availableReplay':
        if (this.apiCCWebRTCClient) {
          logger.log('message availableReplay received');

          if (this.apiCCWebRTCClient) {
            isRemoteStream = this.apiCCWebRTCClient.webRTCClient.MCUClient.newAvailableReplay(msg.msg);
            myWebRTC_Event.createMCUAvailableReplayEvent(msg.msg, isRemoteStream);
          } else {
            logger.warn('WebRTCClient is not created');
          }
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'availableComposite':
        if (this.apiCCWebRTCClient) {
          logger.log('message availableComposite received');

          if (this.apiCCWebRTCClient) {
            isRemoteStream = this.apiCCWebRTCClient.webRTCClient.MCUClient.newAvailableStream(msg.msg, 'composite');
            myWebRTC_Event.createMCUAvailableCompositeEvent(msg.msg, isRemoteStream);
          } else {
            logger.warn('WebRTCClient is not created');
          }
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'onRemoveStream':
        if (this.apiCCWebRTCClient) {
          logger.log('message onRemoveStream received:', msg);

          if (this.apiCCWebRTCClient) {
            this.apiCCWebRTCClient.webRTCClient.MCUClient.removeMCUStream(msg.callId, msg.msg.id, msg.msg.reason);
          } else {
            logger.warn('WebRTCClient is not created');
          }
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'availableStreamsUpdate':
        if (this.apiCCWebRTCClient) {
          logger.log('message availableStreamsUpdate received');

          if (this.apiCCWebRTCClient) {
            this.apiCCWebRTCClient.webRTCClient.MCUClient.updateAvailableStream(msg.msg, 'regular', function (isRemoteStream, stream, type, changes) {
              myWebRTC_Event.createMCUAvailableStreamUpdateEvent([stream], isRemoteStream);
            });
          } else {
            logger.warn('WebRTCClient is not created');
          }
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'checkCallStatus':
        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.processCheckCallStatus(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'MCUSessionInvitation':
        logger.log('MCUSessionInvitation');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.MCUClient.receiveSessionInvitation(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'MCUSessionInvitationToGroupChat':
        logger.log('MCUSessionInvitationToGroupChat');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.MCUClient.receiveSessionInvitation(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'participantEjected':
        logger.log('participantEjected');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.MCUClient.participantEjected(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'recordingStarted':
        logger.log('recordingStarted');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.MCUClient.recordingStarted(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'recordingStopped':
        logger.log('recordingStopped');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.MCUClient.recordingStopped(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'recordingStreamAvailable':
        logger.log('recordingStreamAvailable');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.MCUClient.recordingStreamAvailable(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'streamingStarted':
        logger.log('streamingStarted');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.MCUClient.streamingStarted(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'streamingStopped':
        logger.log('streamingStopped');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.MCUClient.streamingStopped(msg);
        } else {
          logger.warn('WebRTCClient is not created');
        }

        break;

      case 'sessionId':
        logger.log('sessionId :' + msg.sessionId);
        this.sessionId = msg.sessionId;
        break;

      case 'roomCreation':
        logger.log('roomCreation');
        this.roomMgr.roomCreation(msg);
        break;

      case 'roomJoin':
        logger.log('roomJoined');
        this.roomMgr.roomJoin(msg);
        break;

      case 'inviteInRoomStatus':
        logger.log('inviteInRoomStatus');
        this.roomMgr.inviteInRoomStatus(msg);
        break;

      case 'contactListInRoom':
        logger.log('contactListInRoom');
        this.roomMgr.onContactListInRoom(msg);
        break;

      case 'roomInvitation':
        logger.log('roomInvitation');
        this.roomMgr.roomInvitation(msg);
        break;

      case 'roomMessage':
        logger.log('roomMessage');
        this.roomMgr.receiveRoomMessage(msg);
        break;

      case 'roomMemberUpdate':
        logger.log('roomMemberUpdate');
        this.roomMgr.roomMemberUpdate(msg);
        break;

      case 'agentReconnect':
        var callFound = this.apiCCWebRTCClient.webRTCClient.findCallWithCallId(msg.callId);

        if (callFound !== undefined && callFound !== null) {
          callFound.getUserMediaOnCall();
        }

        break;

      case 'sequence':
        logger.log('Sequential message');
        this.handleSequentialMessage(msg);
        break;

      case 'Ack':
        logger.log('Ack received');
        break;

      case 'receipt':
        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.processReceipt(msg);
        }

        break;

      case 'error':
        logger.log('error received');

        if (this.apiCCWebRTCClient) {
          this.apiCCWebRTCClient.webRTCClient.processError(msg);
        } else {
          myWebRTC_Event.createErrorEvent(msg.errorInfo, msg.errorCode, msg.callId, msg.roomId, null, null, msg.convId);
        }

        break;

      case 'enterpriseConfig':
        logger.log('enterpriseConfig received');
        this.handleEnterpriseConfigMessage(msg);
        break;

      case 'AIEMessage':
        logger.log('AIEMessage received');
        this.handleAIEMessage(msg);
        break;

      case 'cloudEventOccurred':
        this.processCloudEventOccurred(msg);
        break;

      default:
        logger.log('Error : No type for this message');
    }
  };

  this.handleSequentialMessage = function (message) {
    if (message.id === undefined || message.packetNum === undefined || message.totalPacketsNum === undefined || message.data === undefined) {
      logger.error('Error : sequential message is inconsistent :', message);
      return;
    }

    logger.debug('Handle sequential message packet ' + message.packetNum + '/' + message.totalPacketsNum, message);
    var storage = [];

    if (_this5.sequentialMessagesStorage[message.id] !== undefined) {
      storage = _this5.sequentialMessagesStorage[message.id];
    }

    storage.push(message);
    _this5.sequentialMessagesStorage[message.id] = storage;

    if (storage.length === message.totalPacketsNum) {
      storage.sort(function (a, b) {
        return a.packetNum - b.packetNum;
      });
      var stringMessage = '';
      storage.forEach(function (elem) {
        stringMessage += elem.data;
      });
      delete _this5.sequentialMessagesStorage[message.id];
      var restoredMessage = null;

      try {
        restoredMessage = JSON.parse(stringMessage);
      } catch (e) {
        logger.error('Error : can\'t parse sequential message JSON :', e);
        return;
      }

      if (!restoredMessage) {
        logger.error('Error : can\'t restore sequential message, it\'s null');
        return;
      }

      logger.debug('Restored sequential message :', stringMessage);

      _this5.processSignalingMessage(restoredMessage);
    }
  };

  this.handleEnterpriseConfigMessage = function (message) {
    logger.debug("handleEnterpriseConfigMessage :", message); // Sentry log activation

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isPropertyTypeof)(message, 'sentry', 'boolean') && message.sentry === true) {
      var protocol = '';

      if (window !== undefined && window.location !== undefined && window.location.protocol !== undefined) {
        if (window.location.protocol !== "https:") {
          protocol = 'http';
        } else {
          protocol = 'https';
        }
      } else {
        protocol = 'https';
      }

      apiCC.loadSentry(apiCC.initApiKey, protocol);
    } // CustomJson parsing


    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isPropertyTypeof)(message, 'customJson', 'string') && message.customJson !== "") {
      try {
        logger.debug("customJson :", message.customJson);
        message.customJson = JSON.parse(message.customJson);
      } catch (error) {
        logger.error(error);
      }
    } // iceServer configuration


    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isPropertyTypeof)(message, 'iceServers', 'string') && message.iceServers !== "") {
      try {
        logger.debug("iceServers :", message.iceServers);
        message.iceServers = JSON.parse(message.iceServers);

        _this5.apiCCWebRTCClient.setPcConfig(message.iceServers);
      } catch (error) {
        logger.error(error);
      }
    } // apiRTC logLevel configuration


    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isPropertyTypeof)(message, 'logLevel', 'string') && message.logLevel !== "" && !isNaN(parseInt(message.logLevel))) {
      apiRTC.setLogLevel(parseInt(message.logLevel));
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isPropertyTypeof)(message, 'ccs', 'object')) {
      _this5.ccsInfo = Object.assign({}, message.ccs);
    }
  };

  this.handleAIEMessage = function (message) {
    logger.debug("handleAIEMessage :", message);

    switch (message.detail) {
      case 'modelLoaded':
        if (apiCC !== undefined && message.userMediaStreamId !== undefined) {
          var userMediaStream = apiCC.getUserMediaStream(message.userMediaStreamId);
          var mediaFilterManager = userMediaStream.mediaFilterManager;

          for (var filter in mediaFilterManager.filters) {
            if (mediaFilterManager.filters[filter] !== undefined && mediaFilterManager.filters[filter].streamAIE !== null) {
              mediaFilterManager.filters[filter].streamAIE.modelLoaded(message);
            }
          }
        }

        break;

      case 'unknownModelName':
        logger.error('Unknown model name :', message.modelName);
        break;

      case 'loadModelError':
        logger.error('Error while loading model :', message.info);
        break;

      default:
        logger.debug('Unknown detail :', message.detail);
        break;
    }
  };

  this.handleJWTApzToken = function (JWTApztoken) {
    logger.debug("handleJWTApzToken :", JWTApztoken);
    _this5.JWTApzToken = JWTApztoken;

    if (_this5.cloudIsSecured === true) {
      logger.debug("Setting JWTApzToken on cloudAPI");
      apiCC.CloudApi.setJWTApzToken(_this5.JWTApzToken);
    } else {
      logger.debug("JWTApzToken is not set on cloudAPI");
    }

    if (_this5.JWTApzTokentimeOutId !== -1) {
      clearTimeout(_this5.JWTApzTokentimeOutId);
    }

    _this5.JWTApzTokentimeOutId = setTimeout(function () {
      //Send a JWTTokenRefreshRequest
      var messageToSend = {
        type: 'JWTTokenRefreshRequest'
      };
      var msgString = JSON.stringify(messageToSend);
      logger.log('C->S: ' + msgString);
      apiCC.session.channel.socket.emit('JWTTokenRefreshRequest', msgString);
    }, _this5.JWTApzTokenRefreshTimer);
  };

  this.fetchUserData = function (msg) {
    logger.debug('fetchUserData');
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'fetchUserData',
      id: msg.id,
      apiKey: msg.apiKey,
      timeout: msg.timeout
    };
    msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    this.channel.socket.emit('fetchUserData', msgString);
  };
};
/**
 * Fired on Channel event
 * @event channelEvent
 * @param {String} e.detail.eventType 'channelEvent'
 * @param {String} e.detail.time Date
 * @param {String} e.detail.channelEvent Event that has occured on the session channel,<br><br>
 * <b>Event can be one of the following :</b><br>
 * onChannelConnecting<br>
 * onChannelDisconnect<br>
 * onChannelConnect_failed<br>
 * onChannelReconnect_failed<br>
 * onChannelReconnect<br>
 * onChannelReconnecting<br>
 * onChannelOpened<br>
 * onChannelError<br>
 * onChannelClosed
**/

/**
 * Fired when WebRTC Client is created
 * @event webRTCClientCreated
 * @param {String} eventType 'webRTCClientCreated'
 * @param {String} time Date
**/

/**
 * Fired to update the presence information of other users : online / offline
 * @event updatePresence
 * @param {String} eventType 'updatePresence'
 * @param {String} time Date
 * @param {List} connectedUsersList List of connected users. Array of connected users Id - DEPRECATED : use connectedUsersListWithStatus instead
 * @param {List} connectedUsersListWithStatus List of connected users with call status. Array of JSON : {"userId":"Id of the user","callState":"user call state."}. CallState can have following values : no_Call, contacting, contacted, answered.
 * @param {String} state status of the users : online or offline
**/

/**
 * Fired when a conversation list answer is received
 * @event receiveConversationList
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'receiveConversationList'
 * @param {String} e.detail.convList List of user's conversation. JSON Table of conversation entries :
 * {
 *     convId:Identifier of the conversation,
 *     type: Values can be : call / chat / groupChat,
 *     destId: Identifier of the conversation destination,
 *     destNickname: Nickname of the conversation destination,
 *     isInitiator: Is the client the initiator of the conversation,
 *     status: Values can be : contacting, contacted, answered, ended, missed chat, new (groupChat), ongoing (groupChat)
 *     startTime:1385673909353,
 *     answeredTime:1385673911863,
 *     endTime:1385673917296,
 *     reason:Hangup_From_Callee
 * }
 * Table is classified using communication starting date. Last conversation is the first entry in the list
**/

/**
 * Fired when a Contact Occurrences From ConversationList answer is received
 * @event receiveContactOccurrencesFromConversationList
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'receiveContactOccurrencesFromConversationList'
 * @param {String} e.detail.occurrencesList List of contacts occurrences. JSON Table of contacts occurrences entries :
 * {
 *     destId: identifier of the destination,
 *     nb: number of occurrences
 * }
 * Entries are classified using occurences numbers, first entry is the smallest
**/

/**
 * Fired when a conversation detail report is received
 * @event receiveConversationDetailReport
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'receiveConversationDetailReport'
 * @param {String} e.detail.CDR JSON describing the conversation detail report :
 * {
 *     convId:Identifier of the conversation,
 *     type: Values can be : call / chat / groupChat,
 *     destId: Identifier of the conversation destination,
 *     destNickname: Nickname of the conversation destination,
 *     isInitiator: Is the client the initiator of the conversation,
 *     status: Values can be : contacting, contacted, answered, ended, missed chat, new (groupChat), ongoing (groupChat)
 *     startTime:1385673909353,
 *     answeredTime:1385673911863,
 *     endTime:1385673917296,
 *     reason:Hangup_From_Callee
 * }
**/

/**
 * Fired when the connectedUserList is updated
 * @event connectedUsersListUpdate
 * @param {String} eventType 'connectedUsersListUpdate'
 * @param {String} time Date
 * @param {String} group updated presence group
 * @param {String} usersList List of updated users identifiers
 * @param {String} status can be online, offline, userDataUpdate
 * @param {String} updateReason newConnectionState, userDataUpdate, callState
**/

/**
 * Fired when the Whiteboard is closed
 * @event closingWhiteBoard
 * @param {String} eventType 'closingWhiteBoard'
 * @param {String} time Date
 * @param {String} roomId Id of the room
 * @param {String} reason closing reason. Value can be USER_DISCONNECTION or NETWORK_DISCONNECTION
**/

/**
 * Fired when a new CloudEvent occurred.
 * @event cloudEventOccurred
 * @param {string} eventType 'cloudEventOccurred'
 * @param {Date} time
 * @param {string} topic
 * @param {object} target
 */




/***/ }),

/***/ "./src/Core/ApiCCUserMediaStream.js":
/*!******************************************!*\
  !*** ./src/Core/ApiCCUserMediaStream.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiCCUserMediaStream": () => (/* binding */ ApiCCUserMediaStream)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* harmony import */ var _MediaFilter_MediaFilterManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MediaFilter/MediaFilterManager */ "./src/Core/MediaFilter/MediaFilterManager.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* globals apiCC, cordova, alert*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ApiCCUserMediaStream');



var myWebRTC_Event = apiCC.myWebRTC_Event; // The maximum amount of time (ms) for a getUserMedia to perform.

var GET_USER_MEDIA_DELAY = 10000; // The local storage key for isUserMediaAccessAllowed/setUserMediaAccessAllowed.

var LOCAL_STORAGE_KEY_GET_USER_MEDIA_ACCESS_ALLOWED = 'getUserMediaAccessAllowed';

var ApiCCUserMediaStream = function ApiCCUserMediaStream() {
  if (Number.MAX_SAFE_INTEGER !== undefined) {
    this.userMediaStreamId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString();
  } else {
    this.userMediaStreamId = Math.floor(Math.random() * 1000001).toString();
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Edge' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 15) {
    this.gum_config = {
      'audio': true,
      'video': true
    };
  } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 49 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50) {
    this.gum_config = {
      'audio': {
        'mandatory': {},
        'optional': []
      },
      'video': {
        'mandatory': {},
        'optional': []
      }
    };
  } else {
    this.gum_config = {
      'audio': {},
      'video': {}
    };
  }

  this.inputs = {};
  this.callbacks = {};
  this.callType = null; // callType: media, audio, screenSharing, videoOnly, data, screenSharingWithAudio, or inactive.

  this.audio = false; // whether an audio track exists.

  this.audioDeviceLabel = null; // the label of the audio device.

  this.audioMuted = false; // mediaStreamTrack.enabled of the audio track

  this.audioSilent = false; // mediaStreamTrack.muted of the audio track

  this.video = false; // whether a video track exists.

  this.videoDeviceLabel = null; // the label of the video device.

  this.videoMuted = false; // mediaStreamTrack.enabled of the video track

  this.videoSilent = false; // mediaStreamTrack.muted of the video track

  this.stream = null;
  this.streamStolen = false; // whether the stream has been stolen, i.e. this one is not the owner.

  this.notifyUserMediaSuccess = true;
  this.notifyUserMediaStop = true;

  if (apiCC.session !== null && apiCC.session !== undefined) {
    this.tryAudioCallAfterUserMediaError = apiCC.session.tryAudioCallAfterUserMediaError;
  } else {
    this.tryAudioCallAfterUserMediaError = false;
  } // Info list of related calls/userMedia:
  // - property [string] callId - callId (for WebRTC_Call) or userMediaId (for WebRTC_UserMedia).
  // - property [boolean] flavor - call or userMedia.
  // - property [boolean] owner - whether related call/userMedia is the owner of this one.


  this.callInfoList = [];
  this.iOSMediaSelectionWorkAroundApplied = false; //whether we have tried getUserMedia with iOS MediaSelection workaround

  this.getUserMediaTimeoutId = null;

  if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 72 && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version <= 73) {
    this.displayMediaStreamConstraints = {
      video: true,
      audio: false
    };
  } else {
    this.displayMediaStreamConstraints = {
      video: true,
      audio: true
    };
  }

  this.forceExtensionOnChrome = false;
  this.filters = null;
  this.mediaFilterManager = null;
  this.videoSettings = false;
  /**
   * Returns the single video track.
   * @return {MediaStreamTrack|null} MediaStreamTrack on success, null otherwise.
   */

  this.getVideoTrack = function () {
    if (!this.stream || typeof this.stream.getVideoTracks !== 'function') {
      return null;
    }

    var tracks = this.stream.getVideoTracks();

    if (!tracks || tracks.length !== 1) {
      return null;
    }

    return tracks[0];
  };

  this.release = function () {
    var idx = 0,
        tracks = null,
        callId = null,
        owner = null;
    logger.debug("[ApiCCUserMediaStream] release; userMediaStreamId: " + this.userMediaStreamId);

    if (this.mediaFilterManager !== null) {
      this.mediaFilterManager.release();
      this.mediaFilterManager = null;
    } //release audioNode context if exist


    apiCC.audioProcessor.stopAudioNodeCtx(this.nodeCtx);

    if (this.stream !== null) {
      if (this.streamStolen !== true) {
        // This one is the stream owner.
        if (typeof cordova !== "undefined" && typeof cordova.plugins !== "undefined" && typeof cordova.plugins.iosrtc !== "undefined") {
          if (cordova !== undefined && cordova.plugins !== undefined && cordova.plugins.iosrtc !== undefined) {
            logger.debug("[ApiCCUserMediaStream] release on iosrtc cordova");
            this.stream.onended = null; //NO stream stop as not supported on iosRTC
          }
        } else {
          if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 45 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 44 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Opera" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 34 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chromium" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 44 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome WebView" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 45) {
            this.stream.onended = null;
            this.stream.stop();
          } else {
            this.stream.onended = null;
            tracks = this.stream.getTracks();

            for (idx = tracks.length; --idx >= 0;) {
              tracks[idx].onended = null;
              tracks[idx].stop();
            }
          }
        }
      }

      this.stream = null;
      this.streamStolen = false;

      if (this.notifyUserMediaStop === true) {
        owner = this.getOwnerCallInfo();

        if (owner !== null) {
          callId = owner.callId;
        }

        myWebRTC_Event.createUserMediaStopEvent(callId, this.callType, this.userMediaStreamId);
      }

      this.callbacks.release(this);
    }
  };

  this.getUserMedia = function () {
    var _this = this;

    var removeEntry = function removeEntry(userMediaStreamId) {
      var idx = apiCC.userMediaStreamTable.length;

      while (--idx >= 0) {
        if (apiCC.userMediaStreamTable[idx].userMediaStreamId === userMediaStreamId) {
          apiCC.userMediaStreamTable.splice(idx, 1);
          break;
        }
      }
    };

    logger.debug("[ApiCCUserMediaStream] getUserMedia; userMediaStreamId: " + this.userMediaStreamId);

    if (this.stream === null) {
      try {
        if (this.callType === 'media') {
          this.gum_config = apiCC.setAudioSourceIdInConstraint(this.inputs.audioSourceId, this.gum_config);
          this.gum_config = apiCC.setVideoSourceIdInConstraint(this.inputs.videoSourceId, this.gum_config);
          this.gum_config = apiCC.setVideoFacingModeInConstraint(this.inputs.facingMode, this.gum_config);
        } else if (this.callType === 'audio') {
          this.gum_config = apiCC.setAudioSourceIdInConstraint(this.inputs.audioSourceId, this.gum_config);
          this.gum_config.video = false;
        } else if (this.callType === 'videoOnly') {
          this.gum_config.audio = false;
          this.gum_config = apiCC.setVideoSourceIdInConstraint(this.inputs.videoSourceId, this.gum_config);
          this.gum_config = apiCC.setVideoFacingModeInConstraint(this.inputs.facingMode, this.gum_config);
        } else {
          removeEntry(this.userMediaStreamId);
          setTimeout(this.callbacks.failure.bind(this, this, 'wrong type'));
          return;
        }

        apiCC.checkConstraintDependingOnDevice(this.gum_config);

        if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version > 8.0) {
          apiCC.getUserMediaWithCB(this.gum_config, this.callback(this, 'onUserMediaSuccess'), this.callback(this, 'onUserMediaError'));
        } else {
          if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome') {
            if (this.isUserMediaAccessAllowed() === true) {
              // Set a timeout to handle a no response situation.
              this.getUserMediaTimeoutId = setTimeout(function () {
                _this.onUserMediaError('timeout');
              }, GET_USER_MEDIA_DELAY);
            }
          }

          apiCC.getUserMedia(this.gum_config).then(this.callback(this, 'onUserMediaSuccess'))["catch"](this.callback(this, 'onUserMediaError'));
        }
      } catch (e) {
        logger.error('getUserMedia() failed. Is this a WebRTC capable browser?');
        logger.log('getUserMedia failed with exception: ' + e.message);
      }
    }
  };

  this.listenForMuteEvents = function () {
    var _this2 = this;

    var registerMuteEvents = function registerMuteEvents(track) {
      var audiotrackMutedTimeoutId = null;
      var videotrackMutedTimeoutId = null;

      track.onmute = function (e) {
        logger.debug('mute event :', track);

        if (track.kind === "audio" && audiotrackMutedTimeoutId === null) {
          audiotrackMutedTimeoutId = setTimeout(function () {
            //logger.error(track.kind + ' mute event timeout reached'); 
            _this2.audioSilent = true;
            audiotrackMutedTimeoutId = null;

            _this2.notifyMLineMuted(track.kind, true, "muted");
          }, 3 * 840); //logger.error('mute event audio audiotrackMutedTimeoutId :', audiotrackMutedTimeoutId);
        } else if (track.kind === "video" && videotrackMutedTimeoutId === null) {
          videotrackMutedTimeoutId = setTimeout(function () {
            //logger.error(track.kind + ' mute event timeout reached'); 
            _this2.videoSilent = true;
            videotrackMutedTimeoutId = null;

            _this2.notifyMLineMuted(track.kind, true, "muted");
          }, 3 * 840); //logger.error('mute event video videotrackMutedTimeoutId :', videotrackMutedTimeoutId);
        }
      };

      track.onunmute = function (e) {
        logger.debug(track.kind + ' unmute event');

        if (track.kind === "audio" && audiotrackMutedTimeoutId !== null) {
          //logger.error('clearTimeout audiotrackMutedTimeoutId :', audiotrackMutedTimeoutId);
          clearTimeout(audiotrackMutedTimeoutId);
          audiotrackMutedTimeoutId = null;
        } else if (track.kind === "video" && videotrackMutedTimeoutId !== null) {
          //logger.error('clearTimeout videotrackMutedTimeoutId :', videotrackMutedTimeoutId);
          clearTimeout(videotrackMutedTimeoutId);
          videotrackMutedTimeoutId = null;
        } else {
          if (track.kind === "audio") {
            _this2.audioSilent = false;
          } else if (track.kind === "video") {
            _this2.videoSilent = false;
          }

          _this2.notifyMLineMuted(track.kind, false, "muted");
        }
      };

      track.onended = function (e) {
        logger.debug(track.kind + ' ended event');

        if (track.kind === "audio" && audiotrackMutedTimeoutId !== null) {
          clearTimeout(audiotrackMutedTimeoutId);
          audiotrackMutedTimeoutId = null;
        } else if (track.kind === "video") {
          if (videotrackMutedTimeoutId !== null) {
            clearTimeout(videotrackMutedTimeoutId);
            videotrackMutedTimeoutId = null;
          }

          if (_this2.callType === 'screenSharing' || _this2.callType === 'screenSharingWithAudio') {
            _this2.stopScreenSharing();
          }
        }
      };
    };

    var _iterator = _createForOfIteratorHelper(this.stream.getVideoTracks()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var videoTrack = _step.value;
        registerMuteEvents(videoTrack);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var _iterator2 = _createForOfIteratorHelper(this.stream.getAudioTracks()),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var audioTrack = _step2.value;
        registerMuteEvents(audioTrack);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    if (this.callType === 'screenSharing' || this.callType === 'screenSharingWithAudio') {
      this.stream.onended = this.callback(this, 'stopScreenSharing');
    }
  };

  this.onUserMediaSuccess = function (stream) {
    var _this3 = this;

    this.applyFiltersIfNeeded(stream).then(function (stream) {
      var callId = null,
          remoteId = null,
          restarted = false,
          owner = _this3.getOwnerCallInfo(),
          call = _this3.getCall(owner);

      logger.info('[ApiCCUserMediaStream] onUserMediaSuccess; userMediaStreamId: ' + _this3.userMediaStreamId);

      if (_this3.getUserMediaTimeoutId !== null) {
        clearTimeout(_this3.getUserMediaTimeoutId);
        _this3.getUserMediaTimeoutId = null;
      }

      if (call) {
        logger.debug('call exist');
        remoteId = call.callee ? call.callerId : call.calleeId;
        restarted = call.restarted;
      }

      _this3.updateMediaProperties(stream);

      _this3.stream = stream;

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome') {
        // Persists that user media access is allowed.
        _this3.setUserMediaAccessAllowed(true);
      }

      if (_this3.notifyUserMediaSuccess === true) {
        if (owner) {
          callId = owner.callId;
        }

        myWebRTC_Event.createUserMediaSuccessEvent(callId !== null, _this3.audio, _this3.audioDeviceLabel, _this3.video, _this3.videoDeviceLabel, _this3.callType, callId, stream, remoteId, restarted, _this3.userMediaStreamId);
      }

      _this3.listenForMuteEvents();

      logger.debug('Starting a new getMediaDevices after userMediaSuccess');
      apiCC.mediaDeviceMgr.getMediaDevices('updatedAfterGetUserMediaSuccess');

      _this3.callbacks.success(_this3);
    });
  };

  this.updateMediaProperties = function (stream) {
    var audioIsAvailable = false,
        audioDeviceLabel = 'Unknown',
        audioDeviceId = 'Unknown',
        videoIsAvailable = false,
        videoDeviceLabel = 'Unknown';

    if (stream.getAudioTracks().length > 0) {
      audioIsAvailable = true;

      if (stream.getAudioTracks()[0].label) {
        audioDeviceLabel = stream.getAudioTracks()[0].label;
        audioDeviceId = stream.getAudioTracks()[0].id;
        apiCC.audioProcessor.listenToAudio(stream, this);
      }

      if (stream.getAudioTracks()[0].enabled === false) {
        this.audioMuted = true;
      }

      if (stream.getAudioTracks()[0].muted === false) {
        this.audioSilent = true;
      }
    }

    if (stream.getVideoTracks().length > 0) {
      videoIsAvailable = true;

      if (stream.getVideoTracks()[0].label) {
        videoDeviceLabel = stream.getVideoTracks()[0].label;
      }

      if (stream.getVideoTracks()[0].enabled === false) {
        this.videoMuted = true;
      }

      if (stream.getVideoTracks()[0].muted === false) {
        this.videoSilent = true;
      }
    }

    this.audio = audioIsAvailable;
    this.audioDeviceLabel = audioDeviceLabel;
    this.audioDeviceId = audioDeviceId;
    this.video = videoIsAvailable;
    this.videoDeviceLabel = videoDeviceLabel;
  };

  this.manageFailure = function (error) {
    var errorJson = {};

    if (_typeof(error) === 'object') {
      errorJson.message = error.message;
      errorJson.code = error.code;
      errorJson.name = error.name;
    } else {
      errorJson = error;
    }

    this.callbacks.failure(this, errorJson);
  };

  this.onUserMediaError = function (error) {
    var removeEntry = function removeEntry(userMediaStreamId) {
      var idx = apiCC.userMediaStreamTable.length;

      while (--idx >= 0) {
        if (apiCC.userMediaStreamTable[idx].userMediaStreamId === userMediaStreamId) {
          apiCC.userMediaStreamTable.splice(idx, 1);
          break;
        }
      }
    };

    var callId = null,
        owner = this.getOwnerCallInfo();
    logger.info("[ApiCCUserMediaStream] onUserMediaError; userMediaStreamId: " + this.userMediaStreamId + ", error: " + error);

    if (this.getUserMediaTimeoutId !== null) {
      if (error !== 'timeout') {
        clearTimeout(this.getUserMediaTimeoutId);
      }

      this.getUserMediaTimeoutId = null;
    }

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.applicationType !== 'electron' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version > 47) {
      if (window.location.protocol !== "https:") {
        logger.error("HTTPS is now mandatory to use getUserMedia()");
      }
    }

    if (owner !== null) {
      callId = owner.callId;
    }

    if (this.callType === 'media' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "iOS" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Mobile Safari' && this.iOSMediaSelectionWorkAroundApplied === false) {//We will try iOSWorkAround, no need to fire userMediaError event
    } else {
      myWebRTC_Event.createUserMediaErrorEvent(callId !== null, this.callType, error, this.userMediaStreamId, callId, this.tryAudioCallAfterUserMediaError, this.gum_config);
    }

    if (error !== 'timeout' && this.callType === 'media') {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "iOS" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Mobile Safari' && this.iOSMediaSelectionWorkAroundApplied === false) {
        //PATCH for deviceId change on iOS / Safari Mobile : the only fix value is label ... See https://apizee.atlassian.net/browse/WEBCONF-111
        logger.warn("try mediaDevice selection workaround on iOS / Mobile Safari - after MediaError");
        this.iOSMediaSelectionWorkAroundApplied = true;
        this.gum_config.video = {};
        var deviceLabel = apiCC.getMediaDeviceLabelFromDeviceid(this.inputs.videoSourceId);
        logger.log('getMediaDeviceLabelFromDeviceid :', deviceLabel);

        if (deviceLabel === "Camra arrire" || deviceLabel === "Back Camera") {
          logger.log('Setting FacingMode to environment :', deviceLabel);
          this.gum_config = apiCC.setVideoFacingModeInConstraint('environment', this.gum_config);
        } else {
          logger.log('Setting FacingMode to user :', deviceLabel);
          this.gum_config = apiCC.setVideoFacingModeInConstraint('user', this.gum_config);
        }

        this.inputs.videoSourceId = null; //this.gum_config.video = false;

        this.getUserMedia();
      } else if (this.tryAudioCallAfterUserMediaError === true) {
        logger.warn("try AudioCall after UserMediaError is activated");
        this.tryAudioCallAfterUserMediaError = false;

        if (this.gum_config.video !== false) {
          logger.debug("[ApiCCUserMediaStream] Trying to getUserMedia with audioOnly");
          this.inputs.videoSourceId = null;
          this.gum_config.video = false;
          this.getUserMedia();
        } else {
          removeEntry(this.userMediaStreamId);
          this.manageFailure(error);
        }
      } else {
        removeEntry(this.userMediaStreamId);
        this.manageFailure(error);
      }
    } else {
      removeEntry(this.userMediaStreamId);
      this.manageFailure(error);
    }
  };

  this.getDisplayMediaProcess = function () {
    var _this4 = this;

    logger.debug('using getDisplayMedia with browser :', _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser);
    logger.debug('displayMediaStreamConstraints :', this.displayMediaStreamConstraints);

    if (_typeof(this.displayMediaStreamConstraints) !== 'object' || Array.isArray(this.displayMediaStreamConstraints) === true) {
      logger.warn('Defined displayMediaStreamConstraints format is not correct, reinitialization ...');

      if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 72 && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version <= 73) {
        this.displayMediaStreamConstraints = {
          video: true,
          audio: false
        };
      } else {
        this.displayMediaStreamConstraints = {
          video: true,
          audio: true
        };
      }

      logger.debug('displayMediaStreamConstraints :', this.displayMediaStreamConstraints);
    }

    if (navigator.getDisplayMedia) {
      logger.debug('navigator.getDisplayMedia defined');
      navigator.getDisplayMedia(this.displayMediaStreamConstraints).then(function (stream) {
        // do something with the stream
        logger.debug('getDisplayMedia stream available');

        _this4.onUserMediaSuccess(stream);
      })["catch"](function (e) {
        // handle any errors
        logger.debug('getDisplayMedia error :', e);

        _this4.onUserMediaError(e);
      });
    } else if (navigator.mediaDevices.getDisplayMedia) {
      logger.debug('navigator.mediaDevices.getDisplayMedia defined');
      navigator.mediaDevices.getDisplayMedia(this.displayMediaStreamConstraints).then(function (stream) {
        // do something with the stream
        logger.debug('getDisplayMedia stream available');

        _this4.onUserMediaSuccess(stream);
      })["catch"](function (e) {
        // handle any errors
        logger.debug('getDisplayMedia error :', e);

        _this4.onUserMediaError(e);
      });
    } else {
      logger.debug('getDisplayMedia not available');
      myWebRTC_Event.createDesktopCaptureEvent("Browser_Not_Compatible");
    }
  };

  this.getScreenMedia = function () {
    logger.debug("[ApiCCUserMediaStream] getScreenMedia; userMediaStreamId: " + this.userMediaStreamId);

    var moveUserMediaEntryInWaitingScreen = function moveUserMediaEntryInWaitingScreen(userMediaStreamId) {
      logger.debug("[ApiCCUserMediaStream] moveUserMediaEntryInWaitingScreen: " + userMediaStreamId); //Moving screenSharing MediaEntry from userMediaStreamTable during extension installation

      var idx = apiCC.userMediaStreamTable.length;

      while (--idx >= 0) {
        if (apiCC.userMediaStreamTable[idx].userMediaStreamId === userMediaStreamId) {
          apiCC.waitingShareScreenUserMediaStream = apiCC.userMediaStreamTable.splice(idx, 1);
          break;
        }
      }
    };

    if (this.stream === null) {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 52) {
        if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome') {
          logger.log('shareScreen on Chrome');

          if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 72 && this.forceExtensionOnChrome === false) {
            this.getDisplayMediaProcess();
          } else {
            logger.debug('this.captureSourceType :', this.captureSourceType);

            if (apiCC.apiRTCExtensionInstalled === false) {
              apiCC.waitingShareScreenUserMediaStreamId = this.userMediaStreamId;
              moveUserMediaEntryInWaitingScreen(this.userMediaStreamId);
              apiCC.manageNotInstalledExtension('getScreenMedia', 'getScreenMedia', this.captureSourceType);
              return;
            }

            if (this.captureSourceType === undefined || this.captureSourceType === null) {
              this.captureSourceType = ['screen', 'window', 'tab'];
            }

            if (Array.isArray(this.captureSourceType) === false) {
              logger.warn('Defined captureSourceType format is not correct, reinitialization ...');
              this.captureSourceType = ['screen', 'window', 'tab'];
              logger.debug('this.captureSourceType :', this.captureSourceType);
            }

            window.postMessage({
              // NOSONAR
              'command': 'getDesktopId',
              'callNumber': this.userMediaStreamId,
              'remoteId': 'getScreenMedia',
              'captureSourceType': this.captureSourceType,
              'browser_major_version': _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version
            }, '*');
          }
        } else {
          logger.log('shareScreen on Firefox');

          if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 67) {
            this.getDisplayMediaProcess();
          } else {
            if (this.captureSourceType === undefined || this.captureSourceType === null) {
              this.captureSourceType = 'screen';
            }

            if (typeof this.captureSourceType === 'string') {
              logger.warn('Defined captureSourceType format is not correct, reinitialization ...');
              this.captureSourceType = 'screen';
              logger.debug('this.captureSourceType :', this.captureSourceType);
            }

            this.registerScreenMedia(this.captureSourceType);
          }
        }
      } else {
        //Usage of getDisplayMedia API
        this.getDisplayMediaProcess();
      }
    }
  };

  this.registerScreenMedia = function (captureSourceType, desktopId) {
    var removeEntry = function removeEntry(userMediaStreamId) {
      var idx = apiCC.userMediaStreamTable.length;

      while (--idx >= 0) {
        if (apiCC.userMediaStreamTable[idx].userMediaStreamId === userMediaStreamId) {
          apiCC.userMediaStreamTable.splice(idx, 1);
          break;
        }
      }
    };

    var localUserMediaConstraint = null,
        owner = this.getOwnerCallInfo(),
        call = this.getCall(owner),
        remoteId = null;
    logger.debug("[ApiCCUserMediaStream] registerScreenMedia; userMediaStreamId: " + this.userMediaStreamId);

    if (desktopId === 'mediaError') {
      if (call !== null) {
        remoteId = call.callee === true ? call.callerId : call.calleeId;

        if (call.callType === "screenSharing" || call.callType === "screenSharingWithAudio") {
          apiCC.session.apiCCWebRTCClient.webRTCClient.removeCallFromTableWithCallIdandRemoteId(call.callId, remoteId, 'Media_Error');
        } else {
          logger.log("switch video / screen : call is not removed");
        }

        if (window.location.protocol !== "https:") {
          logger.log("Please connect to your web page using 'HTTPS'. This is mandatory for desktop capture");
        }

        myWebRTC_Event.createDesktopCaptureEvent("UserMediaError", call.callId, remoteId);
      } else {
        logger.log("Call not found on message EventListener");
        myWebRTC_Event.createDesktopCaptureEvent("UserMediaError");
      }

      removeEntry(this.userMediaStreamId);
      this.callbacks.failure(this, 'UserMediaError');
    } else {
      try {
        if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome") {
          logger.log("desktopId: " + desktopId);
          localUserMediaConstraint = {
            video: {
              mandatory: {
                chromeMediaSource: "desktop",
                chromeMediaSourceId: desktopId
              }
            }
          };
        } else {
          //Browser is Firefox
          logger.log("captureSourceType: " + captureSourceType);

          if (captureSourceType !== 'screen' && captureSourceType !== 'window' && captureSourceType !== 'application') {
            logger.error("captureSourceType value is not correct");
            return;
          }

          localUserMediaConstraint = {
            video: {
              mediaSource: captureSourceType
            }
          };
        }

        if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version > 8.0) {
          apiCC.getUserMediaWithCB(localUserMediaConstraint, this.callback(this, 'onUserMediaSuccess'), this.callback(this, 'onUserMediaError'));
        } else {
          apiCC.getUserMedia(localUserMediaConstraint).then(this.callback(this, 'onUserMediaSuccess'))["catch"](this.callback(this, 'onUserMediaError'));
        }
      } catch (e) {
        logger.error('getUserMedia() failed. Is this a WebRTC capable browser?');
        logger.log('getUserMedia failed with exception: ' + e.message);
      }
    }
  };

  this.stopScreenSharing = function () {
    logger.debug("[ApiCCUserMediaStream] stopScreenSharing; userMediaStreamId: " + this.userMediaStreamId);
    var blank = true;

    if (apiCC.session && apiCC.session.apiCCWebRTCClient && apiCC.session.apiCCWebRTCClient.webRTCClient) {
      for (var idx = this.callInfoList.length; --idx >= 0;) {
        if (this.callInfoList[idx].owner === true) {
          blank = false;
        }

        apiCC.session.apiCCWebRTCClient.webRTCClient.onHangup(this.callInfoList[idx].callId);
      }
    }

    if (blank === true) {
      this.release();
    }
  };
  /*
   * Returns the call/userMedia of a given call info.
   *
   * @param {object} callInfo - Call info.
   *
   * @return {WebRTC_Call|WebRTC_UserMedia} Call/userMedia on success, null otherwise.
   */


  this.getCall = function (callInfo) {
    var ret = null;

    if (callInfo && apiCC.session && apiCC.session.apiCCWebRTCClient && apiCC.session.apiCCWebRTCClient.webRTCClient) {
      if (callInfo.flavor === 'call') {
        ret = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallWithCallId(callInfo.callId);
      } else if (callInfo.flavor === 'userMedia') {
        ret = apiCC.session.apiCCWebRTCClient.webRTCClient.findUserMediaById(callInfo.callId);
      }
    }

    return ret;
  };
  /*
   * Returns the call info of the owner of this one (if any).
   *
   * @return {object} Call info if owner found, null otherwise.
   */


  this.getOwnerCallInfo = function () {
    var idx = this.callInfoList.length;

    while (--idx >= 0) {
      if (this.callInfoList[idx].owner === true) {
        return this.callInfoList[idx];
      }
    }

    return null;
  };
  /*
   * Returns the call info for a given call id.
   *
   * @param {string} callId - Call id.
   *
   * @return {object} Call info if found, null otherwise.
   */


  this.getCallInfo = function (callId) {
    var idx = this.callInfoList.length;

    while (--idx >= 0) {
      if (this.callInfoList[idx].callId === callId) {
        return this.callInfoList[idx];
      }
    }

    return null;
  };
  /*
   * Tests whether a given call id exists in this one.
   *
   * @param {string} callId - Call id.
   *
   * @return {boolean} true if found, false otherwise.
   */


  this.containsCallInfo = function (callId) {
    var ret = false,
        idx = this.callInfoList.length;

    while (--idx >= 0) {
      if (this.callInfoList[idx].callId === callId) {
        ret = true;
        break;
      }
    }

    return ret;
  };
  /*
   * Adds a given call id into this one.
   *
   * @param {string} callId - Call id.
   * @param {string} flavor - call/userMedia (default is call).
   * @param {boolean} owner - Whether call is owner of this one (default is false).
   *
   * @return {boolean} true if not found and added, false otherwise.
   */


  this.addCallInfo = function (callId, flavor, owner) {
    if (callId !== null && typeof callId === 'string') {
      if (flavor !== 'call' && flavor !== 'userMedia') {
        flavor = 'call';
      }

      if (owner === null || typeof owner !== 'boolean') {
        owner = false;
      }

      if (!this.containsCallInfo(callId)) {
        this.callInfoList.push({
          'callId': callId,
          'flavor': flavor,
          'owner': owner
        });
        return true;
      }
    }

    return false;
  };
  /*
   * Removes a given call id from this one.
   *
   * @param {string} callId - Call id.
   *
   * @return {boolean} true if found and removed, false otherwise.
   */


  this.removeCallInfo = function (callId) {
    var ret = false,
        idx = this.callInfoList.length;

    while (--idx >= 0) {
      if (this.callInfoList[idx].callId === callId) {
        this.callInfoList.splice(idx, 1);
        ret = true;
        break;
      }
    }

    return ret;
  };

  this.accessToLocalMedia = function () {
    if (this.callType === 'screenSharing' || this.callType === 'screenSharingWithAudio' || this.callType === 'data') {
      return false;
    }

    return this.stream !== null;
  };
  /*
   * @param {string} attribute - one of the following value: muted, enabled 
   * @returns 
   */


  this.muteAudioOnStreams = function () {
    var attribute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "enabled";
    //This function mute the stream and associated cloned streams
    logger.debug("[ApiCCUserMediaStream] muteAudioOnStreams; userMediaStreamId: " + this.userMediaStreamId);
    var status = null; //Muting stream

    this.stream.getAudioTracks().forEach(function (track) {
      track.enabled = false;
    });

    if (attribute === "enabled") {
      this.audioMuted = true;
    } else if (attribute === "muted") {
      this.audioSilent = true;
    }

    this.notifyMLineMuted('audio', true, attribute);
    status = {
      type: 'audio',
      muted: true
    };
    return status;
  };
  /*
   * @param {string} attribute - one of the following value: muted, enabled 
   * @returns 
   */


  this.unMuteAudioOnStreams = function () {
    var attribute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "enabled";
    //This function mute the stream and associated cloned streams
    logger.debug("[ApiCCUserMediaStream] unMuteAudioOnStreams; userMediaStreamId: " + this.userMediaStreamId);
    var status = null; //Muting stream

    this.stream.getAudioTracks().forEach(function (track) {
      track.enabled = true;
    });

    if (attribute === "enabled") {
      this.audioMuted = false;
    } else if (attribute === "muted") {
      this.audioSilent = false;
    }

    this.notifyMLineMuted('audio', false, attribute);
    status = {
      type: 'audio',
      muted: false
    };
    return status;
  };
  /*
   * This function mute the stream and associated cloned streams
   * @param {string} attribute - one of the following value: muted, enabled 
   * @returns 
   */


  this.muteVideoOnStreams = function () {
    var attribute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "enabled";
    logger.debug("[ApiCCUserMediaStream] muteVideoOnStreams; userMediaStreamId: " + this.userMediaStreamId);
    var status = null; //Muting stream

    this.stream.getVideoTracks().forEach(function (track) {
      track.enabled = false;
    });

    if (attribute === "enabled") {
      this.videoMuted = true;
    } else if (attribute === "muted") {
      this.videoSilent = true;
    }

    this.notifyMLineMuted('video', true, attribute);
    status = {
      type: 'video',
      muted: true
    };
    return status;
  };
  /*
   * @param {string} attribute - one of the following value: muted, enabled 
   * @returns 
   */


  this.unMuteVideoOnStreams = function () {
    var attribute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "enabled";
    logger.debug("[ApiCCUserMediaStream] unMuteVideoOnStreams; userMediaStreamId: " + this.userMediaStreamId);
    var status = null; //Muting stream

    this.stream.getVideoTracks().forEach(function (track) {
      track.enabled = true;
    });

    if (attribute === "enabled") {
      this.videoMuted = false;
    } else if (attribute === "muted") {
      this.videoSilent = false;
    }

    this.notifyMLineMuted('video', false, attribute);
    status = {
      type: 'video',
      muted: false
    };
    return status;
  };

  this.removeVideoTrackOnStreams = function () {
    logger.debug("[ApiCCUserMediaStream] removeVideoTrackOnStreams; userMediaStreamId: " + this.userMediaStreamId);
    var videoTracks = null,
        status = null; // Removing video track.

    videoTracks = this.stream.getVideoTracks();

    if (videoTracks.length > 0) {
      this.stream.removeTrack(videoTracks[0]);
    }

    this.video = false;
    status = {
      type: 'video',
      present: false
    };
    return status;
  };
  /*
   * Helper function used to send localStreamUpdated event to end user and
   * to send streamTrackChanged and streamTrackStatusChanged info to CCS.
   *
   * @param {string} mline - audio video.
   * @param {boolean} value - value of the changed attribute.
   * @param {string} attribute - one of the following value: muted, enabled
   */


  this.notifyMLineMuted = function (mline, value, attribute) {
    var blank = true,
        call,
        userMedia;

    if (apiCC.session && apiCC.session.apiCCWebRTCClient && apiCC.session.apiCCWebRTCClient.webRTCClient) {
      for (var idx = this.callInfoList.length; --idx >= 0;) {
        if (this.callInfoList[idx].flavor === 'call') {
          call = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallWithCallId(this.callInfoList[idx].callId);
          this.notifyMLineMutedCall(mline, value, attribute, call, null);
        } else if (this.callInfoList[idx].flavor === 'userMedia') {
          userMedia = apiCC.session.apiCCWebRTCClient.webRTCClient.findUserMediaById(this.callInfoList[idx].callId);
          this.notifyMLineMutedCall(mline, value, attribute, null, userMedia);
        }

        if (this.callInfoList[idx].owner === true) {
          blank = false;
        }
      }
    }

    if (blank === true) {
      // No call/userMedia is owner of this one.
      this.notifyMLineMutedCall(mline, value, attribute, null, null);
    }
  };
  /*
   * Helper function used to send localStreamUpdated event to end user and
   * to send streamTrackChanged info to CCS.
   *
   * @param {string} mline - audio video.
   * @param {boolean} value - value of the changed attribute.
   * @param {string} attribute - one of the following value: muted, enabled
   * @param {WebRTC_Call} call - associated call (may be null).
   * @param {WebRTC_UserMedia} meshUserMedia - associated mesh user media (may be null).
   */


  this.notifyMLineMutedCall = function (mline, value, attribute, call, meshUserMedia) {
    logger.debug('notifyMLineMutedCall; mline: ' + mline + ', muted: ' + value);
    var changes = [];

    if (attribute === "enabled") {
      changes = [mline + 'IsMuted'];
    } else if (attribute === "muted") {
      changes = [mline + 'IsSilent'];
    }

    var audio = {
      available: this.audio,
      deviceLabel: this.audioDeviceLabel,
      active: true,
      muted: this.audioMuted,
      silent: this.audioSilent
    },
        video = {
      available: this.video,
      deviceLabel: this.videoDeviceLabel,
      active: true,
      muted: this.videoMuted,
      silent: this.videoSilent
    },
        dataToSend = null;

    if (call) {
      // Updating call.
      if (mline === 'audio') {
        call.isLocalAudioMuted = value;
      } else if (mline === 'video') {
        call.isLocalVideoMuted = value;
      } // Regular call.


      if (call.belongsToRoom()) {
        // Call linked to conference room.
        // Sending info to CCS.
        dataToSend = {
          'clientId': apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
          'callId': call.callId,
          'roomId': call.sessionMCU.roomName,
          'pubSub': apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.pubConnector,
          'mline': mline
        };

        if (call.data.mesh) {
          dataToSend.mesh = call.data.mesh;
        }

        if (attribute === 'muted') {
          dataToSend.change = 'silent';
          dataToSend.silent = value;
          call.myWebRTC_Stack.sendInfo('streamTrackStatusChanged', dataToSend);
        } else if (attribute === 'enabled') {
          dataToSend.muted = value;
          call.myWebRTC_Stack.sendInfo('streamTrackChanged', dataToSend);
        }
      } else {
        // Call not linked to conference room.
        // Sending info to directly to remote.
        dataToSend = {
          'callerId': apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
          'calleeId': call.callee ? call.callerId : call.calleeId,
          'callId': call.callId,
          'mline': mline
        };

        if (attribute === 'muted') {
          dataToSend.type = 'streamTrackStatusChanged';
          dataToSend.change = 'silent';
          dataToSend.silent = value;
        } else if (attribute === 'enabled') {
          dataToSend.type = 'streamTrackChanged';
          dataToSend.muted = value;
        }

        call.myWebRTC_Stack.sendDataMessage(apiCC.session.apiCCWebRTCClient.webRTCClient.clientId, dataToSend);
      } // Emitting event to end user.


      audio.active = call.localCallProfile.audioActive;
      video.active = call.localCallProfile.videoActive;
      myWebRTC_Event.createLocalStreamUpdatedEvent(changes, audio, video, true, call.callType, call.callId, this.stream, this.userMediaStreamId, 'userAction');
    } else if (meshUserMedia) {
      // Mesh call (belongs to conference room).
      // Sending info to CCS about that.
      dataToSend = {
        'clientId': apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
        'callId': meshUserMedia.userMediaId,
        'roomId': meshUserMedia.sessionMCU.roomName,
        'pubSub': apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.pubConnector,
        'mline': mline
      };

      if (attribute === 'muted') {
        dataToSend.change = 'silent';
        dataToSend.silent = value;
        meshUserMedia.myWebRTC_Stack.sendInfo('streamTrackStatusChanged', dataToSend);
      } else if (attribute === 'enabled') {
        dataToSend.muted = value;
        meshUserMedia.myWebRTC_Stack.sendInfo('streamTrackChanged', dataToSend);
      } // Emitting event to end user.


      if (meshUserMedia.audioSdpDirection === 'inactive') {
        audio.active = false;
      }

      if (meshUserMedia.videoSdpDirection === 'inactive') {
        video.active = false;
      }

      myWebRTC_Event.createLocalStreamUpdatedEvent(changes, audio, video, true, meshUserMedia.callType, meshUserMedia.userMediaId, this.stream, this.userMediaStreamId, 'userAction');
    } else {
      // No associated call.
      // Emitting event to end user.
      myWebRTC_Event.createLocalStreamUpdatedEvent(changes, audio, video, false, null, null, this.stream, this.userMediaStreamId, 'userAction');
    }
  };
  /*
   * Helper function used to send active speaker event to end user and
   * to send active speaker info to CCS.
   *
   * @param {WebRTC_Call} call - associated call (may be null).
   * @param {WebRTC_UserMedia} meshUserMedia - associated mesh user media (may be null).
   */


  this.notifyActiveSpeaker = function (amplitude) {
    var blank = true,
        call,
        userMedia;

    if (apiCC.session && apiCC.session.apiCCWebRTCClient && apiCC.session.apiCCWebRTCClient.webRTCClient) {
      for (var idx = this.callInfoList.length; --idx >= 0;) {
        if (this.callInfoList[idx].flavor === 'call') {
          call = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallWithCallId(this.callInfoList[idx].callId);
          this.notifyActiveSpeakerCall(amplitude, call, null);
        } else if (this.callInfoList[idx].flavor === 'userMedia') {
          userMedia = apiCC.session.apiCCWebRTCClient.webRTCClient.findUserMediaById(this.callInfoList[idx].callId);
          this.notifyActiveSpeakerCall(amplitude, null, userMedia);
        }

        if (this.callInfoList[idx].owner === true) {
          blank = false;
        }
      }
    }

    if (blank === true) {
      // No call/userMedia is owner of this one.
      this.notifyActiveSpeakerCall(amplitude, null, null);
    }
  };
  /*
   * Helper function used to send active speaker event to end user and
   * to send active speaker info to CCS.
   *
   * @param {WebRTC_Call} call - associated call (may be null).
   * @param {WebRTC_UserMedia} meshUserMedia - associated mesh user media (may be null).
   */


  this.notifyActiveSpeakerCall = function (amplitude, call, meshUserMedia) {
    var dataToSend = null;

    if (call) {
      // Regular call.
      if (call.belongsToRoom()) {
        // Call linked to conference room.
        // Send info to CCS.
        dataToSend = {
          'clientId': apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
          'callId': call.callId,
          'roomId': call.sessionMCU.roomName,
          'pubSub': apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.pubConnector,
          // Tell janusConnector to resolve the message before sending it to other participants.
          'resolve': true,
          'descriptor': {
            'audioAmplitude': amplitude,
            'streamID': this.userMediaStreamId
          }
        };

        if (call.data.mesh) {
          dataToSend.mesh = call.data.mesh;
        }

        call.myWebRTC_Stack.sendInfo('activeSpeaker', dataToSend);
      } else {
        // Call not linked to conference room.
        // Send info to directly to remote.
        dataToSend = {
          'type': 'activeSpeaker',
          'callerId': apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
          'calleeId': call.callee ? call.callerId : call.calleeId,
          'callId': call.callId,
          'descriptor': {
            'audioAmplitude': amplitude,
            'streamID': this.userMediaStreamId
          }
        };
        call.myWebRTC_Stack.sendDataMessage(apiCC.session.apiCCWebRTCClient.webRTCClient.clientId, dataToSend);
      } // Emit event to end user.


      myWebRTC_Event.createAudioAmplitudeEvent(amplitude, true, call.callId, this.userMediaStreamId);
    } else if (meshUserMedia) {
      // Mesh call (belongs to conference room).
      // Send info to CCS about that.
      dataToSend = {
        'clientId': apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
        'callId': meshUserMedia.userMediaId,
        'roomId': meshUserMedia.sessionMCU.roomName,
        'pubSub': apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.pubConnector,
        // Tell janusConnector to resolve the message before sending it to other participants.
        'resolve': true,
        'descriptor': {
          'audioAmplitude': amplitude,
          'streamID': this.userMediaStreamId
        }
      };
      meshUserMedia.myWebRTC_Stack.sendInfo('activeSpeaker', dataToSend); // Emit event to end user.

      myWebRTC_Event.createAudioAmplitudeEvent(amplitude, true, meshUserMedia.userMediaId, this.userMediaStreamId);
    } else {
      // No associated call.
      // Emit event to end user.
      myWebRTC_Event.createAudioAmplitudeEvent(amplitude, true, null, this.userMediaStreamId);
    }
  };

  this.notifyNotActiveSpeaker = function (amplitude) {
    var blank = true,
        call,
        userMedia;

    if (apiCC.session && apiCC.session.apiCCWebRTCClient && apiCC.session.apiCCWebRTCClient.webRTCClient) {
      for (var idx = this.callInfoList.length; --idx >= 0;) {
        if (this.callInfoList[idx].flavor === 'call') {
          call = apiCC.session.apiCCWebRTCClient.webRTCClient.findCallWithCallId(this.callInfoList[idx].callId);
          this.notifyNotActiveSpeakerCall(amplitude, call, null);
        } else if (this.callInfoList[idx].flavor === 'userMedia') {
          userMedia = apiCC.session.apiCCWebRTCClient.webRTCClient.findUserMediaById(this.callInfoList[idx].callId);
          this.notifyNotActiveSpeakerCall(amplitude, null, userMedia);
        }

        if (this.callInfoList[idx].owner === true) {
          blank = false;
        }
      }
    }

    if (blank === true) {
      // No call/userMedia is owner of this one.
      this.notifyNotActiveSpeakerCall(amplitude, null, null);
    }
  };
  /*
   * Helper function used to send active speaker event to end user and
   * to send active speaker info to CCS.
   *
   * @param {WebRTC_Call} call - associated call (may be null).
   * @param {WebRTC_UserMedia} meshUserMedia - associated mesh user media (may be null).
   */


  this.notifyNotActiveSpeakerCall = function (amplitude, call, meshUserMedia) {
    var dataToSend = null;

    if (call) {
      // Regular call.
      if (call.belongsToRoom()) {
        // Call linked to conference room.
        // Send info to CCS.
        dataToSend = {
          'clientId': apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
          'callId': call.callId,
          'roomId': call.sessionMCU.roomName,
          'pubSub': apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.pubConnector,
          // Tell janusConnector to resolve the message before sending it to other participants.
          'resolve': true,
          'descriptor': {
            'audioAmplitude': amplitude,
            'streamID': this.userMediaStreamId
          }
        };

        if (call.data.mesh) {
          dataToSend.mesh = call.data.mesh;
        }

        call.myWebRTC_Stack.sendInfo('stopSpeaking', dataToSend);
      } else {
        // Call not linked to conference room.
        // Send info to directly to remote.
        dataToSend = {
          'type': 'stopSpeaking',
          'callerId': apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
          'calleeId': call.callee ? call.callerId : call.calleeId,
          'callId': call.callId,
          'descriptor': {
            'audioAmplitude': amplitude,
            'streamID': this.userMediaStreamId
          }
        };
        call.myWebRTC_Stack.sendDataMessage(apiCC.session.apiCCWebRTCClient.webRTCClient.clientId, dataToSend);
      } // Emit event to end user.


      myWebRTC_Event.createAudioAmplitudeEvent(amplitude, false, call.callId, this.userMediaStreamId);
    } else if (meshUserMedia) {
      // Mesh call (belongs to conference room).
      // Send info to CCS about that.
      dataToSend = {
        'clientId': apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
        'callId': meshUserMedia.userMediaId,
        'roomId': meshUserMedia.sessionMCU.roomName,
        'pubSub': apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.pubConnector,
        // Tell janusConnector to resolve the message before sending it to other participants.
        'resolve': true,
        'descriptor': {
          'audioAmplitude': amplitude,
          'streamID': this.userMediaStreamId
        }
      };
      meshUserMedia.myWebRTC_Stack.sendInfo('stopSpeaking', dataToSend); // Emit event to end user.

      myWebRTC_Event.createAudioAmplitudeEvent(amplitude, false, meshUserMedia.userMediaId, this.userMediaStreamId);
    } else {
      // No associated call.
      // Emit event to end user.
      myWebRTC_Event.createAudioAmplitudeEvent(amplitude, false, null, this.userMediaStreamId);
    }
  };

  this.callback = function (that, fnct) {
    this.closureHandler = function (e, f) {
      return that[fnct](e, f);
    };

    return this.closureHandler;
  };
  /*
   * Returns whether user media access is allowed.
   * @ignore
   * @return {boolean|null} True or false on success, null if the information is not available.
   */


  this.isUserMediaAccessAllowed = function () {
    if (localStorage !== null && (typeof localStorage === "undefined" ? "undefined" : _typeof(localStorage)) === 'object' && typeof localStorage.getItem === 'function') {
      return localStorage.getItem(LOCAL_STORAGE_KEY_GET_USER_MEDIA_ACCESS_ALLOWED) === 'true';
    }

    return null;
  };
  /*
   * Sets whether user media access is allowed.
   * @ignore
   * @param {boolean} allowed
   * @return {boolean} True or false on success, null if the information cannot be set.
   */


  this.setUserMediaAccessAllowed = function (allowed) {
    if (localStorage !== null && (typeof localStorage === "undefined" ? "undefined" : _typeof(localStorage)) === 'object' && typeof localStorage.setItem === 'function') {
      localStorage.setItem(LOCAL_STORAGE_KEY_GET_USER_MEDIA_ACCESS_ALLOWED, !!allowed ? 'true' : 'false');
      return !!allowed;
    }

    return null;
  };
  /*
   * Starts filtration if any filters set to stream
   * @ignore
   * @param {MediaStream} stream
   * @return {MediaStream} Filtered stream
   */


  this.applyFiltersIfNeeded = function (stream) {
    if (this.filters === null) {
      return Promise.resolve(stream);
    }

    this.mediaFilterManager = new _MediaFilter_MediaFilterManager__WEBPACK_IMPORTED_MODULE_3__["default"](stream, this.filters, this.userMediaStreamId);
    return this.mediaFilterManager.applyFilters();
  };
  /*
   * Returns the video track settings of the media stream represented by this one.
   * @ignore
   * @return {object|null} The video track settings on success, null otherwise.
   */


  this.getVideoSettings = function () {
    if (this.videoSettings !== false) {
      return this.videoSettings;
    }

    var videoTrack = this.getVideoTrack();

    if (!videoTrack || typeof videoTrack.getSettings !== 'function') {
      this.videoSettings = null;
      return this.videoSettings;
    }

    var settings = videoTrack.getSettings();

    if (!settings) {
      this.videoSettings = null;
      return this.videoSettings;
    }

    this.videoSettings = {};

    if (Object.prototype.hasOwnProperty.call(settings, 'width')) {
      this.videoSettings.width = settings.width;
    }

    if (Object.prototype.hasOwnProperty.call(settings, 'height')) {
      this.videoSettings.height = settings.height;
    }

    if (Object.prototype.hasOwnProperty.call(settings, 'frameRate')) {
      this.videoSettings.frameRate = settings.frameRate;
    }

    return this.videoSettings;
  };
  /*
   * Tests whether the media stream represented by this one is compliant with simulcasting.
   * @ignore
   * @return {boolean} true if this one is compliant with simulcasting, false otherwise.
   */


  this.isSimulcastCompliant = function () {
    var videoSettings = this.getVideoSettings();

    if (!videoSettings) {
      return false;
    }

    return true;
  };
  /*
   * @typedef SimulcastProfile
   * @property {SimulcastProfileCategory} substream
   * @property {SimulcastProfileCategory} temporal
   */

  /*
   * @typedef SimulcastProfileCategory
   * @property {SimulcastProfileCategoryElement} high
   * @property {SimulcastProfileCategoryElement} medium
   * @property {SimulcastProfileCategoryElement} low
   */

  /*
   * @typedef SimulcastProfileCategoryElement
   * @property {boolean} active - Whether the element is active (exists).
   * @property {boolean} selectable - Whether the element is selectable.
   */

  /*
   * Returns the simulcast profile associated to the media stream represented by this one.
   * @ignore
   * @return {SimulcastProfile | null} A SimulcastProfile if this one is compliant with simulcasting, null otherwise.
   */


  this.getSimulcastProfile = function () {
    var videoSettings = this.getVideoSettings();

    if (!videoSettings) {
      return null;
    }

    var profile = {
      substream: {
        high: {
          active: true,
          selectable: true
        },
        medium: {
          active: true,
          selectable: true
        },
        low: {
          active: true,
          selectable: true
        }
      },
      temporal: {
        high: {
          active: true,
          selectable: true
        },
        medium: {
          active: true,
          selectable: true
        },
        low: {
          active: true,
          selectable: true
        }
      }
    };

    if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome') {
      // With chrome.
      if (videoSettings.width < 1280 || videoSettings.height < 720) {
        // In VGA, there are only 2 substreams: high and medium.
        // However, when both high and medium substreams are disabled, the low substream is active.
        profile.substream.low.selectable = false;
      }

      profile.temporal.high.active = false;
      profile.temporal.high.selectable = false;
    }

    return profile;
  };
};



/***/ }),

/***/ "./src/Core/ApiCCWebRTCClient.js":
/*!***************************************!*\
  !*** ./src/Core/ApiCCWebRTCClient.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiCCWebRTCClient": () => (/* binding */ ApiCCWebRTCClient)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _WebRTC_Client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebRTC_Client */ "./src/Core/WebRTC_Client.js");
/* harmony import */ var _PreCallTest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PreCallTest */ "./src/Core/PreCallTest.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ApiCCWebRTCClient');




/**
 * <p>This is the ApiRTCWebRTCClient.</p>
 * <p>This class enables you to manage WebRTC communications (audio, video)</p>
 * @module ApiRTCWebRTCClient
 **/

var ApiCCWebRTCClient = function ApiCCWebRTCClient(session) {
  logger.debug('apiCC.ApiCCWebRTCClient');
  this.myWebRTC_Event = apiCC.myWebRTC_Event;
  this.webRTCClient = new _WebRTC_Client__WEBPACK_IMPORTED_MODULE_1__.WebRTC_Client(session);
  this.webRTCClient.channelReady = true;
  this.callTest = null;
  /**
  * <b>Description</b>
  * <p>This method enables you to call with audio and video a registered user using its clientId.</p>
  * <b>Associated events :</b>
  * <li>userMediaSuccess</li>
  * <li>userMediaError</li>
  * <li>callEstablished</li>
  * <li>remoteHangup</li>
  *
  * @method call
  * @param {String} calledNumber ClientId to call
  * @param {JSON} data parameter. JSON Data can be added on call and retrieved on CDR.
  * @param {JSON} callConfiguration JSON with following parameters :
  * - mediaTypeForOutgoingCall : This enables to choose the media type to establish a call.
  * Value can be : VIDEO (audio and video will be used to establish call), AUDIO (audio only), VIDEOONLY, NONE (establishing call without sharing any media)
  * - mediaRoutingMode : This enables to choose the media routing mode.
  * - turnServerAddress : This enables to change the turn server used for the call
  * Value can be : hostOnly, stun, stunOnly, turn, turnOnly
  * - record : boolean. true to activate the call recording on server side. Check Server_Side_API on documentation to play, get or delete recorded files.
  * - muted : This parameter enables to start a muted call.
  * Value can be : VIDEO (audio and video will be muted), AUDIOONLY (only audio will be muted), VIDEOONLY (only video will be muted)
  */

  this.call = function (calledNumber, data, callConfiguration) {
    if (data === "RECORD") {
      logger.warn("DEPRECATED : usage of data parameter on call() as a string with 'RECORD' value will be deprecated in a next version of apiRTC. Please consider using a JSON Data parameter instead : data = {isRecorded : true}");
    }

    var callId = null;

    if (this.webRTCClient.recordedCall === true) {
      logger.log('recordedCall option is activated');

      if (data === undefined || data === "RECORD") {
        data = {};
      }

      data.MCUType = 'MCU-Caller';
      data.confId = Math.floor(Math.random() * 1000001).toString();
    }

    if (data !== undefined) {
      //data === "RECORD" or data.isRecorded === true is keep for retrocompatibility
      if (data === "RECORD" || data.isRecorded === true) {
        logger.log('recordedCall option is activated');

        if (data === "RECORD") {
          data = {};
        }

        data.MCUType = 'MCU-Caller';
        data.confId = Math.floor(Math.random() * 1000001).toString();
      }
    }

    if (callConfiguration !== undefined && callConfiguration !== null) {
      if (callConfiguration.record === true) {
        logger.log('callConfiguration record option is activated');

        if (data === undefined || data === "RECORD") {
          data = {};
        }

        data.MCUType = 'MCU-Caller';
        data.confId = Math.floor(Math.random() * 1000001).toString();
      }
    }

    logger.log('session.webRTCPluginActivated =', session.webRTCPluginActivated);

    if ((_BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'IE' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser_major_version < 11) && session.webRTCPluginActivated === true) {
      logger.log("managing call with WebRTC Plugin");

      if (callConfiguration === undefined || callConfiguration === null) {
        callConfiguration = {};
      } //Generating a callId for the call


      callConfiguration.apzcallId = apiCC.generateCallId();
      apiCC.manageWebRTCPlugin(function () {
        logger.log("manageWebRTCPlugin cb in call");
        apiCC.session.apiCCWebRTCClient.webRTCClient.callWithNumber(calledNumber, true, data, callConfiguration);
      }, function () {
        logger.log("actionOnInstallationNeeded");
      });
      callId = callConfiguration.apzcallId;
      return callId;
    } else {
      logger.log("managing call with browser");
      callId = this.webRTCClient.callWithNumber(calledNumber, true, data, callConfiguration);
      return callId;
    }
  };
  /**
  * <b>Description</b>
  * <p>This method returns current webRTC raw stats for a call.</p>
  *
  * @method getStatsFromCall
  * @param {String} callId call id to get stats from
  * @param {function} callback first parameter being error and second being the statistics result
  */


  this.getStatsFromCall = function (callId, callback) {
    var call = this.webRTCClient.findCallWithCallId(callId);

    if (call === null) {
      callback(new Error('Call was not found'), null);
    } else if (call.pc === null) {
      callback(new Error('Call has no peerconnection'), null);
    } else {
      if (this.webRTCClient.csmEnable === true) {
        callback(null, this.webRTCClient.csmLastResults);
      } else {
        callback(new Error('Call stats monitoring not activated'), null);
      }
    }
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to start a test call.</p>
  * <b>Associated events :</b>
  * <li>userMediaSuccess</li>
  * <li>userMediaError</li>
  * <li>callEstablished</li>
  * <li>remoteHangup</li>
  *
  * @method testCall
  * @param {JSON} callConfiguration JSON with following parameters :
  * - mediaTypeForOutgoingCall :This enables to choose the media type to establish a call.
  * Value can be : VIDEO (audio and video will be used to establish call), AUDIO (audio only), VIDEOONLY, NONE (establishing call without sharing any media)
  * - mediaRoutingMode :This enables to choose the media routing mode.
  * - turnServerAddress : This enables to change the turn server used for the call
  * Value can be : hostOnly, stun, stunOnly, turn, turnOnly
  * - muted : This parameter enables to start a muted call.
  * Value can be : VIDEO (audio and video will be muted), AUDIOONLY (only audio will be muted), VIDEOONLY (only video will be muted)
  */


  this.testCall = function (callConfiguration) {
    var callId = null;
    logger.log('session.webRTCPluginActivated =', session.webRTCPluginActivated);

    if ((_BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'IE' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser_major_version < 11) && session.webRTCPluginActivated === true) {
      logger.log("managing call with WebRTC Plugin");

      if (callConfiguration === undefined || callConfiguration === null) {
        callConfiguration = {};
      } //Generating a callId for the call


      callConfiguration.apzcallId = apiCC.generateCallId();
      apiCC.manageWebRTCPlugin(function () {
        logger.log("manageWebRTCPlugin cb in call");
        apiCC.session.apiCCWebRTCClient.webRTCClient.startTestCall(true, callConfiguration);
      }, function () {
        logger.log("actionOnInstallationNeeded");
      });
      callId = callConfiguration.apzcallId;
      return callId;
    } else {
      logger.log("managing call with browser");
      callId = this.webRTCClient.startTestCall(true, callConfiguration);
      return callId;
    }
  };
  /**
  * <b>Description</b>
  * <p>This method is used to set Turn Server address to use for all established calls</p>
  *
  * @method setClientTurnServer
  * @param {String} turnServerAddress turn server address to be use for all calls
  */


  this.setClientTurnServer = function (turnServerAddress) {
    this.webRTCClient.setClientTurnServer(turnServerAddress);
  };
  /**
  * <b>Description</b>
  * <p>This method is used to initialize screenSharing feature</p>
  *
  * @method activateScreenSharing
  * @param {String} [extensionId] extensionId to be used for screenSharing feature. If not defined ApiRTC's extension will be used.
  */


  this.activateScreenSharing = function (extensionId) {
    this.webRTCClient.activateScreenSharing(extensionId);
  };
  /**
  * <b>Description</b>
  * <p>This Feature require the page to be loaded using HTTPS</p>
  * <p>This method enables you to share your screen with a registered user using its clientId.</p>
  * <b>Associated events :</b>
  * <li>userMediaSuccess</li>
  * <li>userMediaError</li>
  * <li>callEstablished</li>
  * <li>remoteHangup</li>
  *
  * @method shareScreen
  * @param {String} calledNumber ClientId of the contact you want to share your screen with.
  * @param {JSON} data parameter. JSON Data can be added on call and retrieved on CDR. For call recording use the parameter 'isRecorded' : var data = {isRecorded : true} In this case, call will be recorded on server side. Check Server_Side_API on documentation to play, get or delete recorded files.
  * @param {JSON} captureSourceType This enables to choose what the user will be propose to share between screen, applications, browser tab and audio.
  Usage is different depending the browser :
  -on Chrome, captureSourceTypevalue value is an array that can be ["screen", "window", "tab", "audio"]. This array is used to restrict what will be proposed to the user
  -on Firefox, captureSourceTypevalue value is a string that can be "screen", "window" or "application". This string is used to choose what will be proposed to the user
  * @return {String} CallId : call identifier
  */


  this.shareScreen = function (calledNumber, data, captureSourceType) {
    logger.info("shareScreen");
    var callId = this.webRTCClient.shareScreen(calledNumber, data, captureSourceType);
    return callId;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to start a screenSharing on an existing calls, screen stream will be sended to your call party. See Also toggleVideoScreen()</p>
  *
  * @method startScreenSharingOnCall
  * @param {String} callId callId of the call on which you want to add the screenSharing
  * @param {JSON} captureSourceType This parameters enables to choose what the user will be propose to share between screen, applications, browser tab and audio. Value can be ["screen", "window", "tab", "audio"]
  */


  this.startScreenSharingOnCall = function (callId, captureSourceType) {
    logger.info("startScreenSharingOnCall");
    this.webRTCClient.startScreenSharingOnCall(callId, captureSourceType);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to start a dataChannel with a registered user using its clientId</p>
  *<p>Then it enables to send data to the call party using sendDataWithCallId()</p>
  * <b>Associated events :</b>
  * <li>callEstablished</li>
  * <li>remoteHangup</li>
  *
  * @method startDataChannel
  * @param {String} calledNumber ClientId of the contact you want to share data with.
  * @param {JSON} data parameter. JSON Data can be added on call and retrieved on CDR.
  * @return {String} CallId : call identifier
  */


  this.startDataChannel = function (calledNumber, data) {
    logger.info('startDataChannel');

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'Edge' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser_major_version < 79) {
      logger.warn('Cannot startDataChannel as it is not supported on Edge');
      return;
    }

    var callConfiguration = null,
        callId = null;

    if (data !== undefined) {
      data.dataCall = true;
    } else {
      data = {};
      data.dataCall = true;
    }

    callId = this.webRTCClient.callWithNumber(calledNumber, true, data, callConfiguration);
    return callId;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to start a dataChannel on an existing calls.</p>
  * <p>Then it enables to send data to the call party using sendDataWithCallId().</p>
  *
  * @method startDataChannelOnCall
  * @param {String} callId callId
  */


  this.startDataChannelOnCall = function (callId) {
    this.webRTCClient.startDataChannelOnCall(callId);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to send data to a peer using the webRTC dataChannel
   * the call must already be established with the callee</p>
   *
   * <b>Associated events :</b>
   * <li>receiveDataChannelOpen</li>
   * <li>receiveDataChannelClose</li>
   * <li>receiveDataChannelError</li>
   * <li>sendDataChannelOpen</li>
   * <li>sendDataChannelClose</li>
   * <li>sendDataChannelError</li>
   *
   * @method sendDataWithCallId
   * @param {String} callId WebRTC Call Id
   * @param {JSON} data {file : { File, Blob, ArrayBuffer, ArrayBufferView or String },
   *                       name : {String},
   *                       type : {'text/plain', 'application/octet-stream'...}}
   **/


  this.sendDataWithCallId = function (callId, data, onProgress) {
    this.webRTCClient.sendDataWithCallId(callId, data, onProgress);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to call with audio only a registered user using its clientId.</p>
  * <b>Associated events :</b>
  * <li>userMediaSuccess</li>
  * <li>userMediaError</li>
  * <li>callEstablished</li>
  * <li>remoteHangup</li>
  *
  * @method callAudio
  * @param {String} calledNumber ClientId to call
  * @param {JSON} data parameter. JSON Data can be added on call and retrieved on CDR.
  * @param {JSON} callConfiguration JSON with following parameters :
  * - mediaTypeForOutgoingCall :This enables to choose the media type to establish a call.
  * Value can be : VIDEO (audio and video will be used to establish call), AUDIO (audio only), VIDEOONLY, NONE (establishing call without sharing any media)
  * - mediaRoutingMode :This enables to choose the media routing mode.
  * - turnServerAddress : This enables to change the turn server used for the call
  * Value can be : hostOnly, stun, stunOnly, turn, turnOnly
  * - muted : This parameter enables to start a muted call.
  * Value can be : VIDEO (audio and video will be muted), AUDIOONLY (only audio will be muted), VIDEOONLY (only video will be muted)
  * @return {String} CallId : call identifier
  */


  this.callAudio = function (calledNumber, data, callConfiguration) {
    logger.info('callAudio');
    var callId = this.webRTCClient.callWithNumber(calledNumber, false, data, callConfiguration);
    return callId;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to call someone by mail
  * This will send an invitation to join your client for a conference.
  * Callee will only have to click on the mail link to establish the communication</p>
  *
  * @method callbymail
  * @param {String} destMailAddress Mail address of the person to join
  */


  this.callbymail = function (destMailAddress) {
    this.webRTCClient.callbymail(destMailAddress);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you add Media on unidirectional call</p>
  * <p>This will established the communication from the callee to the caller on unidirectional calls</p>
  * <b>Associated events :</b>
  * <li>userMediaSuccess</li>
  * <li>userMediaError</li>
  *
  * @method addMedia
  * @param {String} callId callId
  * @return {String} CallId : call identifier
  */


  this.addMedia = function (callId) {
    this.webRTCClient.addMedia(callId);
    return callId;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to hangup a call</p>
  * <b>Associated events :</b>
  * <li>hangup</li>
  *
  * @method hangUp
  */


  this.hangUp = function (callId) {
    this.webRTCClient.onHangup(callId);
  };
  /**
  * <b>Description</b>
  * <p>This method will ask for the access to user micro and camera.</p>
  * <p>User camera will then be displayed on local Video Element (Check init())</p>
  * <b>Associated events :</b>
  * <li>userMediaSuccess</li>
  * <li>userMediaError</li>
  *
  * @method getMyMedia
  * @param {String} type Value can be 'screen' to get a screen stream
  * @param {JSON} captureSourceType If type value is 'screen', this parameters enables to choose what the user will be propose to share between screen, applications, browser tab and audio. Value can be ["screen", "window", "tab", "audio"]
  */


  this.getMyMedia = function (type, captureSourceType) {
    logger.info('getMyMedia : ', type);

    if (type === 'screen') {
      var data = {};
      this.webRTCClient.shareScreen('LOCAL', data, captureSourceType);
    } else {
      this.webRTCClient.getUserMedia();
    }
  };

  this.releaseStream = function (stream) {
    logger.info('releaseStream : ', stream);
    logger.info('releaseStream.callId : ', stream.callId);

    if (stream.callId !== undefined) {
      this.webRTCClient.removeCallFromTableWithCallIdAndSendBye(stream.callId, 'stop_ScreenSharing');
    } else {
      this.webRTCClient.stopStream(stream);
    }
  };

  this.autoAnswerUserMediaSuccessHandler = function (e) {
    logger.info("autoAnswerUserMediaSuccessHandler :" + e);
    e = null;
    this.webRTCClient.autoAnswer = true;
  };

  this.autoAnswerUserMediaErrorHandler = function (e) {
    logger.info("autoAnswerUserMediaErrorHandler :" + e);
    e = null;
    this.webRTCClient.autoAnswer = false;
  };
  /**
  * <b>Description</b>
  * <p>This method will enables your application to automatically answer a call : it will ask for the access to user micro and camera as it is required for AutoAnswer feature</p>
  * <p>User camera will then be displayed on local Video Element (Check init())</p>
  * <b>Associated events :</b>
  * <li>userMediaSuccess</li>
  * <li>userMediaError</li>
  *
  * @method activateAutoAnswer
  */


  this.activateAutoAnswer = function () {
    apiCC.addEventListener('userMediaSuccess', this.callback(this, 'autoAnswerUserMediaSuccessHandler'));
    apiCC.addEventListener('userMediaError', this.callback(this, 'autoAnswerUserMediaErrorHandler'));
    this.webRTCClient.getUserMedia();
  };
  /**
  * <b>Description</b>
  * <p>This method will enables you to get the status of AutoAnswer feature</p>
  *
  * @method getAutoAnswer
  * @return {Boolean} True if AutoAnswer feature is activated
  */


  this.getAutoAnswer = function () {
    return this.webRTCClient.autoAnswer;
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to set unidirectional Call support.
  * When this feature is activated, a caller will be able to send his audio and video media to the client without any request on callee side.
  * Media flows are established one way from caller to the callee</p>
  * <p>UnidirectionalCall is desactivated by default.</p>
  * <b>Associated events :</b>
  * <li>errorEvent</li>
  *
  * @method setUnidirectionalCall
  * @param {Boolean} boolean true or False
  */


  this.setUnidirectionalCall = function (val) {
    if (val === true || val === false) {
      this.webRTCClient.unidirectionelCallOnly = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setUnidirectionalCall()', 'PARAMETER_ERROR_SETUNIDIRCALL');
    }
  };

  this.setReceiveMediaDeactivated = function (val) {
    if (val === true || val === false) {
      this.webRTCClient.receiveMediaDeactivated = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setReceiveMediaDeactivated()', 'PARAMETER_ERROR_SETRECVMEDIADEACTIVATED');
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to set VP9 as prefered codec</p>
  * <b>Associated events :</b>
  * <li>errorEvent</li>
  *
  * @method setPreferVP9Codec
  * @param {Boolean} boolean true or False
  */


  this.setPreferVP9Codec = function (val) {
    if (val === true || val === false) {
      this.webRTCClient.preferVP9Codec = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setPreferVP9Codec()', 'PARAMETER_ERROR_SETPREFERVP9CODEC');
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to set H264 as prefered codec</p>
  * <b>Associated events :</b>
  * <li>errorEvent</li>
  *
  * @method setPreferH264Codec
  * @param {Boolean} boolean : true or False
  */


  this.setPreferH264Codec = function (val) {
    if (val === true || val === false) {
      this.webRTCClient.preferH264Codec = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setPreferH264Codec()', 'PARAMETER_ERROR_SETPREFERH264CODEC');
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to know if unidirectional Call is activated or not.
  * See also : setUnidirectionalCall
  *
  * @method getUnidirectionalCall
  * @return {Boolean} True if UnidirectionalCall feature is activated
  */


  this.getUnidirectionalCall = function () {
    return this.webRTCClient.unidirectionelCallOnly;
  };
  /**
  * <b>Description</b>
  * <p>This method will change Video mute state</p>
  *
  * @method toggleVideoMute
  * @param {String} callId call Identifier of the call you want to apply a video mute. If callId is not setted toggleVideoMute apply to all local video.
  * @return {Object} JSON Object :
  *<pre><code>
  *{
  *    muteState : resulting mute state test
  *        Value can be : true, false or in case of error : 'STREAM_NOT_FOUND', 'CALL_NOT_FOUND'
  *    , callId : call identifier if any
  *        Value can be : callId or 'ALL' if toggleVideoMute apply to client
  *}
  *</pre></code>
  */


  this.toggleVideoMute = function (callId) {
    return this.webRTCClient.toggleVideoMute(callId);
  };
  /**
  * <b>Description</b>
  * <p>This method will return if Video is muted or not</p>
  *
  * @method isVideoMuted
  * @param {String} callId call Identifier of the call you want know the video mute status. If callId is not setted isVideoMuted apply to client status
  */


  this.isVideoMuted = function (callId) {
    logger.debug('isVideoMuted :', callId);
    var index;

    if (callId === undefined || callId === null) {
      return this.webRTCClient.isVideoMuted;
    } else {
      logger.debug('callId is defined :', callId);
      index = this.webRTCClient.findCallIndexWithCallId(callId);

      if (index !== -1) {
        return this.webRTCClient.callsTable[index].isLocalVideoMuted;
      }
    }
  };
  /**
  * <b>Description</b>
  * <p>This method will change Audio mute state</p>
  *
  * @method toggleAudioMute
  * @param {String} callId call Identifier of the call you want to apply an audio mute. If callId is not setted toggleAudioMute apply to all local video.
  * @return {Object} JSON Object :
  *<pre><code>
  *{
  *    muteState : resulting mute state test
  *        Value can be : true, false or in case of error : 'STREAM_NOT_FOUND', 'CALL_NOT_FOUND'
  *    , callId : call identifier if any
  *        Value can be : callId or 'ALL' if toggleAudioMute apply to client
  *}
  *</pre></code>
  */


  this.toggleAudioMute = function (callId) {
    return this.webRTCClient.toggleAudioMute(callId);
  }; //TODO Describe function to add in API

  /*
      The tones parameter is treated as a series of characters. The characters 0 through 9, A through D, #, and * generate the associated DTMF tones.
      The characters a to d MUST be normalized to uppercase on entry and are equivalent to A to D. As noted in [RTCWEB-AUDIO] Section 3, support for the characters 0 through 9, A through D, #, and * are required.
      The character ',' MUST be supported, and indicates a delay of 2 seconds before processing the next character in the tones parameter. All other characters (and only those other characters) MUST be considered unrecognized.
  
      The duration parameter indicates the duration in ms to use for each character passed in the tones parameters. The duration cannot be more than 6000 ms or less than 40 ms. The default duration is 100 ms for each tone.
  
      The interToneGap parameter indicates the gap between tones in ms. The user agent clamps it to at least 30 ms and at most 6000 ms. The default value is 70 ms.
  */


  this.sendDTMF = function (callId, tones, duration, gap) {
    return this.webRTCClient.sendDTMF(callId, tones, duration, gap);
  };
  /**
  * <b>Description</b>
  * <p>This method will return if Audio is muted or not</p>
  *
  * @method isAudioMuted
  * @param {String} callId call Identifier of the call you want know the video mute status. If callId is not setted isAudioMuted apply to client status
  */


  this.isAudioMuted = function (callId) {
    logger.debug('isAudioMuted :', callId);
    var index;

    if (callId === undefined || callId === null) {
      return this.webRTCClient.isAudioMuted;
    } else {
      logger.debug('callId is defined :', callId);
      index = this.webRTCClient.findCallIndexWithCallId(callId);

      if (index !== -1) {
        return this.webRTCClient.callsTable[index].isLocalAudioMuted;
      }
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to set the conference mode : NtoN or Nto1.</p>
  * <p>When NtoN is set to false, on video conference, the caller will only be connected to the conference administrator (N to 1).
  * The administrator will be the only one connected to all conference participants. </p>
  * <p>NtoN calls is activated by default : this mean that client will be connected to all users in the conference by default</p>
  * <b>Associated events :</b>
  * <li>errorEvent</li>
  * @method setNtoNConf
  * @param {Boolean} boolean true or False
  */


  this.setNtoNConf = function (val) {
    if (val === true || val === false) {
      this.webRTCClient.NtoNConf = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setNtoNConf()', 'PARAMETER_ERROR_SETNTONCONF');
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to know the conference mode activated (NtoN or Nto1).
  * See also : setNtoNConf
  *
  * @method getNtoNConf
  * @return {Boolean} True if N to N conference feature is activated
  */


  this.getNtoNConf = function () {
    return this.webRTCClient.NtoNConf;
  };
  /**
  * <b>Description</b>
  * <p><b>BETA - This function is still in beta and may not work depending of your browser version</b></p>
  * <p>Client Configuration method that enables you to activate RTP instead of SRTP.
  * When this feature is activated, media stream will be exchange using RTP</p>
  * <p>RTP is desactivated by default : SRTP is used.</p>
  * <b>Associated events :</b>
  * <li>errorEvent</li>
  *
  * @method setRTPMedia
  * @param {Boolean} boolean true or False
  */


  this.setRTPMedia = function (val) {
    if (val === true || val === false) {
      this.webRTCClient.RTPMedia = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setRTPMedia()', 'PARAMETER_ERROR_SETRTPMEDIA');
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to know the status of RTP Media feature activation.
  * See also : setRTPMedia
  *
  * @method getRTPMedia
  * @return {Boolean} True if RTPMedia feature is activated
  */


  this.getRTPMedia = function () {
    return this.webRTCClient.RTPMedia;
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to set media routing mode (hostOnly, stun, turn, turnOnly)
  * <li>hostOnly : only host candidate will be considered : (host)</li>
  * <li>stun : host and candidate from stun server will be considered : (host + srflx)</li>
  * <li>stunOnly : Only candidate from stun server will be considered : (srflx)</li>
  * <li>turn : host and candidate from turn will be considered : (host + srflx + relay)</li>
  * <li>turnOnly : only host candidate will be considered : (relay)</li>
  * <p>turn mode is activated by default : this is the default and advised mode as all candidates will be considered</p>
  * <b>Associated events :</b>
  * <li>errorEvent</li>
  *
  * @method setMediaRoutingMode
  * @param {String} MediaRoutingMode : hostOnly, stun, stunOnly, turn, turnOnly
  */


  this.setMediaRoutingMode = function (val) {
    if (val === "hostOnly") {
      this.webRTCClient.mediaRoutingMode = this.webRTCClient.mediaRoutingModeEnum.hostOnly;
    } else if (val === "stun") {
      this.webRTCClient.mediaRoutingMode = this.webRTCClient.mediaRoutingModeEnum.stun;
    } else if (val === "stunOnly") {
      this.webRTCClient.mediaRoutingMode = this.webRTCClient.mediaRoutingModeEnum.stunOnly;
    } else if (val === "turn") {
      this.webRTCClient.mediaRoutingMode = this.webRTCClient.mediaRoutingModeEnum.turn;
    } else if (val === "turnOnly") {
      this.webRTCClient.mediaRoutingMode = this.webRTCClient.mediaRoutingModeEnum.turnOnly;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setMediaRoutingMode()', 'PARAMETER_ERROR_SETMEDIAROUTINGMODE');
    }
  };
  /**
  * <b>Description</b>
  * <p>Allows to enable or disable QoS for next call</p>
  * <li>enabled : sets QoS mode</li>
  * <li>interval : (OPTIONAL) sets interval between QoS statistics fetch</li>
  * <b>Associated events:</b>
  * <li>onQosStatsUpdate</li>
  * <li>onQosChange</li>
  * <li>onQosVideoChange</li>
  * <li>onQosAudioChange</li>
  *
  * @method enableQos
  * @param {Boolean} enabled true or false
  * @param {Integer} interval interval between QoS statistics fetch
  */


  this.enableQos = function (enabled, interval) {
    if (apiCC.browser !== 'Chrome' && apiCC.browser !== 'Firefox') {
      logger.warn('enableQos() is only supported on Chrome and Firefox, support on other browsers will be added soon');
      enabled = false;
    }

    logger.info("this.enableQos=" + enabled);
    this.webRTCClient.qosEnable = enabled;
    this.webRTCClient.qosInterval = interval || this.webRTCClient.qosInterval;
  };
  /**
  * <b>Description</b>
  * <p>Allows to enable or disable Call Stats Monitoring</p>
  * <li>enabled: whether to enable Call Stats Monitoring</li>
  * <li>interval: time in milliseconds (OPTIONAL)</li>
  * <b>Associated events:</b>
  * <li>onCallStatsUpdate</li>
  *
  * @method enableCallStatsMonitoring
  * @param {Boolean} enabled whether to enable Call Stats Monitoring
  * @param {Integer} interval time in milliseconds
  */


  this.enableCallStatsMonitoring = function (enabled, interval) {
    if (['chrome', 'firefox'].indexOf(_Utils__WEBPACK_IMPORTED_MODULE_4__.browserDetails.type) < 0) {
      logger.warn('enableCallStatsMonitoring() is only supported on Chrome and Firefox, support on other browsers will be added soon');
      return;
    }

    this.webRTCClient.csmEnable = enabled;

    if (interval) {
      this.webRTCClient.csmIntervalMs = interval;
    }
  };
  /**
  * <b>Description</b>
  * <p>Allows to enable or disable Quality evaluation</p>
  * <li>enabled: whether to enable Quality evaluation</li>
  * <li>interval: time in milliseconds (OPTIONAL)</li>
  * <b>Associated events:</b>
  * <li>onCallScoreUpdate</li>
  *
  * @method enableQualityEvaluating
  * @param {Boolean} enabled whether to enable Call Stats Monitoring
  * @param {Integer} interval time in milliseconds
  */


  this.enableQualityEvaluating = function (enabled, interval) {
    if (['chrome', 'firefox'].indexOf(_Utils__WEBPACK_IMPORTED_MODULE_4__.browserDetails.type) < 0) {
      logger.warn('enableQualityEvaluating() is only supported on Chrome and Firefox, support on other browsers will be added soon');
      return;
    }

    this.webRTCClient.qualityScoreEnable = enabled;

    if (interval) {
      this.webRTCClient.qualityScoreIntervalMs = interval;
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to know the activated media routing mode
  * See also : setMediaRoutingMode
  *
  * @method getMediaRoutingMode
  * @return {String} MediaRoutingMode value can be :
  * <li>hostOnly : only "host" candidates are considered</li>
  * <li>stun : "host and srflx" candidates are considered</li>
  * <li>stunOnly : "srflx" candidates are considered</li>
  * <li>turn : "host, srflx and relay" candidates are considered</li>
  * <li>turnOnly : only "relay" candidates are considered</li>
  */


  this.getMediaRoutingMode = function () {
    var mode = null;

    if (this.webRTCClient.mediaRoutingMode === this.webRTCClient.mediaRoutingModeEnum.hostOnly) {
      mode = 'hostOnly';
    } else if (this.webRTCClient.mediaRoutingMode === this.webRTCClient.mediaRoutingModeEnum.stun) {
      mode = 'stun';
    } else if (this.webRTCClient.mediaRoutingMode === this.webRTCClient.mediaRoutingModeEnum.stunOnly) {
      mode = 'stunOnly';
    } else if (this.webRTCClient.mediaRoutingMode === this.webRTCClient.mediaRoutingModeEnum.turn) {
      mode = 'turn';
    } else if (this.webRTCClient.mediaRoutingMode === this.webRTCClient.mediaRoutingModeEnum.turnOnly) {
      mode = 'turnOnly';
    }

    return mode;
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to set the type of media that will be used to answer the call. This method enable a global configuration at webRTCClient level
  * <li>VIDEO : Audio + video will be used</li>
  * <li>AUDIO : Audio only</li>
  * <li>VIDEOONLY : Video only</li>
  * <li>NONE : No media will be used. Media will only send from caller to callee</li>
  * See also : acceptCall()
  * <b>Associated events :</b>
  * <li>errorEvent</li>
  *
  * @method setMediaTypeForIncomingCall
  * @param {String} MediaTypeForIncomingCall value can be : VIDEO, AUDIO, VIDEOONLY, NONE
  */


  this.setMediaTypeForIncomingCall = function (val) {
    logger.debug("setMediaTypeForIncomingCall :", val);

    if (val === "VIDEO" || val === "AUDIO" || val === "VIDEOONLY" || val === "NONE") {
      this.webRTCClient.mediaTypeForIncomingCall = val;
    } else {
      logger.log("setMediaTypeForIncomingCall, value is not correct", val);
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to set the type of media that will be used to establish the call. This method enable a global configuration at webRTCClient level
  * <li>VIDEO : Audio + video will be used</li>
  * <li>AUDIO : Audio only</li>
  * <li>VIDEOONLY : Video only</li>
  * <li>NONE : No media will be used. Media will only send from caller to callee</li>
  * See also : call()
  * <b>Associated events :</b>
  * <li>errorEvent</li>
  *
  * @method setMediaTypeForOutgoingCall
  * @param {String} MediaTypeForOutgoingCall value can be : VIDEO, AUDIO, VIDEOONLY, NONE
  */


  this.setMediaTypeForOutgoingCall = function (val) {
    logger.debug("setMediaTypeForOutgoingCall :", val);

    if (val === "VIDEO" || val === "AUDIO" || val === "VIDEOONLY" || val === "NONE") {
      this.webRTCClient.mediaTypeForOutgoingCall = val;
    } else {
      logger.log("setMediaTypeForOutgoingCall, value is not correct", val);
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to set stereo on Opus audio codec.
  * This method enable a global configuration at webRTCClient level
  * NOTE : echoCancellation is desactivated to enable stereo
  *
  * @method setStereo
  * @param {Boolean} value true or false to activate /deactivate stereo on Opus
  */


  this.setStereo = function (val) {
    logger.info("setStereo :", val);

    if (val === true) {
      this.webRTCClient.setStereo = val;
      this.webRTCClient.gum_config = {
        'audio': {
          'mandatory': {
            echoCancellation: false,
            googEchoCancellation: false
          },
          'optional': []
        },
        'video': {
          'mandatory': {},
          'optional': []
        }
      };
    } else if (val === false) {
      this.webRTCClient.setStereo = val;
    } else {
      logger.log("setStereo, value is not correct", val);
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to set MCU Connector to use.
  *
  * @method setMCUConnector
  * @param {String} value : mcu2.apizee.com or mcu3.apizee.com
  */


  this.setMCUConnector = function (val) {
    logger.info("setMCUConnector :", val);
    logger.log("setting value :", val);

    if (val === 'mcu4.apizee.com') {
      this.webRTCClient.MCUClient.pubConnector = 'janusConnector';
    } else if (val === 'mcu3.apizee.com') {
      this.webRTCClient.MCUClient.pubConnector = 'groupKurentoConnector';
    } else {
      logger.log("value is incorrect :", val);
    }
  };
  /**
  * <b>Description</b>
  * <p><Enables P2P video conferencing communication (no use of MCU/SFU)./p>
  *
  * @method enableMeshRoomMode
  * @param {Boolean} enabled wether P2P room mode is enabled.
  */


  this.enableMeshRoomMode = function (enabled) {
    logger.info("enableMeshRoomMode :", enabled);

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'IE') {
      logger.log("IE detected, MeshRoomMode is not supported");
      this.webRTCClient.MCUClient.meshModeEnabled = false;
    } else {
      this.webRTCClient.MCUClient.meshModeEnabled = enabled;
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to set AllowAsymetricMediaCalls.
  * This method enable a answer with video media to an audio call request
  *
  * @method setAllowAsymetricMediaCalls
  * @param {Boolean} value true or false to activate /deactivate Asymetric Media Calls
  */


  this.setAllowAsymetricMediaCalls = function (val) {
    logger.info("setAllowAsymetricMediaCalls :", val);

    if (val === true) {
      this.webRTCClient.allowAsymetricMediaCalls = val;
    } else if (val === false) {
      this.webRTCClient.allowAsymetricMediaCalls = val;
    } else {
      logger.log("setAllowAsymetricMediaCalls, value is not correct", val);
    }
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to take snapshot of your localVideo</p>
  * <p>This will create a photo and send it to a server and/or publish it on your Web page</p>
  * <b>Associated events :</b>
  * <li>snapShotPhotoUploaded</li>
  *
  * @method takeSnapshot
  * @param {String} URL URL where the photo will be send (POST parameters are : photo & clientId)
  * @param {String} {Object} [localPhotoIdOrDiv] Div Id or Div Object where your snapshot can be published
  * @param {String} [blurLevel] Blur level added on photo "Desactivated, Low, Medium, High"
  * @param {String} [sessionId] sessionId
  * @param {Callable} [progressCallback] Callable function for progress event - Optional
  * @param {String} [videoforSnapShotId] Id of the video to use for the snapshot. This enables you to select the video from which you want a snapshot.
  * @param {JSON} [options] JSON with following parameters :
  * - width : Enable to select the width of the snapshot. Default value is the video width
  * - height : Enable to select the height of the snapshot. Default value is the video height
  */


  this.takeSnapshot = function (postUrl, localPhotoIdOrDiv, blurLevel, sessionId, progressCallback, videoForSnapShotId, options) {
    this.webRTCClient.takeSnapshot(postUrl, localPhotoIdOrDiv, session.apiKey, blurLevel, sessionId, progressCallback, videoForSnapShotId, options);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to take snapshot of your localVideo</p>
  * <p>This will create a photo and send it to your call party using datachannel</p>
  * @method takeSnapshotAndSendOnDataChannel
  * @param {String} {Object} [localPhotoIdOrDiv] Div Id or Div Object where your snapshot can be published
  * @param {String} videoForSnapShotId Id of the video that will be used for the snapshot
  * @param {String} callId Identifier of the datachannel call to use
  * @param {function} [onProgressCallback] Callable function for progress event
  * <p>Progress callback receive a Json parameter with following parameters:</p>
      sendChunkNb : Chunk number sended,
      fileSize : Total size of the file,
      remainingSize : Remaining size of the file,
      uuid : Unique Identifier of the file transfer,
      lastPacket : true if this is the last packet,
      startingDate : starting Date of the file transfer,
      transferDuration : duration of the file transfer,
      percentage : percentage of the file transfer,
      transferEnded : true, if the transfer is ended
  */


  this.takeSnapshotAndSendOnDataChannel = function (localPhotoIdOrDiv, videoForSnapShotId, callId, onProgress) {
    this.webRTCClient.takeSnapshotAndSendOnDataChannel(localPhotoIdOrDiv, videoForSnapShotId, callId, onProgress);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set UserAcceptOnIncomingCall option</p>
  * <p>This option will enables you to request user to accept or refuse the call when getUserMedia can not be used</p>
  * @method setUserAcceptOnIncomingCall
  * @param {Boolean} value true or false
  */


  this.setUserAcceptOnIncomingCall = function (val) {
    logger.info("setUserAcceptOnIncomingCall :", val);

    if (val === true || val === false) {
      this.webRTCClient.userAcceptOnIncomingCall = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setUserAcceptOnIncomingCall()', 'PARAMETER_ERROR_SETUSERACCEPTONINCOCALL');
    }
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set UserAcceptOnIncomingCallBeforeGetUserMedia option</p>
  * <p>This option will enables you to request user to accept or refuse the call before the user is requested to share his media</p>
  * @method setUserAcceptOnIncomingCallBeforeGetUserMedia
  * @param {Boolean} value true or false
  */


  this.setUserAcceptOnIncomingCallBeforeGetUserMedia = function (val) {
    logger.info("setUserAcceptOnIncomingCallBeforeGetUserMedia :", val);

    if (val === true || val === false) {
      this.webRTCClient.userAcceptOnIncomingCallBeforeGetUserMedia = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setUserAcceptOnIncomingCallBeforeGetUserMedia()', 'PARAMETER_ERROR_SETUSERACCEPTONINCOCALLBEFOREGUM');
    }
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set UserAcceptOnIncomingDataCall option</p>
  * <p>This option will enables you to request user to accept or refuse the call on Data calls</p>
  *
  * @method setUserAcceptOnIncomingDataCall
  * @param {Boolean} value true or false
  */


  this.setUserAcceptOnIncomingDataCall = function (val) {
    if (val === true || val === false) {
      this.webRTCClient.userAcceptOnIncomingDataCall = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setUserAcceptOnIncomingDataCall()', 'PARAMETER_ERROR_SETUSERACCEPTONINCOCALL');
    }
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set UserAcceptOnIncomingScreenSharingCall option</p>
  * <p>This option will enables you to request user to accept or refuse the call on Data calls</p>
  *
  * @method setUserAcceptOnIncomingScreenSharingCall
  * @param {Boolean} value true or false
  */


  this.setUserAcceptOnIncomingScreenSharingCall = function (val) {
    if (val === true || val === false) {
      this.webRTCClient.userAcceptOnIncomingScreenSharingCall = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setUserAcceptOnIncomingScreenSharingCall()', 'PARAMETER_ERROR_SETUSERACCEPTONINCOSCREENSHARINGCALL');
    }
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set multipleCalls option</p>
  * <p>This option will enables you to set wheather the user is allowed to receive multiple simultaneous calls or not</p>
  *
  * @method setAllowMultipleCalls
  * @param {Boolean} value true or false
  */


  this.setAllowMultipleCalls = function (val) {
    if (val === true || val === false) {
      this.webRTCClient.allowMultipleCalls = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setAllowMultipleCalls()', 'PARAMETER_ERROR_SETALLOWMULTIPLECALLS');
    }
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set pc_config parameter on peerConnection</p>
  *
  * @method setPcConfig
  * @param {String} value of the pc_config
  */


  this.setPcConfig = function (val) {
    logger.info("Setting PC_config to :", val);
    this.webRTCClient.pc_config = val;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set pc_constraints parameter on peerConnection</p>
  *
  * @method setPcConstraint
  * @param {String} value of the pc_constraints
  */


  this.setPcConstraints = function (val) {
    logger.info("Setting PC_constraints to :" + val);
    this.webRTCClient.pc_constraints = val;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set GetUserMedia configuration</p>
  *
  * @method setGetUserMediaConfig
  * @param {JSON} constraints value to be used on getUserMedia. Default value is : {'audio': {'mandatory': {}, 'optional': []}, 'video': {'mandatory': {}, 'optional': []}}
  */


  this.setGetUserMediaConfig = function (config) {
    this.webRTCClient.setGetUserMediaConfig(config);
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to desactivate trickleIce process.
  * When this feature is desactivated, phone call will be established when all candidates are known</p>
  * <p>TrickleIce is activated by default</p>
  * <b>Associated events :</b>
  * <li>errorEvent</li>
  *
  * @method setTrickleIce
  * @param {Boolean} boolean true or False
  */


  this.setTrickleIce = function (val) {
    logger.info("Setting trickleIce to :" + val);

    if (val === true || val === false) {
      this.webRTCClient.trickleIce = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setTrickleIce()', 'PARAMETER_ERROR_SETTRICKLEICE');
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to set recorded Call support.
  * When this feature is activated, calls will be established throught MCU and will be recorded (one .webm file for each callparty). Check Server_Side_API on documentation to play, get or delete recorded files.</p>
  * <p>recorded Call is desactivated by default.</p>
  * <b>Associated events :</b>
  * <li>errorEvent</li>
  *
  * @method setRecordedCall
  * @param {Boolean} boolean true or False
  */


  this.setRecordedCall = function (val) {
    if (val === true || val === false) {
      this.webRTCClient.recordedCall = val;
    } else {
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setRecordedCall()', 'PARAMETER_ERROR_SETRECORDEDCALL');
    }
  };
  /**
  * <b>Description</b>
  * <p>Client Configuration method that enables you to know if recorded Call option is activated or not.
  * See also : setRecordedCall
  *
  * @method getRecordedCall
  * @return {Boolean} True if recorded call feature is activated
  */


  this.getRecordedCall = function () {
    return this.webRTCClient.recordedCall;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to accept an incoming call if option UserAcceptOnIncomingCall is set to true</p>
  * <p>This will established the communication from the callee to the caller after user accept</p>
  *
  * @method acceptCall
  * @param {String} callId callId
  * @param {JSON} callConfiguration JSON with following parameters :
  * - mediaTypeForIncomingCall :This enables to choose the media type to answer an incoming call.
  * Value can be : VIDEO (audio and video will be used to answer), AUDIO (audio only), VIDEOONLY, NONE (answering call without sharing any media)
  * - mediaRoutingMode :This enables to choose the media routing mode.
  * - turnServerAddress : This enables to change the turn server used for the call
  * Value can be : hostOnly, stun, stunOnly, turn, turnOnly
  * - muted : This parameter enables to start a muted call.
  * Value can be : VIDEO (audio and video will be muted), AUDIOONLY (only audio will be muted), VIDEOONLY (only video will be muted)
  */


  this.acceptCall = function (callId, callConfiguration) {
    this.webRTCClient.acceptCall(callId, callConfiguration);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to refuse an incoming call if option UserAcceptOnIncomingCall is set to true</p>
  * <p>This will close the communication from the callee to the caller after user refuse</p>
  *
  * @method refuseCall
  * @param {String} callId callId
  */


  this.refuseCall = function (callId) {
    logger.info("refuseCall");
    this.webRTCClient.refuseCall(callId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to add video media on an established audio call</p>
  * <b>Associated events :</b>
  * addVideoMedia
  *
  * @method addVideoMedia()
  * @param {String} callId callId
  */


  this.addVideoMedia = function (callId) {
    logger.info("addVideoMedia");
    this.webRTCClient.addVideoMedia(callId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to update media during a call</p>
  * <b>Associated events :</b>
  * <li>userMediaSuccess</li>
  * <li>userMediaError</li>
  *
  * @method updateMediaDeviceOnCall
  * @param {String} callId callId
  * @param {(MediaStream|string)} [stream] Either MediaStream to switch to (deprecated), or userMediaStreamId.
  * @return {String} CallId : call identifier
  */


  this.updateMediaDeviceOnCall = function (callId, stream) {
    logger.info("updateMediaDeviceOnCall");
    callId = this.webRTCClient.updateMediaDeviceOnCall(callId, stream);
    return callId;
  };
  /**
   * <b>Description</b>
   * <p>Updates the media type during a call. Only for subscribe calls.</p>
   *
   * @method updateMediaTypeOnCall
   * @param {String} callId - Call identifier.
   * @param {String} mediaType - New media type. One of VIDEO, AUDIOONLY and VIDEOONLY.
   * @return {Promise} - Resolved when it is done.
   */


  this.updateMediaTypeOnCall = function (callId, mediaType) {
    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isTypeof)(callId, 'string') || mediaType !== 'VIDEO' && mediaType !== 'AUDIOONLY' && mediaType !== 'VIDEOONLY') {
      return Promise.reject('wrong arguments');
    }

    return this.webRTCClient.updateMediaTypeOnCall(callId, mediaType);
  }; //TODO Doc Completer description function releaseUserMedia

  /*
  * <b>Description</b>
  * <p></p>
  * <p></p>
  * <b>Associated events :</b>
  *
  * @method releaseUserMedia
  * @param
  */


  this.releaseUserMedia = function () {
    this.webRTCClient.releaseUserMedia();
  };
  /**
  * <b>Description</b>
  * <p>This method enables to filter audio codecs used by the webRTCClient</p>
  * <p>Value can be : opus/48000/2, ISAC/16000, ISAC/32000, PCMU/8000, PCMA/8000, G722/8000, CN/8000, CN/16000, CN/32000, telephone-event/8000, telephone-event/16000, telephone-event/32000, telephone-event/48000</p>
  *
  * @method setAllowedAudioCodecs
  * @param {string} availableCodecSet Comma delimited list of available codecs (codec/rate[/chans])
  */


  this.setAllowedAudioCodecs = function (val) {
    this.webRTCClient.allowedAudioCodecs = val;
  };
  /**
  * <b>Description</b>
  * <p>This method enables to filter video codecs used by the webRTCClient</p>
  * <p>Value can be : VP8/90000, H264/90000, red/90000, ulpfec/90000, rtx/90000</p>
  *
  * @method setAllowedVideoCodecs
  * @param {string} availableCodecSet Comma delimited list of available codecs (codec/rate[/chans])
  */


  this.setAllowedVideoCodecs = function (val) {
    this.webRTCClient.allowedVideoCodecs = val;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you set the maximum bandwidth that will be used for the audio stream </p>
  *
  * @method setAudioBandwidth
  * @param {String} bandwidth maximum bandwidth value
  */


  this.setAudioBandwidth = function (bandwidth) {
    this.webRTCClient.setAudioBandwidth(bandwidth);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you set the maximum bandwidth that will be used for the video stream </p>
  * @deprecated since apiRTC 4.3.13
  * @method setVideoBandwidth
  * @param {String} bandwidth maximum bandwidth value
  */


  this.setVideoBandwidth = function (bandwidth) {// Implementation removed due to janus (1-1.13.0.0) inability to parse a SDP containing both AS and TIAS.
  };
  /**
  * <b>Description</b>
  * <p>This method enables you set the maximum received bandwidth for the video stream </p>
  *
  * @method setRemoteVideoBandwidth
  * @param {String} bandwidth - Maximum bandwidth value (in kbps).
  */


  this.setRemoteVideoBandwidth = function (bandwidth) {
    if (typeof bandwidth !== 'number') {
      logger.error('Unvalid target bandwidth usage value needs to be a number :', bandwidth);
      return;
    }

    this.webRTCClient.setVideoBandwidth(bandwidth, 'remote');
  };
  /**
  * <b>Description</b>
  * <p>This method sets the maximum overall incoming video bandwidth.</p>
  *
  * @method setOverallIncomingVideoBandwidth
  * @param {Number} bandwidth - Maximum overall incoming video bandwidth (in kbps).
  */


  this.setOverallIncomingVideoBandwidth = function (bandwidth) {
    if (typeof bandwidth !== 'number') {
      logger.error('Unvalid target bandwidth usage value needs to be a number :', bandwidth);
      return;
    }

    this.webRTCClient.setVideoBandwidth(bandwidth, 'overall', 'incoming');
  };
  /**
  * <b>Description</b>
  * <p>This method sets the maximum overall outgoing video bandwidth.</p>
  *
  * @method setOverallOutgoingVideoBandwidth
  * @param {Number} bandwidth - Maximum overall outgoing video bandwidth (in kbps).
  */


  this.setOverallOutgoingVideoBandwidth = function (bandwidth) {
    if (typeof bandwidth !== 'number') {
      logger.error('Unvalid target bandwidth usage value needs to be a number :', bandwidth);
      return;
    }

    this.webRTCClient.setVideoBandwidth(bandwidth, 'overall', 'outgoing');
  };
  /**
  * <b>Description</b>
  * <p>This method sets the maximum per-call incoming video bandwidth.</p>
  *
  * @method setPerCallIncomingVideoBandwidth
  * @param {Number} bandwidth - Maximum per-call incoming video bandwidth (kbps).
  */


  this.setPerCallIncomingVideoBandwidth = function (bandwidth) {
    if (typeof bandwidth !== 'number') {
      logger.error('Unvalid target bandwidth usage value needs to be a number :', bandwidth);
      return;
    }

    this.webRTCClient.setVideoBandwidth(bandwidth, 'perCall', 'incoming');
  };
  /**
  * <b>Description</b>
  * <p>This method sets the maximum per-call outgoing video bandwidth.</p>
  *
  * @method setPerCallOutgoingVideoBandwidth
  * @param {Number} bandwidth - Maximum per-call outgoing video bandwidth (in kbps).
  */


  this.setPerCallOutgoingVideoBandwidth = function (bandwidth) {
    if (typeof bandwidth !== 'number') {
      logger.error('Unvalid target bandwidth usage value needs to be a number :', bandwidth);
      return;
    }

    this.webRTCClient.setVideoBandwidth(bandwidth, 'perCall', 'outgoing');
  };
  /**
  * <b>Description</b>
  * <p>This method enables you set the maximum bandwidth that will be used for the data stream </p>
  *
  * @method setDataBandwidth
  * @param {String} bandwidth maximum bandwidth value
  */


  this.setDataBandwidth = function (bandwidth) {
    this.webRTCClient.setDataBandwidth(bandwidth);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to create a MCUSession and to get a sessionId. On answer reception, local video will be pusblished</p>
  * <b>Associated events :</b>
  * <li>MCUSessionCreation</li>
  *
  * @method createMCUSession
  * @param {String} localDivId Id of the Div for local video
  * @param {String} remoteDivId Id of the Div for remote videos
  */


  this.createMCUSession = function (localDivId, remoteDivId) {
    logger.info("createMCUSession");
    this.webRTCClient.MCUClient.initDivElements(localDivId, remoteDivId);
    this.webRTCClient.MCUClient.createSession();
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to join an MCU session using a room Identifier. If room doesn't exist, it will be created</p>
   * <b>Associated events :</b>
   * <li>JoinMCUSessionAnswer</li>
   *
   * @method joinMCUSession
   * @param {string} roomId Identifier of the room to join
   * @param {object} options
   * @param {boolean} options.meshModeEnabled - Whether the mesh mode is enabled.
   * @param {boolean} options.meshOnlyEnabled - Whether the mesh mode is the only mode allowed, i.e. no transition to another will occur.
   * @param {boolean} options.moderationEnabled - Whether the moderation is enabled.
   * @param {boolean} options.moderator - Whether the user is moderator.
   * @paran {(string[]|object[])} options.supportedVideoCodecs - Preferred video codecs.
   * @param {boolean} options.qualityAdaptationEnabled - Whether quality adaptation shall be used instead of slow link adaptation.
   * @return {string} 'OK' on sucess, an Error otherwise.
   */


  this.joinMCUSession = function (roomId) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    logger.debug("joinMCUSession");

    if (!roomId) {
      return new Error('wrong roomId');
    }

    return this.webRTCClient.MCUClient.joinSession(roomId, options);
  }; //Modif_Fred TODO Doc


  this.getMCUStreamList = function () {
    logger.debug("getMCUStreamList");
    return this.webRTCClient.MCUClient.getStreamList();
  }; //Modif_Fred TODO Doc


  this.getStreamFromList = function (streamId) {
    logger.debug("getStreamFromList");
    return this.webRTCClient.MCUClient.getStreamFromList(streamId);
  }; //Modif_Fred TODO Doc


  this.getStreamIdOfUser = function (userId) {
    logger.debug("getStreamIdOfUser");
    return this.webRTCClient.MCUClient.getStreamIdOfUser(userId);
  }; //Modif_Fred TODO Doc


  this.getCallIdFromStreamId = function (streamId) {
    logger.debug("getCallIdFromStreamId");
    var call = this.webRTCClient.findCallWithStreamId(streamId);

    if (call === null) {
      logger.log("call not found in getCallIdFromStreamId");
      return null;
    } else {
      return call.callId;
    }
  };

  this.getCallIdFromRemoteMCUUser = function (userId) {
    logger.debug("getCallIdFromRemoteMCUUser");
    var streamId = null,
        call = null;
    streamId = this.webRTCClient.MCUClient.getStreamIdOfUser(userId);
    call = this.webRTCClient.findCallWithStreamId(streamId);

    if (call === null) {
      logger.log("call not found in getCallIdFromRemoteMCUUser");
      return null;
    } else {
      return call.callId;
    }
  };
  /**
   * <b>Description</b>
   * <b>The method enables you to eject a given participant from the current room.</b>
   * @method ejectUserFromMCUSession
   * @param {string} userId - Participant identifier.
   * @param {object} data - User data (optional).
   * @param {string} roomId - Room ID.
   */


  this.ejectParticipantFromMCUSession = function (userId, data, roomId) {
    this.webRTCClient.MCUClient.ejectParticipant(userId, data, roomId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to publish your stream in room.</p>
  *
  * @method publish
  * @param {String} roomId Identifier of the room to join
  * @param {String} sessionId Identifier of the session, received on joinMCUSessionAnswer event
  * @param {String} token token of the session, received on joinMCUSessionAnswer event
  * @param {JSON} callConfiguration JSON with following parameters : (parameter used to be audioOnly before apiRTC 3.11)
  * - audioOnly : true if publish is to be done in audio only. Video is used by default
  * - videoOnly : true if publish is to be done in video only. Video is used by default, audioOnly parameter is used in priority
  * - private : true if publish is to be done for the user only. This stream will not be shared with other participant in the conference : this can be used for instance to record the stream. Default value is false
  * - record : true if this stream has to be recorded on the server. Default value is false
  * - userMediaStreamId : user media stream to use.
  * @param {JSON} data parameter. JSON Data can be added on call and retrieved on CDR
  * @return {String} callId : callIdentifier of the published stream
  * @see joinMCUSession()
  * @see unpublish()
  */
  //INTERNAL PARAM : @param {object} options  - forceScreenSharingCallType {boolean} call will be specified as 'screenSharing' (used for external stream sources)


  this.publish = function (roomId, sessionId, token, callConfiguration, data, options) {
    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'IE') {
      logger.log('apiCC.session.webRTCPluginActivated =' + apiCC.session.webRTCPluginActivated);
      logger.log('apiCC.webRTCPluginInstalled =' + apiCC.webRTCPluginInstalled);
    }

    if ((_BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'IE' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser_major_version < 11) && apiCC.session.webRTCPluginActivated === true && apiCC.webRTCPluginInstalled === false) {
      logger.log("managing call with WebRTC Plugin");

      if (callConfiguration === undefined || callConfiguration === null) {
        callConfiguration = {};
      } //Generating a callId for the call


      callConfiguration.apzcallId = apiCC.generateCallId();
      apiCC.manageWebRTCPlugin(function () {
        apiCC.webRTCPluginInstalled = true;
        logger.info("manageWebRTCPlugin cb in call");
        var sessionMCU = this.webRTCClient.MCUClient.getSessionMCU(roomId);

        if (sessionMCU && sessionMCU.roomMode === 'mesh') {
          return this.webRTCClient.MCUClient.meshPublish(roomId, sessionId, token, callConfiguration, data, options);
        }

        logger.debug("publish");
        return this.webRTCClient.MCUClient.publish(roomId, sessionId, token, callConfiguration, data, options);
      }, function () {
        logger.log("actionOnInstallationNeeded");
      });
      return callConfiguration.apzcallId;
    }

    var sessionMCU = this.webRTCClient.MCUClient.getSessionMCU(roomId);

    if (sessionMCU && sessionMCU.roomMode === 'mesh') {
      return this.webRTCClient.MCUClient.meshPublish(roomId, sessionId, token, callConfiguration, data, options);
    }

    logger.debug("publish");
    return this.webRTCClient.MCUClient.publish(roomId, sessionId, token, callConfiguration, data, options);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to unpublish your stream in room.</p>
  *
  * @method unpublish
  * @param {String} callId callIdentifier of the published stream
  * @see publish()
  */


  this.unpublish = function (callId) {
    logger.info("unpublish");
    this.webRTCClient.MCUClient.unpublish(callId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to publish your screen stream in room.</p>
  *
  * @method publishScreen
  * @param {String} roomId Identifier of the room to join
  * @param {JSON} data parameter. JSON Data can be added on call and retrieved on CDR
  * @param {JSON} callConfiguration JSON with following parameters :
  * - private : true if publish is to be done for the user only. This stream will not be shared with other participant in the conference : this can be used for instance to record the stream. Default value is false
  * - record : true if this stream has to be recorded on the server. Default value is false
  * @param {JSON} captureSourceType. This enables to choose what the user will be propose to share between screen, applications, browser tab and audio. Value can be ["screen", "window", "tab", "audio"]
  * @return {String} callId : callIdentifier of the published stream
  * @see joinMCUSession()
  * @see unpublish()
  */


  this.publishScreen = function (roomId, data, callConfiguration, captureSourceType) {
    var sessionMCU = this.webRTCClient.MCUClient.getSessionMCU(roomId);

    if (sessionMCU && sessionMCU.roomMode === 'mesh') {
      logger.info("publishScreen");
      return this.webRTCClient.MCUClient.meshPublishScreen(roomId, data, callConfiguration, captureSourceType);
    }

    logger.info("publishScreen");
    return this.webRTCClient.MCUClient.publishScreen(roomId, data, callConfiguration, captureSourceType);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to subscribe to a stream in room.</p>
  *
  * @method subscribe
  * @param {String} streams Stream from which you want to subscribe
  * @param {String} mediaType value can be VIDEO (subscribe done to audio and video) - AUDIOONLY or VIDEOONLY - VIDEO is used by default
  * @param {JSON} data JSON Data can be added on call and retrieved on CDR
  * @param {JSON} callConfiguration JSON with following parameters :
  * - turnServerAddress This enables to change the turn server used for the call
  * @see joinMCUSession()
  * @see unsubscribe()
  */


  this.subscribe = function (streams, mediaType, data, callConfiguration, options) {
    logger.info("subscribe :", streams);

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'IE') {
      logger.log('apiCC.session.webRTCPluginActivated =' + apiCC.session.webRTCPluginActivated);
      logger.log('apiCC.webRTCPluginInstalled =' + apiCC.webRTCPluginInstalled);
    }

    if ((_BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'IE' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_3__.browser_major_version < 11) && apiCC.session.webRTCPluginActivated === true && apiCC.webRTCPluginInstalled === false) {
      logger.log("managing call with WebRTC Plugin");
      apiCC.manageWebRTCPlugin(function () {
        apiCC.webRTCPluginInstalled = true;
        logger.log("manageWebRTCPlugin cb in subscribe");

        if (typeof mediaType === 'boolean') {
          logger.warn("DEPRECATED : usage of audioOnly parameter on subscribe() is now replaced by mediatype with value VIDEO, AUDIOONLY or VIDEOONLY and will be deprecated in a next version of apiRTC");

          if (mediaType === true) {
            mediaType = 'AUDIOONLY';
          } else {
            mediaType = 'VIDEO';
          }
        }

        return apiCC.session.apiCCWebRTCClient.subscribe(streams, mediaType, data, callConfiguration);
      }, function () {
        logger.log("actionOnInstallationNeeded");
      });
      return "WebRTC_Plugin";
    }

    if (typeof mediaType === 'boolean') {
      logger.warn("DEPRECATED : usage of audioOnly parameter on subscribe() is now replaced by mediatype with value VIDEO, AUDIOONLY or VIDEOONLY and will be deprecated in a next version of apiRTC");

      if (mediaType === true) {
        mediaType = 'AUDIOONLY';
      } else {
        mediaType = 'VIDEO';
      }
    }

    return this.webRTCClient.MCUClient.subscribeToStreams(streams, mediaType, data, callConfiguration, options);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to unsubscribe to a stream in room.</p>
  *
  * @method unsubscribe
  * @param {String} streamId Identifier of the Stream you want to unsubscribe
  * @see subscribe()
  */


  this.unsubscribe = function (streamId) {
    logger.info("unsubscribe :", streamId);
    this.webRTCClient.MCUClient.unsubscribe(streamId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to start streaming your published stream</p>
  * <b>Associated events:</b>
  *
  * @method startStreaming
  * @param {String} service
  * @param {String} server
  * @param {String} streamKey
  * @param {String} callIdToStream callId if the call to stream
  * @see stopStreaming()
  * @see MCUStreamingStarted event
  */


  this.startStreaming = function (service, server, streamKey, callIdToStream) {
    logger.info("startStreaming");
    return this.webRTCClient.MCUClient.startStreaming(service, server, streamKey, callIdToStream);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to stop streaming your published stream</p>
  * <b>Associated events:</b>
  *
  * @method stopStreaming
  * @param {String} callIdToStream callId if the call to stream
  * @see stopStreaming()
  * @see MCUStreamingStopped event
  */


  this.stopStreaming = function (callIdToStream) {
    logger.info("stopStreaming");
    return this.webRTCClient.MCUClient.stopStreaming(callIdToStream);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to start recording your published stream</p>
  *
  * @method startRecording
  * @param {String} mediaType Value can be 'AUDIO-VIDEO' for recording audio and video, 'AUDIO-ONLY' to record audio only, 'VIDEO-ONLY' to record video only
  * @param {String} customIdInFilename This string will be added in recorded file name. This can enables you to identify your recorded files
  * @param {String} convId ConversationId used to store the recorded file entry on ApiRTC SMS
  * @param {String} callId callId of the call to record. By default, the callId linked to the published stream (publish()) is selected
  * @param {Object} data user data
  * @see stopRecording()
  * @see MCURecordingStarted event
  */


  this.startRecording = function (mediaType, customIdInFilename, convId, callIdToRecord, data) {
    logger.info("startRecording");
    this.webRTCClient.MCUClient.startRecording(mediaType, customIdInFilename, convId, callIdToRecord, data);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to stop the recording of your published stream</p>
  *
  * @method stopRecording
  * @param {String} callId callId of the call to stop recording. By default, the callId linked to the published stream (publish()) is selected
  * @see startRecording()
  * @see MCURecordedStreamsAvailable
  */


  this.stopRecording = function (callIdToRecord) {
    logger.info("stopRecording");
    this.webRTCClient.MCUClient.stopRecording(callIdToRecord);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to Change the priority of your published stream</p>
   *
   * @method changeStreamPriority
   * @param {string} callId - callId of the call
   * @param {number} priority - positive integer
   * @return {boolean} true one success, false otherwise.
   */


  this.changeStreamPriority = function (callId, priority) {
    var call = this.webRTCClient.findCallWithCallId(callId);

    if (!call) {
      // Not a regular call, maybe a mesh publish
      call = this.webRTCClient.findUserMediaById(callId);

      if (!call) {
        logger.error('changeStreamPriority - no such call', callId);
        return false;
      }
    }

    if (!call.sessionMCU) {
      logger.error('changeStreamPriority - no such sessionMCU');
      return false;
    }

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isTypeof)(priority, 'number') || priority < 0) {
      logger.error('changeStreamPriority - wrong priority', priority);
      return false;
    }

    var msgString = JSON.stringify({
      type: 'changeStreamPriority',
      roomId: call.sessionMCU.roomName,
      callerId: apiCC.session.apiCCWebRTCClient.webRTCClient.clientId,
      callId: callId,
      data: {
        pubSub: this.webRTCClient.MCUClient.pubConnector,
        priority: priority
      }
    });
    logger.log('C->S: ' + msgString);
    apiCC.session.channel.socket.emit('changeStreamPriority', msgString);
    return true;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to start a composite stream on media server. You will then be able to subscribe to this stream</p>
  *
  * @method startComposite
  * @param {string} roomId - Room ID.
  * @see stopComposite()
  * @see MCUAvailableComposite event
  */


  this.startComposite = function (roomId) {
    logger.info("startComposite");
    this.webRTCClient.MCUClient.startComposite(roomId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to stop a composite stream on media server</p>
  *
  * @method stopComposite
  * @param {string} roomId - Room ID.
  * @see startComposite()
  * @see MCUAvailableComposite event
  */


  this.stopComposite = function (roomId) {
    logger.info("stopComposite");
    this.webRTCClient.MCUClient.stopComposite(roomId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to start recording of part or all streams in the room.</p>
  * <p>The <i>mediaType</i> parameter allows you to directly select audio/video input for all
  * streams in the room. The default value is <i>AUDIO-VIDEO</i>. For custom stream selection,
  * you shall set <i>AUDIO-VIDEO</i> for this parameter and use the following parameters
  * instead: <i>data.mode</i>, <i>data.labelEnabled</i>, <i>data.labels</i>.</p>
  * <p>The <i>data.mode</i> parameter allows you to configure how streams will be rendered in the
  * media file. In the <i>complete</i> mode, selected audio-only streams will occupied the same
  * amount of place than video streams. In the <i>efficient</i> mode, selected audio-only streams
  * will not occupied any video space. In the <i>audioOnly</i> mode, only the audio part of
  * selected streams will be rendered and the media file will not contain any video
  * component.</p>
  * <p>The <i>data.labelEnabled</i> parameter activates the use of label(s) for stream
  * selection.</p>
  * <p>The <i>data.labels</i> parameter allows you to select stream(s). Only streams with
  * matching label will be rendered in the final media file.</p>
  *
  * @method startCompositeRecording
  * @param {string} mediaType - Either 'AUDIO-VIDEO' (default), 'AUDIO-ONLY' or 'VIDEO-ONLY'.
  * @param {string} customIdInFilename - String as part of the media filename.
  * @param {string} convId - Cloud conversation identifier.
  * @param {object} data - options.
  * @param {string} data.mode - Recording mode. Either 'complete' (default), 'efficient', 'audioOnly'.
  * @param {boolean} data.labelEnabled - Whether streams are selected based on label(s).
  * @param {object} data.labels - Array of labels (string) to select stream in the room.
  * @param {string} roomId - Room ID.
  * @see stopCompositeRecording()
  * @see MCURecordingStarted event
  */


  this.startCompositeRecording = function (mediaType, customIdInFilename, convId, data, roomId) {
    logger.info("startCompositeRecording");
    this.webRTCClient.MCUClient.startCompositeRecording(mediaType, customIdInFilename, convId, data, roomId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to stop recording the composite stream of the room</p>
  *
  * @method stopCompositeRecording
  * @param {string} roomId - Room ID.
  * @see startCompositeRecording()
  * @see MCURecordedStreamsAvailable
  */


  this.stopCompositeRecording = function (roomId) {
    logger.info("stopCompositeRecording");
    this.webRTCClient.MCUClient.stopCompositeRecording(roomId);
  };

  this.checkCallExist = function (callId) {
    var call = null;

    for (var callIdx = this.webRTCClient.callsTable.length; --callIdx >= 0;) {
      var c = this.webRTCClient.callsTable[callIdx];

      if (c.callId === callId && c.data && c.sessionMCU && (c.data.MCUType === 'MCU-Caller' || c.data.MCUType === 'MCU-Callee') && c.data.confId === c.sessionMCU.roomName) {
        call = c;
        break;
      }
    } // for


    if (!call) {
      logger.error('startCallRecording: no such call');
    }

    return call;
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to start recording a call.</p>
   * <p>Only available for recorded call.</p>
   *
   * @method startCallRecording
   * @param {string} callId - Call identifier.
   */


  this.startCallRecording = function (callId) {
    var call = null;
    call = this.checkCallExist(callId);

    if (call) {
      var data = (0,_Utils__WEBPACK_IMPORTED_MODULE_4__.assignObject)({}, call.data);
      this.webRTCClient.MCUClient.startCompositeRecording('AUDIO-VIDEO', null, call.sessionMCU.convId, data, call.sessionMCU.roomName);
    }
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to stop recording a call.</p>
   * <p>Only available for recorded call.</p>
   *
   * @method startCallRecording
   * @param {string} callId - Call identifier.
   */


  this.stopCallRecording = function (callId) {
    var call = null;
    call = this.checkCallExist(callId);

    if (call) {
      this.webRTCClient.MCUClient.stopCompositeRecording(call.sessionMCU.roomName);
    }
  };
  /**
   * <b>Description</b>
   * <p>This method enforces the use of MCU/SFU gateway.</p>
   *
   * @method enforceMCU
   * @param {string} roomId - Room ID.
   */


  this.enforceMCU = function (roomId) {
    this.webRTCClient.MCUClient.enforceMCU(roomId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to take a snapshot of a contact during an MCU session</p>
  *
  * @method takeSnapshotOnMCUSession
  * @param {String} remoteId Id of the contact for which we want to get the photo. If remoteId = 0, it take snapshot of the local user
  * @return a base-64-encoded string of PNG data representing the contact video
  */


  this.takeSnapshotOnMCUSession = function (remoteId) {
    logger.info("takeSnapshotOnMCUSession");
    var imgData = this.webRTCClient.MCUClient.takeSnapshot(remoteId);
    return imgData;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to invite a remote party to the MCU session</p>
  * <b>Associated events :</b>
  * <li>receiveMCUSessionInvitation</li>
  *
  * @method sendMCUSessionInvitation
  * @param {String} destId Identifier of the destination to invite on the MCU session
  * @param {String} sessionId Identifier of the session
  * @param {String} [groupChatId] Identifier of the groupChat if any
  */


  this.sendMCUSessionInvitation = function (destId, sessionId, groupChatId) {
    this.webRTCClient.MCUClient.sendSessionInvitation(destId, sessionId, groupChatId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to invite all users that are connected to a group Chat for an MCU session</p>
  * <b>Associated events :</b>
  * <li>receiveMCUSessionInvitation</li>
  *
  * @method sendMCUSessionInvitationToGroupChat
  * @param {String} groupChatId Identifier of the groupChat where user to invite are connected
  * @param {String} sessionId Identifier of the session
  */


  this.sendMCUSessionInvitationToGroupChat = function (groupChatId, sessionId) {
    this.webRTCClient.MCUClient.sendSessionInvitationToGroupChat(groupChatId, sessionId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to accept an MCU Invitation. User stream will be published on the MCU session</p>
  *
  * @method acceptMCUSessionInvitation
  * @param {String} sessionId Identifier of the session
  * @param {String} token Identifier of the user for the session
  * @param {String} localDivId Id of the Div for local video
  * @param {String} remoteDivId Id of the Div for remote videos
  */


  this.acceptMCUSessionInvitation = function (sessionId, token, localDivId, remoteDivId) {
    this.webRTCClient.MCUClient.initDivElements(localDivId, remoteDivId);
    this.webRTCClient.MCUClient.acceptSessionInvitation(sessionId, token);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to leave the MCU session</p>
   * @method leaveMCUSession
   * @param {String} roomId Identifier of the room to leave
   * @return {String} Result of leaveMCUSession : 'OK' or Error()
   */


  this.leaveMCUSession = function (roomId) {
    this.webRTCClient.MCUClient.leaveSession(roomId);
  };

  this.recordStream = function (stream) {
    logger.info("recordStream :", stream);

    if (MediaRecorder === undefined) {
      logger.debug("MediaRecorder is not supported on this browser, leaving recordStream process"); //TODO remonter erreur

      return;
    }

    apiCC.recordMgr.record(stream).then(function () {
      logger.log("Recording started");
    })["catch"](function (error) {
      // error
      logger.error('startRecord failed :', error);
    });
  };

  this.stopRecordStream = function (stopcallback) {
    logger.info("stopRecordStream");

    if (MediaRecorder === undefined) {
      logger.debug("MediaRecorder is not supported on this browser, leaving recordStream process"); //TODO remonter erreur

      return;
    }

    apiCC.recordMgr.stop().then(function (recordedVideoBuffer) {
      logger.log("Recording stopped");
      stopcallback(recordedVideoBuffer);
    })["catch"](function (error) {
      // error
      logger.error('stopRecord failed :', error);
    });
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to get the media device list available on your devices.
  *
  * @method getMediaDevices
  * @param {Function} callback function that will be call on success
  *     <p>Exemple :<br>
  *     function gotSources(sourceInfos) {...}<br>
  *     webRTCClient.getMediaDevices(gotSources);</p>
  *
  *     DEPRECATED - prefer the usage of apiCC.getMediaDevices() which return a promise
  */


  this.getMediaDevices = function (callback) {
    logger.debug('getMediaDevices 2');
    apiCC.getMediaDevices().then(function (sources) {
      callback(sources);
      apiCC.mediaDeviceMgr.gotSources(sources);
    })["catch"](function (err) {
      callback(null);
      apiCC.mediaDeviceMgr.gotSources(null);
    });
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set the audio media device to use for webRTC calls</p>
  * <p>Your choice will be store in your browser local Storage in order to keep the configuration after a page reload</p>
  *
  * @method setAudioSourceId
  * @param {String} Id Id of the audio source
  */


  this.setAudioSourceId = function (audioSourceId) {
    logger.info('setAudioSourceId :' + audioSourceId);
    this.webRTCClient.audioSourceId = audioSourceId;
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to set the audio output to use for webRTC calls</p>
   * <p>Your choice will be store in your browser local Storage in order to keep the configuration after a page reload</p>
   *
   * @method setaudioOutputId
   * @param {String} Id Id of the audio output
   */


  this.setAudioOutputId = function (audioOutputId) {
    logger.info('setaudioOutputId :' + audioOutputId);
    this.webRTCClient.audioOutputId = audioOutputId;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set the video media device to use for webRTC calls</p>
  * <p>Your choice will be store in your browser local Storage in order to keep the configuration after a page reload</p>
  *
  * @method setVideoSourceId
  * @param {String} Id Id of the video source
  */


  this.setVideoSourceId = function (videoSourceId) {
    logger.info('setVideoSourceId :' + videoSourceId);
    this.webRTCClient.videoSourceId = videoSourceId;
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set the video mode to select camera to use for webRTC calls. This is usefull for iOS devices where media deviceId can change</p>
  * <p>This method override any videoSourceId settings.</p>
  *
  * @method setVideoFacingMode
  * @param {String} facingMode should be equal to 'user', 'environment', 'left', 'right' or 'deactivated'.
  */


  this.setVideoFacingMode = function (facingMode) {
    logger.info('setVideoFacingMode :' + facingMode);

    if (facingMode !== 'user' && facingMode !== 'environment' && facingMode !== 'left' && facingMode !== 'right' && facingMode !== 'deactivated') {
      logger.log('facingMode value is not correct');
      return;
    }

    if (facingMode === 'deactivated') {
      this.webRTCClient.facingMode = null;
    } else {
      this.webRTCClient.facingMode = facingMode;
    }
  };
  /**
  * <b>Description</b>
  * <p>This method enables you attach the media stream to your video element</p>
  *
  * @method attachMediaStream
  * @param {DOMElement} videoElt video element where the media stream has to be displayed
  * @param {MediaStream} stream stream that need to be attached
  */


  this.attachMediaStream = function (videoElt, stream) {
    logger.debug('attachMediaStream');
    apiCC.attachMediaStream(videoElt, stream);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to add media stream in Div</p>
  * @method addStreamInDiv
  * @param {stream} stream stream to be addded in the div
  * @param {String} streamType Type of the stream to be added in Div : can be audio, video or screenSharing
  * @param {String} divId Div Id where to add the stream
  * @param {String} mediaEltId Id of the media element that will be added in the div
  * @param {String} style Json string with format {width : "160px", height : "120px"} to define width and height of the media element
  * @param {Boolean} muted Boolean to set if media element is muted or not
  */


  this.addStreamInDiv = function (stream, streamType, divId, mediaEltId, style, muted) {
    logger.debug('addStreamInDiv');
    apiCC.addStreamInDiv(stream, streamType, divId, mediaEltId, style, muted);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to to remove media stream element from Div</p>
  * @method removeElementFromDiv
  * @param {String} divId Div Id where to add the stream
  * @param {String} mediaEltId Id of the media element that will be added in the div
  */


  this.removeElementFromDiv = function (divId, eltId) {
    logger.debug('removeElementFromDiv');
    apiCC.removeElementFromDiv(divId, eltId);
  };
  /**
  * <b>Description</b>
  * <p>This method enables you to set the selected stream</p>
  * @method setSelectedStream
  * @param {MediaStream} MediaStream to select as local video
  * @deprecated Use 'Hangup' event
  */


  this.setSelectedStream = function (stream) {
    logger.warn("setSelectedStream() is now deprecated");
  };

  this.callback = function (that, fnct) {
    this.closureHandler = function (e) {
      return that[fnct](e);
    };

    return this.closureHandler;
  };

  this.startPrecallTest = function (precallTestTerminated, enableCamResolutionTest, maxVideoBandwidth, audioSourceId, videoSourceId) {
    var btConfig = {
      'webRTCClient': this,
      'notifyTerminated': precallTestTerminated
    };
    this.callTest = new _PreCallTest__WEBPACK_IMPORTED_MODULE_2__.PreCallTest(btConfig, enableCamResolutionTest, maxVideoBandwidth, audioSourceId, videoSourceId);
    this.callTest.runBitRateTest();
  };
}; //End of @class ApiCCWebRTCClient

/**
 * Fired on incoming Call on your client
 * @event incomingCall
 * @param {String} type - 'incomingCall'.
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'incomingCall'.
 * @param {String} detail.time - Date
 * @param {String} detail.callId - callId
 * @param {String} detail.clientId - clientId
 * @param {String} detail.callerId - callerId
 * @param {String} detail.callerNickname - callerNickname
 * @param {Boolean} detail.autoAnswerActivated - autoAnswerActivated
 * @param {String} detail.callNumber - established callNumber for the client (the incoming call is included)
 * @param {Boolean} detail.audioOnly - audioOnly
 * @param {String} detail.callType - callType value can be 'screenSharing' or 'media' in other case
 * @param {Boolean} detail.recordedCall - used to indicate if the call is recorded or not
 */

/**
 * Fired on receiving a Call Attempt on your client. For instance, on a second call reception if multiple calls are not allowed
 * @event callAttempt
 * @param {String} type - 'callAttempt'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'callAttempt'
 * @param {String} detail.time Date
 * @param {String} detail.clientId - clientId
 * @param {String} detail.callerId - callerId
 * @param {String} detail.callerNickname - callerNickname
 */

/**
 * Fired on outgoing call when call is established : the callee has accepted the call and the call is established
 * @event callEstablished
 * @param {String} type - 'callEstablished'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'callEstablished'
 * @param {String} detail.time - Date
 * @param {String} detail.calleeId - calleeId
 * @param {String} detail.callType - callType value can be 'screenSharing' or 'media' in other case
 * @param {String} detail.callId - call identifier
 * @param {String} detail.destCallType - callType for the calling party : value can be 'audio' or 'media' in other case (If destination has no Webcam, destCallType will be audio)
 */

/**
 * Fired on Hangup : remote user has leaved the call or local user has hanged up (This event is send on hangup() or if remote user leave the web site)
 * @event hangup
 * @param {String} type - 'hangup'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'hangup'
 * @param {String} detail.time - Date
 * @param {String} detail.hangupType - Type of hangup, can be: 'local' or 'remote'
 * @param {String} detail.clientId - clientId
 * @param {String} detail.remoteId - remoteId
 * @param {String} detail.lastEstablishedCall - true or false, indicate whether it is the last established call for the WebRTC Client (several calls can be established in case of conferencing)
 * @param {String} detail.reason - reason can have the value :
<ul>
    <li>User_Busy : user is already in communication and simultaneous calls are not activated.</li>
    <li>User_Refused_Call : user has refused the call.</li>
    <li>User_Media_Error : error when accessing media device on getUserMedia  : there is a failure in finding valid tracks or the user denies permission. This reason can happened on caller and callee side.</li>
    <li>Hangup_From_Callee : the callee has hangup.</li>
    <li>Hangup_From_Caller : the caller has hangup.</li>
    <li>stop_ScreenSharing : screenSharing has been stopped.</li>
    <li>Ice_disconnected : a disconnection has been detected on media connection. This may be due to a network issue during the call.</li>
    <li>Ice_failed : media connection was not possible during the call establishment. This may be due to a network or firewall issue.</li>
    <li>WebRTC_Plugin_Installation_needed : user need to install the webRTC plugin to be able to establish calls.</li>
    <li>User_Not_Found : Destination is not connected</li>
    <li>disconnected : a disconnection has been detected on signaling connection. This may be due to a network issue during the call.</li>
    <li>call take on other device : destination was connected on two different apiRTC Client (several device or browser tabs) and has answered the call on the other client.</li>
    <li>bye on other device: destination was connected on two different apiRTC Client (several device or browser tabs) and has hangup or refuse the call on the other client.</li>
    <li>DataChannel_Not_Supported : call was ended as Datachannel is not supported on user's Browser</li>
</ul>
Some additional reason are available on our dashboard :
<ul>
    <li>200OKNotSended : call was accepted but caller was disconnected and we were not able to send the call acceptation</li>
    <li>ByeNotSended : we were not able to send the call end information as user was disconnected</li>
    <li>Remote_Socket_Disconnection_Detected : a disconnection was detected on signaling connection on remote side</li>
    <li>Socket_Disconnection_Detected : a disconnection was detected on signaling connection on user side</li>
</ul>
 */

/**
 * Fired on remote Hangup : remote user has leaved the call. (This event is send on hangup() or if user leave the web site)
 * @event remoteHangup
 * @deprecated Use 'Hangup' event
 * @param {String} type - 'remoteHangup'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'remoteHangup'
 * @param {String} detail.time - Date
 * @param {String} detail.clientId - clientId
 * @param {String} detail.remoteId - remoteId
 * @param {String} detail.lastEstablishedCall - true or false, indicate whether it is the last established call for the WebRTC Client (several calls can be established in case of conferencing)
 * @param {String} detail.reason - reason can have the value  : User_Busy, User_Refused_Call, User_Media_Error, Hangup_From_Callee, Hangup_From_Caller, WebRTC_Plugin_Installation_needed, DataChannel_Not_Supported
 * @param {String} detail.callType - callType of the call
 */

/**
 * Fired on user media access success : user has granted the access to his micro and webcam
 * @event userMediaSuccess
 * @param {String} type - 'userMediaSuccess'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'userMediaSuccess'
 * @param {String} detail.time - Date
 * @param {String} detail.onCallEstablishment - true or false, indicate whether access to media has been requested on call establishment or not (can be requested on autoAnswer feature activation)
 * @param {Boolean} detail.audioIsAvailable - true if audio is present in the stream
 * @param {String} detail.audioDeviceLabel - label of the audio device used
 * @param {Boolean} detail.videoIsAvailable - true if video is present in the stream
 * @param {String} detail.videoDeviceLabel - label of the video device used
 * @param {String} detail.callType - value can be 'media' or screenSharing
 * @param {String} detail.callId - call Identifier if access is requested on call. Value can be null if media access is requested outside of a call context
 * @param {MediaStream} detail.stream - local stream generated by getUserMedia()
 * @param {String} detail.remoteId - Id of the remote user
 */

/**
 * Fired on user media access error : user has not granted the access to his micro and webcam or brower was not able to access medias
 * @event userMediaError
 * @param {String} type - 'userMediaError'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'userMediaError'
 * @param {String} detail.time - Date
 * @param {String} detail.onCallEstablishment - true or false, indicate whether access to media has been requested on call establishment or not (can be requested on autoAnswer feature activation)
 * @param {String} detail.callType - value can be 'media' or screenSharing
 * @param {Object} detail.error - error given by WebRTC API
 */

/**
 * Fired on user media stop : user has stop sharing the access to his micro, webcam and/or screen
 * @event userMediaStop
 * @param {String} type - 'userMediaStop'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'userMediaStop'
 * @param {String} detail.time - Date
 * @param {String} detail.callId - Id of the call, if userMedia was link to a call
 * @param {String} detail.mediaType - value can be 'media' or 'screen'
 */

/**
 * Fired when the recorded file is available on the server
 * @event recordedFileAvailable
 * @param {String} type - 'recordedFileAvailable'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'recordedFileAvailable'
 * @param {String} detail.time - Date
 * @param {String} detail.fileName - fileName and link of the recorded file
 */

/**
 * Fired when the record is stopped : timeout is reached or user stop the record
 * @event stopRecord
 * @param {String} type - 'stopRecord'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'stopRecord'
 * @param {String} detail.time - Date
 */

/**
 * Fired at the end of the call when the recorded streams are available on the server
 * @event recordedStreamsAvailable
 * @param {String} type - 'recordedStreamsAvailable'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'recordedStreamsAvailable'
 * @param {String} detail.time - Date
 * @param {String} detail.confId - Identifier of the conference
 * @param {String} detail.userId1 - Identifier of the first user
 * @param {String} detail.userId2 - Identifier of the second user
 */

/**
 * Fired when photoSnapShop is uploaded on the server
 * @event snapShotPhotoUploaded
 * @param {String} type - 'snapShotPhotoUploaded'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'snapShotPhotoUploaded'
 * @param {String} detail.time - Date
 * @param {String} detail.filename - fileName of the uploaded photo
 */

/**
 * Fired on desktopCapture event
 * @event desktopCapture
 * @param {String} type - 'desktopCapture'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'desktopCapture'
 * @param {String} detail.time - Date
 * @param {String} detail.event - event that has happened. Values can be : UserMediaError_HTTPS_needed, UserMediaError, Extension_installation_Error, Extension_not_installed, Browser_Not_Compatible
 * @param {String} detail.callId - callId of the screenCapture call
 * @param {String} detail.remoteId - remoteId of the screenCapture call
 */

/**
 * Fired on switchStream event
 * @event switchStream
 * @param {String} type - 'switchStream'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'switchStream'
 * @param {String} detail.time - Date
 * @param {String} detail.callId - callId of the screenCapture call
 * @param {String} detail.stream - stream that is now sended to the call party
 */

/**
 * Fired when MCU Session Creation is received
 * @event MCUSessionCreation
 * @param {String} type - 'MCUSessionCreation'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'MCUSessionCreation'
 * @param {String} detail.sessionId - Id of the MCU session
 * @param {String} detail.token - token of the MCU session
 */

/**
 * Fired when MCU Session Invitation is received
 * @event receiveMCUSessionInvitation
 * @param {String} type - 'receiveMCUSessionInvitation'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'receiveMCUSessionInvitation'
 * @param {String} detail.sessionId - Id of the MCU session
 * @param {String} detail.token - user token for the session
 * @param {String} detail.groupChatId - Id of the groupChat or 0 if the invitation is not linked to a groupChat
 * @param {String} detail.initiatorId - Id of the invitation initiator
 */

/**
 * Fired when receive DataChannel is opened
 * @event receiveDataChannelOpen
 * @param {String} type - 'receiveDataChannelOpen'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'receiveDataChannelOpen'
 * @param {String} detail.callId - Id of datachannel call
 * @param {String} detail.evt - dataChannel onOpen event
 */

/**
 * Fired when receive DataChannel is closed
 * @event receiveDataChannelClose
 * @param {String} type - 'receiveDataChannelClose'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'receiveDataChannelClose'
 * @param {String} detail.callId - Id of datachannel call
 * @param {String} detail.evt - dataChannel onClose event
 */

/**
 * Fired when an error occurs on receive DataChannel
 * @event receiveDataChannelError
 * @param {String} type - 'receiveDataChannelError'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'receiveDataChannelError'
 * @param {String} detail.callId - Id of datachannel call
 * @param {String} detail.evt - dataChannel onError event
 */

/**
 * Fired when send DataChannel is opened
 * @event sendDataChannelOpen
 * @param {String} type - 'sendDataChannelOpen'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'sendDataChannelOpen'
 * @param {String} detail.callId - Id of datachannel call
 * @param {String} detail.evt - dataChannel onOpen event
 */

/**
 * Fired when send DataChannel is closed
 * @event sendDataChannelClose
 * @param {String} type - 'sendDataChannelClose'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'sendDataChannelClose'
 * @param {String} detail.callId - Id of datachannel call
 * @param {String} detail.evt - dataChannel onClose event
 */

/**
 * Fired when an error occurs on send DataChannel
 * @event sendDataChannelError
 * @param {String} type - 'sendDataChannelError'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'sendDataChannelError'
 * @param {String} detail.callId - Id of datachannel call
 * @param {String} detail.evt - dataChannel onError event
 */

/**
 * Fired when file has been sended
 * @event onFileSended
 * @param {String} type - 'onFileSended'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'onFileSended'
 * @param {String} detail.callId - Id of datachannel call
 * @param {String} detail.name - name of the sended file
 * @param {String} detail.uuid - Unique identifier of the receiving file
**/

/**
 * Fired when file sending has started
 * @event onFileSending
 * @param {String} type - 'onFileSending'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'onFileSending'
 * @param {String} detail.callId - Id of datachannel call
 * @param {String} detail.name - name of the sending file
 * @param {String} detail.uuid - Unique identifier of the receiving file
 */

/**
 * Fired when file sending has started
 * @event onFileProgress
 * @param {String} type - 'onFileSending'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'onFileSending'
 * @param {String} detail.callId - Id of datachannel call
 * @param {String} detail.name - name of the sending file
 * @param {String} detail.uuid - Unique identifier of the receiving file
 * @param {String} detail.sendChunkNb - Number of chunk already emitted
 * @param {String} detail.fileSize - Total file size
 * @param {String} detail.remainingSize - Size remaining to transfer
 * @param {String} detail.remoteId - Identifier of the remote user
 * @param {String} detail.lastPacket - Last packet transfered
 * @param {String} detail.startingDate - Date of transfer beginning
 * @param {String} detail.transferDuration - Time since start of transfer
 * @param {String} detail.percentage - Transfer progression in percent
 * @param {Boolean} detail.transferEnded - indicate if transfer is terminated or not
 */

/**
 * Fired when file receiving has started
 * @event onFileReceiving
 * @param {String} type - 'onFileReceiving'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'onFileReceiving'
 * @param {String} detail.callId - Id of datachannel call
 * @param {String} detail.remoteId - Id file emitter
 * @param {String} detail.name - name of the receiving file
 * @param {String} detail.uuid - Unique identifier of the receiving file
 */

/**
 * Fired when file is received
 * @event onFileReceived
 * @param {String} type - 'onFileReceived'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'onFileReceived'
 * @param {String} detail.callId - Id of datachannel call
 * @param {String} detail.remoteId - Id file emitter
 * @param {File|image} detail.data.file - received file
 * @param {String} detail.data.name - name of the received file
 * @param {String} detail.data.type - type of the received file
 * @param {String} detail.data.uuid - Unique identifier of the received file
 * @param {String} detail.evt - dataChannel onMessage event
 */

/**
 * Fired when webRTC Plugin installation is asked
 * @event webRTCPluginInstallation
 * @param {String} type - 'webRTCPluginInstallation'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'webRTCPluginInstallation'
 */

/**
 * Fired when the browser can start playing the specified remote video
 * @event remoteStreamAdded
 * @param {String} type - "remoteStreamAdded"
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - "remoteStreamAdded"
 * @param {String} detail.time - Date
 * @param {String} detail.callId - Identifier of call
 * @param {String} detail.callType - callType value can be 'screenSharing' or 'media' in other case
 * @param {MediaStream} detail.stream - added remote stream
 * @param {String} detail.remoteId - Id of the remote user
 * @param {String} detail.destCallType - callType for the calling party : value can be 'audio' or 'media' in other case (If destination has no Webcam, destCallType will be audio)
 */

/**
 * Fired when the specified remote video is removed
 * @event remoteStreamRemoved
 * @param {String} type - "remoteStreamRemoved"
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - "remoteStreamRemoved"
 * @param {String} detail.time - Date
 * @param {String} detail.callId - Identifier of call
 * @param {String} detail.callType - callType value can be 'screenSharing' or 'media' in other case
 * @param {MediaStream} detail.stream - added remote stream
 * @param {String} detail.remoteId - Id of the remote user
 * @param {String} detail.destCallType - callType for the calling party : value can be 'audio' or 'media' in other case (If destination has no Webcam, destCallType will be audio)
 */

/**
 * Fired when the specified local media is removed
 * @event localStreamRemoved
 * @param {String} type - "localStreamRemoved"
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - "localStreamRemoved"
 * @param {String} detail.time - Date
 * @param {String} detail.callId - Identifier of call
 * @param {String} detail.callType - callType value can be 'screenSharing' or 'media' in other case
 * @param {MediaStream} detail.stream - added local stream
 * @param {String} detail.remoteId - Id of the remote user
 * @param {String} detail.destCallType - callType for the calling party : value can be 'audio' or 'media' in other case (If destination has no Webcam, destCallType will be audio)
 */

/**
 * Fired when you are connected to the room
 * @event joinMCUSessionAnswer
 * @param {String} type - 'joinMCUSessionAnswer'.
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'joinMCUSessionAnswer'.
 * @param {String} detail.sessionId - Identifier of the session
 * @param {String} detail.token - token associated to the session
 * @param {String} detail.groupChatId - Identifier of the groupChat associated to the session
 * @see MCURemoveStream event
 */

/**
 * @typedef {Object} StreamInfo
 * @property {String} id - Stream ID.
 * @property {String} room - Room ID.
 * @property {Boolean} audio - Whether the audio track is active.
 * @property {Boolean} video - Whether the video track is active.
 * @property {Boolean} audioMuted - Whether the audio track is muted.
 * @property {Boolean} videoMuted - Whether the video track is muted.
 * @property {Boolean} screen - Whether the stream is a screen share.
 * @property {Boolean} sip - Whether the stream comes from a SIP gateway.
 * @property {Object} attributes - Information about stream owner.
 * @property {String} attributes.name - Stream name.
 * @property {String} attributes.callType -
 * @property {String} attributes.callId - Call ID.
 * @property {String} attributes.callerId - User ID of the stream owner.
 */

/**
 * Fired when new streams are available on MCU session.
 * @event MCUAvailableStream
 * @param {String} type - 'MCUAvailableStream'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'MCUAvailableStream'
 * @param {Array<StreamInfo>} detail.streams - streams that are available on session
 * @param {String} detail.isRemoteStream - Boolean that indicate if this is your own stream or the one of of a remote party
 * @see MCURemoveStream event
 */

/**
 * Fired when streams changed on MCU session.
 * @event MCUAvailableStreamUpdate
 * @param {String} type - 'MCUAvailableStreamUpdate'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'MCUAvailableStreamUpdate'
 * @param {Array<StreamInfo>} detail.streams - streams that are available on session
 * @param {String} detail.isRemoteStream - Boolean that indicate if this is your own stream or the one of of a remote party
 * @see MCUAvailableStream event
 */

/**
 * Fired when new streams are removed from an MCU session
 * @event MCURemoveStream
 * @param {String} type - 'MCURemoveStream'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'MCURemoveStream'
 * @param {String} detail.streamId - Identifier of the removed stream
 * @see MCUAvailableStream event
 */

/**
 * Fired when new recorded streams are available on an MCU session
 * @event MCURecordedStreamsAvailable
 * @param {String} type - 'MCURecordedStreamsAvailable'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'MCURecordedStreamsAvailable'
 * @param {Boolean} detail.roomName - Name of the room
 * @param {Boolean} detail.callId - Call Identifier of the published stream, or 'COMPOSITE'
 * @param {Boolean} detail.clientId - Identifier of the client
 * @param {String} detail.recordType - Type of record. Value can either be 'userStream' or 'composite'.
 * @param {String} detail.recordStartTime - Recording start time
 * @param {String} detail.convId - Cloud conversation ID.
 * @param {String} detail.mediaId - Cloud media ID.
 * @param {String} detail.mediaURL - Cloud media URL.
 * @param {String} detail.remoteId - User Id of remote user (for recorded call).
 * @param {String} detail.recordedFileName - Name of final media file.
 * @param {String} detail.mediaType - The media type defined at recording start.
 * @param {Object} detail.descriptor
 * @param {String} detail.descriptor.mode - The recording mode defined at recording start.
 * @param {String} detail.descriptor.labelEnabled - Whether label use was enabled at recording start.
 * @param {String} detail.descriptor.labels - The recording labels defined at recording start.
 */

/**
 * Fired when a recording started
 * @event MCURecordingStarted
 * @param {String} type - 'MCURecordingStarted'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'MCURecordingStarted'
 * @param {Boolean} detail.roomName - Name of the room
 * @param {Boolean} detail.callId - Call Identifier of the published stream, or 'COMPOSITE'
 * @param {Boolean} detail.clientId - Identifier of the client
 * @param {String} detail.recordType - Type of record. Value can either be 'userStream' or 'composite'.
 * @param {String} detail.recordStartTime - Recording start time
 * @param {String} detail.convId - Cloud conversation ID.
 * @param {String} detail.mediaId - Cloud media ID.
 * @param {String} detail.mediaURL - Cloud media URL.
 * @param {String} detail.remoteId - User Id of remote user (for recorded call).
 * @param {String} detail.recordedFileName - Name of final media file.
 * @param {String} detail.mediaType - The media type defined at recording start.
 * @param {Object} detail.descriptor
 * @param {String} detail.descriptor.mode - The recording mode defined at recording start.
 * @param {String} detail.descriptor.labelEnabled - Whether label use was enabled at recording start.
 * @param {String} detail.descriptor.labels - The recording labels defined at recording start.
 */

/**
 * Fired when a recording stopped
 * @event MCURecordingStopped
 * @param {String} type - 'MCURecordingStopped'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'MCURecordingStopped'
 * @param {Boolean} detail.roomName - Name of the room
 * @param {Boolean} detail.callId - Call Identifier of the published stream, or 'COMPOSITE'
 * @param {Boolean} detail.clientId - Identifier of the client
 * @param {String} detail.recordType - Type of record. Value can either be 'userStream' or 'composite'.
 * @param {String} detail.recordStartTime - Recording start time
 * @param {String} detail.convId - Cloud conversation ID.
 * @param {String} detail.mediaId - Cloud media ID.
 * @param {String} detail.mediaURL - Cloud media URL.
 * @param {String} detail.remoteId - User Id of remote user (for recorded call).
 * @param {String} detail.recordedFileName - Name of final media file.
 * @param {String} detail.mediaType - The media type defined at recording start.
 * @param {Object} detail.descriptor
 * @param {String} detail.descriptor.mode - The recording mode defined at recording start.
 * @param {String} detail.descriptor.labelEnabled - Whether label use was enabled at recording start.
 * @param {String} detail.descriptor.labels - The recording labels defined at recording start.
 */

/**
 * Fired when new composite stream is available on an MCU session
 * @event MCUAvailableComposite
 * @param {String} type - 'MCUAvailableComposite'
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.eventType - 'MCUAvailableComposite'
 * @param {Boolean} detail.streams - streams that are available on session
 * @param {String} detail.isRemoteStream - Boolean that indicate if this is your own stream or the one of of a remote party
 */

/**
 * Fired when a call is restarted after a disconnection
 * @event callRestarting
 * @param {String} type - 'callRestarting'.
 * @param {Object} detail - Event detail.
 * @param {String} detail.time Date
 * @param {String} detail.eventType 'callRestarting'
 * @param {String} detail.dataType - Type of MCU call. Value can be 'publish' or 'subscribe'. May be null.
 * @param {String} detail.destRoom - Destination room, this value is given in case of a publish call
 * @param {String} detail.streamId - Identifier of the stream, this value is given in case of a subscribe call
 * @param {Boolean} detail.audioOnly - Boolean that indicate if the call is audioOnly
 * @param {String} detail.callType - Type of call, can be media, screenSharing.
 * @param {String} detail.clientId - Identifier of the local client.
 * @param {String} detail.remoteId - Identifier of the remote client.
 * @param {String} detail.oldCallId - callId before restart.
 * @param {String} detail.newCallId - callId after restart. May be as before.
 */

/**
 * Fired when the selected candidate is available
 * @event ICECandidateTypeUpdate
 * @param {String} type - 'ICECandidateTypeUpdate'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'ICECandidateTypeUpdate'
 * @param {String} detail.time - Date
 * @param {String} detail.callId - Id of the call
 * @param {String} detail.localCandidate - local candidate type, value can be : unknown, local, host, stun, relay, srflx , prflx
 * @param {String} detail.remoteCandidate - local candidate type, value can be : unknown, local, host, stun, relay, srflx , prflx
 */

/**
 * Fired when the selected candidate is available
 * @event selectedICECandidate
 * @param {String} type - 'selectedICECandidate'
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'selectedICECandidate'
 * @param {String} detail.time - Date
 * @param {String} detail.callId - Id of the call
 * @param {String} detail.localCandidateType - local candidate type, value can be : unknown, local, host, stun, relay, srflx , prflx
 * @param {String} detail.remoteCandidateType - local candidate type, value can be : unknown, local, host, stun, relay, srflx , prflx
 * @param {String} detail.localAddress - localAddress and port used for RTP receiving/sending .Format is address:port
 * @param {String} detail.remoteAdress - remoteAdress and port used for RTP receiving/sending .Format is address:port
 * @param {String} detail.transportType - transportType for RTP stream. Be careful, when mediaProxy is used it can describe the flow between medaiProxy and remote user. Can be UDP or TCP
 * @param {String} detail.localTransportType - localTransportType for RTP stream. (Only available on Firefox). Can be UDP or TCP
 */

/**
 * Fired upon change on local stream.
 * @event localStreamUpdated
 * @param {String} type - 'localStreamUpdated'.
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'localStreamUpdated'
 * @param {String} detail.time - Date
 * @param {Object} detail.changeList - an array of field names.
 * @param {Boolean} detail.audioIsAvailable - whether an audio track exists.
 * @param {String} detail.audioDeviceLabel - the label of the audio device.
 * @param {Boolean} detail.audioIsActive - whether the audio is active in peer connection (not inactive).
 * @param {Boolean} detail.audioIsMuted - whether the audio track is muted.
 * @param {Boolean} detail.videoIsAvailable - whether an video track exists.
 * @param {String} detail.videoDeviceLabel - the label of the video device.
 * @param {Boolean} detail.videoIsActive - whether the video is active in peer connection (not inactive).
 * @param {Boolean} detail.videoIsMuted - whether the video track is muted.
 * @param {Boolean} detail.onCall - whether this is related to a call.
 * @param {String} detail.callType - call type.
 * @param {String} detail.callId - call id.
 * @param {MediaStream} detail.stream - media stream.
 * @param {String} detail.userMediaStreamId - user media stream id.
 * @param {String} detail.cause - either 'adaptation' or 'userAction'.
 */

/**
 * Fired upon change on remote stream.
 * @event remoteStreamUpdated
 * @param {String} type - 'remoteStreamUpdated'.
 * @param {Object} detail - Event detail.
 * @param {String} detail.eventType - 'remoteStreamUpdated'
 * @param {String} detail.time - Date
 * @param {Object} detail.changeList - an array of field names.
 * @param {Boolean} detail.audioIsAvailable - whether an audio track exists.
 * @param {Boolean} detail.audioIsActive - whether the audio is active in peer connection (not inactive).
 * @param {Boolean} detail.audioIsMuted - whether the audio track is muted.
 * @param {Boolean} detail.videoIsAvailable - whether an video track exists.
 * @param {Boolean} detail.videoIsActive - whether the video is active in peer connection (not inactive).
 * @param {Boolean} detail.videoIsMuted - whether the video track is muted.
 * @param {String} detail.callType - call type.
 * @param {String} detail.callId - call id.
 * @param {String} detail.cause - either 'adaptation' or 'userAction'.
 */

/**
 * Fired upon eviction of participant from conference room.
 * @event MCUParticipantEjected
 * @param {String} type - 'MCUParticipantEjected'.
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date
 * @param {String} detail.roomId - The room identifier.
 * @param {String} detail.clientId - The user ID of participant being ejected from the conference room.
 * @param {Object} detail.data - Optional data given at eviction time.
 */

/**
 * Fired when the mode of conference room is changing or changed.
 * @event MCURoomModeChanged
 * @param {String} type - 'MCURoomModeChanged'.
 * @param {Object} detail - Event detail.
 * @param {String} detail.time - Date.
 * @param {String} detail.roomId - The room identifier.
 * @param {String} detail.oldMode - Either 'mesh' or 'sfu'.
 * @param {String} detail.newMode - Either 'mesh' or 'sfu'.
 * @param {String} detail.state - Either 'ongoing' or 'complete'.
 */




/***/ }),

/***/ "./src/Core/ApiCCWhiteBoardClient.js":
/*!*******************************************!*\
  !*** ./src/Core/ApiCCWhiteBoardClient.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiCCWhiteBoardClient": () => (/* binding */ ApiCCWhiteBoardClient)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ApiCCWhiteBoardClient');
/**
 * <p>This is the ApiRTCWhiteBoardClient.</p>
 * <p>This class enables you to manage Whiteboard exchanges between two clients</p>
 *
 * @module ApiRTCWhiteBoardClient
 */

var ApiCCWhiteBoardClient = function ApiCCWhiteBoardClient(session, paperDivId, userCursorColor, instructionsDivId, disconnectionTimer) {
  logger.debug('Loading apiCC.ApiCCWhiteBoardClient');
  this.roomId = null;
  this.whiteBoardDisconnectionTimeoutId = 0;
  this.sessionStarted = false;
  this.prev = {};
  this.lastEmit = Date.now();
  this.clients = {};
  this.listenedPeers = {};
  this.touchScreenActivated = false;
  this.touchControlPoint = {};
  this.drawElements = [];
  this.ghostElements = {};
  this.redoStack = [];
  this.undoIndex = 0;
  this.userCursorColor = null; //cursor color seen by other participants

  this.cursors = {};
  this.cursorStyle = 'cross';
  this.CURSOR_STYLES = ['circle', 'cross']; //canvas zoom parameters

  this.currentScale = 1;
  this.dx = 0;
  this.dy = 0;
  this.instructionsFaded = false;
  this.canvas = null;
  this.ctx = null;
  this.currentTool = 'pen';
  this.currentColor = 'rgba(0, 0, 0, 1)';
  this.currentBrushWidth = 1;
  this.readOnly = false;
  this.isDrawing = false;
  this.focusOnDrawing = false; //id to keep track of paper version when it is cleared

  this.paperSheetId = 0; //id to keep track of sent drawings

  this.drawingId = 0;
  this.offline = false; //Used to know if whiteboard is working offline

  this.roomJoined = false;
  this.laserModeActivated = false;
  this.AVAILABLE_TOOLS = ['pen', 'ellipse', 'rectangle', 'erase', 'void', 'arrow'];
  this.GEOMETRY_TOOLS = [//those tools create draw objects only on mouse/touch release
  'arrow', 'rectangle', 'ellipse'];

  if (disconnectionTimer !== undefined) {
    this.disconnectionTimer = disconnectionTimer;
  } else {
    this.disconnectionTimer = 30000;
  }

  logger.log('Setting Whiteboard disconnectionTimer to : ' + this.disconnectionTimer);
  /**
   * <b>Description</b>
   * <p>This method binds the whiteboard to a canvas/p>
   * @method setCanvas
   * @param {String} canvasId Id of the canvas element to set the whiteboard to
   */

  this.setCanvas = function (canvasId) {
    logger.debug('[Whiteboard] setCanvas() :', canvasId);

    if (this.canvas !== null) {
      logger.log('Unsetting old canvas events'); // we're done with these events

      if (this.sessionStarted && !this.readOnly) {
        this.canvas.onmousedown = null;
        this.canvas.onmouseup = null;
        this.canvas.onmouseleave = null;
        this.canvas.onmousemove = null;

        if (this.touchScreenActivated) {
          this.canvas.removeEventListener('touchstart', this.onTouchStart, false);
          this.canvas.removeEventListener('touchend', this.onTouchEnd, false);
          this.canvas.removeEventListener('touchcancel', this.onTouchCancel, false);
          this.canvas.removeEventListener('touchleave', this.onTouchEnd, false);
          this.canvas.removeEventListener('touchmove', this.onTouchMove, false);
        }
      }
    }

    if (canvasId !== null && document.getElementById(canvasId) !== null) {
      this.canvas = document.getElementById(canvasId);
      this.ctx = this.canvas.getContext('2d'); //(re)set events on canvas set

      if (this.sessionStarted && !this.readOnly) {
        this.canvas.onmousedown = this.onmousedown;
        this.canvas.onmouseup = this.onmouseup;
        this.canvas.onmouseleave = this.onmouseleave;
        this.canvas.onmousemove = this.onmousemove;

        if (this.touchScreenActivated) {
          this.canvas.addEventListener('touchstart', this.onTouchStart, false);
          this.canvas.addEventListener('touchend', this.onTouchEnd, false);
          this.canvas.addEventListener('touchcancel', this.onTouchCancel, false);
          this.canvas.addEventListener('touchleave', this.onTouchEnd, false);
          this.canvas.addEventListener('touchmove', this.onTouchMove, false);
        }
      }
    } else {
      if (canvasId !== null && document.getElementById(canvasId) === null) {
        logger.warn('No such element whose id is : ' + canvasId);
      }

      this.canvas = null;
      this.ctx = null;
    }
  };

  this.setCanvas(paperDivId);
  /**
   * Private wrapper to send data to all other peers in room
   */

  this.sendDataToRoom = function (data) {
    logger.info('[Whiteboard] sendDataToRoom()');

    if (this.offline === false && this.roomId !== null) {
      if (apiCC.session === null || apiCC.session === undefined) {
        logger.info('apiCC.session does not exist, leaving process');
        return;
      }

      logger.debug('this.drawElements :', this.drawElements);
      logger.debug('data.tool :', data.tool);
      var drawElementsToSend = [];
      logger.debug('drawElementsToSend :', drawElementsToSend); //default data

      var bundle = {
        x: 0,
        y: 0,
        drawing: false,
        tool: this.currentTool,
        cursorColor: this.userCursorColor,
        color: this.currentColor,
        width: this.currentBrushWidth,
        paperSheetId: this.paperSheetId,
        //drawElements: this.drawElements,
        drawElements: drawElementsToSend,
        id: apiCC.session.apiCCId
      },
          keys = Object.keys(data),
          i;

      for (i = 0; i < keys.length; i++) {
        bundle[keys[i]] = data[keys[i]];
      }

      apiCC.session.roomMgr.sendMessageToRoom(this.roomId, 'whiteBoard', bundle);
    } //else {
    //logger.log('Whiteboard is in offline mode, leaving sendDataToRoom');
    //}

  };
  /**
   * <b>Description</b>
   * <p>This method binds the peer cursors to a div (OBSOLETE)</p>
   * @method setCursorsDiv
   * @param {String} divId Id div to display the peers cursors into
   */


  this.setCursorsDiv = function () {
    logger.warn('[Whiteboard] setCursorsDiv() - method obsolete, please use setUserCursorColor to set a cursor pointer that will be seen by other users');
  };
  /**
   * <b>Description</b>
   * <p>This method sets the user cursor color that will be seen by other participants</p>
   * @method setUserCursorColor
   * @param {String} color User cursor color, set to null or 'invisible' if cursor is invisible
   */


  this.setUserCursorColor = function (color) {
    logger.debug('[Whiteboard] setUserCursorColor() : ' + color);

    if (color === null || color === 'invisible') {
      this.userCursorColor = 'invisible';
    } else if (/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color)) {
      this.userCursorColor = color;
    } else {
      logger.warn('[Whiteboard] setUserCursorColor() color ' + color + ' is invalid, defaulting to invisible'); //this.userCursorColor = '#000000';

      this.userCursorColor = 'invisible';
    }
  };

  this.setUserCursorColor(userCursorColor);
  /**
   * <b>Description</b>
   * <p>This method sets the cursor style of other participants</p>
   * @method setCursorStyle
   * @param {String} style Cursor style
   */

  this.setCursorStyle = function (style) {
    logger.debug('[Whiteboard] setCursorStyle() : ' + style);

    if (this.CURSOR_STYLES.indexOf(style) > -1) {
      this.userCursorColor = 'invisible';
      this.cursorStyle = style;
    } else {
      logger.error('[Whiteboard] setCursorStyle() style ' + style + ' is invalid');
    }
  };
  /**
   * <b>Description</b>
   * <p>This method sets if the whiteboard should follow the drawings done by other users if the canvas is set on a scrollable container</p>
   * @method setFocusOnDrawing
   * @param {boolean} value
   */


  this.setFocusOnDrawing = function (value) {
    logger.debug('[Whiteboard] setFocusOnDrawing()');
    this.focusOnDrawing = value;
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to create a whiteboard room</p>
   * @method createRoom
   * @param {object} options
   * @param {string} options.convId - Optional Cloud Conversation ID.
   * @param {boolean} options.webconf - If true, the room is linked to a conference.
   */


  this.createRoom = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    logger.debug('[Whiteboard] createRoom()');
    apiCC.session.roomMgr.createRoom('whiteBoard', options);
  };
  /*
      * <b>Description</b>
      * <p>This method returns the contact list in a room</p>
      * @method requestContactListInRoom
      * @param {String} roomId roomId
      */


  this.requestContactListInRoom = function (roomId) {
    logger.log('[Whiteboard] requestContactListInRoom :' + roomId);
    apiCC.session.roomMgr.requestContactListInRoom(roomId);
  };
  /**
   * <b>Description</b>
   * <p>This method enables the user to change their current drawing tool from the ones available</p>
   * <b>Tools :</b>
   * <li>pen : draw hand drawn lines</li>
   * <li>arrow : draw an arrow</li>
   * <li>ellipse : draw an ellipse</li>
   * <li>rectangle : draw an rectangle</li>
   * <li>erase : clear an area of the canvas</li>
   * <li>void : no effect on canvas, use it if you need to implement some custom mouse behaviour on client</li>
   * @method setDrawingTool
   * @param {String} tool Tool to change to
   */


  this.setDrawingTool = function (tool) {
    logger.debug('[Whiteboard] setDrawingTool()');
    var userId = 0;

    if (apiCC.session !== null) {
      userId = apiCC.session.apiCCId;
    }

    if (this.AVAILABLE_TOOLS.indexOf(tool) > -1) {
      this.currentTool = tool;
      this.ghostElements[userId] = null;
    }
  };
  /**
   * <b>Description</b>
   * <p>This method enables or diables the ability for the user to write on the whiteboard</p>
   * @method setReadOnly
   * @param {Boolean} value Is the whiteboard read-only?
   */


  this.setReadOnly = function (value) {
    logger.debug('[Whiteboard] setReadOnly()');
    var userId = 0;

    if (apiCC.session !== null) {
      userId = apiCC.session.apiCCId;
    }

    this.ghostElements[userId] = null;
    this.readOnly = value === true;

    if (this.readOnly && this.canvas !== null) {
      this.canvas.onmousedown = null;
      this.canvas.onmouseup = null;
      this.canvas.onmouseleave = null;
      this.canvas.onmousemove = null;

      if (this.touchScreenActivated) {
        this.canvas.removeEventListener('touchstart', this.onTouchStart, false);
        this.canvas.removeEventListener('touchend', this.onTouchEnd, false);
        this.canvas.removeEventListener('touchcancel', this.onTouchCancel, false);
        this.canvas.removeEventListener('touchleave', this.onTouchEnd, false);
        this.canvas.removeEventListener('touchmove', this.onTouchMove, false);
      }
    } else if (this.canvas !== null) {
      this.canvas.onmousedown = this.onmousedown;
      this.canvas.onmouseup = this.onmouseup;
      this.canvas.onmouseleave = this.onmouseleave;
      this.canvas.onmousemove = this.onmousemove;

      if (this.touchScreenActivated) {
        this.canvas.addEventListener('touchstart', this.onTouchStart, false);
        this.canvas.addEventListener('touchend', this.onTouchEnd, false);
        this.canvas.addEventListener('touchcancel', this.onTouchCancel, false);
        this.canvas.addEventListener('touchleave', this.onTouchEnd, false);
        this.canvas.addEventListener('touchmove', this.onTouchMove, false);
      }
    }
  };

  this.laserModeProcess = function (drawingId) {
    var _this = this;

    //logger.debug('[Whiteboard] laserModeProcess activated for element with Id :', drawingId);
    //Calling undo with drawingId
    setTimeout(function () {
      return _this.undo(drawingId);
    }, 5000);
  };
  /**
   * <b>Description</b>
   * <p>This method undoes last user drawing</p>
   * @method undo
   */


  this.undo = function (drawingId) {
    logger.debug('[Whiteboard] undo()');
    var i = this.drawElements.length - 1,
        undoIndex = null,
        undoneElements = [],
        undoneElementsIds = [],
        element = null,
        userId = 0;

    if (apiCC.session !== null) {
      userId = apiCC.session.apiCCId;
    }

    if (drawingId === undefined) {
      //This is classical undo
      // Fetch elements to delete
      while (i >= 0) {
        if (this.drawElements[i].userId == userId) {
          if (undoIndex === null) {
            undoIndex = this.drawElements[i].undoIndex;
          }

          if (undoIndex === this.drawElements[i].undoIndex) {
            element = this.drawElements.splice(i, 1)[0];
            undoneElements.push(element);
            undoneElementsIds.push(element.drawingId);
          }
        }

        i--;
      }
    } else {
      //This is undo for laser mode
      for (i = 0; i < this.drawElements.length; i++) {
        if (this.drawElements[i].userId == userId && this.drawElements[i].drawingId === drawingId) {
          logger.debug('[Whiteboard] element found with drawingId in undo laser :', drawingId);
          element = this.drawElements.splice(i, 1)[0];
          undoneElements.push(element);
          undoneElementsIds.push(element.drawingId);
        }
      }
    }

    if (undoneElements.length > 0) {
      this.redraw(); // Send deleted elements to peers

      this.sendDataToRoom({
        tool: 'void',
        "delete": undoneElementsIds,
        undoneElements: undoneElements
      }); // Stack elements for possible redo

      this.redoStack.push(undoneElements);
    }
  };
  /**
   * <b>Description</b>
   * <p>This method redraws previously undone user drawing</p>
   * @method redo
   */


  this.redo = function () {
    logger.debug('[Whiteboard] redo()');
    var i,
        redoneElements = [];

    if (this.redoStack.length > 0) {
      redoneElements = this.redoStack.pop();

      for (i = 0; i < redoneElements.length; i++) {
        this.addNewDrawing(redoneElements[i]);
      }

      this.sendDataToRoom({
        tool: 'void',
        drawObjectsArray: redoneElements
      });
      this.redraw();
    }
  };
  /**
   * <b>Description</b>
   * <p>This method enables the user to change their current drawing brush size</p>
   * @method setBrushSize
   * @param {Integer} size Brush size to change to
   */


  this.setBrushSize = function (size) {
    logger.debug('[Whiteboard] setBrushSize()');

    if (!isNaN(size) && size > 0) {
      this.currentBrushWidth = size;
    }
  };
  /**
   * <b>Description</b>
   * <p>This method enables the user to change their current drawing brush size</p>
   * @method setBrushColor
   * @param {String} color Javascript color string to change to
   */


  this.setBrushColor = function (color) {
    logger.debug('[Whiteboard] setBrushColor()');
    this.currentColor = color;
  };
  /**
   * <b>Description</b>
   * <p>This method sets the scale factor for the local canvas then redraws it</p>
   * @method setScale
   * @param {Float} factor Scale factor, 1 being normal scale
   */


  this.setScale = function (factor) {
    logger.debug('[Whiteboard] setScale()');

    if (factor > 0) {
      this.currentScale = factor;
      this.redraw();
    } else {
      logger.warn('Scale factor must be > 0!');
    }
  };
  /**
   * <b>Description</b>
   * <p>This method gets the scale factor for the local canvast</p>
   * @method getScale
   */


  this.getScale = function () {
    logger.debug('[Whiteboard] getScale()');
    return this.currentScale;
  };
  /**
   * <b>Description</b>
   * <p>This method sets the canvas offset then redraws it</p>
   * @method setOffset
   * @param {Integer} x Scale factor, 1 being normal scale
   * @param {Integer} y Scale factor, 1 being normal scale
   */


  this.setOffset = function (x, y) {
    logger.debug('[Whiteboard] setOffset()');
    var tX = parseInt(x, 10),
        tY = parseInt(y, 10);

    if (!isNaN(tX) && !isNaN(tY)) {
      this.dx = Number(tX);
      this.dy = Number(tY);
      this.redraw();
    }
  };
  /**
   * <b>Description</b>
   * <p>This method gets the canvas offset</p>
   * @method getOffset
   */


  this.getOffset = function () {
    logger.debug('[Whiteboard] getOffset()');
    return {
      x: this.dx,
      y: this.dy
    };
  };
  /**
   * <b>Description</b>
   * <p>This method prints text in the canvas for all the peers</p>
   * @method printSharedText
   * @param {Integer} x x coordinate of the text
   * @param {Integer} y y coordinate of the text
   * @param {String} text Text to display
   * @param {Integer} size Font size of the text
   * @param {String} font Font of the text
   * @param {String} border Border for the printed text
   */


  this.printSharedText = function (x, y, text, size, font, border) {
    logger.debug('[Whiteboard] printSharedText()');
    this.setBrushStyle(this.currentColor, this.currentBrushWidth);
    this.undoIndex++;
    this.redoStack = [];
    var userId = 0;

    if (apiCC.session !== null) {
      userId = apiCC.session.apiCCId;
    }

    var drawObject = {
      type: 'text',
      x: x,
      y: y,
      text: text,
      size: size,
      font: font,
      border: border,
      userId: userId,
      drawingId: this.drawingId,
      color: this.currentColor,
      width: this.currentBrushWidth,
      undoIndex: this.undoIndex,
      time: Date.now()
    };
    this.sendDataToRoom({
      x: x,
      y: y,
      tool: 'void',
      drawObject: drawObject
    });
    this.drawingId++;
    this.addNewDrawing(drawObject);
  };
  /**
   * <b>Description</b>
   * <p>Allows to listen on a peer's events on the whiteboard room</p>
   * @method addPeerListener
   * @param {String} peerId Id of the peer to listen to
   * @param {Function} handler Event handler function
   */


  this.addPeerListener = function (peerId, handler) {
    logger.debug('[Whiteboard] addPeerListener()');

    if (!this.listenedPeers.hasOwnProperty(peerId)) {
      this.listenedPeers[peerId] = [];
    }

    this.listenedPeers[peerId].push(handler);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to invite a contact to the Whiteboard session</p>
   * @method inviteInRoom
   * @param {string} roomId - Id of the room
   * @param {string} destId - Id of the contact to invite
   * @param {object} context - Context to send to invited user
   * @param {object} options
   * @param {string} options.convId - Optional Cloud Conversation ID.
   * @param {boolean} options.webconf - If true, the room is linked to a conference.
   */


  this.inviteInRoom = function (roomId, destId, context) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    logger.debug('[Whiteboard] inviteInRoom()');

    if (roomId === null) {
      logger.debug('wrong roomId');
      return;
    }

    if (destId === null) {
      logger.debug('wrong destId');
      return;
    }

    apiCC.session.roomMgr.inviteInRoom(roomId, destId, 'whiteBoard', context, options);
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to answer to a room invitation</p>
   * <p>This returns true if user joins the room and false otherwise</p>
   * @method answerToRoomInvitation
   * @param {String} roomId Id of the room
   * @param {Boolean} accept true or false to accept or refuse the invitation
   */


  this.answerToRoomInvitation = function (roomId, accept) {
    logger.info('[Whiteboard] answerToRoomInvitation()');
    var userJoining = accept && !this.isInRoom();

    if (this.isInRoom()) {
      logger.error('[Whiteboard] cannot answer room invitation : user is already in a room');
    } else {
      apiCC.session.roomMgr.answerToRoomInvitation(roomId, accept, 'whiteBoard');
    }

    if (userJoining) {
      logger.log('[Whiteboard] user joining room'); //request most recent whiteboard data

      this.paperSheetId = 0;
      this.drawingId = 0;
      this.roomId = roomId;
      this.sendDataToRoom({
        tool: 'void',
        needCatchUp: '*||-1'
      });
    }

    return userJoining;
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to join a room</p>
   * @method joinRoom
   * @param {string} roomId Id of the room
   * @param {object} options
   * @param {string} options.convId - Optional Cloud Conversation ID.
   * @param {boolean} options.webconf - If true, the room is linked to a conference.
   */


  this.joinRoom = function (roomId) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    logger.info('[Whiteboard] joinRoom() roomId :', roomId);

    if (typeof roomId === 'undefined' || roomId === null) {
      logger.error('[Whiteboard] cannot join room : room is null or undefined');
    } else if (this.isInRoom() && this.roomJoined === true) {
      logger.error('[Whiteboard] cannot join room : user is already in a room');
    } else {
      apiCC.session.roomMgr.joinRoom(roomId, 'whiteBoard', options);
    }
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to leave a room</p>
   * @method leaveRoom
   * @param {String} roomId Id of the room
   */


  this.leaveRoom = function () {
    logger.info('[Whiteboard] leaveRoom()');

    if (this.isInRoom()) {
      apiCC.session.roomMgr.leaveRoom(this.roomId, 'whiteBoard');
      this.roomId = null;
      this.paperSheetId = 0;
      this.drawingId = 0;
      this.listenedPeers = {};
      this.roomJoined = false;
    }
  };
  /**
   * <b>Description</b>
   * <p>This method returns whether whiteboard client is currently a room or not</p>
   * @method isInRoom
   */


  this.isInRoom = function () {
    return this.roomId !== null;
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to clear the whiteboard and clear the history</p>
   * <p>Alias for deleteHistory</p>
   * @method clearPaper
   */


  this.clearPaper = function () {
    logger.debug('[Whiteboard] clearPaper()');
    this.deleteHistory();
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to clear the canvas. This method does not clear history, please use deleteHistory to reset the whiteboard</p>
   * @method refreshCanvas
   */


  this.refreshCanvas = function () {
    //logger.info('[Whiteboard] refreshCanvas()');
    if (this.canvas !== null && this.ctx !== null) {
      var tempWidth = this.canvas.width;
      this.canvas.width = tempWidth; //this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to clear the whiteboard and clear the history</p>
   * @method deleteHistory
   */


  this.deleteHistory = function () {
    logger.info('[Whiteboard] deleteHistory()');
    var userId = 0;

    if (apiCC.session !== null) {
      userId = apiCC.session.apiCCId;
    }

    this.refreshCanvas();
    this.drawElements = [];
    this.ghostElements[userId] = null;
    this.paperSheetId++;
    this.drawingId = 0;
    this.sendDataToRoom({
      tool: 'void',
      deleteHistory: true
    });
  }; //(private) sets brush style for next canvas drawing


  this.setBrushStyle = function (color, width) {
    if (this.ctx !== null) {
      this.ctx.strokeStyle = color;
      this.ctx.fillStyle = color;
      this.ctx.lineWidth = width;
    }
  };
  /**
   * <b>Description</b>
   * <p>This method redraws the whiteboard entierely</p>
   * @method redraw
   */


  this.redraw = function () {
    logger.debug('[Whiteboard] redraw()');
    var i, keys, obj;
    this.refreshCanvas(); //draw elements already drawn on the canvas

    for (i = 0; i < this.drawElements.length; i++) {
      this.drawSingleObject(this.drawElements[i]);
    } //draw elements being drawn on the canvas


    keys = Object.keys(this.ghostElements);

    for (i = 0; i < keys.length; i++) {
      if (this.ghostElements[keys[i]] !== null) {
        this.drawSingleObject(this.ghostElements[keys[i]]);
      }
    } //draw other participant's cursors


    keys = Object.keys(this.cursors);

    for (i = 0; i < keys.length; i++) {
      if (this.cursors[keys[i]] !== null && this.cursors[keys[i]].color !== 'invisible') {
        if (!(this.cursors[keys[i]].x === 0 && this.cursors[keys[i]].y === 0)) {
          //don't show 'idle' pointers
          obj = {
            fromx: (this.cursors[keys[i]].x - this.dx) * this.currentScale - 13,
            fromy: (this.cursors[keys[i]].y - this.dy) * this.currentScale - 13,
            tox: (this.cursors[keys[i]].x - this.dx) * this.currentScale + 13,
            toy: (this.cursors[keys[i]].y - this.dy) * this.currentScale + 13
          };
          this.setBrushStyle(this.cursors[keys[i]].color, 4);

          switch (this.cursorStyle) {
            case 'circle':
              if (this.ctx !== null) {
                this.ctx.globalAlpha = 0.4;
                this.fillEllipse(obj.fromx, obj.fromy, obj.tox, obj.toy);
                this.drawEllipse(obj.fromx + 2, obj.fromy + 2, obj.tox - 2, obj.toy - 2);
                this.ctx.globalAlpha = 1;
              }

              break;

            case 'cross':
              if (this.ctx !== null) {
                this.ctx.globalAlpha = 0.7;
                this.ctx.beginPath();
                this.ctx.moveTo(obj.fromx + (obj.tox - obj.fromx) / 2, obj.fromy);
                this.ctx.lineTo(obj.fromx + (obj.tox - obj.fromx) / 2, obj.toy);
                this.ctx.lineCap = 'butt';
                this.ctx.stroke();
                this.ctx.beginPath();
                this.ctx.moveTo(obj.fromx, obj.fromy + (obj.toy - obj.fromy) / 2);
                this.ctx.lineTo(obj.tox, obj.fromy + (obj.toy - obj.fromy) / 2);
                this.ctx.lineCap = 'butt';
                this.ctx.stroke();
                this.ctx.globalAlpha = 1;
              }

              break;
          }
        }
      }
    }
  }; //(private) adds a new element to the drawingElement stack and then draws this element


  this.addNewDrawing = function (obj) {
    var userId = 0;
    this.drawElements.push(obj);
    this.drawSingleObject(obj);

    if (apiCC.session !== null) {
      userId = apiCC.session.apiCCId;
    }

    if (obj.userId === userId && this.laserModeActivated === true) {
      this.laserModeProcess(obj.drawingId);
    }
  };

  this.drawSingleObject = function (drawObject) {
    if (this.ctx !== null && this.canvas !== null) {
      var obj = {};
      this.setBrushStyle(drawObject.color, drawObject.width);
      this.ctx.scale(this.currentScale, this.currentScale); // set new draw object coordinates according to scale factor and offset

      obj.fromx = drawObject.fromx - this.dx;
      obj.tox = drawObject.tox - this.dx;
      obj.x = drawObject.x - this.dx;
      obj.fromy = drawObject.fromy - this.dy;
      obj.toy = drawObject.toy - this.dy;
      obj.y = drawObject.y - this.dy;

      switch (drawObject.type) {
        case 'arrow':
          this.drawArrow(obj.fromx, obj.fromy, obj.tox, obj.toy);
          break;

        case 'ellipse':
          this.drawEllipse(obj.fromx, obj.fromy, obj.tox, obj.toy);
          break;

        case 'rectangle':
          this.drawRectangle(obj.fromx, obj.fromy, obj.tox, obj.toy);
          break;

        case 'pen':
          this.drawLine(obj.fromx, obj.fromy, obj.tox, obj.toy);
          break;

        case 'erase':
          this.eraseArea(obj.fromx, obj.fromy);
          break;

        case 'text':
          this.drawText(obj.x, obj.y, drawObject.text, drawObject.size, drawObject.font, drawObject.border);
          break;

        default:
          break;
      }

      this.ctx.scale(1 / this.currentScale, 1 / this.currentScale);
    }
  }; //(private) this draws a line contained between (fromx,fromy) and (tox,toy) on the canvas


  this.drawLine = function (fromx, fromy, tox, toy) {
    if (this.ctx !== null) {
      //logger.log('this.drawLine : ' + '(' + fromx + ',' + fromy + ')--(' + tox + ',' + toy + ')');
      this.ctx.beginPath();
      this.ctx.moveTo(fromx, fromy);
      this.ctx.lineTo(tox, toy);
      this.ctx.lineCap = 'round';
      this.ctx.stroke();
    }
  }; //(private) this draws a text on a canvas with a specified size


  this.drawText = function (x, y, text, size, font, border) {
    if (this.ctx !== null) {
      var f = 'Arial',
          oldStrokeColor,
          oldLineWidth;

      if (typeof font !== 'undefined' && font !== null) {
        f = font;
      }

      this.ctx.font = size + 'px ' + f;
      this.ctx.fillText(text, x, y); //print border

      if (typeof border !== 'undefined' && border !== null) {
        oldStrokeColor = this.ctx.strokeStyle;
        oldLineWidth = this.ctx.lineWidth;
        this.ctx.strokeStyle = border;
        this.ctx.lineWidth = 1;
        this.ctx.strokeText(text, x, y);
        this.ctx.strokeStyle = oldStrokeColor;
        this.ctx.lineWidth = oldLineWidth;
      }
    }
  }; //(private) this erases a square area on the canvas


  this.eraseArea = function (x, y) {
    if (this.ctx !== null) {
      this.ctx.clearRect(x - this.ctx.lineWidth - 1, y - this.ctx.lineWidth - 1, this.ctx.lineWidth * 2 + 2, this.ctx.lineWidth * 2 + 2);
    }
  }; //(private) this draws an arrow  contained between (fromx,fromy) and (tox,toy) on the canvas


  this.drawArrow = function (fromx, fromy, tox, toy) {
    if (this.ctx !== null) {
      var headlen = 10,
          // length of head in pixels
      angle = Math.atan2(toy - fromy, tox - fromx);
      this.ctx.beginPath();
      this.ctx.lineCap = 'butt';
      this.ctx.moveTo(fromx, fromy);
      this.ctx.lineTo(tox, toy);
      this.ctx.stroke(); //draw arrow head

      this.ctx.save();
      this.ctx.beginPath();
      this.ctx.translate(tox, toy);
      this.ctx.rotate(angle + Math.PI / 2);
      this.ctx.moveTo(0, -this.ctx.lineWidth);
      this.ctx.lineTo(5 * this.ctx.lineWidth * 0.5 + 1, headlen + this.ctx.lineWidth * 0.25);
      this.ctx.lineTo(-5 * this.ctx.lineWidth * 0.5 - 1, headlen + this.ctx.lineWidth * 0.25);
      this.ctx.closePath();
      this.ctx.restore();
      this.ctx.fill();
    }
  }; //(private) this draws an ellipse contained between (fromx,fromy) and (tox,toy) on the canvas


  this.drawEllipse = function (fromx, fromy, tox, toy) {
    var radius = null,
        center = null;

    if (this.ctx !== null) {
      radius = {
        'x': Math.abs(fromx - tox) / 2,
        'y': Math.abs(fromy - toy) / 2
      };
      center = {
        'x': fromx - (fromx - tox) / 2,
        'y': fromy - (fromy - toy) / 2
      }; //logger.log(radius);

      this.ctx.beginPath();

      if (apiRTC.browser !== 'IE') {
        this.ctx.ellipse(center.x, center.y, radius.x, radius.y, 0, 0, 2 * Math.PI);
      }

      this.ctx.stroke();
    }
  }; //(private) this fills an ellipse contained between (fromx,fromy) and (tox,toy) on the canvas


  this.fillEllipse = function (fromx, fromy, tox, toy) {
    if (this.ctx !== null) {
      var radius = {
        'x': Math.abs(fromx - tox) / 2,
        'y': Math.abs(fromy - toy) / 2
      },
          center = {
        'x': fromx - (fromx - tox) / 2,
        'y': fromy - (fromy - toy) / 2
      }; //logger.log(radius);

      this.ctx.beginPath();

      if (apiRTC.browser !== 'IE') {
        this.ctx.ellipse(center.x, center.y, radius.x, radius.y, 0, 0, 2 * Math.PI);
      }

      this.ctx.fill();
    }
  }; //(private) this draws a rectangle contained between (fromx,fromy) and (tox,toy) on the canvas


  this.drawRectangle = function (fromx, fromy, tox, toy) {
    if (this.ctx !== null) {
      this.ctx.beginPath();
      var x0 = fromx,
          y0 = fromy;

      if (fromx > tox) {
        x0 = tox;
      }

      if (fromy > toy) {
        y0 = toy;
      }

      this.ctx.rect(x0, y0, Math.abs(fromx - tox), Math.abs(fromy - toy));
      this.ctx.stroke();
    }
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to get the context, for instance to customize the cursor</p>
   * @method getContext
   */


  this.getContext = function () {
    return this.ctx;
  };

  function fade(element) {
    element.style.display = 'none';
  }
  /**
   * <b>Description</b>
   * <p>This method enables you to load a photo in the whiteBoard background</p>
   * @method loadPhotoInBackground
   * @param {String} bkgPhoto link of the photo to load
   */


  this.loadPhotoInBackground = function (bkgPhoto) {
    logger.debug('[Whiteboard] loadPhotoInBackground :' + bkgPhoto);
    var body = document.getElementsByTagName('body')[0];
    body.style.backgroundImage = 'url(' + bkgPhoto + ')';
    body.style.backgroundPosition = '50% 50%';
    body.style.backgroundRepeat = 'no-repeat';
  };

  this.messageProcessing = function (data) {
    logger.debug('[Whiteboard] messageProcessing');
    var parentDiv = null,
        drawObject = null,
        invalidate = false,
        //dataToSend = {},
    i,
        peerEvent = null,
        catchupIndex = null,
        catchUpData = null,
        needCatchUp = null,
        element = null;

    if (!this.cursors[data.id]) {
      logger.log('[Whiteboard] messageProcessing - creating cursor for new user : ' + data.id);
      this.cursors[data.id] = {
        id: data.id
      }; //Initialising this.clients[data.id]

      this.clients[data.id] = {};
    }

    this.cursors[data.id].x = data.x;
    this.cursors[data.id].y = data.y;
    this.cursors[data.id].lastUpdate = Date.now();

    if (data.cursorColor && data.cursorColor !== null) {
      this.cursors[data.id].color = data.cursorColor;
    } else {
      //this.cursors[data.id].color = '#000000'; //default for retro compatiblilty
      this.cursors[data.id].color = 'invisible';
    }

    if (apiRTC.userAgentInstance === undefined) {
      if (this.cursors[data.id].color !== 'invisible') {
        invalidate = true;
      }
    } else {
      if (apiRTC.userAgentInstance.capabilities.whiteboardCursor === 'ON') {
        if (this.cursors[data.id].color !== 'invisible') {
          invalidate = true;
        }
      } else {
        logger.debug('[Whiteboard] - cursor is not supported on userAgent');
        this.cursors[data.id].color = 'invisible';
      }
    }

    if (this.ghostElements[data.id] !== null) {
      this.ghostElements[data.id] = null;
      invalidate = true;
    }

    if (this.listenedPeers.hasOwnProperty(data.id)) {
      peerEvent = {
        id: data.id,
        x: data.x,
        y: data.y,
        tool: data.tool,
        drawing: data.drawing
      };

      for (i = 0; i < this.listenedPeers[data.id].length; i++) {
        if (typeof this.listenedPeers[data.id][i] === 'function') {
          this.listenedPeers[data.id][i](peerEvent);
        } else {
          logger.warn('[Whiteboard] Peer listenener is not a function!');
        }
      }
    } // Is the user drawing?


    if (data.drawing && this.clients[data.id]) {
      logger.debug('data.drawing && this.clients[data.id]'); // Draw a line on the canvas.

      drawObject = {
        fromx: typeof data.prevX !== 'undefined' ? data.prevX : this.clients[data.id].x,
        fromy: typeof data.prevY !== 'undefined' ? data.prevY : this.clients[data.id].y,
        tox: data.x,
        toy: data.y,
        type: data.tool !== null ? data.tool : 'pen',
        color: data.color,
        width: data.width,
        userId: data.id,
        drawingId: data.drawingId
      };

      if (this.GEOMETRY_TOOLS.indexOf(drawObject.type) > -1) {
        //ghost tool
        if (data.prevX && data.prevY) {
          this.ghostElements[data.id] = drawObject;
          invalidate = true;
        }
      } else {
        this.addNewDrawing(drawObject);
      }

      if (this.focusOnDrawing) {
        //Add Focus on drawing
        parentDiv = this.canvas.parentNode;
        parentDiv.scrollLeft = this.currentScale * (data.x - this.dx) - parentDiv.clientWidth / 2;
        parentDiv.scrollTop = this.currentScale * (data.y - this.dy) - parentDiv.clientHeight / 2;
      }
    } // Peer added new element to whiteboard


    if (data.drawObject) {
      drawObject = data.drawObject;
      drawObject.color = data.color;
      drawObject.width = data.width;
      this.ghostElements[data.id] = null;
      this.addNewDrawing(drawObject);

      if (this.focusOnDrawing) {
        //Add Focus on drawing
        parentDiv = this.canvas.parentNode;
        parentDiv.scrollLeft = this.currentScale * (data.x - this.dx) - parentDiv.clientWidth / 2;
        parentDiv.scrollTop = this.currentScale * (data.y - this.dy) - parentDiv.clientHeight / 2;
      }
    } // Peer added multiple new elements to whiteboard or redone them


    if (data.hasOwnProperty('drawObjectsArray')) {
      for (i = 0; i < data.drawObjectsArray.length; i++) {
        this.addNewDrawing(data.drawObjectsArray[i]);
      }
    } // Peer deleted elements from the whiteboard


    if (data.hasOwnProperty('delete')) {
      i = this.drawElements.length - 1;
      invalidate = true;

      while (i >= 0) {
        if (data["delete"].indexOf(this.drawElements[i].drawingId) > -1 && this.drawElements[i].userId == data.id) {
          this.drawElements.splice(i, 1);
        }

        i--;
      }
    } //check paper version


    if (data.hasOwnProperty('paperSheetId')) {
      //check for missed whiteboard updates
      if (data.paperSheetId < this.paperSheetId) {
        //This is no more suppose to happened
        logger.debug('[Whiteboard] - data.paperSheetId < this.paperSheetId');
      } else if (data.paperSheetId > this.paperSheetId) {
        //get updated by with more recent version of the paper and update
        logger.debug('[Whiteboard] - messageProcessing : peer has a more recent version : ' + this.paperSheetId + ' vs ' + data.paperSheetId);

        if (data.hasOwnProperty('deleteHistory')) {
          logger.debug('User : ' + data.id + ' ,has deleted the history');
        }

        if (data.hasOwnProperty('drawElements')) {
          logger.debug('[Whiteboard] - messageProcessing : receiving update from peer');

          if (data.drawElements !== null) {
            this.drawElements = data.drawElements;
          } else {
            this.drawElements = [];
          }

          for (i = 0; i < this.drawElements.length; i++) {
            if (this.drawElements[i].hasOwnProperty('userId') && this.drawElements[i].hasOwnProperty('drawingId')) {
              this.clients[this.drawElements[i].userId] = {
                x: 0,
                y: 0,
                drawing: false,
                tool: 'pen',
                cursorColor: null,
                color: null,
                width: 1,
                paperSheetId: this.paperSheetId,
                drawingId: this.drawElements[i].drawingId,
                id: this.drawElements[i].userId
              };
            }
          }

          this.paperSheetId = data.paperSheetId;
          this.drawingId = 0;
          invalidate = true;
        }
      } else if (data.hasOwnProperty('drawingId')) {
        logger.debug('[Whiteboard] - data.hasOwnProperty(drawingId): ');

        if (data.drawingId !== 0 && typeof this.clients[data.id] === 'undefined' || typeof this.clients[data.id] !== 'undefined' && this.clients[data.id].hasOwnProperty('drawingId') && data.drawingId - this.clients[data.id].drawingId > 1) {
          //check if there's a need to ask for some catchup (drawing objects missing)
          logger.log('[Whiteboard] - messageProcessing : catchup from peer required : ' + data.drawingId); // Alerting peer that user is missing some WB elements

          needCatchUp = data.id + '||-1';

          if (typeof this.clients[data.id] !== 'undefined' && this.clients[data.id].hasOwnProperty('drawingId')) {
            // Sending last received drawing id
            needCatchUp = data.id + '||' + this.clients[data.id].drawingId;
          }

          this.sendDataToRoom({
            tool: 'void',
            needCatchUp: needCatchUp
          });
        } else if (data.hasOwnProperty('needCatchUp') && (data.needCatchUp.startsWith(apiCC.session.apiCCId + '||') || data.needCatchUp.startsWith('*||'))) {
          //check if user can send catchup data
          logger.debug('[Whiteboard] - messageProcessing : letting peer catchup: ' + data.id);
          catchupIndex = data.needCatchUp.split('||')[1];
          catchUpData = []; // Sending missing WB elements to peer

          for (i = 0; i < this.drawElements.length; i++) {
            element = this.drawElements[i];

            if (element.hasOwnProperty('userId') && element.hasOwnProperty('drawingId') && element.userId === apiCC.session.apiCCId && element.drawingId > parseInt(catchupIndex, 10)) {
              catchUpData.push(element);
            }
          }

          this.sendDataToRoom({
            tool: 'void',
            catchUpData: catchUpData,
            catchupIndex: catchupIndex
          });
        } else {
          logger.debug('[Whiteboard] - else - drawingId');
        }
      } else if (data.hasOwnProperty('needCatchUp')) {
        logger.debug('[Whiteboard] - messageProcessing : needCatchUp' + data.id);
        catchupIndex = data.needCatchUp.split('||')[1];
        catchUpData = []; // Sending missing WB elements to peer

        for (i = 0; i < this.drawElements.length; i++) {
          element = this.drawElements[i];
          /*
                              if (element.hasOwnProperty('userId') && element.hasOwnProperty('drawingId') && element.userId === apiCC.session.apiCCId && element.drawingId > parseInt(catchupIndex, 10)) {
                                  catchUpData.push(element);
                              }
          */

          catchUpData.push(element);
        }

        logger.debug('[Whiteboard] - sending catchUpData : ', catchUpData);
        this.sendDataToRoom({
          tool: 'void',
          catchUpData: catchUpData,
          catchupIndex: catchupIndex
        });
      } else {
        logger.debug('[Whiteboard] - else - paperSheetId');
      } // if (data.hasOwnProperty('catchUpData') && data.hasOwnProperty('catchUpDest') && data.catchUpDest.toString() === apiCC.session.apiCCId.toString()) { //catching up


      if (data.hasOwnProperty('catchUpData')) {
        //catching up
        //ccatchup old unreceived data
        logger.debug('[Whiteboard] - messageProcessing : catching up: ' + data.id); // Update drawing id if user received their own drawings
        //logger.debug('[Whiteboard] - this.drawElements on catchUpData : avant concat :', this.drawElements);

        if (data.catchUpStatus === 'complete') {
          logger.debug('catchUpData is complete, cleaning drawElements');
          this.drawElements.splice(0, this.drawElements.length);
        }

        for (i = 0; i < data.catchUpData.length; i++) {
          element = data.catchUpData[i];

          if (data.userId === apiCC.session.apiCCId && element.hasOwnProperty('drawingId') && this.drawingId < element.drawingId) {
            this.drawingId = element.drawingId + 1;
          }
        }

        this.drawElements = data.catchUpData.concat(this.drawElements); //logger.error('[Whiteboard] - this.drawElements on catchUpData : ap concat :', this.drawElements);

        this.paperSheetId = data.paperSheetId;
        invalidate = true;
      }
    }

    if (invalidate) {
      this.redraw();
    } // Saving the current client state


    this.clients[data.id] = data;
  };
  /**
   * <b>Description</b>
   * <p>This method returns whether whiteboard client is started or not</p>
   * @method isStarted
   */


  this.isStarted = function () {
    return this.sessionStarted;
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to start the whiteBoard session</p>
   * @method start
   */


  this.start = function () {
    if (this.isStarted()) {
      logger.warn('[Whiteboard] WhiteBoardClient is already started');
    } else {
      logger.info('[Whiteboard] starting WhiteBoardClient'); // A flag for drawing activity

      this.isDrawing = false;
      this.prev = {};
      this.lastEmit = Date.now();
      this.currentScale = 1;
      this.dx = 0;
      this.dy = 0;
      this.drawingId = 0;
      this.clients = {};
      this.listenedPeers = {};
      this.cursors = {};
      this.drawElements = [];
      this.touchScreenActivated = false;
      this.sessionStarted = true;

      if (this.canvas !== null) {
        this.canvas.onmousedown = this.onmousedown;
        this.canvas.onmouseup = this.onmouseup;
        this.canvas.onmouseleave = this.onmouseleave;
        this.canvas.onmousemove = this.onmousemove;
      }

      this.redraw();
    }

    if (apiCC.session === null || apiCC.session.roomMgr === undefined) {
      logger.log('[Whiteboard] roomMgr is not defined, setting offline mode');
      this.offline = true;
    }
  };
  /**
   * <b>Description</b>
   * <p>This method enables you to stop the whiteBoard session</p>
   * @method stop
   */


  this.stop = function () {
    if (!this.isStarted()) {
      logger.info('[Whiteboard] cannot stop WhiteboardClient as it is not started');
    } else {
      logger.info('[Whiteboard] Stopping WhiteBoardClient');

      if (this.isInRoom()) {
        this.leaveRoom();
      }

      this.sessionStarted = false;

      if (this.canvas !== null) {
        // we're done with these events
        this.canvas.onmousedown = null;
        this.canvas.onmouseup = null;
        this.canvas.onmouseleave = null;
        this.canvas.onmousemove = null;

        if (this.touchScreenActivated) {
          this.canvas.removeEventListener('touchstart', this.onTouchStart, false);
          this.canvas.removeEventListener('touchend', this.onTouchEnd, false);
          this.canvas.removeEventListener('touchcancel', this.onTouchCancel, false);
          this.canvas.removeEventListener('touchleave', this.onTouchEnd, false);
          this.canvas.removeEventListener('touchmove', this.onTouchMove, false);
        }
      } //Initialising Whiteboard elements : drawElements / ghostElements / redoStack


      this.drawElements = [];
      this.ghostElements = {};
      this.redoStack = [];
    }
  }; // Returns touch offset on canvas for touch events


  this.getTouchOffSet = function (touche) {
    logger.debug('[Whiteboard] getTouchOffSet():');
    var target = null,
        style = null,
        borderLeftWidth = 0,
        borderTopWidth = 0,
        rect = null,
        offset = {};
    offset.offsetX = 0;
    offset.offsetY = 0;
    target = touche.target; //style = target.currentStyle || window.getComputedStyle(target, null);

    style = window.getComputedStyle(target, null);
    borderLeftWidth = parseInt(style.borderLeftWidth, 10);
    borderTopWidth = parseInt(style.borderTopWidth, 10);
    rect = target.getBoundingClientRect();
    offset.offsetX = touche.clientX - borderLeftWidth - rect.left;
    offset.offsetY = touche.clientY - borderTopWidth - rect.top;
    logger.log('offset.offsetX :' + offset.offsetX);
    logger.log('offset.offsetY :' + offset.offsetY);
    return offset;
  };

  this.toggleTouchScreen = function () {
    if (this.touchScreenActivated === true) {
      this.deactivateTouchScreen();
    } else {
      this.activateTouchScreen();
    }
  };

  this.activateTouchScreen = function () {
    if (this.canvas !== null) {
      this.touchScreenActivated = true;
      this.canvas.addEventListener('touchstart', this.onTouchStart, false);
      this.canvas.addEventListener('touchend', this.onTouchEnd, false);
      this.canvas.addEventListener('touchcancel', this.onTouchCancel, false);
      this.canvas.addEventListener('touchleave', this.onTouchEnd, false);
      this.canvas.addEventListener('touchmove', this.onTouchMove, false);
    } else {
      logger.warn('Trying to activateTouchScreen() while canvas is null.');
    }
  };

  this.deactivateTouchScreen = function () {
    if (this.canvas !== null) {
      this.touchScreenActivated = false;
      this.canvas.removeEventListener('touchstart', this.onTouchStart, false);
      this.canvas.removeEventListener('touchend', this.onTouchEnd, false);
      this.canvas.removeEventListener('touchcancel', this.onTouchCancel, false);
      this.canvas.removeEventListener('touchleave', this.onTouchEnd, false);
      this.canvas.removeEventListener('touchmove', this.onTouchMove, false);
    } else {
      logger.warn('Trying to deactivateTouchScreen() while canvas is null.');
    }
  };

  this.activateLaserMode = function () {
    this.laserModeActivated = true;
  };

  this.deactivateLaserMode = function () {
    this.laserModeActivated = false;
  };

  this.sendDrawingData = function (offset, isDrawing, drawObject) {
    logger.debug('[Whiteboard] sendDrawingData()');
    var data = {
      x: offset.offsetX,
      y: offset.offsetY,
      drawing: isDrawing,
      prevX: this.prev.x,
      prevY: this.prev.y
    };

    if (isDrawing === false && this.userCursorColor === 'invisible') {
      logger.debug('isDrawing false and userCursorColor invisible - leaving sendDrawingData');
      return;
    }

    var userId = 0;

    if (apiCC.session !== null) {
      userId = apiCC.session.apiCCId;
    }

    if (drawObject !== null) {
      data.drawObject = drawObject;
      data.drawObject.drawingId = this.drawingId;
      data.drawObject.userId = userId;
      this.drawingId++;
    }

    data.drawingId = this.drawingId;
    this.sendDataToRoom(data);
  };

  this.onmousedown = function (e) {
    e.preventDefault();
    var target = e.target || e.srcElement,
        style = target.currentStyle || window.getComputedStyle(target, null),
        borderLeftWidth = parseInt(style.borderLeftWidth, 10) || 0,
        borderTopWidth = parseInt(style.borderTopWidth, 10) || 0,
        rect = target.getBoundingClientRect(),
        offset = {
      offsetX: this.dx + 1 / this.currentScale * (e.clientX - borderLeftWidth - rect.left),
      offsetY: this.dy + 1 / this.currentScale * (e.clientY - borderTopWidth - rect.top)
    },
        instructions = null,
        drawObject;
    this.prev.x = offset.offsetX;
    this.prev.y = offset.offsetY;
    this.isDrawing = true;
    this.undoIndex++;
    this.redoStack = []; // Hide the instructions

    instructions = document.getElementById(instructionsDivId);

    if (instructions !== null && !this.instructionsFaded) {
      fade(instructions);
      this.instructionsFaded = true;
    } //erase on mouse down


    if (this.currentTool === 'erase') {
      this.sendDrawingData(offset, this.isDrawing, null);
      var userId = 0;

      if (apiCC.session !== null) {
        userId = apiCC.session.apiCCId;
      }

      this.lastEmit = Date.now();
      drawObject = {
        type: this.currentTool,
        fromx: this.prev.x,
        fromy: this.prev.y,
        color: this.currentColor,
        width: this.currentBrushWidth,
        userId: userId,
        drawingId: this.drawingId,
        undoIndex: this.undoIndex,
        time: Date.now()
      };
      this.drawingId++;
      this.addNewDrawing(drawObject);
      this.redraw();
    }
  }.bind(this);

  this.onmouseup = function (e) {
    var target = null,
        style = null,
        borderLeftWidth = 0,
        borderTopWidth = 0,
        rect = null,
        offset = {
      offsetX: 0,
      offsetY: 0
    },
        drawObject,
        userId = 0; //draw an object if the user has selected an object drawing tool and leaving the mouse button

    if (this.isDrawing && this.GEOMETRY_TOOLS.indexOf(this.currentTool) > -1) {
      target = e.target || e.srcElement;
      style = target.currentStyle || window.getComputedStyle(target, null);
      borderLeftWidth = parseInt(style.borderLeftWidth, 10) || 0;
      borderTopWidth = parseInt(style.borderTopWidth, 10) || 0;
      rect = target.getBoundingClientRect();
      offset.offsetX = this.dx + 1 / this.currentScale * (e.clientX - borderLeftWidth - rect.left);
      offset.offsetY = this.dy + 1 / this.currentScale * (e.clientY - borderTopWidth - rect.top);

      if (apiCC.session !== null) {
        userId = apiCC.session.apiCCId;
      }

      drawObject = {
        type: this.currentTool,
        fromx: this.prev.x,
        fromy: this.prev.y,
        tox: offset.offsetX,
        toy: offset.offsetY,
        color: this.currentColor,
        width: this.currentBrushWidth,
        userId: userId,
        undoIndex: this.undoIndex,
        time: Date.now()
      };
      this.sendDrawingData(offset, this.isDrawing, drawObject);
      this.ghostElements[userId] = null;
      this.redraw();
      this.addNewDrawing(drawObject);
      this.prev.x = offset.offsetX;
      this.prev.y = offset.offsetY;
    }

    this.isDrawing = false;
    this.ghostElements[userId] = null;
  }.bind(this);

  this.onmouseleave = function () {
    var userId = 0;

    if (apiCC.session !== null) {
      userId = apiCC.session.apiCCId;
    }

    this.isDrawing = false;
    this.sendDrawingData({
      offsetX: 0,
      offsetY: 0
    }, this.isDrawing, null);
    this.ghostElements[userId] = null; //ONGOING Testing if necessary
    //this.redraw();
  }.bind(this);

  this.onmousemove = function (e) {
    var target = null,
        style = null,
        borderLeftWidth = 0,
        borderTopWidth = 0,
        rect = null,
        offset = {},
        drawObject;
    target = e.target || e.srcElement;
    style = target.currentStyle || window.getComputedStyle(target, null);
    borderLeftWidth = parseInt(style.borderLeftWidth, 10) || 0;
    borderTopWidth = parseInt(style.borderTopWidth, 10) || 0;
    rect = target.getBoundingClientRect();
    offset.offsetX = this.dx + 1 / this.currentScale * (e.clientX - borderLeftWidth - rect.left);
    offset.offsetY = this.dy + 1 / this.currentScale * (e.clientY - borderTopWidth - rect.top);

    if (Date.now() - this.lastEmit > 30) {
      this.sendDrawingData(offset, this.isDrawing, null);
      this.lastEmit = Date.now(); // Draw a line for the current user's movement if using the pen tool, as it is
      // not received in the socket.on('moving') event above

      if (this.isDrawing) {
        var userId = 0;

        if (apiCC.session !== null) {
          userId = apiCC.session.apiCCId;
        }

        drawObject = {
          type: this.currentTool,
          fromx: this.prev.x,
          fromy: this.prev.y,
          color: this.currentColor,
          width: this.currentBrushWidth,
          userId: userId,
          undoIndex: this.undoIndex,
          time: Date.now()
        };

        if (this.currentTool === 'pen' || this.currentTool === 'erase') {
          if (this.currentTool === 'pen') {
            drawObject.tox = offset.offsetX;
            drawObject.toy = offset.offsetY;
          }

          drawObject.drawingId = this.drawingId;
          this.drawingId++;
          this.addNewDrawing(drawObject);
          this.prev.x = offset.offsetX;
          this.prev.y = offset.offsetY;
        } else if (this.GEOMETRY_TOOLS.indexOf(this.currentTool) > -1) {
          //ghost tools
          drawObject.tox = offset.offsetX;
          drawObject.toy = offset.offsetY;
          this.ghostElements[userId] = drawObject;
        } //ONGOING Testing if necessary //optimisation


        if (this.currentTool !== 'pen') {
          this.redraw();
        }
      } else {
        //show erase area indicator
        if (this.currentTool === 'erase') {
          this.redraw();
          drawObject = {
            type: 'rectangle',
            fromx: offset.offsetX - this.currentBrushWidth,
            fromy: offset.offsetY - this.currentBrushWidth,
            tox: parseInt(offset.offsetX, 10) + parseInt(this.currentBrushWidth, 10),
            toy: parseInt(offset.offsetY, 10) + parseInt(this.currentBrushWidth, 10),
            color: '#444444',
            width: 1
          };
          this.drawSingleObject(drawObject);
          drawObject.color = '#DDDDDD';
          drawObject.fromx = drawObject.fromx - 1;
          drawObject.fromy = drawObject.fromy - 1;
          drawObject.tox = drawObject.tox + 1;
          drawObject.toy = drawObject.toy + 1;
          this.drawSingleObject(drawObject);
        }
      }
    }
  }.bind(this); //TouchScreen Events


  this.onTouchStart = function (e) {
    logger.debug('[Whiteboard] handleStart');
    e.preventDefault();
    var touches = e.changedTouches,
        instructions = null,
        offset = {};
    this.isDrawing = true;
    this.undoIndex++;
    this.redoStack = [];
    offset = this.getTouchOffSet(touches[0]);
    offset.offsetX = this.dx + 1 / this.currentScale * offset.offsetX;
    offset.offsetY = this.dy + 1 / this.currentScale * offset.offsetY;
    this.prev.x = offset.offsetX;
    this.prev.y = offset.offsetY;
    this.sendDrawingData(offset, false, null); // Hide the instructions

    instructions = document.getElementById(instructionsDivId);

    if (instructions !== null) {
      fade(instructions);
    }
  }.bind(this);

  this.onTouchEnd = function (e) {
    logger.debug('[Whiteboard] handleEnd :' + e);
    var offset = {},
        touches = e.changedTouches,
        drawObject,
        userId = 0; //draw an object if the user has selected an object drawing tool and leaving the touchscreen

    if (this.isDrawing && this.GEOMETRY_TOOLS.indexOf(this.currentTool) > -1) {
      offset = this.getTouchOffSet(touches[0]);
      offset.offsetX = this.dx + 1 / this.currentScale * offset.offsetX;
      offset.offsetY = this.dy + 1 / this.currentScale * offset.offsetY;

      if (apiCC.session !== null) {
        userId = apiCC.session.apiCCId;
      }

      drawObject = {
        type: this.currentTool,
        fromx: this.prev.x,
        fromy: this.prev.y,
        tox: offset.offsetX,
        toy: offset.offsetY,
        color: this.currentColor,
        width: this.currentBrushWidth,
        userId: userId,
        undoIndex: this.undoIndex,
        time: Date.now()
      };
      this.sendDrawingData(offset, this.isDrawing, drawObject);
      this.addNewDrawing(drawObject);
      this.prev.x = offset.offsetX;
      this.prev.y = offset.offsetY;
    }

    this.isDrawing = false;
    this.ghostElements[userId] = null;
    e = null;
  }.bind(this);

  this.onTouchCancel = function (e) {
    logger.debug('[Whiteboard] handleCancel :' + e);
    var userId = 0;

    if (apiCC.session !== null) {
      userId = apiCC.session.apiCCId;
    }

    this.isDrawing = false;
    this.ghostElements[userId] = null;
    e = null;
  }.bind(this);

  this.onTouchMove = function (e) {
    logger.debug('[Whiteboard] handleMove :' + e);
    var touches = e.changedTouches,
        drawObject,
        offset = {};

    if (Date.now() - this.lastEmit > 30) {
      offset = this.getTouchOffSet(touches[0]);
      offset.offsetX = this.dx + 1 / this.currentScale * offset.offsetX;
      offset.offsetY = this.dy + 1 / this.currentScale * offset.offsetY;
      this.sendDrawingData(offset, this.isDrawing, null);
      this.lastEmit = Date.now(); // Draw a line for the current user's movement, as it is
      // not received in the socket.on('moving') event above

      if (this.isDrawing) {
        offset = this.getTouchOffSet(touches[0]);
        offset.offsetX = this.dx + 1 / this.currentScale * offset.offsetX;
        offset.offsetY = this.dy + 1 / this.currentScale * offset.offsetY;
        var userId = 0;

        if (apiCC.session !== null) {
          userId = apiCC.session.apiCCId;
        }

        drawObject = {
          type: this.currentTool,
          fromx: this.prev.x,
          fromy: this.prev.y,
          color: this.currentColor,
          width: this.currentBrushWidth,
          userId: userId,
          undoIndex: this.undoIndex,
          time: Date.now()
        };

        if (this.currentTool === 'pen' || this.currentTool === 'erase') {
          if (this.currentTool === 'pen') {
            drawObject.tox = offset.offsetX;
            drawObject.toy = offset.offsetY;
          }

          drawObject.drawingId = this.drawingId;
          this.drawingId++;
          this.addNewDrawing(drawObject);
          this.prev.x = offset.offsetX;
          this.prev.y = offset.offsetY;
        } else if (this.GEOMETRY_TOOLS.indexOf(this.currentTool) > -1) {
          //ghost tools
          drawObject.tox = offset.offsetX;
          drawObject.toy = offset.offsetY;
          this.ghostElements[userId] = drawObject;
          this.redraw();
        }
      }
    }
  }.bind(this);
}; //End ApiCCWhiteBoardClient class

/**
 * Fired on room creation answer
 * @event roomCreation
 * @param {String} e.detail.eventType 'roomCreation',
 * @param {String} e.detail.time Date
 * @param {String} e.detail.status 'roomCreated',
 * @param {String} e.detail.roomId Id of the room,
 * @param {String} e.detail.roomType value can be : whiteBoard, coBrowsing. It will be coBrowsing in this case.
 */

/**
 * Fired when a room invitation is received
 * @event roomInvitation
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'roomInvitation',
 * @param {String} e.detail.roomId Id of the room,
 * @param {String} e.detail.contactList List of contacts already present in the room,
 * @param {String} e.detail.senderId Id of the invitation sender,
 * @param {String} e.detail.senderNickname Nickname of the invitation sender,
 * @param {String} e.detail.senderPhotoURL PhotoURL of the invitation sender
 * @param {String} e.detail.roomType value can be : whiteBoard, coBrowsing. It will be coBrowsing in this case.
 */

/**
 * Fired when there is an update on room members (online/offline)
 * @event roomMemberUpdate
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'roomMemberUpdate',
 * @param {String} e.detail.roomId Id of the room,
 * @param {String} e.detail.contactList List of JSON object describing the updated contact, format of the JSON Object is
 * {contactId : Id, contactNickname : nickname, contactPhotoURL : URL},
 * @param {String} e.detail.status updated status of contact : offline / online
 * @param {String} e.detail.roomType value can be : whiteBoard, coBrowsing. It will be coBrowsing in this case.
 */

/**
 * Fired on request to get the contact list in a room
 * @event contactListInRoom
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'roomMemberUpdate',
 * @param {String} e.detail.roomId Id of the room,
 * @param {String} e.detail.contactList List of JSON object describing the updated contact, format of the JSON Object is
 * {contactId : Id, contactNickname : nickname, contactPhotoURL : URL},
 * @param {String} e.detail.roomType value can be : whiteBoard, coBrowsing. It will be coBrowsing in this case.
 */

/**
 * Fired when a room message is received
 * @event receiveRoomMessage
 * @param {String} e.detail.time Date
 * @param {String} e.detail.eventType 'receiveRoomMessage',
 * @param {String} e.detail.roomId Id of the room,
 * @param {String} e.detail.senderId Id of the message sender,
 * @param {String} e.detail.senderNickname nickname of the message sender,
 * @param {String} e.detail.message message received
 * @param {String} e.detail.roomType value can be : whiteBoard, coBrowsing. It will be whiteBoard in this case.
 */




/***/ }),

/***/ "./src/Core/ApiCC_Channel.js":
/*!***********************************!*\
  !*** ./src/Core/ApiCC_Channel.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiCC_Channel": () => (/* binding */ ApiCC_Channel)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _WebRTC_Event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebRTC_Event */ "./src/Core/WebRTC_Event.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* globals apiCC, apiDB*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ApiCC_Channel');


/*
* This is the description for my class ApiCC_Channel.
*
* @module ApiCC_Channel
*/

var ApiCC_Channel = function ApiCC_Channel(session) {
  logger.debug('ApiCC_Channel');
  this.channelReady = false;
  this.socket = null;
  this.channelId = session.apiCCId;
  this.myWebRTC_Event = new _WebRTC_Event__WEBPACK_IMPORTED_MODULE_1__.WebRTC_Event();
  this.channelHasBeenDisconnected = false;
  this.cSeq = 0;
  this.updatePresenceGroupIsNeeded = false;
  this.oldPresenceGroup = null;
  this.newPresenceGroup = null;
  this.updateSubscribeToPresenceGroupIsNeeded = false;
  this.oldSubscribeToPresenceGroup = null;
  this.newSubscribeToPresenceGroup = null;

  this.initialize = function () {
    logger.info('ApiCC_Channel::initialize()');
    this.openChannel();
  };

  this.getNewCSeq = function () {
    //Incrementing cSeq before sending
    this.cSeq = this.cSeq + 1;
    return this.cSeq;
  };

  this.openChannel = function () {
    var requestOptions = "",
        stringUserData = null,
        stringUserDataEncoded = null,
        stringPresenceGroup = null,
        stringPresenceGroupEncoded = null,
        stringsubscribeToPresenceGroup = null,
        stringsubscribeToPresenceGroupEncoded = null,
        appIdContent = null,
        siteIdContent = null,
        urlStr = null,
        protocol = null;
    logger.debug('openChannel channelId :' + this.channelId);
    logger.debug('session.apiKey :' + session.apiKey);
    logger.log('session.sessionId :' + session.sessionId); //TODO Ticket #38 ApiRTC
    //Force xhrPolling for now

    session.xhrPolling = true; //TODO Ticket #38 ApiRTC

    logger.log('CCSserver used : ' + session.ccsServer);

    if (session.appId !== undefined) {
      appIdContent = '&appId=' + session.appId;
    } else {
      appIdContent = '';
    }

    if (session.siteId !== undefined) {
      siteIdContent = '&siteId=' + session.siteId;
    } else {
      siteIdContent = '';
    }

    if (session.userData !== undefined) {
      logger.log('Defined userData : ', session.userData);
      stringUserData = JSON.stringify(session.userData);
      logger.log("stringUserData.length :" + stringUserData.length); //Limiting userData length to 500

      if (stringUserData.length <= 1000) {
        //add encodeURIComponent to avoid issues on socket.io parameters if '=' is present
        stringUserDataEncoded = encodeURIComponent(stringUserData);
        requestOptions = '&userData=' + stringUserDataEncoded;
      } else {
        logger.warn("userData length is too long :" + stringUserData.length + " .Need to be <= 500");
      }
    }

    if (session.presenceGroup !== undefined) {
      logger.log('Defined presenceGroup : ' + session.presenceGroup);
      stringPresenceGroup = JSON.stringify(session.presenceGroup);
      logger.log("stringPresenceGroup.length :" + stringPresenceGroup.length); //Limiting stringPresenceGroup length to 750

      if (stringPresenceGroup.length <= 750) {
        //add encodeURIComponent to avoid issues on socket.io parameters if '=' is present
        stringPresenceGroupEncoded = encodeURIComponent(stringPresenceGroup);
        requestOptions += '&presenceGroup=' + stringPresenceGroupEncoded;
      } else {
        logger.warn("presenceGroup length is too long :" + stringPresenceGroup.length + " .Need to be <= 750");
      }
    }

    if (session.subscribeToPresenceGroup !== undefined) {
      logger.log('Defined subscribeToPresenceGroup : ' + session.subscribeToPresenceGroup);
      stringsubscribeToPresenceGroup = JSON.stringify(session.subscribeToPresenceGroup);
      logger.log("stringsubscribeToPresenceGroup.length :" + stringsubscribeToPresenceGroup.length); //Limiting stringsubscribeToPresenceGroup length to 750

      if (stringsubscribeToPresenceGroup.length <= 750) {
        //add encodeURIComponent to avoid issues on socket.io parameters if '=' is present
        stringsubscribeToPresenceGroupEncoded = encodeURIComponent(stringsubscribeToPresenceGroup);
        requestOptions += '&subscribeToPresenceGroup=' + stringsubscribeToPresenceGroupEncoded;
      } else {
        logger.warn("subscribeToPresenceGroup length is too long :" + stringsubscribeToPresenceGroup.length + " .Need to be <= 750");
      }
    }

    if (session.token !== undefined) {
      logger.log('Defined token : ' + session.token);
      requestOptions += '&token=' + session.token;
    }

    if (session.conversationSpace !== undefined && session.conversationSpace !== null) {
      logger.log('Defined conversationSpace : ' + session.conversationSpace);
      requestOptions += '&conversationSpace=' + session.conversationSpace;
    }

    logger.log('ApplicationUUID : ' + window.location.hostname);
    requestOptions += '&applicationUUID=' + window.location.hostname;
    requestOptions += '&apiLibType=apiRTC_JS';
    logger.log("requestOptions on connect :" + requestOptions);
    logger.log("session.ccsServer :" + session.ccsServer);
    urlStr = '?channelId=' + this.channelId + '&apiKey=' + session.apiKey + '&apiVersion=' + apiCC.version + '&apiCCSessionId=' + session.apiCCSessionId + '&sessionId=' + session.sessionId + appIdContent + siteIdContent + requestOptions;

    if (typeof apiRTC_React !== 'undefined') {
      protocol = 'https';
    } else {
      if (window.location.protocol === 'http:') {
        protocol = 'http';
      } else {
        protocol = 'https';
      }
    }

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_2__.osUAParser.name === "iOS" || _BrowserInfo__WEBPACK_IMPORTED_MODULE_2__.osUAParser.name === "Android") {
      logger.log(_BrowserInfo__WEBPACK_IMPORTED_MODULE_2__.osUAParser.name + " detected forcing protocol to https");
      protocol = 'https';
    }

    logger.info('CCS Connect, socket url is : ' + protocol + '://' + session.ccsServer + '/' + urlStr);
    this.ccsConnectionRetryNb = session.ccsConnectionRetryNb;
    this.ccsConnectionRetryDelay = session.ccsConnectionRetryDelay;
    this.socket = window.rtcio.connect(protocol + '://' + session.ccsServer + '/' + urlStr, {
      'forceNew': true,
      'multiplex': false,
      'withCredentials': true,
      'reconnectionAttempts': this.ccsConnectionRetryNb,
      'reconnectionDelay': this.ccsConnectionRetryDelay
    }); //this.socket = rtcio.connect(protocol + '://' + session.ccsServer + '/' + urlStr, {'forceNew': true, 'multiplex': false,  'transports': ['polling']});
    //this.socket = rtcio.connect(protocol + '://' + session.ccsServer + '/' + urlStr, {'forceNew': true, 'multiplex': false,  'transports': ['websocket']});

    this.socket.on('connect', this.callback(this, 'onChannelOpened')).on('connect_error', this.callback(this, 'onChannelConnectError')).on('message', this.callbackWithParams(this, 'onChannelMessage')).on('disconnect', this.callback(this, 'onChannelDisconnect'));
    this.socket.io.on('error', this.callback(this, 'onChannelError')).on('reconnect', this.callback(this, 'onChannelReconnect')).on('reconnect_attempt', this.callback(this, 'onChannelReconnectAttempt')).on('reconnect_error', this.callback(this, 'onChannelReconnectError')).on('reconnect_failed', this.callback(this, 'onChannelReconnect_failed'));
  };

  this.onWhiteBoardDisconnection = function () {
    logger.info('onWhiteBoardDisconnection');
    apiCC.session.closeWhiteBoardClient('NETWORK_DISCONNECTION');
  };

  this.onChannelDisconnect = function (reason) {
    logger.info('onChannelDisconnect');
    var date = Date();
    logger.debug('date :' + date); //Removing connectedUsersList Entries

    apiCC.session.connectedUsersList.splice(0, apiCC.session.connectedUsersList.length);
    this.myWebRTC_Event.createChannelEvent('onChannelDisconnect', reason);
    this.channelHasBeenDisconnected = true;

    if (apiCC.myApiCCWhiteBoardClient !== null) {
      logger.log("apiCC.myApiCCWhiteBoardClient.roomId :" + apiCC.myApiCCWhiteBoardClient.roomId);

      if (apiCC.myApiCCWhiteBoardClient.roomId !== null) {
        logger.log("Disconnection with an ongoing whiteboard");
        logger.error("Whiteboard disconnectionTimer is set to:", apiCC.myApiCCWhiteBoardClient.disconnectionTimer);
        apiCC.myApiCCWhiteBoardClient.whiteBoardDisconnectionTimeoutId = setTimeout(this.callback(this, 'onWhiteBoardDisconnection'), apiCC.myApiCCWhiteBoardClient.disconnectionTimer);
      } else {
        logger.log('Disconnection without an ongoing whiteboard');
      }
    }

    if (apiCC.session.JWTApzTokentimeOutId !== -1) {
      clearTimeout(apiCC.session.JWTApzTokentimeOutId);
    }
  };

  this.onChannelReconnect_failed = function () {
    logger.info('onChannelReconnect_failed');
    this.myWebRTC_Event.createChannelEvent('onChannelReconnect_failed');
  };

  this.onChannelReconnect = function (attemptNb) {
    logger.error('onChannelReconnect', attemptNb);
    var data = null,
        callsNumber = 0,
        i,
        callList = [],
        callListEntry = null,
        messageToSend = null,
        msgString = null,
        reconnectHasToBeSend = false,
        whiteBoardRoomId = 0,
        pointerSharingRoomIds = null,
        call = null;

    if (session.conversationSpace !== null && session.conversationSpace !== undefined) {
      logger.debug('conversationSpace is set :', session.conversationSpace);
      session.joinConversationSpace(session.conversationSpace);
    } else {
      logger.debug('no conversationSpace defined');
    }

    if (typeof session.userData !== "undefined" && session.userData !== null) {
      logger.debug('sending userData :', session.userData);
      session.setUserData(session.userData, true);
    }

    if (session.presenceGroup !== null) {
      logger.debug('presenceGroup is set :', session.presenceGroup);
      session.sendPresenceGroupManagementCommand('join', session.presenceGroup);
    } else {
      logger.debug('no presenceGroup defined');
    }

    if (session.subscribeToPresenceGroup !== null) {
      logger.debug('subscribeToPresenceGroup is set :', session.subscribeToPresenceGroup);
      session.sendPresenceGroupManagementCommand('subscribe', session.subscribeToPresenceGroup);
    } else {
      logger.debug('no subscribeToPresenceGroup defined');
    }

    if (apiCC.session.apiCCIMClient !== null) {
      if (apiCC.session.apiCCIMClient.userDataSetted === true) {
        //UserData was set, resending data to server
        data = {
          photoURL: apiCC.session.apiCCIMClient.photoURL
        };
        apiCC.session.apiCCIMClient.setUserData(data);
      } else {
        logger.log('apiCC.session.apiCCIMClient.userDataSetted !== true');
      }
    } else {
      logger.log('apiCC.session.apiCCIMClient === null');
    }

    if (apiCC.session.apiCCWebRTCClient !== null) {
      // Restarting all mesh publish calls.
      if (apiCC.session.apiCCWebRTCClient.webRTCClient.userMediaTable.length > 0) {
        reconnectHasToBeSend = true;

        for (i = 0; i < apiCC.session.apiCCWebRTCClient.webRTCClient.userMediaTable.length; i += 1) {
          call = apiCC.session.apiCCWebRTCClient.webRTCClient.userMediaTable[i];
          callListEntry = {
            destId: call.remoteId,
            convId: call.userMediaId,
            callType: call.callType,
            roomId: call.roomId,
            data: call.data,
            meshPublish: true
          };
          callList.push(callListEntry);
        } // for

      }

      callsNumber = apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable.length;

      if (callsNumber !== 0) {
        logger.log('Reconnecting with calls ongoing');

        for (i = 0; i < callsNumber; i += 1) {
          if (apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable[i] === null || apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable[i] === undefined) {
            logger.log('call no more exist');
            continue;
          }

          call = apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable[i];
          logger.debug('call.iceState =', call.iceState);

          if (call.data !== null) {
            if (call.data.type !== 'publish' && call.data.type !== 'subscribe') {
              logger.log("Call is P2P, updating media");
              call.updateMediaWithRetryManagement(true);
              callListEntry = {
                destId: call.remoteId,
                convId: call.callId,
                callType: call.callType,
                roomId: call.dest_roomId,
                data: call.data
              };
              callList.push(callListEntry);
            } else {
              logger.log("Call is in an MCU session"); // Call update will happen later, upon receipt of updateSessionAnswer message.

              callListEntry = {
                destId: call.remoteId,
                convId: call.callId,
                callType: call.callType,
                roomId: call.dest_roomId,
                data: call.data
              };
              callList.push(callListEntry);
            }
          } else {
            logger.log("Call is P2P, updating media - no data");
            call.updateMediaWithRetryManagement(true);
            callListEntry = {
              destId: call.remoteId,
              convId: call.callId,
              callType: call.callType,
              roomId: call.dest_roomId,
              data: call.data
            };
            callList.push(callListEntry);
          }
        }

        reconnectHasToBeSend = true;
      } else {
        logger.log('Reconnecting without calls ongoing');
      }

      var sessionMCUs = apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.sessionMCUs;

      for (var idx = 0; idx < sessionMCUs.length; idx += 1) {
        logger.log('Reconnecting with an ongoing sessionMCU'); //Joining and subscribing to presence group for the room

        var groupArray = [];
        groupArray.push(sessionMCUs[idx].roomName);
        apiCC.session.sendPresenceGroupManagementCommand('join', groupArray);
        apiCC.session.sendPresenceGroupManagementCommand('subscribe', groupArray);
      } // for

    }

    if (apiCC.myApiCCWhiteBoardClient !== null) {
      if (apiCC.myApiCCWhiteBoardClient.whiteBoardDisconnectionTimeoutId !== 0) {
        //Removing whiteBoardDisconnectionTimeoutId as connection is back
        logger.debug('clearing whiteBoardDisconnectionTimeoutId');
        clearTimeout(apiCC.myApiCCWhiteBoardClient.whiteBoardDisconnectionTimeoutId);
        apiCC.myApiCCWhiteBoardClient.whiteBoardDisconnectionTimeoutId = 0;
      }

      logger.log("apiCC.myApiCCWhiteBoardClient.roomId :" + apiCC.myApiCCWhiteBoardClient.roomId);

      if (apiCC.myApiCCWhiteBoardClient.roomId !== null) {
        logger.log("Reconnection with an ongoing whiteboard");
        whiteBoardRoomId = apiCC.myApiCCWhiteBoardClient.roomId;
        reconnectHasToBeSend = true;
        logger.debug("Reconnection , sending request to get most recent whiteboard data"); //request most recent whiteboard data

        apiCC.myApiCCWhiteBoardClient.paperSheetId = 0;
        apiCC.myApiCCWhiteBoardClient.drawingId = 0;
        apiCC.myApiCCWhiteBoardClient.sendDataToRoom({
          tool: 'void',
          needCatchUp: '*||-1'
        });
      } else {
        logger.log('Reconnecting without an ongoing whiteboard');
      }
    }

    if (apiCC.session.apiCCPointerSharingClient !== null) {
      pointerSharingRoomIds = apiCC.session.apiCCPointerSharingClient.getRoomIds();

      if (pointerSharingRoomIds.length > 0) {
        reconnectHasToBeSend = true;
      }
    }

    if (reconnectHasToBeSend === true) {
      logger.log('Sending reconnectContext to CCS'); //send infos to CCS to avoid CCS disconnection detection and hangup

      messageToSend = {
        type: 'reconnectContext',
        callList: callList,
        whiteBoardRoomId: whiteBoardRoomId
      };

      if (pointerSharingRoomIds !== null && pointerSharingRoomIds.length > 0) {
        messageToSend.pointerSharingRoomIds = pointerSharingRoomIds;
      }

      var _sessionMCUs = apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.sessionMCUs;

      if (_sessionMCUs.length > 0) {
        // Legacy for backward compatibility
        messageToSend.updateSession = apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.createJoinSessionMessage(null);
        messageToSend.updateSession.type = 'updateSession'; // New version

        messageToSend.updateSessions = [];

        var _iterator = _createForOfIteratorHelper(_sessionMCUs),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var sessionMCU = _step.value;
            // We will receive an updateSessionAnswer with the whole room context.
            var updateSession = apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.createJoinSessionMessage(null, {
              sessionMCU: sessionMCU
            });
            updateSession.type = 'updateSession';
            messageToSend.updateSessions.push(updateSession);
          } // for

        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      msgString = JSON.stringify(messageToSend);
      logger.log('C->S: ' + msgString);
      apiCC.session.channel.socket.emit('reconnectContext', msgString);
    }

    callList.splice(0, callList.length);
    this.myWebRTC_Event.createChannelEvent('onChannelReconnect', attemptNb);
  };

  this.onChannelReconnecting = function (attemptNb) {
    logger.info('onChannelReconnecting', attemptNb);
    var date = Date();
    logger.debug('date :' + date);
    this.myWebRTC_Event.createChannelEvent('onChannelReconnecting', attemptNb);
  };

  this.onChannelOpened = function () {
    logger.info('Channel opened');
    logger.log('this.channelId :' + this.channelId);
    this.channelReady = true;

    if (this.channelHasBeenDisconnected === false) {
      /*
              logger.log('socket.transport.name, type is :' + this.socket.socket.transport.name);
              logger.dir(this.socket.socket);
      */
      session.onChannelOpened();
    } else {
      logger.log('onChannelOpened after a disconnection, no change on session');
      this.channelHasBeenDisconnected = false; //session.onChannelOpened();
      //logger.log('params.ApiDBActivated :' + session.apiDBActivated);

      if (session.ApiDBActivated !== false && session.ApiDBActivated !== undefined && session.ApiDBActivated !== null) {
        //if (session.apiDBActivated === true) {
        //apiDB initialisation
        logger.log('apiDB initialisation');
        apiDB.init(session.channel.socket);
      }
    } //This is done on re-init


    if (this.updatePresenceGroupIsNeeded === true) {
      logger.log('Updating presence group');
      session.leavePresenceGroup(this.oldPresenceGroup);
      session.joinPresenceGroup(this.newPresenceGroup);
    }

    if (this.updateSubscribeToPresenceGroupIsNeeded === true) {
      logger.log('Updating subscribe to presence group');
      session.unsubscribePresenceGroup(this.oldSubscribeToPresenceGroup);
      session.subscribePresenceGroup(this.newSubscribeToPresenceGroup);
    }

    this.myWebRTC_Event.createChannelEvent('onChannelOpened');
  };

  this.onChannelMessage = function (message, fn) {
    var msg = null,
        quiet = false,
        convId = null;

    try {
      msg = JSON.parse(message);
    } catch (e) {
      return;
    }

    quiet = msg.type === 'checkCallStatus' || msg.type === 'apiRTCDataMessage' && msg.data && ['activeSpeaker', 'stopSpeaking'].indexOf(msg.data.type) >= 0;

    if (!quiet) {
      logger.info('onChannelMessage S->C: ' + message);
    }

    if (msg.type === 'IMMessage') {
      logger.log("IMMessage convId :" + msg.IMId);
      convId = msg.IMId;
    }

    if (fn !== undefined) {
      logger.trace("ack on message reception");
      logger.trace("convId :" + convId);
      fn({
        "reason": "ack",
        "convId": convId
      });
    }

    session.processSignalingMessage(msg, {
      quiet: quiet
    });
  }; //onChannelConnectError


  this.onChannelConnectError = function (error) {
    logger.error('onChannelConnectError :', error.message);
    this.myWebRTC_Event.createChannelEvent('onChannelConnectError', error);
    this.checkIfConnectionAttemptNeedToBeStopped(error);
  }; //onChannelReconnectError


  this.onChannelReconnectError = function (error) {
    logger.log('onChannelReconnectError :', error.message);
    this.myWebRTC_Event.createChannelEvent('onChannelReconnectError', error);
    this.checkIfConnectionAttemptNeedToBeStopped(error);
  }; //onChannelReconnectAttempt


  this.onChannelReconnectAttempt = function (attemptNb) {
    logger.log('onChannelReconnectAttempt :', attemptNb);
    this.myWebRTC_Event.createChannelEvent('onChannelReconnectAttempt', attemptNb); // Since socket.io v3, the 'reconnecting' event is no longer emitted.
    // Simulate event.

    this.onChannelReconnecting(attemptNb);
  };

  this.onChannelError = function (error) {
    logger.error('Channel error :', error.message);
    this.checkIfConnectionAttemptNeedToBeStopped(error);
    this.myWebRTC_Event.createChannelEvent('onChannelError', error);
  };

  this.checkIfConnectionAttemptNeedToBeStopped = function (error) {
    logger.debug('checkIfConnectionAttemptNeedToBeStopped');

    if (error.message === 'not authorized' || error.message.includes("access token failure:") || error.message.includes("DISABLED_ENTERPRISE") || error.message.includes("An account is needed") || error.message.includes("ApiRTC update is needed")) {
      logger.error('Stopping connection attempts');
      this.socket.disconnect();
    }
  };

  this.callback = function (that, fnct) {
    this.closureHandler = function (e) {
      return that[fnct](e);
    };

    return this.closureHandler;
  };

  this.callbackWithParams = function (that, fnct) {
    this.closureHandler = function (e, f, g) {
      return that[fnct](e, f, g);
    };

    return this.closureHandler;
  };
};



/***/ }),

/***/ "./src/Core/ApiCC_Methods.js":
/*!***********************************!*\
  !*** ./src/Core/ApiCC_Methods.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");
/* harmony import */ var _WebRTC_Event__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebRTC_Event */ "./src/Core/WebRTC_Event.js");
/* harmony import */ var _RecordManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RecordManager */ "./src/Core/RecordManager.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* harmony import */ var _AudioProcessor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AudioProcessor */ "./src/Core/AudioProcessor.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/* globals $jqApz,jQuery, MediaStreamTrack, AdapterJS, RTCSessionDescription, RTCIceCandidate, RTCPeerConnection, attachMediaStream, webkitURL, apiCC, loadjs, Sentry, apiRTC_React, eventManager, mediaDevices*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ApiCC_Methods');

var WebRTC_Adapter = (__webpack_require__(/*! ./WebRTC_Adapter.js */ "./src/Core/WebRTC_Adapter.js").WebRTC_Adapter);

apiCC.myWebRTC_Adapter = new WebRTC_Adapter();




 //TEMP_APIRTCV4 a voir

apiCC.myWebRTC_Event = new _WebRTC_Event__WEBPACK_IMPORTED_MODULE_2__.WebRTC_Event();
var myWebRTC_Event = apiCC.myWebRTC_Event;
apiCC.myEventTable = [];
apiCC.ApiCCSession = (__webpack_require__(/*! ./ApiCCSession.js */ "./src/Core/ApiCCSession.js").ApiCCSession);
apiCC.ApiCCWebRTCClient = (__webpack_require__(/*! ./ApiCCWebRTCClient.js */ "./src/Core/ApiCCWebRTCClient.js").ApiCCWebRTCClient);
apiCC.ApiCCUserMediaStream = (__webpack_require__(/*! ./ApiCCUserMediaStream.js */ "./src/Core/ApiCCUserMediaStream.js").ApiCCUserMediaStream);
apiCC.ApiCCPointerSharingClient = (__webpack_require__(/*! ./ApiCCPointerSharingClient.js */ "./src/Core/ApiCCPointerSharingClient.js").ApiCCPointerSharingClient);
apiCC.ApiCCWhiteBoardClient = (__webpack_require__(/*! ./ApiCCWhiteBoardClient.js */ "./src/Core/ApiCCWhiteBoardClient.js").ApiCCWhiteBoardClient);
apiCC.ApiCCDataClient = (__webpack_require__(/*! ./ApiCCDataClient.js */ "./src/Core/ApiCCDataClient.js").ApiCCDataClient);
apiCC.ApiCCIMClient = (__webpack_require__(/*! ./ApiCCIMClient.js */ "./src/Core/ApiCCIMClient.js").ApiCCIMClient);
apiCC.recordMgr = new _RecordManager__WEBPACK_IMPORTED_MODULE_3__.RecordManager();
apiCC.audioProcessor = new _AudioProcessor__WEBPACK_IMPORTED_MODULE_5__.AudioProcessor();

if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.applicationType !== 'electron') {
  // adding window.onbeforeunload
  __webpack_require__(/*! ./onbeforeunload.js */ "./src/Core/onbeforeunload.js");
} else {
  logger.debug("Electron detected, not loading onbeforeunload");
}
/**
 * <p>This is the ApiRTC library. <b>Version: 3.18.19</b></p>
 * <p>This library enables you to easily integrate communication features in your Web application.</p>
 * @module ApiRTC
**/

/**
* <b>Description</b>
* <p>addEventListener enables you to get notifications on apiRTC events. This enables you to customize the behavior of your application. </p>
* @method addEventListener
* @param {String} type A string representing the event type to listen for.
* @param {Object} listener The object that receives a notification when an event of the specified type occurs. (JavaScript function).
*/


apiCC.addEventListener = function (type, listener) {
  var addedElement = {},
      number = null,
      availableEvents = ["sessionReady", "incomingCall", "callEstablished", "remoteHangup", "userMediaSuccess", "userMediaError", "userMediaStop", "error", "receiveIMMessage", 'updatePresence', 'webRTCClientCreated', 'updateUserStatus', 'channelEvent', 'groupChatCreation', 'groupChatInvitation', 'groupChatMemberUpdate', 'addUserInGroupChatAnswer', 'receiveGroupChatMessage', 'userDataAnswer', 'fetchUserDataAnswer', 'receiveConversationList', 'receiveConversationHistory', 'receiveConversationDetailReport', 'receiveContactOccurrencesFromConversationList', 'receiveMCUSessionInvitation', 'MCUSessionCreation', 'MCUAvailableStream', 'MCUAvailableStreamUpdate', 'MCUAvailableReplay', 'MCURemoveStream', 'canPlayRemoteVideo', 'recordedFileAvailable', 'receiveData', 'roomCreation', 'roomJoined', 'roomInvitation', 'roomMemberUpdate', 'receiveRoomMessage', 'contactListInRoom', 'snapShotPhotoUploaded', 'stopRecord', 'callAttempt', 'joinMCUSessionAnswer', 'hangup', 'desktopCapture', 'remoteStreamAdded', 'localStreamRemoved', 'remoteStreamRemoved', 'switchStream', 'sendDataChannelOpen', 'sendDataChannelClose', 'sendDataChannelError', 'receiveDataChannelOpen', 'receiveDataChannelClose', 'receiveDataChannelError', 'connectedUsersListUpdate', 'onFileSended', 'onFileSending', 'onFileReceiving', 'onFileReceived', 'onFileProgress', 'onFilePending', 'recordedStreamsAvailable', 'closingWhiteBoard', 'webRTCPluginInstallation', 'onQosStatsUpdate', 'onQosChange', 'onQosAudioChange', 'onCallScoreUpdate', 'activeSpeaker', 'stopSpeaking', 'audioAmplitude', 'preCallTestStatus', 'onQosVideoChange', 'onCallStatsUpdate', 'cpuLimited', 'bandwidthLimited', 'MCURecordedStreamsAvailable', 'MCURecordingStarted', 'MCURecordingStopped', 'ICECandidateTypeUpdate', 'disconnectionWarning', 'MCUAvailableComposite', 'callRestarting', 'selectedICECandidate', 'MCUParticipantEjected', 'MCURoomModeChanged', 'MCUStreamingStarted', 'MCUStreamingStopped', 'mediaDeviceChanged', 'externalJsLoadingStatus', 'slowLink', 'localStreamUpdated', 'remoteStreamUpdated', 'simulcastFeedChanged', 'videoQualityChanged', 'bandwidthResourceManagement', 'backgroundSubstractionStopVisibilityChange', 'backgroundSubstractionStopComputeTime', 'AIESnapshot', 'AIELog', 'cloudEventOccurred'];

  if (availableEvents.indexOf(type) > -1) {
    if (type === "remoteHangup") {
      logger.warn("DEPRECATED : ApiRTC : remoteHangup event is now deprecated, please use hangup event instead");
    }

    logger.log('Adding listener on type :' + type);

    if (typeof apiRTC_React !== 'undefined') {
      eventManager.addEventListener(type, listener);
    } else if (document.addEventListener) {
      document.addEventListener(type, listener, false);
    } else if (typeof $jqApz !== 'undefined') {
      //Custom Event not supported in IE8, trying with JQuery
      logger.log('using $jqApz');
      $jqApz(document).on(type, listener);
    } else if (typeof jQuery !== 'undefined') {
      //Custom Event not supported in IE8, trying with JQuery
      logger.log('using jQuery');
      jQuery(document).on(type, listener);
    } else {
      logger.warn('Custom Events not supported on this browser : addEventListener()');
    }

    addedElement = {
      type: type,
      listener: listener
    };
    number = apiCC.myEventTable.push(addedElement);
    logger.trace('number of myEventTable:' + number);
  } else {
    myWebRTC_Event.createErrorEvent('ERROR: Trying to add a listener on an unknow event', 'UNKNOWN_EVENT_ON_ADDLISTENER');
    logger.log('ERROR: Trying to add a listener on an unknow event :' + type);
  }
};

apiCC.removeEventListener = function (type, listener) {
  //if ((type !== "sessionReady") || (type !== "incomingCall")  || (type !== "callEstablished") || (type !== "remoteHangup") || (type !== "userMediaSuccess") || (type !== "userMediaError") || (type !== "Error")) {
  logger.debug('Removing listener on type :' + type);

  if (document.removeEventListener) {
    document.removeEventListener(type, listener, false);
  } else if (typeof jQuery !== 'undefined') {
    //Custom Event not supported in IE8, trying with JQuery
    jQuery(document).off(type, listener);
  } else {
    logger.log('Custom Events not supported on this browser');
  } //} else {
  //    myWebRTC_Event.createErrorEvent('ERROR: Trying to add a listener on an unknow event');
  //}
  //TODO Voir pour enlever element de la table

};

apiCC.setSessionStorage = function (sName, sValue, duration) {
  logger.debug('setSessionStorage');
  duration = duration || 3600000; //valeur par defaut

  var today = new Date();
  var expires = new Date();
  expires.setTime(today.getTime() + duration);

  try {
    var toStore = JSON.stringify({
      value: sValue,
      expiresAt: expires
    });
    sessionStorage.setItem(sName, toStore);
  } catch (e) {
    logger.error('Sotheming went wrong during json strigify to set session storage values');
  }
};

apiCC.isWebRTCCompliant = function () {
  logger.debug("isWebRTCCompliant");
  var isWebRTCSupported = false,
      isWebRTCGUMSupported = false; // Detect if system supports WebRTC

  ['RTCPeerConnection', 'webkitRTCPeerConnection', 'mozRTCPeerConnection', 'RTCIceGatherer'].forEach(function (item) {
    if (isWebRTCSupported) {
      return;
    }

    if (item in window) {
      isWebRTCSupported = true;
    }
  });

  if (isWebRTCSupported === false) {
    logger.debug("isWebRTCCompliant::isWebRTCSupported false");
    return false;
  } // Detect if system supports GUM


  ['getUserMedia', 'webkitGetUserMedia', 'mozGetUserMedia', 'msGetUserMedia'].forEach(function (item) {
    if (isWebRTCGUMSupported) {
      return;
    }

    if (item in navigator) {
      isWebRTCGUMSupported = true;
    }
  });

  if (isWebRTCGUMSupported === false) {
    logger.debug("isWebRTCCompliant::isWebRTCGUMSupported false or you are connected with HTTP");
    return false;
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "MIUI Browser") {
    logger.debug("isWebRTCCompliant::MIUI Browser detected false");
    return false;
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "UCBrowser") {
    logger.debug("isWebRTCCompliant::UCBrowser detected false");
    return false;
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "QQ" || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "QQBrowser" || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "QQBrowserLite") {
    logger.debug("isWebRTCCompliant::QQ or QQBrowser or QQBrowserLite detected false");
    return false;
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Baidu" || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "baidu") {
    logger.debug("isWebRTCCompliant::Baidu or baidu detected false");
    return false;
  }

  if ((_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 11) && this.webRTCPluginActivated !== true) {
    logger.debug("isWebRTCCompliant FALSE : IE or Safari");
    return false;
  }

  logger.debug("isWebRTCCompliant:: WebRTC is supported");
  return true;
};

apiCC.isQoSStatCompliant = function () {
  var isQoSStatSupported = false;

  if (['chrome', 'firefox'].indexOf(apiCC.browserDetails.type) < 0) {
    logger.debug('QoS Statistics is only supported on Chrome and Firefox');
    return isQoSStatSupported;
  } else {
    isQoSStatSupported = true;
  }

  return isQoSStatSupported;
};

apiCC.isScreenSharingCompliant = function () {
  var isScreenSharingSupported = false; //ScreenSharing not supported on Android even if navigator.mediaDevices.getDisplayMedia is defined

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osName === "Android" || apiRTC.osName === 'iOS' && typeof cordova !== 'undefined') {
    return isScreenSharingSupported;
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 52 || navigator.getDisplayMedia || navigator.mediaDevices.getDisplayMedia) {
    isScreenSharingSupported = true;
  } else {
    logger.debug('ScreenSharing is not supported');
  }

  return isScreenSharingSupported;
};
/**
* <b>Description</b>
* <p>This method collects information about the User Agent's available media input and output devices.
* This method returns a promise.
* The promise will be fulfilled with a sequence of MediaDeviceInfo dictionaries representing the User Agent's available media input and output devices if enumeration is successful.</p>
* @method getMediaDevices
* @returns {Promise<sequence<MediaDeviceInfo>>}
*/


apiCC.getMediaDevices = function () {
  logger.debug('getMediaDevices');
  return new Promise(function (resolve, reject) {
    if (typeof apiRTC_React !== 'undefined') {
      logger.log("enumerateDevices() is supported - React Native");
      mediaDevices.enumerateDevices().then(function (sources) {
        logger.log("enumerateDevices(), sources :", sources);
        apiCC.mediaDeviceMgr.mediaSourceInfos = sources; //Adding sources in mediaDeviceMgr

        resolve(sources);
      })["catch"](function (err) {
        logger.log("enumerateDevices(), error :", err);
        reject(err);
      });
    } else if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
      logger.log("enumerateDevices() not supported.");

      if (typeof MediaStreamTrack === 'undefined') {
        logger.warn('This browser does not support MediaStreamTrack');
        reject(new Error('getMediaDevices() - MediaStreamTrack undefined'));
      } else {
        try {
          MediaStreamTrack.getSources(resolve);
        } catch (e) {
          logger.debug('catch MediaStreamTrack.getSources :' + e);
          reject(new Error('getMediaDevices() - Error on MediaStreamTrack.getSources :' + e));
        }
      }
    } else {
      logger.log("enumerateDevices() is supported.");
      navigator.mediaDevices.enumerateDevices().then(function (sources) {
        logger.log("enumerateDevices(), sources :", sources);
        apiCC.mediaDeviceMgr.mediaSourceInfos = sources; //Adding sources in mediaDeviceMgr

        resolve(sources);
      })["catch"](function (err) {
        logger.log("enumerateDevices(), error :", err);
        reject(err);
      });
    }
  });
};
/**
* <b>Description</b>
* <p> Deprecated - This method is present for interoperability with browsers that don't support Promise
* This method collects information about the User Agent's available media input and output devices.
* This method returns a callback function.
* Callback will be fulfilled with a sequence of MediaDeviceInfo dictionaries representing the User Agent's available media input and output devices if enumeration is successful.</p>
* @method getMediaDevicesWithCB
* @returns {callbackfct}
*/


apiCC.getMediaDevicesWithCB = function (callbackfct) {
  logger.debug('getMediaDevicesWithCB');

  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
    logger.log("enumerateDevices() not supported.");

    if (typeof MediaStreamTrack === 'undefined') {
      callbackfct(null);
      logger.warn('This browser does not support MediaStreamTrack');
    } else {
      try {
        MediaStreamTrack.getSources(callbackfct);
      } catch (e) {
        logger.debug('catch MediaStreamTrack.getSources :' + e);
        callbackfct(null);
      }
    }
  } else {
    logger.log("enumerateDevices() is supported.");
    navigator.mediaDevices.enumerateDevices().then(callbackfct)["catch"](function (error) {
      logger.log('navigator.mediaDevices.enumerateDevices error: ', error);
      error = null;
    });
  }
};
/**
* <b>Description</b>
* <p>This method prompts the user for permission to use their Web cam or other video or audio input.
* This method returns a promise.
* The promise will be fulfilled with a suitable MediaStream object if the user accepts valid tracks</p>
*
* @method getUserMedia
* @param {MediaStreamConstraints} constraints a dictionary of type MediaStreamConstraints
* @returns {Promise<MediaStream>}
*/


apiCC.getUserMedia = function (constraints) {
  logger.info('getUserMedia');
  logger.debug("with constraints :", constraints);
  return new Promise(function (resolve, reject) {
    if (navigator.mediaDevices !== undefined && navigator.mediaDevices.getUserMedia !== undefined) {
      logger.debug("webRTC getUserMedia with promises");
      navigator.mediaDevices.getUserMedia(constraints).then(resolve)["catch"](reject);
    } else if (typeof apiRTC_React !== 'undefined') {
      logger.debug("webRTC getUserMedia with promises on React Native");
      mediaDevices.getUserMedia(constraints).then(resolve)["catch"](reject);
    } else {
      logger.debug("webRTC getUserMedia without promises");
      apiCC.myWebRTC_Adapter.getUserMedia(constraints, resolve, reject);
    }
  });
};
/**
* <b>Description</b>
* <p> Deprecated - This method is present for interoperability with browsers that don't support Promise
* This method prompts the user for permission to use their Web cam or other video or audio input.
* This method returns callback function success or error.
* Success Callback will be fulfilled with a suitable MediaStream object if the user accepts valid tracks</p>
*
* @method getUserMediaWithCB
* @param {MediaStreamConstraints} constraints a dictionary of type MediaStreamConstraints
* @returns {Promise<MediaStream>}
*/


apiCC.getUserMediaWithCB = function (constraints, success, error) {
  logger.info('getUserMediaWithCB');
  logger.debug("with constraints :" + JSON.stringify(constraints));

  if (navigator.mediaDevices !== undefined && navigator.mediaDevices.getUserMedia !== undefined) {
    logger.log("getUserMedia with promises");
    navigator.mediaDevices.getUserMedia(constraints).then(success)["catch"](error);
  } else {
    logger.log("getUserMedia without promises");
    apiCC.myWebRTC_Adapter.getUserMedia(constraints, success, error);
  }
};

apiCC.userMediaStreamTable = [];
/**
 * Returns all user media stream ids.
 *
 * @method getUserMediaStreamIds
 * @return {object} an array of user media stream id.
 */

apiCC.getUserMediaStreamIds = function () {
  var ret = [],
      idx = apiCC.userMediaStreamTable.length;

  while (--idx >= 0) {
    ret.push(apiCC.userMediaStreamTable[idx].userMediaStreamId);
  }

  return ret;
};
/**
 * Returns a user media stream for a given id.
 * @param {number} userMediaStreamId user media stream id
 * @param {object} options
 * @return {object} user media stream info on success, null otherwise.
 */


apiCC.getUserMediaStream = function (userMediaStreamId, options) {
  var ret = null,
      idx = apiCC.userMediaStreamTable.length;

  if (userMediaStreamId === undefined || userMediaStreamId === null) {
    if (options && typeof options.accept === 'function') {
      while (--idx >= 0) {
        if (options.accept(apiCC.userMediaStreamTable[idx]) === true) {
          ret = apiCC.userMediaStreamTable[idx];
          break;
        }
      }
    }
  } else {
    while (--idx >= 0) {
      if (apiCC.userMediaStreamTable[idx].userMediaStreamId === userMediaStreamId) {
        ret = apiCC.userMediaStreamTable[idx];
        break;
      }
    }
  }

  return ret;
};
/*
 * Returns the first user media stream in table
 * @return {object} user media stream info on success, null otherwise.
 */


apiCC.getFirstUserMediaStream = function () {
  if (apiCC.userMediaStreamTable.length > 0) {
    return apiCC.userMediaStreamTable[0];
  }

  return null;
};
/*
 * @typedef CreateUserMediaStreamOptions
 * @type {Object}
 * @property {string} type - Call type. media audioOnly videoOnly screenSharing screenSharingWithAudio data
 * @property {MediaStream} stream - Media Stream.
 * @property {object} gum_config - Get user media config.
 * @property {string} audioSourceId - Source id for audio track.
 * @property {string} videoSourceId - Source id for video track.
 * @property {string} captureSourceType - Capture source type for screen sharing.
 * @property {boolean} notifyUserMediaSuccess - Whether to notify user media success (default is true).
 * @property {boolean} notifyUserMediaError - Whether to notify user media error (default is true).
 * @property {string} callId - Call id of related call.
 * @property {function} release - Callback called when stream has been released.
 * @property {function} success - Callback called on user media success.
 * @property {function} failure - Callback called on user media error.
 * @property {boolean} sync - Synchronous callback call preferred when possible.
 * @property {boolean} tryAudioCallAfterUserMediaError - whether apiRTC should try the call in audio if a userMediaError was detected 
 * @property {string} childStreamType - type of the childs stream, 'none'|'blur'|'backgroundImage'|'noiseReduction'
 */

/*
 * Creates a new user media stream and performs a getUserMedia if required.
 * @method createUserMediaStream
 * @param {CreateUserMediaStreamOptions} options.
 * @return {object} user media stream info.
 */


apiCC.createUserMediaStream = function (options) {
  var removeEntry = function removeEntry(userMediaStreamId) {
    var idx = apiCC.userMediaStreamTable.length;

    while (--idx >= 0) {
      if (apiCC.userMediaStreamTable[idx].userMediaStreamId === userMediaStreamId) {
        apiCC.userMediaStreamTable.splice(idx, 1);
        break;
      }
    }
  };

  var newUserMediaStream = new apiCC.ApiCCUserMediaStream(),
      callFlavor = 'call';
  logger.debug("[createUserMediaStream] userMediaStreamId: " + newUserMediaStream.userMediaStreamId);

  if (options === undefined || options === null) {
    options = {};
  }

  if (options.type) {
    newUserMediaStream.callType = options.type;
  }

  if (options.stream) {
    newUserMediaStream.stream = options.stream;
    newUserMediaStream.streamStolen = true;
    newUserMediaStream.notifyUserMediaStop = false;
    newUserMediaStream.listenForMuteEvents();
  } else if (options.gum_config) {
    newUserMediaStream.gum_config = (0,_Utils__WEBPACK_IMPORTED_MODULE_4__.mergeJSON)(options.gum_config); //MergeJSON to clone object
  }

  if (options.audioSourceId) {
    newUserMediaStream.inputs.audioSourceId = options.audioSourceId;
  }

  if (options.videoSourceId) {
    newUserMediaStream.inputs.videoSourceId = options.videoSourceId;
  }

  if (options.facingMode) {
    newUserMediaStream.inputs.facingMode = options.facingMode;
  }

  if (options.captureSourceType) {
    newUserMediaStream.captureSourceType = options.captureSourceType;
  }

  if (options.notifyUserMediaSuccess) {
    newUserMediaStream.notifyUserMediaSuccess = options.notifyUserMediaSuccess;
  }

  if (options.notifyUserMediaError) {
    newUserMediaStream.notifyUserMediaError = options.notifyUserMediaError;
  }

  if (options.tryAudioCallAfterUserMediaError) {
    newUserMediaStream.tryAudioCallAfterUserMediaError = options.tryAudioCallAfterUserMediaError;
  }

  if (options.displayMediaStreamConstraints) {
    newUserMediaStream.displayMediaStreamConstraints = options.displayMediaStreamConstraints;
  }

  if (options.forceExtensionOnChrome) {
    newUserMediaStream.forceExtensionOnChrome = options.forceExtensionOnChrome;
  }

  if (options.filters) {
    newUserMediaStream.filters = options.filters;
  }

  if (options.callId) {
    if (options.callFlavor === 'call' || options.callFlavor === 'userMedia') {
      callFlavor = options.callFlavor;
    }

    if (newUserMediaStream.stream === null) {
      // Related call is the owner of the new user media stream.
      newUserMediaStream.addCallInfo(options.callId, callFlavor, true);
    } else {
      // Related call is NOT the owner of the new user media stream.
      newUserMediaStream.addCallInfo(options.callId, callFlavor, false);
    }
  }

  if (options.childStreamType) {
    newUserMediaStream.childStreamType = options.childStreamType;
  }

  newUserMediaStream.callbacks.release = typeof options.release === 'function' ? options.release : function () {};
  newUserMediaStream.callbacks.success = typeof options.success === 'function' ? options.success : function () {};
  newUserMediaStream.callbacks.failure = typeof options.failure === 'function' ? options.failure : function () {};
  apiCC.userMediaStreamTable.push(newUserMediaStream);

  if (newUserMediaStream.stream === null) {
    if (newUserMediaStream.callType === 'screenSharing' || newUserMediaStream.callType === 'screenSharingWithAudio') {
      newUserMediaStream.getScreenMedia();
    } else if (newUserMediaStream.callType !== 'data') {
      newUserMediaStream.getUserMedia();
    } else {
      if (options.sync === true) {
        removeEntry(newUserMediaStream.userMediaStreamId);
        newUserMediaStream.callbacks.failure(newUserMediaStream, 'wrong type');
      } else {
        setTimeout(function () {
          removeEntry(newUserMediaStream.userMediaStreamId);
          newUserMediaStream.callbacks.failure(newUserMediaStream, 'wrong type');
        }, 0);
      }
    }
  } else {
    newUserMediaStream.updateMediaProperties(newUserMediaStream.stream);

    if (options.sync === true) {
      newUserMediaStream.callbacks.success(newUserMediaStream);
    } else {
      setTimeout(function () {
        newUserMediaStream.callbacks.success(newUserMediaStream);
      }, 0);
    }
  }

  return newUserMediaStream;
};
/**
 * Releases a given user media stream.
 * If callId is given, then the user media stream will be released only if that call is the owner
 * of the user media stream.
 * @method releaseUserMediaStream
 * @param {string} userMediaStreamId - User media stream id.
 * @param {string} callId - Related call id.
 * @param {object} options - Options.
 * @return {boolean} true on success, something else otherwise.
 */


apiCC.releaseUserMediaStream = function (userMediaStreamId, callId, options) {
  var ret = false,
      idx = apiCC.userMediaStreamTable.length,
      owner = null;

  if (callId !== null && typeof callId !== 'string') {
    callId = null;
  }

  if (userMediaStreamId === undefined || userMediaStreamId === null) {
    if (options && typeof options.accept === 'function') {
      while (--idx >= 0) {
        if (options.accept(apiCC.userMediaStreamTable[idx]) === true) {
          if (callId) {
            // A callId is mentioned.
            owner = apiCC.userMediaStreamTable[idx].getOwnerCallInfo();

            if (owner === null || owner.callId !== callId) {
              // The targeted userMediaStream has no owner or the given callId does
              // not match the callId of owner. Only removing callInfo.
              apiCC.userMediaStreamTable[idx].removeCallInfo(callId);
              break;
            }
          } else {
            // No callId is mentioned.
            owner = apiCC.userMediaStreamTable[idx].getOwnerCallInfo();

            if (owner !== null) {
              // The targeted has a owner. Only removing callInfo.
              break;
            }
          }

          logger.debug("[releaseUserMediaStream] match; userMediaStreamId: " + apiCC.userMediaStreamTable[idx].userMediaStreamId);
          apiCC.userMediaStreamTable[idx].release();

          if (callId) {
            apiCC.userMediaStreamTable[idx].removeCallInfo(callId);
          }

          apiCC.userMediaStreamTable.splice(idx, 1);
          ret = true;
          break;
        }
      }
    }
  } else {
    while (--idx >= 0) {
      if (apiCC.userMediaStreamTable[idx].userMediaStreamId === userMediaStreamId) {
        if (callId) {
          // A callId is mentioned.
          owner = apiCC.userMediaStreamTable[idx].getOwnerCallInfo();

          if (owner === null || owner.callId !== callId) {
            // The targeted userMediaStream has no owner or the given callId does
            // not match the callId of owner. Only removing callInfo.
            apiCC.userMediaStreamTable[idx].removeCallInfo(callId);
            break;
          }
        } else {
          // No callId is mentioned.
          owner = apiCC.userMediaStreamTable[idx].getOwnerCallInfo();

          if (owner !== null) {
            // The targeted has a owner. Only removing callInfo.
            break;
          }
        }

        logger.debug("[releaseUserMediaStream] id; userMediaStreamId: " + apiCC.userMediaStreamTable[idx].userMediaStreamId);
        apiCC.userMediaStreamTable[idx].release();

        if (callId) {
          apiCC.userMediaStreamTable[idx].removeCallInfo(callId);
        }

        apiCC.userMediaStreamTable.splice(idx, 1);
        ret = true;
        break;
      }
    }
  }

  return ret;
};
/**
* <b>Description</b>
* <p>Allows to enable or disable detecting the active speaker</p>
* <li>enabled: whether to enable Active Speaker Detecting</li>
* <b>Associated events:</b>
* <li>activeSpeaker</li>
* <li>audioAmplitude</li>
*
* @method enableActiveSpeakerDetecting
* @param {Boolean} enabled whether to enable Call Stats Monitoring
* @param {Integer} threshold=0.4 audio amplitude threshold. Integer between 0 and 1
*/


apiCC.activeSpeakerDetect = false;
apiCC.activeSpeakerThreshold = 0.4;

apiCC.enableActiveSpeakerDetecting = function (enabled, threshold) {
  apiCC.activeSpeakerDetect = enabled;

  if (threshold) {
    apiCC.activeSpeakerThreshold = threshold;
  }
};

apiCC.apiRTCExtensionInstalled = false;

apiCC.extensionInstallationSuccessCallback = function () {
  logger.debug("extensionInstallationSuccessCallback");
  apiCC.apiRTCExtensionInstalled = true;
};

apiCC.extensionInstallationFailureCallback = function (error, errorCode) {
  logger.debug("extensionInstallationFailureCallback : Error :" + error + ', ' + errorCode);
  error = null;
  errorCode = null;
  myWebRTC_Event.createDesktopCaptureEvent("Extension_installation_Error", apiRTC.waitingShareScreenCallId, apiRTC.waitingShareScreenDestNumber, apiRTC.waitingCaptureSourceType);
};

apiCC.manageNotInstalledExtension = function (callId, remoteId, captureSourceType) {
  logger.debug('manageNotInstalledExtension');
  logger.warn('apiRTC extension not installed');
  myWebRTC_Event.createDesktopCaptureEvent("Extension_not_installed", callId, remoteId);
  logger.warn('Starting apiRTC extension installation');
  apiRTC.waitingShareScreenDestNumber = remoteId;
  apiRTC.waitingShareScreenCallId = callId;
  apiRTC.waitingCaptureSourceType = captureSourceType;

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 71) {
    logger.debug('Chrome >= 71, opening Chrome web Store'); //chrome.webstore.install is removed

    apiRTC.extensionInstallationFailureCallback("Chrome71 : chrome.webstore.install() no more supported", "Chrome71-screenShare");
    window.open("https://chrome.google.com/webstore/detail/apizee-desktop-capture/mjjnofoemoepfididplbfimokpnpcoeg");
  } else {
    chrome.webstore.install("https://chrome.google.com/webstore/detail/mjjnofoemoepfididplbfimokpnpcoeg", apiRTC.extensionInstallationSuccessCallback, apiRTC.extensionInstallationFailureCallback);
  }
};

apiCC.activateScreenSharing = function (extensionId) {
  //ScreenShare process needed before shareScreen()
  logger.debug('activateScreenSharing');
  var extensionLink = null,
      link = null;

  if (extensionId !== undefined) {
    logger.log('extensionId is defined :' + extensionId);
  } else {
    logger.log("using apirtc extension's Id");
    extensionId = 'mjjnofoemoepfididplbfimokpnpcoeg';
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome') {
    extensionLink = document.getElementById(extensionId);

    if (extensionLink !== null) {
      logger.log("extensionLink is present, screenSharing is already activated"); // sending message to extension to check if extension is installed

      window.postMessage('apiRTC-extension', '*'); // NOSONAR
    } else {
      logger.log("screenSharing is not yet activated"); //Adding link in web page : HEAD

      link = document.createElement('link');
      link.href = 'https://chrome.google.com/webstore/detail/' + extensionId;
      link.rel = 'chrome-webstore-item';
      link.id = extensionId;
      document.getElementsByTagName('head')[0].appendChild(link); //Managing message coming from extension

      window.addEventListener('message', function (event) {
        var userMediaStream = null;
        logger.log("message: event: " + JSON.stringify(event.data));

        if (event.origin != window.location.origin) {
          return;
        }

        if (event.data === 'apiRTC-DeskstopCapture-loaded') {
          apiCC.apiRTCExtensionInstalled = true;
          return;
        }

        if (event.data === 'extensionInstalledAndLoaded') {
          apiCC.apiRTCExtensionInstalled = true;

          if (apiCC.waitingShareScreenUserMediaStream !== null && apiCC.waitingShareScreenUserMediaStream !== undefined) {
            //Adding waitingShareScreenUserMediaStream in userMediaStreamTable
            apiCC.userMediaStreamTable.push(apiCC.waitingShareScreenUserMediaStream[0]);
            delete apiCC.waitingShareScreenUserMediaStream;
          }

          if (apiCC.waitingShareScreenUserMediaStreamId) {
            userMediaStream = apiCC.getUserMediaStream(apiCC.waitingShareScreenUserMediaStreamId);
            delete apiCC.waitingShareScreenUserMediaStreamId;

            if (userMediaStream) {
              userMediaStream.getScreenMedia();
            }
          }

          return;
        }

        if (_typeof(event.data) !== 'object') {
          return;
        }

        if (event.data.desktopId === undefined) {
          return;
        }

        if (event.data.remoteId === 'getScreenMedia') {
          userMediaStream = apiCC.getUserMediaStream(event.data.callNumber);

          if (userMediaStream !== null) {
            userMediaStream.registerScreenMedia(event.data.captureSourceType, event.data.desktopId);
            return;
          }
        }
      }); // sending message to extension to check if extension is installed

      window.postMessage('apiRTC-extension', '*'); // NOSONAR
    }
  } else {
    logger.log('activateScreenSharing is only available for chrome Browser');
    myWebRTC_Event.createDesktopCaptureEvent("Browser_Not_Compatible", null, null);
  }
};

apiCC.checkIfAudioSourceIdExistOnDevice = function (audioSourceId) {
  logger.log('checkIfAudioSourceIdExistOnDevice :', audioSourceId);
  var deviceFound = false,
      i,
      sourceInfo = null;

  if (apiCC.mediaDeviceMgr.mediaSourceInfos !== null) {
    for (i = 0; i < apiCC.mediaDeviceMgr.mediaSourceInfos.length; ++i) {
      sourceInfo = apiCC.mediaDeviceMgr.mediaSourceInfos[i]; //option = document.createElement("option");
      //option.value = sourceInfo.id;

      if (sourceInfo.kind === 'audio' || sourceInfo.kind === 'audioinput') {
        if (sourceInfo.deviceId === audioSourceId) {
          logger.log("Audio device present :", audioSourceId);
          deviceFound = true;
        } else {
          logger.log("not this deviceId");
        }
      }
    }
  }

  return deviceFound;
};
/**
* <b>Description</b>
* <p>This method is an helper to set audioSourceId in MediaStreamConstraints depending of the device / browser versions and API support.</p>
*
* @method setAudioSourceIdInConstraint
* @param {DOMString} audioSourceId unique identifier for the represented audio device (check getMediaDevices)
* @param {MediaStreamConstraints} constraints a dictionary of type MediaStreamConstraints
* @returns {MediaStreamConstraints} constraint modified with the selected audio device
*/


apiCC.setAudioSourceIdInConstraint = function (audioSourceId, constraints) {
  logger.log('setAudioSourceIdInConstraint:', constraints);

  if (audioSourceId === null || audioSourceId === undefined) {
    logger.log('audioSourceId not defined');
  } else if (constraints.audio === false) {
    logger.log('constraints.audio === false, no audio device present');
  } else if (apiCC.checkIfAudioSourceIdExistOnDevice(audioSourceId) === false) {
    logger.log('audioSourceId not found on device');
    constraints.audio = {};
  } else {
    if (constraints.audio === true || constraints.audio === undefined) {
      constraints.audio = {};
    }

    logger.log('audioSourceId is defined :', audioSourceId);

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "iOS") {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Mobile Safari') {//NOTE : On Mobile Safari, there is only one micro, we don't set deviceId to avoid any conflict on getUserMedia if deviceId change
        //constraints.audio.deviceId = audioSourceId ? {exact: audioSourceId} : undefined;
      } else {
        constraints.audio.deviceId = audioSourceId;
      }
    } else {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 50) {
        constraints.audio.deviceId = audioSourceId;
      } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 48 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 11) {
        constraints.audio.optional = [{
          sourceId: audioSourceId
        }];
      } else {
        constraints.audio.deviceId = audioSourceId ? {
          ideal: audioSourceId
        } : undefined;
      }
    }
  }

  logger.debug('constraints =', constraints);
  return constraints;
};

apiCC.checkIfVideoSourceIdExistOnDevice = function (videoSourceId) {
  logger.log('checkIfVideoSourceIdExistOnDevice :', videoSourceId);
  var deviceFound = false,
      i,
      sourceInfo = null;
  logger.debug('apiCC.mediaDeviceMgr.mediaSourceInfos :', apiCC.mediaDeviceMgr.mediaSourceInfos);

  if (apiCC.mediaDeviceMgr.mediaSourceInfos !== null) {
    for (i = 0; i < apiCC.mediaDeviceMgr.mediaSourceInfos.length; ++i) {
      sourceInfo = apiCC.mediaDeviceMgr.mediaSourceInfos[i]; //option = document.createElement("option");
      //option.value = sourceInfo.id;

      if (sourceInfo.kind === 'video' || sourceInfo.kind === 'videoinput') {
        if (sourceInfo.deviceId === videoSourceId) {
          logger.log("Video device present :", videoSourceId);
          deviceFound = true;
        } else {
          logger.log("not this deviceId");
        }
      }
    }
  }

  return deviceFound;
};

apiCC.getMediaDeviceLabelFromDeviceid = function (videoSourceId) {
  logger.log('getMediaDeviceLabelFromDeviceid :', videoSourceId);
  var deviceLabel = 'Not_Found',
      i,
      sourceInfo = null;
  logger.debug('apiCC.mediaDeviceMgr.mediaSourceInfos :', apiCC.mediaDeviceMgr.mediaSourceInfos);

  if (apiCC.mediaDeviceMgr.mediaSourceInfos !== null) {
    for (i = 0; i < apiCC.mediaDeviceMgr.mediaSourceInfos.length; ++i) {
      sourceInfo = apiCC.mediaDeviceMgr.mediaSourceInfos[i];

      if (sourceInfo.deviceId === videoSourceId) {
        logger.log("Video device present :", videoSourceId);
        deviceLabel = sourceInfo.label;
      } else {
        logger.log("not this deviceId");
      }
    }
  }

  return deviceLabel;
};
/**
* <b>Description</b>
* <p>This method is an helper to set videoSourceId in MediaStreamConstraints depending of the device / browser versions and API support.</p>
*
* @method setVideoSourceIdInConstraint
* @param {DOMString} videoSourceId unique identifier for the represented video device (check getMediaDevices)
* @param {MediaStreamConstraints} constraints a dictionary of type MediaStreamConstraints
* @returns {MediaStreamConstraints} constraint modified with the selected video device
*/


apiCC.setVideoSourceIdInConstraint = function (videoSourceId, constraints) {
  logger.log('setVideoSourceIdInConstraint : ', constraints);

  if (videoSourceId === null || videoSourceId === undefined) {
    logger.log('videoSourceId not defined');
  } else if (constraints.video === false) {
    logger.log('constraints.video === false, no video device present');
  } else if (apiCC.checkIfVideoSourceIdExistOnDevice(videoSourceId) === false) {
    logger.log('videoSourceId not found on device');
    constraints.video = {};
  } else {
    logger.log('videoSourceId is defined :', videoSourceId);

    if (constraints.video === true || constraints.video === undefined) {
      constraints.video = {};
    }

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "iOS") {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Mobile Safari') {
        if (videoSourceId) {
          // There is an issue with `ideal` constraint property on iOS < 13:
          // system always returns default (eg front) camera stream
          // To fix it replace `ideal` with `exact` for iOS < 13
          var osRequiresExactConstraint = false;
          var splitOSVersion = _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.version.split('.');

          if (splitOSVersion.length > 0) {
            var osVersion = parseInt(splitOSVersion[0]);

            if (osVersion < 13) {
              osRequiresExactConstraint = true;
            }
          }

          constraints.video.deviceId = osRequiresExactConstraint ? {
            exact: videoSourceId
          } : {
            ideal: videoSourceId
          };
        }
      } else {
        constraints.video.deviceId = videoSourceId;
      }
    } else {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 50) {
        if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 77) {
          logger.debug('FX > 77 using exact to set deviceId');
          constraints.video.deviceId = {
            exact: videoSourceId
          };
        } else {
          constraints.video.deviceId = videoSourceId;
        }
      } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 48 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 11) {
        constraints.video.optional = [{
          sourceId: videoSourceId
        }];
      } else {
        constraints.video.deviceId = videoSourceId ? {
          ideal: videoSourceId
        } : undefined;
      }
    }
  }

  logger.log('constraints =', constraints);
  return constraints;
};
/**
* <b>Description</b>
* <p>This method is an helper to set facingMode in MediaStreamConstraints. This is usefull for iOS</p>
* @method setVideoFacingModeInConstraint
* @param {String} facingMode should be equal to 'user', 'environment', 'left' or 'right'.
* @param {MediaStreamConstraints} constraints a dictionary of type MediaStreamConstraints
* @returns {MediaStreamConstraints} constraint modified with the facingMode setted
*/


apiCC.setVideoFacingModeInConstraint = function (facingMode, constraints) {
  logger.log('setVideoFacingModeInConstraint');
  var supportedConstraints = {};

  if (constraints.video === false) {
    logger.log('facingMode value is not setted, constraints.video is false');
    return constraints;
  }

  if (facingMode === null || facingMode === undefined) {
    logger.log('facingMode value is not setted');
    return constraints;
  }

  if (facingMode !== 'user' && facingMode !== 'environment' && facingMode !== 'left' && facingMode !== 'right') {
    logger.log('facingMode value is not correct');
    return constraints;
  }

  if (navigator.mediaDevices !== null && navigator.mediaDevices !== undefined) {
    if (navigator.mediaDevices.getSupportedConstraints !== null && navigator.mediaDevices.getSupportedConstraints !== undefined) {
      supportedConstraints = navigator.mediaDevices.getSupportedConstraints();
    }
  }

  if (supportedConstraints.hasOwnProperty('facingMode')) {
    logger.log('Setting FacingMode in constraint');

    if (constraints.video === true) {
      constraints.video = {};
    }

    constraints.video.facingMode = {
      ideal: facingMode
    };
    /*
            if (constraints.video.deviceId !== undefined) {
                logger.log('Removing deviceId in constraint to force facingMode usage');
                delete constraints.video.deviceId;
            }
    */
  } else {
    logger.log('FacingMode not supported by device');
  }

  logger.debug('constraints =', constraints);
  return constraints;
};
/**
* <b>Description</b>
* <p>This method is an helper to set resolution in MediaStreamConstraints. This is usefull for iOS</p>
* <p>This method override any resolution settings.</p>
* @method setResolutionInConstraint
* @param {Integer} width width of the video in pixels.
* @param {Integer} height height of the video in pixels.
* @param {MediaStreamConstraints} constraints a dictionary of type MediaStreamConstraints
* @returns {MediaStreamConstraints} constraint modified with the facingMode setted
*/


apiCC.setResolutionInConstraint = function (width, height, constraints) {
  logger.log('setResolutionInConstraint');

  if (width <= 0 || height <= 0) {
    logger.log('Resolution value must be positif non null');
    return constraints;
  }

  if (constraints.video === true || constraints.video !== undefined) {
    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "iOS") {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Mobile Safari') {
        constraints.video.width = width ? {
          exact: width
        } : undefined;
        constraints.video.height = height ? {
          exact: height
        } : undefined;
      } else {
        constraints.video.width = width;
        constraints.video.height = height;
      }
    } else {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 50) {
        constraints.video.width = width;
        constraints.video.height = height;
      } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 11 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Mobile Safari' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Edge' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 49 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 50) {
        constraints.video.width = width ? {
          exact: width
        } : undefined;
        constraints.video.height = height ? {
          exact: height
        } : undefined;
      } else {
        constraints.video.mandatory = [{
          width: width,
          height: height
        }];
      }
    }
  } else {
    logger.error('setResolutionInConstraint : contraint.video must be true or defined');
  }

  logger.debug('constraints =', constraints);
  return constraints;
};

apiCC.checkConstraintDependingOnDevice = function (gum_config) {
  logger.debug('checkConstraintDependingOnDevice :', gum_config);

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Mobile Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 13) {
    if (gum_config.video !== undefined) {
      if (gum_config.video.height !== undefined) {
        if (gum_config.video.width !== undefined) {
          if (gum_config.video.height.ideal === 1080 && gum_config.video.width.ideal === 1920) {
            logger.debug('Downgrading selected height and width resolution on iOS, to avoid stream issue');
            gum_config.video.height.ideal = 720;
            gum_config.video.width.ideal = 1280;
          }
        }
      }
    }
  }
};
/**
* <b>Description</b>
* <p>This method is an helper to attach the mediastream on the HTML <audio> or <video> element depending of the device / browser versions and API support.</p>
*
* @method attachMediaStream
* @param {HTML5DOMElement} mediaElement unique identifier for the represented video device (check getMediaDevices)
* @param {MediaStream} stream a dictionary of type MediaStreamConstraints
*/


apiCC.attachMediaStream = function (mediaElement, stream) {
  logger.debug('attachMediaStream');

  if (mediaElement === null) {
    logger.log('videoElt is null');
    return;
  }

  if (typeof mediaElement.srcObject !== 'undefined') {
    mediaElement.srcObject = stream;
  } else if (typeof mediaElement.mozSrcObject !== 'undefined') {
    mediaElement.mozSrcObject = stream;
  } else if (typeof mediaElement.src !== 'undefined') {
    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 46) {
      logger.log('Attaching media stream for Chrome < 46');
      mediaElement.src = webkitURL.createObjectURL(stream);
    } else {
      mediaElement.src = URL.createObjectURL(stream);
    }
  } else {
    logger.error('Error attaching stream to element.');
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "iOS") {
    logger.log('iOS detected');
    mediaElement.setAttribute('playsinline', true);
  }
};

apiCC.detachMediaStream = function (mediaElement, stream) {
  logger.debug('detachMediaStream');

  if (mediaElement === null) {
    logger.log('videoElt is null');
    return;
  }

  if (typeof mediaElement.srcObject !== 'undefined') {
    mediaElement.srcObject = null;
  } else if (typeof mediaElement.mozSrcObject !== 'undefined') {
    mediaElement.mozSrcObject = null;
  } else if (typeof mediaElement.src !== 'undefined') {
    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 46) {
      logger.log('Attaching media stream for Chrome < 46');
      webkitURL.revokeObjectURL(mediaElement.src);
    } else {
      URL.revokeObjectURL(mediaElement.src);
    }

    mediaElement.src = '';
  } else {
    logger.error('Error while detaching stream to element.');
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "iOS") {
    logger.log('iOS detected');
    mediaElement.removeAttribute('playsinline');
  }
};

apiCC.addStreamInDiv = function (stream, streamType, divId, mediaEltId, style, muted, options) {
  logger.debug('addStreamInDiv');
  var mediaElt = null,
      divElement = null,
      playMediaElement = null,
      separateAudioAndVideoWorkaroundActivated = false,
      //Used to have a workaround on video pause when several non muted video are played on iOS
  separatedMediaEltAudio = null;

  if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isTypeof)(options, 'object') && options.type != undefined) {
    streamType = options.type;
  }

  if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isTypeof)(options, 'object') && options.forceAudioAndVideoMediaElementSeparation !== undefined) {
    logger.debug('forceAudioAndVideoMediaElementSeparation is set'); //We set separateAudioAndVideoWorkaroundActivated to true as it will create audio and video separated elements

    separateAudioAndVideoWorkaroundActivated = true;
  }

  if (streamType === 'audio') {
    mediaElt = document.createElement("audio");
  } else {
    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osName === "iOS" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Mobile Safari') {
      logger.debug('iOS && Mobile Safari');
      separateAudioAndVideoWorkaroundActivated = true;
    }

    mediaElt = document.createElement("video");
  }

  mediaElt.id = mediaEltId;
  mediaElt.autoplay = true;

  if (separateAudioAndVideoWorkaroundActivated === true && muted === false) {
    logger.debug('before adding separated MediaEltAudio');
    separatedMediaEltAudio = document.createElement("audio");
    separatedMediaEltAudio.id = mediaEltId + '_sepAudio';
    separatedMediaEltAudio.muted = muted;
    separatedMediaEltAudio.autoplay = true;
    mediaElt.muted = true;
  } else {
    mediaElt.muted = muted;
  }

  mediaElt.style.width = style.width;
  mediaElt.style.height = style.height;

  if (style.controls === true) {
    mediaElt.controls = true;
  }

  playMediaElement = function playMediaElement(mediaEltToPlay) {
    var _funcFixIoS = null,
        promise = mediaEltToPlay.play();

    _funcFixIoS = function funcFixIoS() {
      var promise = mediaEltToPlay.play();
      logger.log('funcFixIoS');

      if (promise !== undefined) {
        promise.then(function () {
          // Autoplay started!
          logger.log('Autoplay started');
          document.removeEventListener('touchstart', _funcFixIoS);
        })["catch"](function (error) {
          // Autoplay was prevented.
          logger.error('Autoplay was prevented');
        });
      }
    };

    if (promise !== undefined) {
      promise.then(function () {
        // Autoplay started!
        logger.log('Autoplay started');
      })["catch"](function (error) {
        // Autoplay was prevented.
        if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "iOS") {
          logger.warn('iOS : Autoplay was prevented, activating touch event to start media play');
          apiCC.myWebRTC_Event.createErrorEvent('ERROR: iOS : Autoplay was prevented', 'IOS_AUTOPLAY_PREVENTED'); //Show a UI element to let the user manually start playback

          document.addEventListener('touchstart', _funcFixIoS);
        } else {
          logger.warn('Autoplay was prevented');
        }
      });
    }
  }; //Patch for ticket on Chrome 61 Android : https://bugs.chromium.org/p/chromium/issues/detail?id=769148


  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version === '61' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osName === "Android") {
    mediaElt.style.borderRadius = "1px";
    logger.log('Patch for video display on Chrome 61 Android');
  }

  if (apiCC.session && apiCC.session.apiCCWebRTCClient && typeof apiCC.session.apiCCWebRTCClient.webRTCClient.audioOutputId !== 'undefined' && apiCC.session.apiCCWebRTCClient.webRTCClient.audioOutputId !== null) {
    logger.log('audioOutputId set to: ' + apiCC.session.apiCCWebRTCClient.webRTCClient.audioOutputId);
    mediaElt.setSinkId(apiCC.session.apiCCWebRTCClient.webRTCClient.audioOutputId).then(function () {
      logger.log('Success, audio output device attached');
    });
  } else {
    logger.log('No audioOutputId set');
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osName !== "iOS") {
    //Done before attachMediaStream except for iOS
    divElement = document.getElementById(divId);
    divElement.appendChild(mediaElt);
  }

  if (stream !== undefined) {
    apiCC.attachMediaStream(mediaElt, stream);

    if (separateAudioAndVideoWorkaroundActivated === true && muted === false) {
      apiCC.attachMediaStream(separatedMediaEltAudio, stream);
    }
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osName === "iOS") {
    //Done after attachMediaStream for iOS
    divElement = document.getElementById(divId);
    divElement.appendChild(mediaElt);
  }

  if (separateAudioAndVideoWorkaroundActivated === true && muted === false && divElement !== null) {
    divElement.appendChild(separatedMediaEltAudio);
  }

  playMediaElement(mediaElt);

  if (separateAudioAndVideoWorkaroundActivated === true && muted === false) {
    playMediaElement(separatedMediaEltAudio);
  }
};

apiCC.removeElementFromDiv = function (divId, eltId) {
  logger.debug('removeElementFromDiv');
  var element = null,
      divElement = null,
      sepElementAudio = null;
  element = document.getElementById(eltId);
  divElement = document.getElementById(divId);

  if (element !== null) {
    logger.log('Removing video element with Id : ' + eltId);

    if (divElement !== null) {
      divElement.removeChild(element);
    }
  }

  sepElementAudio = document.getElementById(eltId + '_sepAudio');

  if (sepElementAudio !== null) {
    logger.log('iOS : Removing audio element with Id : ' + eltId + '_sepAudio');

    if (divElement !== null) {
      divElement.removeChild(sepElementAudio);
    }
  }
};
/*
 * Generates a variable-length random string.
 * @ignore
 * @param len {number} number of characters.
 * @param charPool {string} optional character set.
 * @return {string}
 */


apiCC.randomString = function (len, charPool) {
  var charSet = typeof charPool === 'string' && charPool.length > 0 ? charPool : '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
  var ret = '';

  while (--len >= 0) {
    ret += charSet.charAt(Math.floor(Math.random() * charSet.length));
  }

  return ret;
};

apiCC.generateCallId = function () {
  //CallId has to be generated by the caller and transmitted to the callee
  var callId = 0;

  if (Number.MAX_SAFE_INTEGER !== undefined) {
    callId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString();
  } else {
    callId = Math.floor(Math.random() * 1000001).toString();
  }

  logger.debug('new callId :' + callId);
  return callId;
};

apiCC.generateInstanceId = function () {
  //InstanceId is used to differentiate call instance. For instance whan a call is restarted after a disconnection
  var instanceId = 0;

  if (Number.MAX_SAFE_INTEGER !== undefined) {
    instanceId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString();
  } else {
    instanceId = Math.floor(Math.random() * 1000001).toString();
  }

  logger.debug('new instanceId :' + instanceId);
  return instanceId;
};

apiCC.myApiCCWhiteBoardClient = null;

apiCC.createWhiteBoard = function (paperDivId, userCursorColor, instructionsDivId, disconnectionTimer) {
  logger.debug('createWhiteBoard');
  apiCC.myApiCCWhiteBoardClient = new apiCC.ApiCCWhiteBoardClient(apiCC.session, paperDivId, userCursorColor, instructionsDivId, disconnectionTimer);
  return apiCC.myApiCCWhiteBoardClient;
};

apiCC.closeWhiteBoardClient = function (reason) {
  logger.info("closeWhiteBoardClient");
  myWebRTC_Event.createClosingWhiteBoardEvent(apiCC.myApiCCWhiteBoardClient.roomId, reason);

  if (apiCC.myApiCCWhiteBoardClient.isInRoom()) {
    apiCC.myApiCCWhiteBoardClient.leaveRoom();
  } //Stopping whiteboard process : mousemove detection ...


  apiCC.myApiCCWhiteBoardClient.stop();
};
/*
    * <b>Description</b>
    * <p>This method register your mobile device</p>
    * @method registerIOsdevice
    * @param {String} token device token
    */


apiCC.registerIOsDevice = function (token) {
  logger.debug('call registerIOsDevice 1');
  var messageToSend = {
    type: 'registerIOsDevice',
    senderId: apiCC.session.apiCCId,
    token: token
  },
      msgString = JSON.stringify(messageToSend);
  logger.debug('call registerIOsDevice ' + msgString);
  apiCC.session.channel.socket.emit('registerIOsDevice', msgString);
  logger.debug('call registerIOsDevice  done');
};
/*
    * <b>Description</b>
    * <p>This method register your mobile device</p>
    * @method registerAndroidDevice
    * @param {String} token device token
    */


apiCC.registerAndroidDevice = function (token) {
  logger.debug('registerAndroidDevice');
  var messageToSend = {
    type: 'registerAndroidDevice',
    senderId: apiCC.session.apiCCId,
    token: token
  },
      msgString = JSON.stringify(messageToSend);
  apiCC.session.channel.socket.emit('registerAndroidDevice', msgString);
};
/*
* <b>Description</b>
* <p>This method remove your mobile device</p>
* @method unRegisterIOsDevice
* @param {String} token device token
*/


apiCC.unRegisterIOsDevice = function (token) {
  logger.debug('unRegisterIOsDevice');
  var messageToSend = {
    type: 'unRegisterIOsDevice',
    senderId: apiCC.session.apiCCId,
    token: token
  },
      msgString = JSON.stringify(messageToSend);
  apiCC.session.channel.socket.emit('unRegisterIOsDevice', msgString);
};
/*
    * <b>Description</b>
    * <p>This method register your mobile device</p>
    * @method unRegisterAndroidDevice
    * @param {String} token device token
    */


apiCC.unRegisterAndroidDevice = function (token) {
  logger.debug('unRegisterAndroidDevice');
  var messageToSend = {
    type: 'unRegisterAndroidDevice',
    senderId: apiCC.session.apiCCId,
    token: token
  },
      msgString = JSON.stringify(messageToSend);
  apiCC.session.channel.socket.emit('unRegisterAndroidDevice', msgString);
};
/*
 * Stores session information in sessionStorage.
 * @ignote
 * @method storeSessionInfoInSessionStorage
 * @param {object} opts
 * @param {number} opts.apiCCIdPersistenceTimeout - Time in ms to keep the apiCCId, the apiKey and the sessionId.
 */


apiCC.storeSessionInfoInSessionStorage = function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  logger.info('storeSessionInfoInSessionStorage', opts);

  if (!apiCC.session) {
    return;
  }

  var apiCCIdPersistenceTimeout = 5000;

  if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isPropertyTypeof)(apiCC.session, 'apiCCIdPersistenceTimeout', 'number') && apiCC.session.apiCCIdPersistenceTimeout >= 0) {
    apiCCIdPersistenceTimeout = apiCC.session.apiCCIdPersistenceTimeout;
  }

  if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isTypeof)(opts.apiCCIdPersistenceTimeout, 'number') && opts.apiCCIdPersistenceTimeout >= 0) {
    apiCCIdPersistenceTimeout = opts.apiCCIdPersistenceTimeout;
  }

  apiCC.setSessionStorage('apiCCId', apiCC.session.apiCCId, apiCCIdPersistenceTimeout);
  apiCC.setSessionStorage('apiKey', apiCC.session.apiKey, apiCCIdPersistenceTimeout);

  if (apiCC.session.sessionId !== null) {
    apiCC.setSessionStorage('sessionId', apiCC.session.sessionId, apiCCIdPersistenceTimeout);
  }
};
/**
 * <b>Description</b>
 * <p>This method enables you to disconnect the apiRTC session.</p>
 * @method disconnect
 * @param {object} opts
 * @param {boolean} opts.invalidateApiCCId - Whether the current apiCCId shall not be kept.
 * @param {number} opts.apiCCIdPersistenceTimeout - Time in ms to keep the apiCCId, the apiKey and the sessionId.
 */


apiCC.disconnect = function () {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  logger.info('disconnect', opts);

  if (apiCC !== null) {
    apiCC.cleanAllEventListener();
  }

  if (apiCC.session !== null && apiCC.session !== undefined) {
    if (typeof apiRTC_React === 'undefined') {
      if (opts.invalidateApiCCId !== true) {
        apiCC.storeSessionInfoInSessionStorage(opts);
      }
    }

    if (apiCC.myApiCCWhiteBoardClient !== null) {
      logger.log("apiCC.myApiCCWhiteBoardClient.roomId :" + apiCC.myApiCCWhiteBoardClient.roomId);

      if (apiCC.myApiCCWhiteBoardClient.roomId !== null) {
        apiCC.closeWhiteBoardClient('USER_DISCONNECTION');
      }
    }

    logger.log('Disconnecting from Server');

    if (apiCC.session.channel.socket !== undefined && apiCC.session.channel.socket !== null) {
      apiCC.session.channel.socket.disconnect();
    } //Setting channelHasBeenDisconnected to false as it is a forced disconnection


    apiCC.session.channel.channelHasBeenDisconnected = false; //Removing connectedUsersList Entries

    apiCC.session.connectedUsersList.splice(0, apiCC.session.connectedUsersList.length); //TODO : Removed on apiRTC 3.6.5 to enable call reconnection, need to check if it has no impact
    //apiCC.session.channel.socket = null;
  }

  if (apiCC) {
    apiCC.session = null;
    apiCC.jsLoaded = false;
  }
};

apiCC.reconnect = function () {
  logger.log('Reconnect');
  logger.log('apiCC.session.channel.socket:', apiCC.session.channel.socket);
  apiCC.session.channel.socket.socket.connect();
};

apiCC.cleanApiRTCContext = function () {
  if (apiCC.session !== null && apiCC.session !== undefined) {
    if (apiCC.session.apiCCWebRTCClient !== null && apiCC.session.apiCCWebRTCClient !== undefined) {
      if (apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable.length !== 0) {
        //INFO : when user refresh his page during a calls, there is no more alert to say that he is in call
        //return "Call is still established, if you continue call will be ended. Do you really want to leave ?";
        logger.warn("Call is still established and will be disconnected");
      }

      if (apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.sessionMCUs.length > 0) {
        logger.log('MCU session is still established and will be disconnected');
      }

      apiCC.session.apiCCWebRTCClient.hangUp();

      if (apiCC.session.apiCCWebRTCClient.webRTCClient.localStream !== null) {
        apiCC.session.apiCCWebRTCClient.webRTCClient.stopStream(apiCC.session.apiCCWebRTCClient.webRTCClient.localStream);
        myWebRTC_Event.createUserMediaStopEvent(null, 'media'); //apiCC.session.apiCCWebRTCClient.webRTCClient.localStream.stop();
        //apiCC.session.apiCCWebRTCClient.webRTCClient.localStream = null;
      }

      apiCC.session.apiCCWebRTCClient = null;
    }

    if (apiCC.session.apiCCIMClient !== null && apiCC.session.apiCCIMClient !== undefined) {
      apiCC.session.apiCCIMClient = null;
    }

    if (apiCC.session.apiCCDataClient !== null && apiCC.session.apiCCDataClient !== undefined) {
      apiCC.session.apiCCDataClient = null;
    }

    if (apiCC.myApiCCWhiteBoardClient !== null && apiCC.myApiCCWhiteBoardClient !== undefined) {
      apiCC.myApiCCWhiteBoardClient = null;
    }
  }
};

apiCC.cleanAllEventListener = function () {
  var number = 0,
      i;

  if (apiCC !== null) {
    if (apiCC.myEventTable !== null) {
      number = apiCC.myEventTable.length;
    }
  }

  if (number !== 0) {
    logger.trace('number of myEventTable:' + number);

    for (i = 0; i < number; i += 1) {
      apiCC.removeEventListener(apiCC.myEventTable[i].type, apiCC.myEventTable[i].listener);
    }

    apiCC.myEventTable.splice(0, number); //TODO Temp a voir pour enlever element de la table sur removeEventHandler

    number = apiCC.myEventTable.length;
    logger.trace('number of myEventTable after splice:' + number);
  }
};
/*
* <b>Description</b>
* <p>This method tests user ping with bandwidth test server. </p>
* @method testUserPing
* @param {function} callback Callback function with two parameters (error, result). error is null when and only when test is successful and result is null when and only when test is unsuccessful.
*/


apiCC.testUserPing = function (callback) {
  logger.debug("testUserPing()");
  var testServer = apiCC.bandwidthTestServer + "/upload-test",
      xhr = new XMLHttpRequest(),
      formData = new FormData(),
      content = Math.round(Math.random() * 5),
      //random to avoid compression,
  blob,
      startTime,
      timedOut = false,
      timeoutError,
      totalTime; //create xhr object

  if ("withCredentials" in xhr) {
    // XHR for Chrome/Firefox/Opera/Safari.
    xhr.open("POST", testServer, true);
  } else if (typeof XDomainRequest !== "undefined") {
    // XDomainRequest for IE.
    xhr = new XDomainRequest();
    xhr.open("POST", testServer);
  } else {
    // CORS not supported.
    xhr = null;
  }

  blob = new Blob([content], {
    type: "text/xml"
  });
  formData.append("file", blob); // Set up the request.

  if (!xhr) {
    callback({
      err: "XMLHttpRequest is not defined",
      msg: "XMLHttpRequest is not defined"
    }, null);
  } else {
    // Set up a handler for when the request finishes.
    xhr.onload = function () {
      if (xhr.status === 200) {
        // File uploaded.
        totalTime = Date.now() - startTime;

        if (!timedOut) {
          clearTimeout(timeoutError);
          callback(null, totalTime);
        }
      }
    };

    xhr.onerror = function (e) {
      logger.log("testUserUpload onerror status :", e.target.status);
      callback({
        err: "An error occured during XMLHttpRequest",
        msg: e.target.status
      }, null);
    }; // Send the Data.


    timeoutError = setTimeout(function () {
      timedOut = true;
      callback("Ping timeout", -1);
    }, 5000);
    xhr.send(formData);
    startTime = Date.now();
  }
};
/*
* <b>Description</b>
* <p>This method starts a speed test for the user download capabilities. </p>
* @method testUserDownload
* @param {function} callback Callback function with two parameters (error, result). error is null when and only when test is successful and result is null when and only when test is unsuccessful.
*/


apiCC.testUserDownload = function (size, callback) {
  logger.debug("testUserDownload()");
  var testServer = apiCC.bandwidthTestServer,
      imageAddr = testServer + "/files/noise_" + size + "ko.jpg",
      downloadSize = 0,
      startTime,
      totalTime,
      download = new Image(),
      BPerSec,
      kBPersec,
      i,
      result,
      rating = 0;
  imageAddr += "?nnn=" + Date.now(); //avoid cache

  var downloadSizes = [[256, 257529], [500, 525944], [768, 787234], [1000, 1055741], [1500, 1541044], [2000, 1992034], [2500, 2596028], [3000, 2904977], [3500, 3648299], [4000, 4151187], [4500, 4741712], [5000, 5264577], [5500, 5776081], [6000, 6318553], [6500, 6779868], [7000, 7334256], [7500, 7874040], [8000, 8081460], [8500, 8651795], [9000, 9081899], [9500, 9503574], [10000, 10082008], [10500, 10543425], [11000, 11200424], [11500, 11200424], [12000, 12110671], [12500, 12715962], [13000, 13222120], [13500, 13605073], [14000, 13954769], [14500, 14777594], [15000, 15178928], [15500, 15602106], [16000, 16054618], [16500, 16578623], [17000, 17048069], [17500, 17456403], [18000, 17910332], [18500, 18725846], [19000, 19284746], [19500, 19771902], [20000, 20121527], [21000, 20975042], [22000, 22189200], [23000, 23027928], [24000, 24027870], [25000, 24878845], [26000, 26237503], [27000, 27112004], [28000, 27953446], [29000, 29313013], [30000, 30474095]];

  for (i = 0; i < downloadSizes.length; i++) {
    if (size === downloadSizes[i][0]) {
      downloadSize = downloadSizes[i][1];
    }
  }

  apiCC.testUserPing(function (pingErr, ping) {
    download.onload = function () {
      totalTime = Date.now() - startTime;

      if (totalTime - ping > 10) {
        //remove ping from total time
        totalTime = totalTime - ping;
      }

      BPerSec = downloadSize / (totalTime / 1000);
      kBPersec = Math.round(BPerSec / 1000);
      result = {
        type: "download",
        //fileSize : downloadSize,
        //totalTime : totalTime,
        kBPerSec: kBPersec
      };

      for (i = 0; i < apiCC.bandwidthRatingThresholds.length; i++) {
        if (result.kBPerSec * 8 >= apiCC.bandwidthRatingThresholds[i]) {
          rating++;
        }
      }

      result.rating = rating + "/" + apiCC.bandwidthRatingThresholds.length;
      callback(null, result);
    };

    download.onerror = function (err, msg) {
      callback({
        label: "Error when downloading",
        err: err,
        msg: msg
      }, null);
    };

    startTime = new Date().getTime();
    download.src = imageAddr;
  });
};
/*
* <b>Description</b>
* <p>This method starts a speed test for the user upload capabilities. </p>
* @method testUserUpload
* @param {Integer} size How much data (in bytes) should be uploaded
* @param {function} callback Callback function with two parameters (error, result). error is null when and only when test is successful and result is null when and only when test is unsuccessful.
*/


apiCC.testUserUpload = function (size, callback) {
  logger.debug("testUserUpload()");
  var testServer = apiCC.bandwidthTestServer + "/upload-test",
      xhr = new XMLHttpRequest(),
      formData = new FormData(),
      content = "",
      blob,
      i,
      rating = 0,
      result,
      startTime,
      totalTime,
      BPerSec,
      kBPersec; //create xhr object

  if ("withCredentials" in xhr) {
    // XHR for Chrome/Firefox/Opera/Safari.
    xhr.open("POST", testServer, true);
  } else if (typeof XDomainRequest !== "undefined") {
    // XDomainRequest for IE.
    xhr = new XDomainRequest();
    xhr.open("POST", testServer);
  } else {
    // CORS not supported.
    xhr = null;
  } //create large file


  for (i = 0; i < size; i++) {
    content += Math.round(Math.random() * 5); //random to avoid compression
  }

  blob = new Blob([content], {
    type: "text/xml"
  });
  formData.append("file", blob); // Set up the request.

  if (!xhr) {
    callback({
      err: "XMLHttpRequest is not defined",
      msg: "XMLHttpRequest is not defined"
    }, null);
  } else {
    // Set up a handler for when the request finishes.
    xhr.onload = function () {
      if (xhr.status === 200) {
        // File uploaded.
        totalTime = Date.now() - startTime;
        BPerSec = size / (totalTime / 1000);
        kBPersec = Math.round(BPerSec / 1000);
        result = {
          type: "upload",
          kBPerSec: kBPersec
        };

        for (i = 0; i < apiCC.bandwidthRatingThresholds.length; i++) {
          if (result.kBPerSec * 8 >= apiCC.bandwidthRatingThresholds[i]) {
            rating++;
          }
        }

        result.rating = rating + "/" + apiCC.bandwidthRatingThresholds.length;
        callback(null, result);
      } else {
        callback({
          err: "An error occured during XMLHttpRequest",
          msg: xhr.status
        }, null);
      }
    };

    xhr.onerror = function (e) {
      logger.log("testUserUpload onerror status :", e.target.status);
      callback({
        err: "An error occured during XMLHttpRequest",
        msg: e.target.status
      }, null);
    }; // Send the Data.


    xhr.send(formData);
    startTime = Date.now();
  }
};

apiCC.testUserUploadLoop = function (size, upload, callback) {
  var finalResult = {
    type: "upload",
    kBPerSec: upload.kbps / 8,
    kbps: upload.kbps,
    rating: upload.rating
  },
      diff = 0;

  if (upload.kbps > 1000) {
    apiCC.testUserUpload(size, function (err, res) {
      if (err !== null) {
        callback({
          err: "An error occured during XMLHttpRequest"
        }, null);
      } else {
        finalResult.kBPerSec = res.kBPerSec;
        finalResult.kbps = res.kBPerSec * 8;
        finalResult.rating = res.rating;
        diff = finalResult.kbps - upload.kbps;
        logger.debug("upload " + size + " " + JSON.stringify(finalResult) + "; diff " + diff);

        if (diff >= 20000 && size < 12000000) {
          apiCC.testUserUploadLoop(size + 8000000, finalResult, callback);
        } else if (diff >= 10000 && size < 14000000) {
          apiCC.testUserUploadLoop(size + 6000000, finalResult, callback);
        } else if (diff >= 5000 && size < 16000000) {
          apiCC.testUserUploadLoop(size + 4000000, finalResult, callback);
        } else if (diff >= 1000 && size < 18000000) {
          apiCC.testUserUploadLoop(size + 2000000, finalResult, callback);
        } else if (diff >= 200 && size < 19000000) {
          apiCC.testUserUploadLoop(size + 1000000, finalResult, callback);
        } else {
          callback(null, finalResult);
        }
      }
    });
  } else {
    callback(null, finalResult);
  }
};

apiCC.testUserDownloadLoop = function (size, download, callback) {
  var finalResult = {
    type: "download",
    kBPerSec: download.kbps / 8,
    kbps: download.kbps,
    rating: download.rating
  },
      diff = 0;

  if (download.kbps >= 3500) {
    apiCC.testUserDownload(size, function (err, res) {
      if (err !== null) {
        callback({
          err: "Error when downloading"
        }, null);
      } else {
        finalResult.kBPerSec = res.kBPerSec;
        finalResult.kbps = res.kBPerSec * 8;
        finalResult.rating = res.rating;
        diff = finalResult.kbps - download.kbps;
        logger.debug("download " + size + " " + JSON.stringify(finalResult) + "; diff " + diff);

        if (diff >= 20000) {
          apiCC.testUserDownloadLoop(30000, finalResult, callback);
        } else if (diff >= 10000 && size <= 20000) {
          apiCC.testUserDownloadLoop(size + 10000, finalResult, callback);
        } else if (diff >= 5000 && size <= 25000) {
          apiCC.testUserDownloadLoop(size + 5000, finalResult, callback);
        } else if (diff >= 1000 && size <= 27000) {
          apiCC.testUserDownloadLoop(size + 3000, finalResult, callback);
        } else if (diff >= 200 && size <= 29000) {
          apiCC.testUserDownloadLoop(size + 1000, finalResult, callback);
        } else {
          callback(null, finalResult);
        }
      }
    });
  } else {
    callback(null, finalResult);
  }
};

apiCC.webRTCPluginInstalled = false;
apiCC.iePluginInstallationPreventUnload = false;
/*
* <b>Description</b>
* <p>This methods is used to enable the log storage</p>
* @method setlogStorageActivated
* @param {Boolean} logStorageActivated true to enable, false to disable.
* @param {function} logStorageLevel, log level to store. Default value is LOG_LEVEL_INFO
*/

apiCC.setlogStorageActivated = function (val, logStorageLevel) {
  logger.debug('setlogStorageActivated :', val);

  if (val === true || val === false) {
    this.logStorageActivated = val;
  } else {
    this.logStorageActivated = false;
  }

  if (logStorageLevel !== undefined) {
    this.logStorageLevel = logStorageLevel;
  }
};
/*
* <b>Description</b>
* <p>This methods is used to send log to cloud</p>
* @method setlogStorageActivated
* @param {Array} externalLog external log to be added at the end of apiRTC log storage
* @param {String} enterpriseId, enterprise identifier on ApiRTC Cloud
* @param {String} cloudURL, cloudURL to use for log upload
* @param {Boolean} notSending, whether to send or not the log - can be used for testing
*/


apiCC.sendLogToCloud = function (externalLog, enterpriseId, cloudURL, notSending) {
  logger.info('sendLogToCloud');
  var i,
      externalLogCloud = [],
      log = null,
      arrayToSend = [],
      data = null,
      fileContent = null,
      xhr = null;
  externalLogCloud.push(JSON.stringify({
    "title": "ApiRTC logs",
    "description": "Logs of apiRTC client"
  }));
  externalLogCloud.push(JSON.stringify({
    'ts': Date.now(),
    'name': 'system-info',
    'args': {
      'browserName': apiCC.browser,
      'browserVersion': apiCC.browser_version,
      'platform': apiCC.osName
    }
  }));

  for (i = 0; i < externalLog.length; i++) {
    if (externalLog[i][0] === "error") {
      log = {
        "name": "test-run",
        "args": {
          "error": externalLog[i][1]
        }
      };
    } else {
      log = {
        "name": "test-run",
        "args": {
          "info": externalLog[i][1]
        }
      };
    }

    externalLogCloud.push(JSON.stringify(log));
  }

  arrayToSend = externalLogCloud.concat(apiCC.logStorage); //send report data to controller

  data = new FormData();
  fileContent = '[' + arrayToSend.join(',\n') + ']';
  logger.debug('fileContent :', fileContent);

  if (notSending !== true) {
    data.append('data', fileContent);
    data.append('apiKey', apiCC.initApiKey);

    if (enterpriseId !== undefined) {
      data.append('id', enterpriseId);
    }

    xhr = new XMLHttpRequest();
    xhr.open('POST', cloudURL + '/test/api/', true);

    xhr.onreadystatechange = function () {
      //Call a function when the state changes.
      if (xhr.readyState === 4 && xhr.status === 200) {
        console.info("[apiRTC_Logs] POST'd successfully");
      }

      console.trace(xhr.responseText);
    };

    xhr.send(data);
  }
};

apiCC.manageWebRTCPlugin = function (actionOnInstalled, actionOnInstallationNeeded) {
  logger.debug('manageWebRTCPlugin');
  var protocol = '';

  if (window.location.protocol !== 'https:') {
    protocol = 'http';
  } else {
    protocol = 'https';
  } //Loading of JS Librairies


  loadjs([protocol + "://cdn.temasys.io/adapterjs/0.15.x/adapter.debug.js"], 'temAdapter', {
    async: true,
    // load files synchronously or asynchronously (default: true)
    numRetries: apiCC.extJsLoadingRetryNb || 100,
    // see caveats about using numRetries with async:false (default: 0)
    reqdelay: apiCC.extJsLoadingRetryDelay || 200,
    success: function success() {
      // temAdapter loaded
      logger.log("End of .js loading for plugin");
      apiCC.myWebRTC_Event.createExternalJsLoadingStatusEvent('temAdapter', 'loaded'); //Checking if plugin is installed or not

      AdapterJS.WebRTCPlugin.isPluginInstalled(AdapterJS.WebRTCPlugin.pluginInfo.prefix, AdapterJS.WebRTCPlugin.pluginInfo.plugName, AdapterJS.WebRTCPlugin.pluginInfo.type, function () {
        //Modification of WebRTC API with plugin Adapter definition
        apiCC.myWebRTC_Adapter.RTCSessionDescription = RTCSessionDescription;
        apiCC.myWebRTC_Adapter.RTCIceCandidate = RTCIceCandidate;
        apiCC.myWebRTC_Adapter.RTCPeerConnection = RTCPeerConnection;
        apiCC.myWebRTC_Adapter.getUserMedia = navigator.getUserMedia;
        apiCC.attachMediaStream = attachMediaStream;
        AdapterJS.webRTCReady(function (isUsingPlugin) {
          // The WebRTC API is ready.
          // isUsingPlugin: true if the WebRTC plugin is being used, false otherwise
          logger.log("webRTCReady, plugin already installed");
          var callId = actionOnInstalled();
          return callId;
        });
      }, function () {
        apiCC.iePluginInstallationPreventUnload = true; //Defining iePluginInstallationPreventUnload to avoid page relaod

        actionOnInstallationNeeded(); //Adding webRTCReady handler to detect the end of plugin installation and start the call

        AdapterJS.webRTCReady(function (isUsingPlugin) {
          // The WebRTC API is ready.
          // isUsingPlugin: true if the WebRTC plugin is being used, false otherwise
          logger.log("webRTCReady after plugin install");
          apiCC.iePluginInstallationPreventUnload = false; //Modification of WebRTC API with plugin Adapter definition

          apiCC.myWebRTC_Adapter.RTCSessionDescription = RTCSessionDescription;
          apiCC.myWebRTC_Adapter.RTCIceCandidate = RTCIceCandidate;
          apiCC.myWebRTC_Adapter.RTCPeerConnection = RTCPeerConnection;
          apiCC.myWebRTC_Adapter.getUserMedia = navigator.getUserMedia;
          apiCC.attachMediaStream = attachMediaStream;
          var callId = actionOnInstalled();
          return callId;
        }); //Sending WebRTCPluginInstallationEvent
        //User has to install the plugin and refresh his page before being able to establish a call

        apiCC.session.apiCCWebRTCClient.myWebRTC_Event.createEvent({
          "eventType": "webRTCPluginInstallation"
        });
        return null;
      });
    },
    error: function error(depsNotFound) {
      // temAdapter bundle load failed
      logger.error("temAdapter loading error");
      apiCC.myWebRTC_Event.createExternalJsLoadingStatusEvent('temAdapter', 'error');
    },
    retrycb: function retrycb(numTries, delayMsec) {
      logger.warn("temAdapter loading retry :" + numTries + " ,delay before retry :" + delayMsec);
      apiCC.myWebRTC_Event.createExternalJsLoadingStatusEvent('temAdapter', 'retry');
    }
  });
};

apiCC.checkMutingStateForUserMedia = function (callConfiguration, userMediaStream) {
  logger.debug('checkMutingStateForUserMedia'); //Checking if muted is setted in callConfiguration

  if ((0,_Utils__WEBPACK_IMPORTED_MODULE_4__.isPropertyTypeof)(callConfiguration, 'muted', 'string')) {
    logger.log('callConfiguration muted is set :', callConfiguration.muted);

    if (callConfiguration.muted === 'VIDEO') {
      //Muting audio & video
      userMediaStream.muteVideoOnStreams("enabled");
      userMediaStream.muteAudioOnStreams("enabled");
    }

    if (callConfiguration.muted === 'AUDIOONLY') {
      //Muting audio only
      userMediaStream.muteAudioOnStreams("enabled");
    }

    if (callConfiguration.muted === 'VIDEOONLY') {
      //Muting video only
      userMediaStream.muteVideoOnStreams("enabled");
    }
  }
};
/**
* <b>Description</b>
* <p> This method can be used to test if the number is a SIP number or not</p>
* @method isSIPNumber
* @returns {Boolean}
*/


apiCC.isSIPNumber = function (number) {
  var startWithSipPrefix = null,
      numberSmallerThan20 = null,
      isSIPNb = false;
  startWithSipPrefix = number.toString().startsWith('sip:');

  if (number.toString().length <= 20) {
    numberSmallerThan20 = true;
  } //If call number start with 0 or + and if number length is <= 20, or if number start with sip: , using sipConnector to establish the call


  if ((number.toString().indexOf('0') === 0 || number.toString().indexOf('+') === 0) && numberSmallerThan20 === true || startWithSipPrefix === true) {
    isSIPNb = true;
  }

  return isSIPNb;
};

apiCC.loadSentry = function (apiKey, protocol) {
  logger.debug("Remote logging activation");
  var loadJsArgs = {
    async: true,
    // load files synchronously or asynchronously (default: true)
    numRetries: 10,
    // see caveats about using numRetries with async:false (default: 0)
    reqdelay: 500,
    success: function success() {
      // socketio loaded
      Sentry.init({
        dsn: 'https://c24c226714f841dbbc3d1518b6cc7fe8@o333237.ingest.sentry.io/5448622',
        release: apiCC.version,
        // We recommend adjusting this value in production, or using tracesSampler
        // for finer control
        tracesSampleRate: 1.0
      });
      Sentry.configureScope(function (scope) {
        scope.setTag("apiKey", apiKey);
      });
    },
    error: function error(depsNotFound) {
      //socketio bundle load failed
      console.error("Remote logging - loading error");
    },
    retrycb: function retrycb(numTries, delayMsec) {
      console.warn("Remote logging - loading retry :" + numTries + " ,delay before retry :" + delayMsec);
    }
  };
  loadjs([protocol + "://" + "browser.sentry-cdn.com/5.24.2/bundle.tracing.min.js"], 'Sentry', loadJsArgs);
};

apiCC.sendSentryEvent = function (opts) {
  logger.debug('sendSentryEvent', opts);

  if (typeof Sentry !== 'undefined') {
    //sentry loaded = sentry activated on company
    var msg = "",
        tags = {};

    if (opts.eventType === "muteUnmuteEvent") {
      msg = 'Mute event on callId:' + opts.callId;
      tags.muteType = opts.muteType;
      tags.source = opts.source;
      tags.mLine = opts.mLine;
      tags.state = opts.state;
      tags.callId = opts.callId;
      tags.username = opts.username;
    } else {
      logger.error('sendSentryEvent error : type ', opts.eventType, ' is not supported');
    }

    var keys = Object.keys(tags);

    if (msg !== '' && keys.length > 0) {
      Sentry.withScope(function (scope) {
        keys.forEach(function (tag) {
          scope.setTag(tag, tags[tag]);
        });
        Sentry.captureMessage(msg);
      });
    }
  } else {
    logger.debug('Sentry not activated');
  }
};

/***/ }),

/***/ "./src/Core/AudioProcessor.js":
/*!************************************!*\
  !*** ./src/Core/AudioProcessor.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AudioProcessor": () => (/* binding */ AudioProcessor),
/* harmony export */   "default": () => (/* binding */ AudioProcessor)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/* globals apiCC, AudioWorkletNode, MediaStreamAudioDestinationNode*/


var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.get('AudioProcessor');
var AudioContext = window.AudioContext || window.webkitAudioContext || false;
/**
 * @class AudioProcessor
 * @description Manage all audio processing -> usage of Web Audio API
 */

var AudioProcessor = /*#__PURE__*/function () {
  /**
  * Init with ...
  */
  function AudioProcessor() {
    _classCallCheck(this, AudioProcessor);

    this.audioContext = null;
  }

  _createClass(AudioProcessor, [{
    key: "getOrCreateAudioContext",
    value: function getOrCreateAudioContext() {
      logger.debug("getOrCreateAudioContext");

      if (apiRTC.osName === 'iOS' && typeof cordova !== 'undefined') {
        logger.debug("No audioContext for iOS cordova");
      } else {
        if (AudioContext) {
          this.audioContext = new AudioContext();
        }
      }

      if (this.audioContext.state === "suspended") {
        this.audioContext.resume().then(function () {
          logger.debug("AudioContext is resumed");
        });
      }

      return this.audioContext;
    }
  }, {
    key: "listenToAudio",
    value: function listenToAudio(mediaStream, userMediaStream) {
      logger.debug("listenToAudio()");
      var MAX_AMPLITUDE = 255; //max value of getByteFrequencyData

      if (userMediaStream === undefined || userMediaStream === null || apiCC.activeSpeakerDetect !== true || userMediaStream.childStreamType === 'noiseReduction') {
        logger.debug("activeSpeakerDetecting is not activated or stream type is noiseReduction");
        return;
      }

      logger.debug("activeSpeakerDetect()");
      var timer = null,
          notified = false,
          audioContext = this.getOrCreateAudioContext();

      if (audioContext === null || typeof audioContext === "undefined") {
        logger.error("listenToAudio() - Unable to create audio context");
        return;
      }

      userMediaStream.nodeCtx = {}; //Used to keep all audioCtx node resources
      //this.sourceNode -> mic

      userMediaStream.nodeCtx.sourceNode = audioContext.createMediaStreamSource(mediaStream); // create analyser node

      userMediaStream.nodeCtx.analyserNode = audioContext.createAnalyser();
      userMediaStream.nodeCtx.analyserNode.fftSize = 2048;
      userMediaStream.nodeCtx.sourceNode.connect(userMediaStream.nodeCtx.analyserNode);
      userMediaStream.nodeCtx.listenToAudioIntervalId = setInterval(function () {
        var array = new Uint8Array(userMediaStream.nodeCtx.analyserNode.frequencyBinCount),
            amplitude,
            values = 0,
            i;
        userMediaStream.nodeCtx.analyserNode.getByteFrequencyData(array); // Take first ~10% max values (more sensitive tnan avg)

        array.sort(function (a, b) {
          return b - a;
        });
        array = array.slice(0, 50);

        for (i = 0; i < array.length; i++) {
          values += array[i];
        }

        amplitude = values / array.length; // activeSpeakerThreshold is a value between 0 and 1

        if (amplitude > MAX_AMPLITUDE * apiCC.activeSpeakerThreshold) {
          if (!notified) {
            notified = true;
            userMediaStream.notifyActiveSpeaker(amplitude);
            logger.error("notifyActiveSpeaker this.userMediaStreamId :", userMediaStream.userMediaStreamId);
          }

          if (timer !== null) {
            clearTimeout(timer);
          }

          timer = setTimeout(function () {
            userMediaStream.notifyNotActiveSpeaker(amplitude);
            logger.error("notifyNotActiveSpeaker this.userMediaStreamId :", userMediaStream.userMediaStreamId);
            notified = false;
          }, 1000); //notify NotActiveSpeaker after 1s
        }
      }, 100); //Checking analyser values every 100 ms
    }
  }, {
    key: "checkstopAudioNodeCtxConditions",
    value: function checkstopAudioNodeCtxConditions(nodeCtx) {
      if (apiCC.userAgentInstance.getCapabilities().noiseReduction === 'OFF') {
        return 'Navigator not compatible with this function';
      }

      if (nodeCtx === undefined) {
        return 'nodeCtx undefined';
      }

      return 'OK';
    }
  }, {
    key: "stopAudioNodeCtx",
    value: function stopAudioNodeCtx(nodeCtx) {
      logger.debug("stopAudioNodeCtx :", nodeCtx);
      var ret = this.checkstopAudioNodeCtxConditions(nodeCtx);

      if (ret !== 'OK') {
        return ret;
      }

      if (nodeCtx.sourceNode !== undefined && nodeCtx.sourceNode !== null) {
        nodeCtx.sourceNode.disconnect();
        nodeCtx.sourceNode = null;
      }

      if (nodeCtx.analyserNode !== undefined && nodeCtx.analyserNode !== null) {
        nodeCtx.analyserNode.disconnect();
        nodeCtx.analyserNode = null;
      }

      if (nodeCtx.audioDestination !== undefined && nodeCtx.audioDestination !== null) {
        nodeCtx.audioDestination.disconnect();
        nodeCtx.audioDestination = null;
      }

      if (nodeCtx.originalMediaTrack !== undefined && nodeCtx.originalMediaTrack !== null) {
        nodeCtx.originalMediaTrack = null;
      }

      if (nodeCtx.outputMediaTrack !== undefined && nodeCtx.outputMediaTrack !== null) {
        nodeCtx.outputMediaTrack = null;
      }

      if (nodeCtx.listenToAudioIntervalId !== undefined && nodeCtx.listenToAudioIntervalId !== null) {
        clearInterval(nodeCtx.listenToAudioIntervalId);
        nodeCtx.listenToAudioIntervalId = null;
      }

      if (nodeCtx.noiseSuppressorNode !== undefined && nodeCtx.noiseSuppressorNode !== null) {
        nodeCtx.noiseSuppressorNode.port.onmessage = null;
        nodeCtx.noiseSuppressorNode.port.close();
        nodeCtx.noiseSuppressorNode = null;
      }
    }
  }, {
    key: "checkChildTypeConditions",
    value: function checkChildTypeConditions(apiRTCStream) {
      if (apiCC.userAgentInstance.getCapabilities().noiseReduction === 'OFF') {
        return 'Navigator not compatible with this function';
      }

      if (apiRTCStream.childType !== undefined && apiRTCStream.childType === 'noiseReduction') {
        return "This stream has already a noiseReduction effect applied : " + apiRTCStream.childType;
      }

      if (apiRTCStream.childrenTypeExists("noiseReduction")) {
        return "This stream has already has a noiseReduction sub instance running";
      }

      return 'OK';
    }
  }, {
    key: "startNoiseReduction",
    value: function startNoiseReduction(apiRTCStream) {
      var _this = this;

      var timer = null,
          notified = false;
      return new Promise(function (resolve, reject) {
        logger.debug('startNoiseReduction');

        var ret = _this.checkChildTypeConditions(apiRTCStream);

        if (ret !== 'OK') {
          return reject(ret);
        }

        apiRTCStream.nodeCtx = {}; //Used to keep all audioCtx node resources

        apiRTCStream.nodeCtx.originalMediaTrack = apiRTCStream.data.getAudioTracks()[0];
        var audioContext = apiCC.audioProcessor.getOrCreateAudioContext();
        apiRTCStream.nodeCtx.sourceNode = audioContext.createMediaStreamSource(apiRTCStream.data); //FIX APIZEE
        //createMediaStreamDestination with channelCount equal to source channelCount
        //this._audioDestination = this._audioContext.createMediaStreamDestination();

        var options = {
          channelCount: apiRTCStream.data.getAudioTracks()[0].getSettings().channelCount,
          channelCountMode: 'explicit'
        };
        apiRTCStream.nodeCtx.audioDestination = new MediaStreamAudioDestinationNode(audioContext, options); //It seems that channelCount on output stream is 2 even if we set channelCount to 1
        //Check https://github.com/WebAudio/web-audio-api/issues/2389
        //End FIX APIZEE

        apiRTCStream.nodeCtx.outputMediaTrack = apiRTCStream.nodeCtx.audioDestination.stream.getAudioTracks()[0];
        var workletUrl = "https://dev.cdn.apizee.com/apiRTC/lib/noiseReduction/ApiRTC_NR_Worklet_1.0.1.js"; // Connect the audio processing graph MediaStream -> AudioWorkletNode -> MediaStreamAudioDestinationNode

        audioContext.audioWorklet.addModule(workletUrl).then(function () {
          // After the resolution of module loading, an AudioWorkletNode can be constructed.
          //We use parameterData to give activeSpeakerDetect information to audioWorklet
          apiRTCStream.nodeCtx.noiseSuppressorNode = new AudioWorkletNode(audioContext, 'NoiseSuppressorWorklet', {
            parameterData: {
              activeSpeakerDetect: apiCC.activeSpeakerDetect
            }
          });
          apiRTCStream.nodeCtx.sourceNode.connect(apiRTCStream.nodeCtx.noiseSuppressorNode).connect(apiRTCStream.nodeCtx.audioDestination);
          var parentStreamCtx = {
            audioFilterIsApplied: apiRTCStream.audioFilterIsApplied,
            audioAppliedFilter: apiRTCStream.audioAppliedFilter,
            videoFilterIsApplied: apiRTCStream.videoFilterIsApplied,
            videoAppliedFilter: apiRTCStream.videoAppliedFilter,
            childType: apiRTCStream.childType
          };
          apiRTCStream.createChildStreamFromStream(apiRTCStream.nodeCtx.audioDestination.stream, "noiseReduction", parentStreamCtx).then(function (child_stream) {
            //Add video tracks
            apiRTCStream.data.getVideoTracks().forEach(function (video_track) {
              //This is a clone to avoid link with first stream on release()
              child_stream.data.addTrack(video_track.clone()); //Update stream type

              child_stream.type = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_VIDEO;
            });
            apiRTCStream.addChildren(child_stream, "noiseReduction");
            child_stream.applyMuteStatusFromParent(); //activeSpeaker Management
            //Stopping activateSpeaker on parent stream if exist

            var userMediaStream = apiCC.getUserMediaStream(apiRTCStream.userMediaStreamId);
            apiCC.audioProcessor.stopAudioNodeCtx(userMediaStream.nodeCtx);
            var child_userMediaStream = apiCC.getUserMediaStream(child_stream.userMediaStreamId); //Message are received from AudioWorklet if activeSpeakerDetect === true

            apiRTCStream.nodeCtx.noiseSuppressorNode.port.onmessage = function (evt) {
              //vadScore is a value between 0 and 1 = like apiCC.activeSpeakerThreshold
              if (evt.data.vadScore > apiCC.activeSpeakerThreshold) {
                if (!notified) {
                  notified = true;
                  child_userMediaStream.notifyActiveSpeaker(evt.data.vadScore);
                  logger.error("notifyActiveSpeaker this.userMediaStreamId :", child_userMediaStream.userMediaStreamId);
                }

                if (timer !== null) {
                  clearTimeout(timer);
                }

                timer = setTimeout(function () {
                  child_userMediaStream.notifyNotActiveSpeaker(evt.data.vadScore);
                  logger.error("notifyNotActiveSpeaker this.userMediaStreamId :", child_userMediaStream.userMediaStreamId);
                  notified = false;
                }, 1000); //notify NotActiveSpeaker after 1s
              }
            };

            return resolve(child_stream);
          })["catch"](reject);
        })["catch"](function (error) {
          console.error('Error while adding audio worklet module: ', error);
        });
      });
    }
  }]);

  return AudioProcessor;
}();




/***/ }),

/***/ "./src/Core/BrowserInfo.js":
/*!*********************************!*\
  !*** ./src/Core/BrowserInfo.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applicationType": () => (/* binding */ applicationType),
/* harmony export */   "browser": () => (/* binding */ browser),
/* harmony export */   "browserInfo": () => (/* binding */ browserInfo),
/* harmony export */   "browser_major_version": () => (/* binding */ browser_major_version),
/* harmony export */   "browser_version": () => (/* binding */ browser_version),
/* harmony export */   "cpuArchitecture": () => (/* binding */ cpuArchitecture),
/* harmony export */   "deviceModel": () => (/* binding */ deviceModel),
/* harmony export */   "deviceType": () => (/* binding */ deviceType),
/* harmony export */   "deviceVendor": () => (/* binding */ deviceVendor),
/* harmony export */   "engineName": () => (/* binding */ engineName),
/* harmony export */   "engineVersion": () => (/* binding */ engineVersion),
/* harmony export */   "osName": () => (/* binding */ osName),
/* harmony export */   "osUAParser": () => (/* binding */ osUAParser),
/* harmony export */   "osVersion": () => (/* binding */ osVersion),
/* harmony export */   "parser": () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var _ua_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ua-parser.js */ "./src/Core/ua-parser.js");
/* harmony import */ var _ua_parser_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ua_parser_js__WEBPACK_IMPORTED_MODULE_0__);
/* globals DeviceInfo */
//import {Logger} from '../private/Logger';
 //const logger = Logger.get('BrowserInfo');

var parser = null,
    browserUAParser = null,
    //browserDetails = null,
browser = null,
    browser_version = null,
    browser_major_version = null,
    osUAParser = null,
    osName = null,
    osVersion = null,
    deviceType = null,
    deviceVendor = null,
    deviceModel = null,
    applicationType = null,
    browserInfo = null,
    cpuArchitecture = null,
    engineName = null,
    engineVersion = null;
parser = new UAParser();
browserUAParser = parser.getBrowser();
osUAParser = parser.getOS();
browserInfo = parser.getBrowser();

if (typeof apiRTC_React !== 'undefined') {
  browser_version = DeviceInfo.getSystemVersion();
  osName = DeviceInfo.getSystemName();
  browser = DeviceInfo.getUserAgent();
  deviceType = DeviceInfo.getModel();
} else {
  browser_version = browserUAParser.version || "Unknown";
  osName = parser.getOS().name || "Unknown";
  osVersion = parser.getOS().version || "Unknown";
  browser = browserUAParser.name || "Unknown";
  cpuArchitecture = parser.getCPU().architecture || "Unknown";
  deviceType = parser.getDevice().type || "Unknown";
  deviceVendor = parser.getDevice().vendor || "Unknown";
  deviceModel = parser.getDevice().model || "Unknown";
  engineName = parser.getEngine().name || "Unknown";
  engineVersion = parser.getEngine().version || "Unknown";
}

if (browser_version !== undefined) {
  browser_major_version = browserUAParser.major;
} else {
  browser_major_version = 99;
}
/*
logger.info("deviceType :" + deviceType);
logger.info("osName :" + osName);
logger.info("osVersion :" + osVersion);
logger.info("browser :" + browser);
logger.info("browser_version :" + browser_version);
*/


if (window && window.navigator && window.navigator.userAgent) {
  var lcua = window.navigator.userAgent.toLowerCase();

  if (lcua.indexOf(' electron/') >= 0) {
    applicationType = 'electron';
  }
}



/***/ }),

/***/ "./src/Core/CallControl.js":
/*!*********************************!*\
  !*** ./src/Core/CallControl.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CallControl": () => (/* binding */ CallControl)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* globals*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('CallControl');
/*
 * @param {object} context
 * @param {string} context.type - 'publish', 'shareScreen', 'subscribe'.
 * @param {string} context.callId - Initial callId.
 * @param {string} context.callType
 * @param {string} context.audioOnly
 * @param {string} context.roomName
 * @param {string} context.mediaType - Optional mediaType in case of type 'subscribe'.
 * @param {object} context.callConfiguration
 * @param {object} context.data
 * @param {object} context.stream - Optional stream descriptor in case of type 'subscribe'.
 */

var CallControl = function CallControl(context) {
  this.type = context.type; // 'publish', 'shareScreen', 'subscribe'

  if (context.callId) {
    this.callId = context.callId;
  }

  if (context.callType) {
    // callType: media, audio, screenSharing, videoOnly, data or screenSharingWithAudio.
    this.callType = context.callType;
  } else {
    this.callType = 'media';
  }

  if (Object.prototype.hasOwnProperty.call(context, 'audioOnly')) {
    this.audioOnly = !!context.audioOnly;
  }

  if (context.roomName) {
    this.roomName = context.roomName;
  }

  if (context.mediaType) {
    // in case of type 'subscribe'
    this.mediaType = context.mediaType;
  }

  if (context.callConfiguration) {
    this.callConfiguration = context.callConfiguration;
  }

  if (context.data) {
    this.data = context.data;
  }

  if (context.stream) {
    // in case of type 'subscribe'
    // represents a remote stream descriptor
    this.stream = context.stream;
  }

  this.autoRestart = {};
};



/***/ }),

/***/ "./src/Core/CallStatsMonitor.js":
/*!**************************************!*\
  !*** ./src/Core/CallStatsMonitor.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CallStatsMonitor": () => (/* binding */ CallStatsMonitor)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('CallStatsMonitor');
/*
* @constructor
* @this {CallStatsMonitor}
* @param {number} interval number of seconds
* @param {string} browserType type of browser (chrome, firefox, etc.)
* @param {string} browserVersion version of browser
* @param {string} stats flavor (either standard or proprietary)
*/

/*
* This is the description for my class CallStatsMonitor.
*
* @module CallStatsMonitor
*/

var CallStatsMonitor = function CallStatsMonitor(interval, browserType, browserVersion, flavor) {
  this.interval = interval;
  this.browserType = browserType;
  this.browserVersion = browserVersion;
  this.flavor = flavor;
  this.prevData = {};
  this.prevDataThreshold = 10 / interval;

  if (this.prevDataThreshold < 2) {
    this.prevDataThreshold = 2;
  }

  this.STANDARD_STAT_KEYS = {
    'audioReceived': {
      'codecId': false,
      'id': false,
      'ssrc': false,
      'trackId': false,
      'transportId': false
    },
    'videoReceived': {
      'codecId': false,
      'id': false,
      'ssrc': false,
      'trackId': false,
      'transportId': false
    },
    'remoteAudioSent': {
      'codecId': false,
      'id': false,
      'ssrc': false,
      'trackId': false,
      'transportId': false
    },
    'remoteVideoSent': {
      'codecId': false,
      'id': false,
      'ssrc': false,
      'trackId': false,
      'transportId': false
    },
    'audioSent': {
      'codecId': false,
      'id': false,
      'ssrc': false,
      'trackId': false,
      'transportId': false
    },
    'videoSent': {
      'codecId': false,
      'id': false,
      'ssrc': false,
      'trackId': false,
      'transportId': false
    },
    'remoteAudioReceived': {
      'codecId': false,
      'id': false,
      'ssrc': false,
      'trackId': false,
      'transportId': false
    },
    'remoteVideoReceived': {
      'codecId': false,
      'id': false,
      'ssrc': false,
      'trackId': false,
      'transportId': false
    }
  };
  /*
   * Refines proprietary chrome stats.
   *
   * @method refineStats_chrome_proprietary
   * @param {object} data - holder for refined data
   * @param {object} stats - raw stats
   * @return {boolean} true if some data has been found, false otherwise
   */

  this.refineStats_chrome_proprietary = function (data, stats) {
    var notify = false,
        si,
        ni;

    for (si = 0; si < stats.length; si += 1) {
      var section = stats[si],
          names = null,
          name = null;

      if (section.type === 'ssrc') {
        if (section.id.indexOf('recv') >= 0) {
          // received media
          if (section.stat('mediaType') === 'audio') {
            data.audioReceived = {
              'timestamp': Math.floor(Date.parse(section.timestamp)) / 1000,
              'type': 'inbound-rtp',
              'isRemote': false,
              'mediaType': 'audio',
              'packetsReceived': 0,
              'bytesReceived': 0
            };
            names = section.names();

            for (ni = 0; ni < names.length; ni += 1) {
              name = names[ni];

              if (name === 'packetsReceived') {
                data.audioReceived.packetsReceived = parseInt(section.stat('packetsReceived'), 10);
              } else if (name === 'bytesReceived') {
                data.audioReceived.bytesReceived = parseInt(section.stat('bytesReceived'), 10);
              }
            } // for

          } else if (section.stat('mediaType') === 'video') {
            data.videoReceived = {
              'timestamp': Math.floor(Date.parse(section.timestamp)) / 1000,
              'type': 'outbound-rtp',
              'isRemote': false,
              'mediaType': 'video',
              'framesDecoded': 0,
              'packetsReceived': 0,
              'bytesReceived': 0
            };
            names = section.names();

            for (ni = 0; ni < names.length; ni += 1) {
              name = names[ni];

              if (name === 'framesDecoded') {
                data.videoReceived.framesDecoded = parseInt(section.stat('framesDecoded'), 10);
              } else if (name === 'packetsReceived') {
                data.videoReceived.packetsReceived = parseInt(section.stat('packetsReceived'), 10);
              } else if (name === 'bytesReceived') {
                data.videoReceived.bytesReceived = parseInt(section.stat('bytesReceived'), 10);
              }
            } // for

          }
        } else if (section.id.indexOf('send') >= 0) {
          // sent media
          if (section.stat('mediaType') === 'audio') {
            data.audioSent = {
              'timestamp': Math.floor(Date.parse(section.timestamp)) / 1000,
              'type': 'outbound-rtp',
              'isRemote': false,
              'mediaType': 'audio',
              'packetsSent': 0,
              'bytesSent': 0
            };
            names = section.names();

            for (ni = 0; ni < names.length; ni += 1) {
              name = names[ni];

              if (name === 'packetsSent') {
                data.audioSent.packetsSent = parseInt(section.stat('packetsSent'), 10);
              } else if (name === 'bytesSent') {
                data.audioSent.bytesSent = parseInt(section.stat('bytesSent'), 10);
              }
            } // for

          } else if (section.stat('mediaType') === 'video') {
            data.videoSent = {
              'timestamp': Math.floor(Date.parse(section.timestamp)) / 1000,
              'type': 'outbound-rtp',
              'isRemote': false,
              'mediaType': 'video',
              'framesEncoded': 0,
              'packetsSent': 0,
              'bytesSent': 0
            };
            names = section.names();

            for (ni = 0; ni < names.length; ni += 1) {
              name = names[ni];

              if (name === 'framesEncoded') {
                data.videoSent.framesEncoded = parseInt(section.stat('framesEncoded'), 10);
              } else if (name === 'packetsSent') {
                data.videoSent.packetsSent = parseInt(section.stat('packetsSent'), 10);
              } else if (name === 'bytesSent') {
                data.videoSent.bytesSent = parseInt(section.stat('bytesSent'), 10);
              }
            } // for

          }
        }
      }
    } // for


    return notify;
  };
  /*
   * Refines standard stats for chrome 57 or older.
   *
   * @method refineStats_chrome_legacy
   * @param {object} data - holder for refined data
   * @param {object} stats - raw stats
   * @return {boolean} true if some data has been found, false otherwise
   */


  this.refineStats_chrome_legacy = function (data, stats) {
    var notify = false; // (1of2) Extracting data

    stats.forEach(function (section) {
      var ts = null,
          itemKey = null;

      if (section.type === "ssrc" && section.id.indexOf("recv") >= 0) {
        // received media
        if (section.mediaType === "audio") {
          data.audioReceived = {};
          ts = Math.floor(Date.parse(section.timestamp) / 1000);

          for (itemKey in section) {
            if (itemKey === "timestamp") {
              data.audioReceived.timestamp = ts;
            } else {
              data.audioReceived[itemKey] = section[itemKey];
            }
          } // for


          notify = true;
        } else if (section.mediaType === "video") {
          data.videoReceived = {};
          ts = Math.floor(Date.parse(section.timestamp) / 1000);

          for (itemKey in section) {
            if (itemKey === "timestamp") {
              data.videoReceived.timestamp = ts;
            } else {
              data.videoReceived[itemKey] = section[itemKey];
            }
          } // for


          notify = true;
        }
      } else if (section.type === "ssrc" && section.id.indexOf("send") >= 0) {
        // sent media
        if (section.mediaType === "audio") {
          data.audioSent = {};
          ts = Math.floor(Date.parse(section.timestamp) / 1000);

          for (itemKey in section) {
            if (itemKey === "timestamp") {
              data.audioSent.timestamp = ts;
            } else {
              data.audioSent[itemKey] = section[itemKey];
            }
          } // for


          notify = true;
        } else if (section.mediaType === "video") {
          data.videoSent = {};
          ts = Math.floor(Date.parse(section.timestamp) / 1000);

          for (itemKey in section) {
            if (itemKey === "timestamp") {
              data.videoSent.timestamp = ts;
            } else {
              data.videoSent[itemKey] = section[itemKey];
            }
          } // for


          notify = true;
        }
      }
    }); // forEach

    return notify;
  };
  /*
   * Refines standard stats for chrome 58 or newer.
   *
   * @method refineStats_chrome_58
   * @param {object} data - holder for refined data
   * @param {object} stats - raw stats
   * @return {boolean} true if some data has been found, false otherwise
   */


  this.refineStats_chrome_58 = function (data, stats) {
    var self = this;
    var notify = false; // (1of2) Extracting data

    stats.forEach(function (section) {
      if (section.type === "inbound-rtp" && !section.isRemote) {
        // received media
        if (section.mediaType === "audio" || section.id.indexOf("Audio") >= 0
        /*For Safari*/
        ) {
          data.audioReceived = {};
          var ts = Math.floor(section.timestamp / 1000);

          for (var itemKey in section) {
            if (self.STANDARD_STAT_KEYS.audioReceived[itemKey] !== false) {
              if (itemKey === "timestamp") {
                data.audioReceived.timestamp = ts;
              } else {
                data.audioReceived[itemKey] = section[itemKey];
              }
            }
          } // for


          notify = true;
        } else if (section.mediaType === "video" || section.id.indexOf("Video") >= 0
        /*For Safari*/
        ) {
          data.videoReceived = {};

          var _ts = Math.floor(section.timestamp / 1000);

          for (var _itemKey in section) {
            if (self.STANDARD_STAT_KEYS.videoReceived[_itemKey] !== false) {
              if (_itemKey === "timestamp") {
                data.videoReceived.timestamp = _ts;
              } else {
                data.videoReceived[_itemKey] = section[_itemKey];
              }
            }
          } // for


          notify = true;
        }
      } else if (section.type === "outbound-rtp" && !section.isRemote) {
        // sent media
        if (section.mediaType === "audio") {
          data.audioSent = {};

          var _ts2 = Math.floor(section.timestamp / 1000);

          for (var _itemKey2 in section) {
            if (self.STANDARD_STAT_KEYS.audioSent[_itemKey2] !== false) {
              if (_itemKey2 === "timestamp") {
                data.audioSent.timestamp = _ts2;
              } else {
                data.audioSent[_itemKey2] = section[_itemKey2];
              }
            }
          } // for


          notify = true;
        } else if (section.mediaType === "video") {
          data.videoSent = {};

          var _ts3 = Math.floor(section.timestamp / 1000);

          for (var _itemKey3 in section) {
            if (self.STANDARD_STAT_KEYS.videoSent[_itemKey3] !== false) {
              if (_itemKey3 === "timestamp") {
                data.videoSent.timestamp = _ts3;
              } else {
                data.videoSent[_itemKey3] = section[_itemKey3];
              }
            }
          } // for


          notify = true;
        }
      }
    }); // forEach

    return notify;
  };
  /*
   * Refines standard stats for firefox.
   *
   * @method refineStats_firefox
   * @param {object} data - holder for refined data
   * @param {object} stats - raw stats
   * @return {boolean} true if some data has been found, false otherwise
   */


  this.refineStats_firefox_legacy = function (data, stats) {
    var notify = false,
        self = this; // (1of2) Extracting data

    stats.forEach(function (section) {
      var itemKey = null,
          ts = null;

      if (section.type === "inbound-rtp" && section.isRemote === false) {
        // received media
        if (section.mediaType === "audio") {
          data.audioReceived = {
            packetsReceived: 0,
            bytesReceived: 0
          };
          ts = Math.floor(section.timestamp / 1000);

          for (itemKey in section) {
            if (self.STANDARD_STAT_KEYS.audioReceived[itemKey] !== false) {
              if (itemKey === "timestamp") {
                data.audioReceived.timestamp = ts;
              } else {
                data.audioReceived[itemKey] = section[itemKey];
              }
            }
          } // for


          notify = true;
        } else if (section.mediaType === "video") {
          data.videoReceived = {
            packetsReceived: 0,
            bytesReceived: 0,
            framesDecoded: 0
          };
          ts = Math.floor(section.timestamp / 1000);

          for (itemKey in section) {
            if (self.STANDARD_STAT_KEYS.videoReceived[itemKey] !== false) {
              if (itemKey === "timestamp") {
                data.videoReceived.timestamp = ts;
              } else {
                data.videoReceived[itemKey] = section[itemKey];
              }
            }
          } // for


          notify = true;
        }
        /*} else if (section.type === "outbound-rtp"  && section.isRemote === true) {
            if (section.mediaType === "audio") {
                data.remoteAudioSent = {};
                var ts = Math.floor(section.timestamp / 1000);
                for (var itemKey in section) {
                    if (self.STANDARD_STAT_KEYS.remoteAudioSent[itemKey] !== false) {
                        if (itemKey === "timestamp") {
                            data.remoteAudioSent.timestamp = ts;
                        } else {
                            data.remoteAudioSent[itemKey] = section[itemKey];
                        }
                    }
                }
                notify = true;
            } else if (section.mediaType === "video") {
                data.remoteVideoSent = {};
                var ts = Math.floor(section.timestamp / 1000);
                for (var itemKey in section) {
                    if (self.STANDARD_STAT_KEYS.remoteVideoSent[itemKey] !== false) {
                        if (itemKey === "timestamp") {
                            data.remoteVideoSent.timestamp = ts;
                        } else {
                            data.remoteVideoSent[itemKey] = section[itemKey];
                        }
                    }
                }
                notify = true;
            }*/

      } else if (section.type === "outbound-rtp" && section.isRemote === false) {
        // sent media
        if (section.mediaType === "audio") {
          data.audioSent = {
            packetsSent: 0,
            bytesSent: 0
          };
          ts = Math.floor(section.timestamp / 1000);

          for (itemKey in section) {
            if (self.STANDARD_STAT_KEYS.audioSent[itemKey] !== false) {
              if (itemKey === "timestamp") {
                data.audioSent.timestamp = ts;
              } else {
                data.audioSent[itemKey] = section[itemKey];
              }
            }
          } // for


          notify = true;
        } else if (section.mediaType === "video") {
          data.videoSent = {
            packetsSent: 0,
            bytesSent: 0,
            framesEncoded: 0
          };
          ts = Math.floor(section.timestamp / 1000);

          for (itemKey in section) {
            if (self.STANDARD_STAT_KEYS.videoSent[itemKey] !== false) {
              if (itemKey === "timestamp") {
                data.videoSent.timestamp = ts;
              } else {
                data.videoSent[itemKey] = section[itemKey];
              }
            }
          } // for


          notify = true;
        }
        /*} else if (section.type === "inbound-rtp"  && section.isRemote === true) {
            if (section.mediaType === "audio") {
                data.remoteAudioReceived = {};
                var ts = Math.floor(section.timestamp);
                for (var itemKey in section) {
                    if (self.STANDARD_STAT_KEYS.remoteAudioReceived[itemKey] !== false) {
                        if (itemKey === "timestamp") {
                            data.remoteAudioReceived.timestamp = ts;
                        } else {
                            data.remoteAudioReceived[itemKey] = section[itemKey];
                        }
                    }
                }
                notify = true;
            } else if (section.mediaType === "video") {
                data.remoteVideoReceived = {};
                var ts = Math.floor(section.timestamp / 1000);
                for (var itemKey in section) {
                    if (self.STANDARD_STAT_KEYS.remoteVideoReceived[itemKey] !== false) {
                        if (itemKey === "timestamp") {
                            data.remoteVideoReceived.timestamp = ts;
                        } else {
                            data.remoteVideoReceived[itemKey] = section[itemKey];
                        }
                    }
                }
                notify = true;
            }*/

      }
    }); // forEach

    return notify;
  };
  /*
   * Refines standard stats for firefox.
   *
   * @method refineStats_firefox
   * @param {object} data - holder for refined data
   * @param {object} stats - raw stats
   * @return {boolean} true if some data has been found, false otherwise
   */


  this.refineStats_firefox_63 = function (data, stats) {
    var notify = false;
    var self = this; // (1of2) Extracting data

    stats.forEach(function (section) {
      if (section.type === "inbound-rtp" && !section.isRemote) {
        // received media
        if (section.kind === "audio") {
          data.audioReceived = {
            packetsReceived: 0,
            bytesReceived: 0
          };
          var ts = Math.floor(section.timestamp / 1000);

          for (var itemKey in section) {
            if (self.STANDARD_STAT_KEYS.audioReceived[itemKey] !== false) {
              if (itemKey === "timestamp") {
                data.audioReceived.timestamp = ts;
              } else {
                data.audioReceived[itemKey] = section[itemKey];
              }
            }
          } // for


          notify = true;
        } else if (section.kind === "video") {
          data.videoReceived = {
            packetsReceived: 0,
            bytesReceived: 0,
            framesDecoded: 0
          };

          var _ts4 = Math.floor(section.timestamp / 1000);

          for (var _itemKey4 in section) {
            if (self.STANDARD_STAT_KEYS.videoReceived[_itemKey4] !== false) {
              if (_itemKey4 === "timestamp") {
                data.videoReceived.timestamp = _ts4;
              } else {
                data.videoReceived[_itemKey4] = section[_itemKey4];
              }
            }
          } // for


          notify = true;
        }
      } else if (section.type === "outbound-rtp" && !section.isRemote) {
        // sent media
        if (section.kind === "audio") {
          data.audioSent = {
            packetsSent: 0,
            bytesSent: 0
          };

          var _ts5 = Math.floor(section.timestamp / 1000);

          for (var _itemKey5 in section) {
            if (self.STANDARD_STAT_KEYS.audioSent[_itemKey5] !== false) {
              if (_itemKey5 === "timestamp") {
                data.audioSent.timestamp = _ts5;
              } else {
                data.audioSent[_itemKey5] = section[_itemKey5];
              }
            }
          } // for


          notify = true;
        } else if (section.kind === "video") {
          data.videoSent = {
            packetsSent: 0,
            bytesSent: 0,
            framesEncoded: 0
          };

          var _ts6 = Math.floor(section.timestamp / 1000);

          for (var _itemKey6 in section) {
            if (self.STANDARD_STAT_KEYS.videoSent[_itemKey6] !== false) {
              if (_itemKey6 === "timestamp") {
                data.videoSent.timestamp = _ts6;
              } else {
                data.videoSent[_itemKey6] = section[_itemKey6];
              }
            }
          } // for


          notify = true;
        }
      }
    }); // forEach

    return notify;
  };
  /*
  * Refines stats and sends them to CCS.
  *
  * @method addCallStats
  * @param {object} stats - raw stats
  * @param {object} callbacks - functions.
  * @param {function} callbacks.post
  * @return {object} refined call stats
  */


  this.addCallStats = function (stats) {
    var callbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var newData = {};

    if (this.refineStats !== undefined) {
      this.refineStats(newData, stats); // Computing extra stats
      // for audioReceived, adding: packetsReceivedPerSecond, bitsReceivedPerSecond, packetsLostPerSecond

      if (newData.audioReceived !== undefined) {
        if (this.prevData.audioReceived !== undefined) {
          var time = newData.audioReceived.timestamp - this.prevData.audioReceived[0].timestamp;

          if (time > 0) {
            if (newData.audioReceived.packetsReceivedPerSecond === undefined) {
              newData.audioReceived.packetsReceivedPerSecond = Math.floor((newData.audioReceived.packetsReceived - this.prevData.audioReceived[0].packetsReceived) / time);
            }

            if (newData.audioReceived.bitsReceivedPerSecond === undefined) {
              newData.audioReceived.bitsReceivedPerSecond = Math.floor((newData.audioReceived.bytesReceived - this.prevData.audioReceived[0].bytesReceived) * 8 / time);
            }

            if (newData.audioReceived.packetsLostPerSecond === undefined) {
              newData.audioReceived.packetsLostPerSecond = Math.floor((newData.audioReceived.packetsLost - this.prevData.audioReceived[0].packetsLost) / time);
            }

            if (newData.audioReceived.packetLossRatio === undefined) {
              newData.audioReceived.packetLossRatio = (newData.audioReceived.packetsLost - this.prevData.audioReceived[0].packetsLost) * 100 / (newData.audioReceived.packetsReceived - this.prevData.audioReceived[0].packetsReceived);
            }

            newData.audioReceived.samplingInterval = time;
          } else {
            if (newData.audioReceived.packetsReceivedPerSecond === undefined) {
              newData.audioReceived.packetsReceivedPerSecond = 0;
            }

            if (newData.audioReceived.bitsReceivedPerSecond === undefined) {
              newData.audioReceived.bitsReceivedPerSecond = 0;
            }

            if (newData.audioReceived.packetsLostPerSecond === undefined) {
              newData.audioReceived.packetsLostPerSecond = 0;
            }

            if (newData.audioReceived.packetLossRatio === undefined) {
              newData.audioReceived.packetLossRatio = 0;
            }

            newData.audioReceived.samplingInterval = 0;
          }
        } else {
          if (newData.audioReceived.packetsReceivedPerSecond === undefined) {
            newData.audioReceived.packetsReceivedPerSecond = 0;
          }

          if (newData.audioReceived.bitsReceivedPerSecond === undefined) {
            newData.audioReceived.bitsReceivedPerSecond = 0;
          }

          if (newData.audioReceived.packetsLostPerSecond === undefined) {
            newData.audioReceived.packetsLostPerSecond = 0;
          }

          if (newData.audioReceived.packetLossRatio === undefined) {
            newData.audioReceived.packetLossRatio = 0;
          }

          newData.audioReceived.samplingInterval = 0;
          this.prevData.audioReceived = [];
        }

        this.prevData.audioReceived.push(newData.audioReceived);

        while (this.prevData.audioReceived.length > this.prevDataThreshold) {
          this.prevData.audioReceived.shift();
        }
      } // for videoReceived, adding: packetsReceivedPerSecond, bitsReceivedPerSecond, packetsLostPerSecond, framesDecodedPerSecond


      if (newData.videoReceived !== undefined) {
        if (this.prevData.videoReceived !== undefined) {
          var _time = newData.videoReceived.timestamp - this.prevData.videoReceived[0].timestamp;

          if (_time > 0) {
            if (newData.videoReceived.packetsReceivedPerSecond === undefined) {
              newData.videoReceived.packetsReceivedPerSecond = Math.floor((newData.videoReceived.packetsReceived - this.prevData.videoReceived[0].packetsReceived) / _time);
            }

            if (newData.videoReceived.bitsReceivedPerSecond === undefined) {
              newData.videoReceived.bitsReceivedPerSecond = Math.floor((newData.videoReceived.bytesReceived - this.prevData.videoReceived[0].bytesReceived) * 8 / _time);
            }

            if (newData.videoReceived.packetsLostPerSecond === undefined) {
              newData.videoReceived.packetsLostPerSecond = Math.floor((newData.videoReceived.packetsLost - this.prevData.videoReceived[0].packetsLost) / _time);
            }

            if (newData.videoReceived.framesDecodedPerSecond === undefined) {
              newData.videoReceived.framesDecodedPerSecond = Math.floor((newData.videoReceived.framesDecoded - this.prevData.videoReceived[0].framesDecoded) / _time);
            }

            if (newData.videoReceived.packetLossRatio === undefined) {
              newData.videoReceived.packetLossRatio = (newData.videoReceived.packetsLost - this.prevData.videoReceived[0].packetsLost) * 100 / (newData.videoReceived.packetsReceived - this.prevData.videoReceived[0].packetsReceived);
            }

            newData.videoReceived.samplingInterval = _time;
          } else {
            if (newData.videoReceived.packetsReceivedPerSecond === undefined) {
              newData.videoReceived.packetsReceivedPerSecond = 0;
            }

            if (newData.videoReceived.bitsReceivedPerSecond === undefined) {
              newData.videoReceived.bitsReceivedPerSecond = 0;
            }

            if (newData.videoReceived.packetsLostPerSecond === undefined) {
              newData.videoReceived.packetsLostPerSecond = 0;
            }

            if (newData.videoReceived.framesDecodedPerSecond === undefined) {
              newData.videoReceived.framesDecodedPerSecond = 0;
            }

            if (newData.videoReceived.packetLossRatio === undefined) {
              newData.videoReceived.packetLossRatio = 0;
            }

            newData.videoReceived.samplingInterval = 0;
          }
        } else {
          if (newData.videoReceived.packetsReceivedPerSecond === undefined) {
            newData.videoReceived.packetsReceivedPerSecond = 0;
          }

          if (newData.videoReceived.bitsReceivedPerSecond === undefined) {
            newData.videoReceived.bitsReceivedPerSecond = 0;
          }

          if (newData.videoReceived.packetsLostPerSecond === undefined) {
            newData.videoReceived.packetsLostPerSecond = 0;
          }

          if (newData.videoReceived.framesDecodedPerSecond === undefined) {
            newData.videoReceived.framesDecodedPerSecond = 0;
          }

          if (newData.videoReceived.packetLossRatio === undefined) {
            newData.videoReceived.packetLossRatio = 0;
          }

          newData.videoReceived.samplingInterval = 0;
          this.prevData.videoReceived = [];
        }

        this.prevData.videoReceived.push(newData.videoReceived);

        while (this.prevData.videoReceived.length > this.prevDataThreshold) {
          this.prevData.videoReceived.shift();
        }
      } // for audioSent, adding: packetsSentPerSecond, bitsSentPerSecond


      if (newData.audioSent !== undefined) {
        if (this.prevData.audioSent !== undefined) {
          var _time2 = newData.audioSent.timestamp - this.prevData.audioSent[0].timestamp;

          if (_time2 > 0) {
            if (newData.audioSent.packetsSentPerSecond === undefined) {
              newData.audioSent.packetsSentPerSecond = Math.floor((newData.audioSent.packetsSent - this.prevData.audioSent[0].packetsSent) / _time2);
            }

            if (newData.audioSent.bitsSentPerSecond === undefined) {
              newData.audioSent.bitsSentPerSecond = Math.floor((newData.audioSent.bytesSent - this.prevData.audioSent[0].bytesSent) * 8 / _time2);
            }

            newData.audioSent.samplingInterval = _time2;
          } else {
            if (newData.audioSent.packetsSentPerSecond === undefined) {
              newData.audioSent.packetsSentPerSecond = 0;
            }

            if (newData.audioSent.bitsSentPerSecond === undefined) {
              newData.audioSent.bitsSentPerSecond = 0;
            }

            newData.audioSent.samplingInterval = 0;
          }
        } else {
          if (newData.audioSent.packetsSentPerSecond === undefined) {
            newData.audioSent.packetsSentPerSecond = 0;
          }

          if (newData.audioSent.bitsSentPerSecond === undefined) {
            newData.audioSent.bitsSentPerSecond = 0;
          }

          newData.audioSent.samplingInterval = 0;
          this.prevData.audioSent = [];
        }

        this.prevData.audioSent.push(newData.audioSent);

        while (this.prevData.audioSent.length > this.prevDataThreshold) {
          this.prevData.audioSent.shift();
        }
      } // for videoSent, adding: packetsSentPerSecond, bitsSentPerSecond, framesEncodedPerSecond


      if (newData.videoSent !== undefined) {
        if (this.prevData.videoSent !== undefined) {
          var _time3 = newData.videoSent.timestamp - this.prevData.videoSent[0].timestamp;

          if (_time3 > 0) {
            if (newData.videoSent.packetsSentPerSecond === undefined) {
              newData.videoSent.packetsSentPerSecond = Math.floor((newData.videoSent.packetsSent - this.prevData.videoSent[0].packetsSent) / _time3);
            }

            if (newData.videoSent.bitsSentPerSecond === undefined) {
              newData.videoSent.bitsSentPerSecond = Math.floor((newData.videoSent.bytesSent - this.prevData.videoSent[0].bytesSent) * 8 / _time3);
            }

            if (newData.videoSent.framesEncodedPerSecond === undefined) {
              newData.videoSent.framesEncodedPerSecond = Math.floor((newData.videoSent.framesEncoded - this.prevData.videoSent[0].framesEncoded) / _time3);
            }

            newData.videoSent.samplingInterval = _time3;
          } else {
            if (newData.videoSent.packetsSentPerSecond === undefined) {
              newData.videoSent.packetsSentPerSecond = 0;
            }

            if (newData.videoSent.bitsSentPerSecond === undefined) {
              newData.videoSent.bitsSentPerSecond = 0;
            }

            if (newData.videoSent.framesEncodedPerSecond === undefined) {
              newData.videoSent.framesEncodedPerSecond = 0;
            }

            newData.videoSent.samplingInterval = 0;
          }
        } else {
          if (newData.videoSent.packetsSentPerSecond === undefined) {
            newData.videoSent.packetsSentPerSecond = 0;
          }

          if (newData.videoSent.bitsSentPerSecond === undefined) {
            newData.videoSent.bitsSentPerSecond = 0;
          }

          if (newData.videoSent.framesEncodedPerSecond === undefined) {
            newData.videoSent.framesEncodedPerSecond = 0;
          }

          newData.videoSent.samplingInterval = 0;
          this.prevData.videoSent = [];
        }

        this.prevData.videoSent.push(newData.videoSent);

        while (this.prevData.videoSent.length > this.prevDataThreshold) {
          this.prevData.videoSent.shift();
        }
      }
    }

    if (Object.keys(newData).length > 0 && typeof callbacks.post === 'function') {
      callbacks.post(newData);
    }

    return newData;
  }; // Setting function refineStats.


  if (this.browserType === 'chrome') {
    if (flavor === 'proprietary') {
      this.refineStats = this.refineStats_chrome_proprietary;
    } else {
      if (this.browserVersion >= 58) {
        this.refineStats = this.refineStats_chrome_58;
      } else {
        this.refineStats = this.refineStats_chrome_legacy;
      }
    }
  } else if (this.browserType === 'firefox') {
    if (this.browserVersion >= 63) {
      this.refineStats = this.refineStats_firefox_63;
    } else {
      this.refineStats = this.refineStats_firefox_legacy;
    }
  } else if (this.browserType === 'safari') {
    this.refineStats = this.refineStats_chrome_58;
  }
};



/***/ }),

/***/ "./src/Core/Checksum64.js":
/*!********************************!*\
  !*** ./src/Core/Checksum64.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createChecksum": () => (/* binding */ createChecksum)
/* harmony export */ });
var Checksum64 = function Checksum64() {
  var HEX_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
  this.a = 1;
  this.b = 0;
  this.c = 7;
  this.d = 0;

  this.update = function (data, off, len) {
    var i = 0;

    if (off === undefined || off === null) {
      off = 0;
    }

    if (len === undefined || len === null) {
      len = data.length;
    }

    for (; i < len; i += 1) {
      this.a = (this.a + data[off + i]) % 65521;
      this.b = (this.b + this.a) % 65521;
      this.c = (this.c + 3) * (data[off + i] + 5) % 65521;
      this.d = (this.d + this.c) % 65521;
    }
  };

  this.digest = function (encoding) {
    return HEX_CHARS[this.d >> 12 & 0xf] + HEX_CHARS[this.d >> 8 & 0xf] + HEX_CHARS[this.d >> 4 & 0xf] + HEX_CHARS[this.d & 0xf] + HEX_CHARS[this.c >> 12 & 0xf] + HEX_CHARS[this.c >> 8 & 0xf] + HEX_CHARS[this.c >> 4 & 0xf] + HEX_CHARS[this.c & 0xf] + HEX_CHARS[this.b >> 12 & 0xf] + HEX_CHARS[this.b >> 8 & 0xf] + HEX_CHARS[this.b >> 4 & 0xf] + HEX_CHARS[this.b & 0xf] + HEX_CHARS[this.a >> 12 & 0xf] + HEX_CHARS[this.a >> 8 & 0xf] + HEX_CHARS[this.a >> 4 & 0xf] + HEX_CHARS[this.a & 0xf];
  };
};

function createChecksum(algo, options) {
  if (options === undefined || options === null) {
    options = {};
  }

  if (algo === 'checksum64') {
    return new Checksum64();
  }

  return null;
}



/***/ }),

/***/ "./src/Core/DataChannelFileSender.js":
/*!*******************************************!*\
  !*** ./src/Core/DataChannelFileSender.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataChannelFileSender": () => (/* binding */ DataChannelFileSender)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('DataChannelFileSender');
var myWebRTC_Event = apiCC.myWebRTC_Event;

var BUFFERED_AMOUNT_THRESHOLD = 1 << 17;
var DATA_END_ACK_RECV_TIMEOUT = 30000;
/*
* This is the DataChannelFileSender
*
* @module DataChannelFileSender
*/

var DataChannelFileSender = function DataChannelFileSender(call) {
  this.call = call;
  this.sendChunkNb = 0;

  this.send = function (data, channel, onProgress) {
    var chunkLength = 12000,
        // Fx is limited to 16384 : 12000 with encoding seems to be OK
    //var chunkLength = 16384,
    dataToSend = {},
        remainingDataToSend = null,
        firstPacket = {},
        lastPacket = false,
        packet = {};
    logger.info("DataChannelFileSender send");
    logger.log("data.name :" + data.name);

    if (data.file instanceof Blob) {
      logger.log("Blob");
      this.blob = data.file;
      this.contentType = data.file.type;
      this.size = data.file.size;
      this.originalDataType = "Blob";
    } else if (data.file instanceof ArrayBuffer) {
      logger.log("ArrayBuffer"); //logger.log("data.file :" + data.file);

      this.blob = data.file;
      this.contentType = 'application/octet-stream';
      this.size = data.file.byteLength; //logger.log("this.size :" + this.size);

      this.originalDataType = "ArrayBuffer";
    } else if (data.file instanceof String || typeof data.file === 'string') {
      logger.log("string");
      this.blob = data.file;
      this.size = data.file.length;
      this.contentType = 'application/octet-stream';
      this.originalDataType = "String";
    } else {
      logger.log("unknown type");
      this.blob = data.file;
      this.contentType = 'application/octet-stream';
      this.size = data.file.length || data.file.byteLength || data.file.size;
      this.originalDataType = "Unknown";
    }

    if (!this.contentType) {
      this.contentType = 'application/octet-stream';
    }

    if (this.size === 0) {
      logger.log("sending done");

      if (onProgress !== undefined) {
        logger.log("onProgress");
        this.transferDuration = new Date() - this.startingDate;
        onProgress({
          sendChunkNb: this.sendChunkNb,
          fileSize: this.fileSize,
          remainingSize: this.size,
          callId: call.callId,
          uuid: data.uuid,
          remoteId: call.remoteId,
          lastPacket: lastPacket,
          startingDate: this.startingDate,
          transferDuration: this.transferDuration,
          percentage: parseInt(100 * (this.fileSize - this.size) / this.fileSize, 10),
          transferEnded: true
        });
      }

      myWebRTC_Event.createEvent({
        "eventType": "onFileProgress",
        sendChunkNb: this.sendChunkNb,
        fileSize: this.fileSize,
        remainingSize: this.size,
        callId: call.callId,
        uuid: data.uuid,
        remoteId: call.remoteId,
        lastPacket: lastPacket,
        startingDate: this.startingDate,
        transferDuration: this.transferDuration,
        percentage: parseInt(100 * (this.fileSize - this.size) / this.fileSize, 10),
        transferEnded: true
      });
      myWebRTC_Event.createEvent({
        "eventType": "onFileSended",
        "callId": call.callId,
        "remoteId": call.remoteId,
        "name": data.name,
        "uuid": data.uuid
      });
      return;
    }

    if (!channel) {
      logger.log("No data channel to send data");
      return;
    }

    if (channel.readyState !== "open") {
      logger.log("Trying to send on a closed channel");
      return;
    }

    if (this.sendChunkNb === 0) {
      logger.log("first packet");
    }

    if (this.sendChunkNb === 0) {
      data.uuid = (Math.random() * new Date().getTime()).toString(36).replace(/\./g, '-');
      firstPacket = {
        "name": data.name,
        "type": data.type,
        "size": this.size,
        "contentType": this.contentType,
        "uuid": data.uuid
      };
      logger.log("first packet", firstPacket);
      this.fileSize = this.size;

      if (onProgress !== undefined) {
        logger.log("onProgress");
        this.startingDate = new Date();
        this.transferDuration = 0;
        onProgress({
          sendChunkNb: this.sendChunkNb,
          fileSize: this.fileSize,
          remainingSize: this.size,
          callId: call.callId,
          uuid: data.uuid,
          remoteId: call.remoteId,
          lastPacket: lastPacket,
          startingDate: this.startingDate,
          transferDuration: this.transferDuration,
          percentage: parseInt(100 * (this.fileSize - this.size) / this.fileSize, 10),
          transferEnded: false
        });
        myWebRTC_Event.createEvent({
          "eventType": "onFileProgress",
          sendChunkNb: this.sendChunkNb,
          fileSize: this.fileSize,
          remainingSize: this.size,
          callId: call.callId,
          uuid: data.uuid,
          remoteId: call.remoteId,
          lastPacket: lastPacket,
          startingDate: this.startingDate,
          transferDuration: this.transferDuration,
          percentage: parseInt(100 * (this.fileSize - this.size) / this.fileSize, 10),
          transferEnded: false
        });
      } //logger.error("channel :", channel);
      //channel.send(JSON.stringify(firstPacket));


      try {
        //channel.send(JSON.stringify(packet));
        channel.send(JSON.stringify(firstPacket));
      } catch (err) {
        logger.warn("error detected when sending on datachannel :", channel);
        logger.warn("error is :", err);
      }

      myWebRTC_Event.createEvent({
        "eventType": "onFileSending",
        "callId": call.callId,
        "remoteId": call.remoteId,
        "name": data.name,
        "uuid": data.uuid
      });
    } else {
      //logger.log("sending data chunk", this.sendChunkNb);
      if (chunkLength < this.size) {
        logger.log("sending chunk");
        dataToSend = this.blob.slice(0, chunkLength);
      } else {
        logger.log("sending last chunk");
        dataToSend = this.blob.slice(0);
        lastPacket = true;
      }

      logger.log("dataToSend.byteLength =" + dataToSend.byteLength);

      if (this.originalDataType === "ArrayBuffer") {
        packet.message = _Utils__WEBPACK_IMPORTED_MODULE_1__.base64Binary.encode(dataToSend);
      } else {
        packet.message = dataToSend;
      }

      packet.messageSize = dataToSend.byteLength;
      packet.uuid = data.uuid;
      packet.originalDataType = this.originalDataType; //packet.sendChunkNb = this.sendChunkNb;
      //packet.size = this.size;
      //logger.error("packet.sendChunkNb =" + packet.sendChunkNb);

      if (onProgress !== undefined) {
        logger.log("onProgress");
        this.transferDuration = new Date() - this.startingDate;
        onProgress({
          sendChunkNb: this.sendChunkNb,
          fileSize: this.fileSize,
          remainingSize: this.size,
          callId: call.callId,
          uuid: data.uuid,
          remoteId: call.remoteId,
          startingDate: this.startingDate,
          lastPacket: lastPacket,
          transferDuration: this.transferDuration,
          percentage: parseInt(100 * (this.fileSize - this.size) / this.fileSize, 10),
          transferEnded: false
        });
        myWebRTC_Event.createEvent({
          "eventType": "onFileProgress",
          sendChunkNb: this.sendChunkNb,
          fileSize: this.fileSize,
          remainingSize: this.size,
          callId: call.callId,
          uuid: data.uuid,
          remoteId: call.remoteId,
          startingDate: this.startingDate,
          lastPacket: lastPacket,
          transferDuration: this.transferDuration,
          percentage: parseInt(100 * (this.fileSize - this.size) / this.fileSize, 10),
          transferEnded: false
        });
      } //logger.log("packet to send :", packet);
      //logger.log("packet.message :", packet.message);
      //logger.log("JSON.stringify(packet) :", JSON.stringify(packet));
      //logger.log("JSON.stringify(packet) :", JSON.stringify(packet));
      //logger.error("channel :", channel);


      try {
        channel.send(JSON.stringify(packet));
      } catch (err2) {
        logger.warn("error detected when sending on datachannel :", channel);
        logger.warn("error is :", err2);
      } //channel.send(JSON.stringify(packet));

    }

    if (this.sendChunkNb === 0) {
      remainingDataToSend = this.blob;
    } else {
      remainingDataToSend = this.blob.slice(chunkLength);
    } //logger.log("sliced", remainingDataToSend);


    if (lastPacket === false) {
      this.sendChunkNb++;
    } else {
      //if lastPacket reinit sendChunkNb, to enable new file sending
      this.sendChunkNb = 0;
    } //logger.log("nextChunkNb", this.sendChunkNb);


    data.file = remainingDataToSend;
    setTimeout(function () {
      //logger.log("remainingDataToSend", remainingDataToSend);
      this.send(data, channel, onProgress);
    }.bind(this));
  };

  this.terminateTransfer = function () {
    var _this = this;

    logger.debug('terminateTransfer; terminated: ' + this.terminated);

    if (this.channel === null) {
      logger.warn('No data channel to send data, leaving terminateTransfer');
      return;
    }

    if (this.useBufferedAmount === true && this.channel.bufferedAmount > 0 && this.canceled !== true) {
      setTimeout(this.terminateTransfer.bind(this));
      return;
    }

    if (this.terminated === true) {
      return;
    }

    this.terminated = true;

    if (this.recvDataEndAckTimeoutId) {
      clearTimeout(this.recvDataEndAckTimeoutId);
      delete this.recvDataEndAckTimeoutId;
    } // The reference to this one is no longer required.


    delete this.call.dcfs;
    logger.debug('terminateTransfer; terminating');

    if (this.call.pipelineCallId) {
      // Call is not the owner of dataChannel.
      if (this.call.pipelineCall) {
        // Unset the relationship.
        delete this.call.pipelineCall.clientCall;
        delete this.call.pipelineCall; // Unset dataChannel.

        this.call.sendDataChannel = null;
      } // Keep dataChannel open.


      this.channel = null;
    } else {
      // Call is the owner of dataChannel.
      setTimeout(function () {
        _this.channel.close();

        _this.channel = null;
      });
    }

    setTimeout(function () {
      if (_this.canceled === true) {
        myWebRTC_Event.createEvent({
          eventType: 'onFileSended',
          callId: _this.call.callId,
          remoteId: _this.call.remoteId,
          name: _this.call.data.filename,
          error: 'canceled'
        });

        _this.call.callbacks.failure('canceled');
      } else if (_this.call.failure) {
        myWebRTC_Event.createEvent({
          eventType: 'onFileSended',
          callId: _this.call.callId,
          remoteId: _this.call.remoteId,
          name: _this.call.data.filename,
          error: _this.call.failure
        });

        _this.call.callbacks.failure(_this.call.failure);
      } else {
        var onFileSended = {
          eventType: 'onFileSended',
          callId: _this.call.callId,
          remoteId: _this.call.remoteId,
          name: _this.call.data.filename
        };

        if (_this.call.success.data) {
          onFileSended.data = _this.call.success.data;
        }

        myWebRTC_Event.createEvent(onFileSended);

        _this.call.callbacks.success(_this.call.success);
      }

      apiCC.session.apiCCWebRTCClient.webRTCClient.onHangup(_this.call.callId);
    });
  };

  this.recvDataEndAckTimeout = function () {
    logger.error('recvDataEndAckTimeout');
    this.call.failure = 'ackNotReceived';
    setTimeout(this.terminateTransfer.bind(this));
  };

  this.subsequentTransfer = function () {
    var chunk,
        complete = false;
    logger.debug('subsequentTransfer; remByteCount: ' + this.remByteCount);

    if (this.canceled === true) {
      setTimeout(this.terminateTransfer.bind(this));
      return;
    }

    if (this.channel === null) {
      logger.warn('No data channel to send data, leaving subsequentTransfer');
      return;
    }

    if (this.useBufferedAmount === true && this.channel.bufferedAmount > BUFFERED_AMOUNT_THRESHOLD) {
      setTimeout(this.subsequentTransfer.bind(this));
      return;
    }

    try {
      while (true) {
        // Evaluating next sending.
        if (this.remByteCount >= this.chunkLength) {
          // Full chunk.
          chunk = this.data.slice(this.offset, this.offset + this.chunkLength);
          this.channel.send(chunk);
          this.packetsSent += 1;
          logger.debug('packetSent ' + this.packetsSent + ' ' + this.chunkLength);
          this.offset += this.chunkLength;
          this.remByteCount -= this.chunkLength;

          if (this.remByteCount <= 0) {
            complete = true;
            break;
          } else if (this.useBufferedAmount !== true || this.channel.bufferedAmount > BUFFERED_AMOUNT_THRESHOLD) {
            break;
          }
        } else {
          // Last chunk.
          chunk = this.data.slice(this.offset, this.offset + this.remByteCount);
          this.channel.send(chunk);
          this.packetsSent += 1;
          logger.debug('packetSent ' + this.packetsSent + ' ' + this.remByteCount);
          this.offset += this.remByteCount;
          this.remByteCount -= this.remByteCount;
          complete = true;
          break;
        }
      }

      if (complete === true) {
        myWebRTC_Event.createEvent({
          'eventType': 'onFileProgress',
          'name': this.call.data.filename,
          'sendChunkNb': this.packetsSent,
          'fileSize': this.call.data.size,
          'remainingSize': this.remByteCount,
          'callId': this.call.callId,
          'remoteId': this.call.remoteId,
          'percentage': 100
        });
        this.call.callbacks.progress({
          'state': 'complete',
          'filename': this.call.data.filename,
          'size': this.call.data.size,
          'remBytes': 0,
          'progress': 100
        });
        this.call.success = {
          'state': 'complete',
          'filename': this.call.data.filename,
          'size': this.call.data.size,
          'mediaURL': this.call.mediaURL,
          'mediaId': this.call.mediaId
        }; // Give time to all packets to arrive.

        this.recvDataEndAckTimeoutId = setTimeout(this.recvDataEndAckTimeout.bind(this), DATA_END_ACK_RECV_TIMEOUT);
      } else {
        myWebRTC_Event.createEvent({
          'eventType': 'onFileProgress',
          'name': this.call.data.filename,
          'sendChunkNb': this.packetsSent,
          'fileSize': this.call.data.size,
          'remainingSize': this.remByteCount,
          'callId': this.call.callId,
          'remoteId': this.call.remoteId,
          'percentage': Math.floor(100 * this.offset / this.call.data.size)
        });
        this.call.callbacks.progress({
          'state': 'incomplete',
          'filename': this.call.data.filename,
          'size': this.call.data.size,
          'remBytes': this.remByteCount,
          'progress': Math.floor(100 * this.offset / this.call.data.size)
        });
        setTimeout(this.subsequentTransfer.bind(this));
      }
    } catch (err) {
      logger.error('transfer: ' + err);
      this.call.failure = 'dataChannelFailed';
      setTimeout(this.terminateTransfer.bind(this));
      return;
    }
  };
  /*
   * Sends first packet and sets timeout for subsequent packets.
   * @ignore
   * @method transfer
   * @param {Buffer} data
   * @param {number} offset
   * @param {RTCDataChannel} channel
   * @param {object} options
   * @param {number} options.delay
   */


  this.transfer = function (data, offset, channel) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var delay = options.hasOwnProperty('delay') ? options.delay : 100;
    logger.info('transfer', offset, delay);

    if (this.call.beginTimeoutId) {
      // Call is set up.
      clearTimeout(this.call.beginTimeoutId);
      delete this.call.beginTimeoutId;
    }

    this.data = data;
    this.channel = channel;

    if (this.channel === null) {
      logger.warn('No data channel to send data, leaving transfer');
      return;
    } // Using bufferedAmount allow us to speed up the transfer.


    if (typeof this.channel.bufferedAmount === 'number' && this.channel.bufferedAmount >= 0) {
      logger.debug('browserDetails', _Utils__WEBPACK_IMPORTED_MODULE_1__.browserDetails);

      if (_Utils__WEBPACK_IMPORTED_MODULE_1__.browserDetails.type === 'chrome') {
        // Prior to chrome 37, bufferedAmount existed but defined a number of packets
        // instead of a number of bytes.
        if (_Utils__WEBPACK_IMPORTED_MODULE_1__.browserDetails.version >= 37) {
          this.useBufferedAmount = true;
          logger.debug('useBufferedAmount enabled');
        }
      } else {
        this.useBufferedAmount = true;
        logger.debug('useBufferedAmount enabled');
      }
    }

    this.chunkLength = 1 << 13;

    if (offset > 0) {
      this.offset = Math.floor(offset / this.chunkLength) * this.chunkLength;
      this.remByteCount = this.data.byteLength - this.offset;
    } else {
      this.offset = 0;
      this.remByteCount = this.data.byteLength;
    }

    this.packetsSent = 0;

    try {
      var packet = {
        chunkLength: this.chunkLength,
        offset: this.offset,
        remBytes: this.remByteCount
      };

      if (this.call.pipelineCallId) {
        // We are lending the dataChannel and we need to send the
        // manifest here since it has not been sent along the pushData
        // message.
        packet.pluginName = call.data.pluginName;
        packet.pluginData = call.data.pluginData;

        if (call.data.context) {
          packet.context = call.data.context;
        }
      }

      this.channel.send(JSON.stringify(packet));
    } catch (err) {
      logger.error('transfer:', err);
      this.call.failure = 'dataChannelFailed';
      setTimeout(this.terminateTransfer.bind(this));
      return;
    }

    myWebRTC_Event.createEvent({
      'eventType': 'onFileSending',
      'callId': this.call.callId,
      'remoteId': this.call.remoteId,
      'name': this.call.data.filename
    });
    setTimeout(this.subsequentTransfer.bind(this), delay);
  };
};



/***/ }),

/***/ "./src/Core/Init.js":
/*!**************************!*\
  !*** ./src/Core/Init.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "init": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");
/* globals io, requirejs, apiCC, apiRTC_sioLoader*/


var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('Init');
/*
 * Tests whether a given apiKey is legal.
 * @param {any} apiKey
 * @return {boolean}
 */

var apiKeyFormatControl = function apiKeyFormatControl(apiKey) {
  var formatOK = true;
  logger.info('apiKey :', apiKey);

  if (apiKey.indexOf('[') !== -1) {
    formatOK = false;
  }

  return formatOK;
};

var APICCID_LIMIT = 128;
/*
 * Tests whether a given apiCCId is legal.
 * @param {any} apiCCId
 * @return {boolean}
 */

var apiCCIdFormatControl = function apiCCIdFormatControl(apiCCId) {
  if (apiCCId !== null) {
    var id = apiCCId;

    if (typeof id === 'number') {
      id = String(id);
    }

    if (typeof id === 'string') {
      return id.length <= APICCID_LIMIT;
    }
  }

  return false;
};
/**
* <b>Description</b>
* <p>This method will initialize the apiRTC session and establish a connection between your application and the server.</p>
* <b>Associated events :</b>
* <li>sessionReady</li>
* @method init
* @memberof module:ApiRTC
* @param {String} initParameters.apiKey API Key that you will receive on your ApiRTC account creation (contact support on apirtc.com)
* @param {String} initParameters.onReady User Identifier that can be used to identify one client
* @param {Number} [initParameters.apiCCId] Optional parameters that enables you to set your client number.
* This is useful if you have an account database on your side and want to associate an apiRTC identifier to theses accounts.
* If not provided apiRTC will create a random ID for your client instance.
* This is the parameter that is used to establish communications between users.
* @param {String} [initParameters.nickname] Optional parameters that enables you to set your client nickname.
* @param {JSON} [initParameters.userData] Optional parameters that enables you to set userData.
* These data are shared with all subscribed group users. UserData format is restricted to key/value {key1 : value1, key2 : value2}
* @param {JSON} [initParameters.presenceGroup] Optional parameters that define groups of the user,
* @param {JSON} [initParameters.subscribeToPresenceGroup] Optional parameters that define presence subscribed groups of the user
* @param {String} [initParameters.appId] Optional application identifier
* @param {String} [initParameters.siteId] Optional site identifier
* @return {ApiCCSession} ApiRTC Session object
**/


var init = function init(initParameters) {
  logger.info("apiRTC initialization, version is :" + apiCC.version);
  logger.info("osName :" + apiCC.osName);
  logger.info("osVersion :" + apiCC.osVersion);
  logger.info("browser :" + apiCC.browser);
  logger.info("browser_version :" + apiCC.browser_version);

  if (apiKeyFormatControl(initParameters.apiKey) !== true) {
    logger.error("Apikey format is not correct, leaving connection process");
    return;
  }

  if (initParameters.hasOwnProperty('apiCCId') && initParameters.apiCCId !== null && initParameters.apiCCId !== '') {
    if (apiCCIdFormatControl(initParameters.apiCCId) !== true) {
      logger.error("apiCCId format is not correct, leaving connection process");
      return;
    }
  }

  var protocol = '';

  if (window !== undefined && window.location !== undefined && window.location.protocol !== undefined) {
    if (window.location.protocol != "https:") {
      protocol = 'http';
    } else {
      protocol = 'https';
    }
  } else {
    protocol = 'https';
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "iOS" || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "Android") {
    logger.log(_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name + " detected forcing protocol to https");
    protocol = 'https';
  }

  if (initParameters.ccsServer === undefined) {
    logger.debug("Setting ccsServer");

    if (window !== undefined && window.location !== undefined && window.location.protocol !== undefined) {
      if (window.location.protocol == "https:" || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "iOS" || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "Android") {
        initParameters.ccsServer = "ccs5.apizee.com:443";
      } else {
        initParameters.ccsServer = "ccs5.apizee.com:80";
      }
    } else {
      initParameters.ccsServer = "ccs5.apizee.com:443";
    }
  } else {
    logger.log("ccsServer is defined on init()");
  }

  if (initParameters.bandwidthTestServer !== null && initParameters.bandwidthTestServer !== undefined) {
    logger.log('bandwidthTestServer is defined :', initParameters.bandwidthTestServer);
    apiCC.bandwidthTestServer = initParameters.bandwidthTestServer;
  } else {
    logger.log('bandwidthTestServer is not defined');
  }

  if (initParameters.userData !== undefined) {
    logger.log("userData :", initParameters.userData);
  }

  apiCC.extJsLoadingRetryNb = initParameters.extJsLoadingRetryNb;
  apiCC.extJsLoadingRetryDelay = initParameters.extJsLoadingRetryDelay;

  if (apiCC.jsLoaded === false) {
    apiCC.initApiKey = initParameters.apiKey;
    apiCC.initApiCCId = initParameters.apiCCId;

    var successFunction = function successFunction() {
      logger.log("sio loaded");
      apiCC.jsLoaded = true;
      apiCC.session = new apiCC.ApiCCSession(initParameters);
      apiCC.myWebRTC_Event.createExternalJsLoadingStatusEvent('sio', 'loaded');
    };

    var apiRTC_sioLoaderOptions = {
      'success': successFunction,
      'error': function error() {
        logger.error("sio loading error");
        apiCC.myWebRTC_Event.createExternalJsLoadingStatusEvent('sio', 'error');
      },
      'retrycb': function retrycb() {
        logger.warn("sio retry");
        apiCC.myWebRTC_Event.createExternalJsLoadingStatusEvent('sio', 'retry');
      }
    };

    if (apiCC.sioEmbedded) {
      window.rtcio = io;
      successFunction();
    } else {
      apiRTC_sioLoader.load(protocol, initParameters, apiRTC_sioLoaderOptions);
    }
  } else {
    logger.log("apiRTC JS Librairies already loaded");
    logger.log("initParameters have changed, need to reload session connection");
    apiCC.addEventListener("sessionReady", initParameters.onReady);
    logger.log("initParameters.userData :", initParameters.userData);

    if (initParameters.apiCCId === undefined || initParameters.apiCCId === '' || initParameters.apiCCId === null) {
      logger.log("keeping apiCCId defined by apiRTC :" + initParameters.apiCCId);
      initParameters.apiCCId = apiCC.session.apiCCId;
    }

    logger.log('initParameters.apiCCId :' + initParameters.apiCCId);

    if (initParameters.userData !== null && initParameters.userData !== undefined) {
      logger.log('userData is defined :', initParameters.userData);
      apiCC.session.userData = initParameters.userData;
    } else {
      logger.log('userData is not defined');
    }

    logger.log("apiCC.session.userData :", apiCC.session.userData);

    if (initParameters.token !== null && initParameters.token !== undefined) {
      logger.log('token is defined :' + initParameters.token);
      apiCC.session.token = initParameters.token;
    } else {
      logger.log('token is not defined');
      apiCC.session.token = null;
    }

    if (initParameters.conversationSpace !== null && initParameters.conversationSpace !== undefined) {
      logger.log('conversationSpace is defined :' + initParameters.conversationSpace);
      apiCC.session.conversationSpace = initParameters.conversationSpace;
    } else {
      logger.log('conversationSpace is not defined');
      apiCC.session.conversationSpace = null;
    } //Re-initialisation of connection with new parameters


    apiCC.session.reOpenChannel(initParameters.apiCCId, initParameters.apiKey);

    if (initParameters.nickname !== null && initParameters.nickname !== undefined) {
      logger.log('Nickname is defined :' + initParameters.nickname);
      apiCC.session.nickname = initParameters.nickname;
    } else {
      logger.log('Nickname is not defined, setting to apiCCId value :' + apiCC.session.apiCCId);
      apiCC.session.nickname = apiCC.session.apiCCId;
    }

    if (initParameters.photoURL !== null && initParameters.photoURL !== undefined) {
      logger.log('photoURL is defined :' + initParameters.photoURL);
      apiCC.session.photoURL = initParameters.photoURL;
    } else {
      logger.log('photoURL is not defined');
      apiCC.session.photoURL = null;
    }

    if (initParameters.presenceGroup !== null && initParameters.presenceGroup !== undefined) {
      logger.log('presenceGroup is defined :' + initParameters.presenceGroup);

      if (JSON.stringify(apiCC.session.presenceGroup) !== JSON.stringify(initParameters.presenceGroup)) {
        logger.log('presenceGroup updated on initParameters');
        apiCC.session.channel.updatePresenceGroupIsNeeded = true;

        if (apiCC.session.channel.oldPresenceGroup === null) {
          //Setting oldPresenceGroup only the first time to keep socket.io URL value : cf socket.io issues/1677
          apiCC.session.channel.oldPresenceGroup = apiCC.session.presenceGroup;
        }

        apiCC.session.channel.newPresenceGroup = initParameters.presenceGroup;
        apiCC.session.presenceGroup = initParameters.presenceGroup;
      }
    } else {
      logger.log('presenceGroup is not defined, setting to ["default"]');

      if (JSON.stringify(apiCC.session.presenceGroup) !== JSON.stringify(["default"])) {
        logger.log('presenceGroup updated on initParameters');
        apiCC.session.channel.updatePresenceGroupIsNeeded = true;

        if (apiCC.session.channel.oldPresenceGroup === null) {
          //Setting oldPresenceGroup only the first time to keep socket.io URL value : cf socket.io issues/1677
          apiCC.session.channel.oldPresenceGroup = apiCC.session.presenceGroup;
        }

        apiCC.session.channel.newPresenceGroup = ["default"];
        apiCC.session.presenceGroup = ["default"];
      }
    }

    if (initParameters.subscribeToPresenceGroup !== null && initParameters.subscribeToPresenceGroup !== undefined) {
      logger.log('subscribeToPresenceGroup is defined :' + initParameters.subscribeToPresenceGroup);

      if (JSON.stringify(apiCC.session.subscribeToPresenceGroup) !== JSON.stringify(initParameters.subscribeToPresenceGroup)) {
        logger.log('subscribeToPresenceGroup updated on initParameters');
        apiCC.session.channel.updateSubscribeToPresenceGroupIsNeeded = true;

        if (apiCC.session.channel.oldSubscribeToPresenceGroup === null) {
          //Setting oldPresenceGroup only the first time to keep socket.io URL value : cf socket.io issues/1677
          apiCC.session.channel.oldSubscribeToPresenceGroup = apiCC.session.subscribeToPresenceGroup;
        }

        apiCC.session.channel.newSubscribeToPresenceGroup = initParameters.subscribeToPresenceGroup;
        apiCC.session.subscribeToPresenceGroup = initParameters.subscribeToPresenceGroup;
      }
    } else {
      logger.log('subscribeToPresenceGroup is not defined, setting to ["default"]');

      if (JSON.stringify(apiCC.session.subscribeToPresenceGroup) !== JSON.stringify(["default"])) {
        logger.log('subscribeToPresenceGroup updated on initParameters');
        apiCC.session.channel.updateSubscribeToPresenceGroupIsNeeded = true;

        if (apiCC.session.channel.oldSubscribeToPresenceGroup === null) {
          //Setting oldPresenceGroup only the first time to keep socket.io URL value : cf socket.io issues/1677
          apiCC.session.channel.oldSubscribeToPresenceGroup = apiCC.session.subscribeToPresenceGroup;
        }

        apiCC.session.channel.newSubscribeToPresenceGroup = ["default"];
        apiCC.session.subscribeToPresenceGroup = ["default"];
      }
    }

    apiCC.initApiKey = initParameters.apiKey;
    apiCC.initApiCCId = initParameters.apiCCId;
  }
};



/***/ }),

/***/ "./src/Core/MediaDeviceManager.js":
/*!****************************************!*\
  !*** ./src/Core/MediaDeviceManager.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MediaDeviceManager": () => (/* binding */ MediaDeviceManager)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _public_MediaDevice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../public/MediaDevice */ "./src/public/MediaDevice.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('MediaDeviceManager');
 //import {UserData} from '../public/UserData';


/*
* This is the MediaDeviceManager
*
* @module MediaDeviceManager
*/

var MediaDeviceManager = function MediaDeviceManager() {
  //Default value for device presence are setted to true and will then be
  //setted on enumerateDevice result
  this.audioDevicePresent = true;
  this.videoDevicePresent = true;
  this.audioOutputPresent = true;
  this.mediaSourceInfos = null; //Media device list from WebRTC API

  this.mediaDeviceChangedDetected = false; //MediaDeviceList classified with audioinput, audiooutput, videoinput

  this.mediaDeviceSourceInfosArray = {
    audioinput: {},
    audiooutput: {},
    videoinput: {}
  };
  this.mediaDeviceSourceInfosArrayBeforeGotSources = null;
  this.defaultVideoInput = null;
  this.defaultAudioInput = null;
  this.defaultAudioOuput = null;
  this.realMediaDevicesListInitialization = false; //This is used to indicate if we were able to get the list from browser (Ex : need getUserMedia accept on Safari)

  this.realMediaDevicesListInitializationWasAlreadyDone = false;
  logger.debug('MediaDeviceManager');

  if (navigator.mediaDevices !== null && navigator.mediaDevices !== undefined) {
    navigator.mediaDevices.ondevicechange = function (event) {
      logger.debug("Media device have changed"); //Media device detection

      apiCC.mediaDeviceMgr.getMediaDevices('updatedOnDeviceChange');
    };
  }

  this.gotSources = function (sourceInfos, updateReason) {
    //let actualLogLevel = Logger.getLogLevel();
    //Logger.setLogLevel(10);
    logger.debug('gotSources : sourceInfos :', sourceInfos); //Reinit audioDevicePresent, videoDevicePresent, audioOutputPresent

    apiCC.mediaDeviceMgr.audioDevicePresent = false;
    apiCC.mediaDeviceMgr.videoDevicePresent = false;
    apiCC.mediaDeviceMgr.audioOutputPresent = false;
    var fireMediaChangedEvent = false;
    apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArrayBeforeGotSources = apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArray;
    var devicePresentInfo = {};
    var firstMediaDeviceListInitialization = false;

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.equals)(apiCC.mediaDeviceMgr.mediaSourceInfos, sourceInfos)) {
      logger.debug('MediaDevices change detected');
      fireMediaChangedEvent = true;
    }

    var i,
        sourceInfo = null,
        nbAudio = 0,
        nbVideo = 0,
        nbAudioOut = 0,
        mediaDevice = null; //Reset mediaDeviceSourceInfosArray

    apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArray = {
      audioinput: {},
      audiooutput: {},
      videoinput: {}
    };
    apiCC.mediaDeviceMgr.mediaSourceInfos = sourceInfos;

    if (sourceInfos !== null) {
      for (i = 0; i !== sourceInfos.length; ++i) {
        //logger.trace('i =' + i);
        sourceInfo = sourceInfos[i];

        if (sourceInfo.deviceId !== null && sourceInfo.deviceId !== "") {
          mediaDevice = new _public_MediaDevice__WEBPACK_IMPORTED_MODULE_1__.MediaDevice(sourceInfo.deviceId, sourceInfo.kind);

          if (sourceInfo.label !== null && sourceInfo.label !== undefined) {
            this.realMediaDevicesListInitialization = true;
          }
        } else {
          logger.debug('MediaDevices change but deviceId is not correct, using fakedeviceId :', i);
          mediaDevice = new _public_MediaDevice__WEBPACK_IMPORTED_MODULE_1__.MediaDevice(i, sourceInfo.kind);
        }

        if (sourceInfo.kind === 'audio' || sourceInfo.kind === 'audioinput') {
          if (!apiCC.mediaDeviceMgr.audioDevicePresent) {
            //logger.debug("Audio device present");
            apiCC.mediaDeviceMgr.audioDevicePresent = true;
          }

          mediaDevice.label = sourceInfo.label || 'microphone ' + ++nbAudio;

          if (apiCC.mediaDeviceMgr.defaultAudioInput === null) {
            apiCC.mediaDeviceMgr.defaultAudioInput = mediaDevice;
          }

          if (sourceInfo.getCapabilities !== null && sourceInfo.getCapabilities !== undefined) {
            mediaDevice.capabilities = sourceInfo.getCapabilities();
          } else {
            logger.debug('getCapabilities not defined');
          }
        } else if (sourceInfo.kind === 'video' || sourceInfo.kind === 'videoinput') {
          if (!apiCC.mediaDeviceMgr.videoDevicePresent) {
            //logger.log("Video device present");
            apiCC.mediaDeviceMgr.videoDevicePresent = true;
          }

          mediaDevice.label = sourceInfo.label || 'camera ' + ++nbVideo;

          if (apiCC.mediaDeviceMgr.defaultVideoInput === null) {
            apiCC.mediaDeviceMgr.defaultVideoInput = mediaDevice;
          }

          if (sourceInfo.getCapabilities !== null && sourceInfo.getCapabilities !== undefined) {
            mediaDevice.capabilities = sourceInfo.getCapabilities();
          } else {
            logger.debug('getCapabilities not defined');
          }
        } else if (sourceInfo.kind === 'audiooutput') {
          if (!apiCC.mediaDeviceMgr.audioOutputPresent) {
            //logger.log("Audio output present");
            apiCC.mediaDeviceMgr.audioOutputPresent = true;
          }

          mediaDevice.label = sourceInfo.label || 'audio output ' + ++nbAudioOut;

          if (apiCC.mediaDeviceMgr.defaultAudioOuput === null) {
            apiCC.mediaDeviceMgr.defaultAudioOuput = mediaDevice;
          }
        } else {
          mediaDevice.label = sourceInfo.label || 'other source ' + sourceInfo.deviceId;
          logger.trace('Detected some other kind of source : ' + sourceInfo.kind);
        }

        logger.trace('Local device : ' + mediaDevice.label + ' - ' + mediaDevice.id);

        if (typeof apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArray[mediaDevice.type] === 'undefined') {
          apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArray[mediaDevice.type] = {};
        }

        apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArray[mediaDevice.type][mediaDevice.id] = mediaDevice;
      }
    } else {
      logger.warn("Media detection is not supported by browser, considering micro and camera present"); //Media detection is not supported by browser
      //In this case we suppose that camera and micro are present

      apiCC.mediaDeviceMgr.audioDevicePresent = true;
      apiCC.mediaDeviceMgr.videoDevicePresent = true;
      apiCC.mediaDeviceMgr.audioOutputPresent = true;
    }

    logger.log("Audio device detected :" + apiCC.mediaDeviceMgr.audioDevicePresent);
    logger.log("Video device detected :" + apiCC.mediaDeviceMgr.videoDevicePresent);
    logger.log("audio Output device detected :" + apiCC.mediaDeviceMgr.audioOutputPresent);
    logger.debug("mediaDeviceSourceInfosArray :", apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArray);

    if (apiCC.mediaDeviceMgr.audioDevicePresent === false) {
      if (apiCC.mediaDeviceMgr.videoDevicePresent === false) {
        //NO AUDIO
        //NO VIDEO
        apiCC.myWebRTC_Event.createErrorEvent('Video device is not present', 'NO_AUDIO_NO_VIDEO_DEVICE');
      } else {
        //NO AUDIO
        //BUT VIDEO
        apiCC.myWebRTC_Event.createErrorEvent('Audio device is not present', 'NO_AUDIO_DEVICE');
      }
    } else {
      if (apiCC.mediaDeviceMgr.videoDevicePresent === false) {
        //AUDIO
        //NO VIDEO
        apiCC.myWebRTC_Event.createErrorEvent('Video device is not present', 'NO_VIDEO_DEVICE');
      } //else {
      //AUDIO
      //VIDEO
      //NO error to send
      //}

    }

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.equals)(apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArray, apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArrayBeforeGotSources)) {
      logger.debug('mediaDeviceSourceInfosArray change detected');
      fireMediaChangedEvent = true;
    }

    if (fireMediaChangedEvent === true) {
      logger.debug("fireMediaChangedEvent :", fireMediaChangedEvent);
      var diff = this.getMediaDeviceListsDiff(apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArray, apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArrayBeforeGotSources);

      if (this.realMediaDevicesListInitialization === true && this.realMediaDevicesListInitializationWasAlreadyDone === false) {
        logger.debug("This is the first real initialization of media device list");
        firstMediaDeviceListInitialization = true;
      }

      if (this.realMediaDevicesListInitialization === true) {
        this.realMediaDevicesListInitializationWasAlreadyDone = true;
      }

      this.mediaDeviceChangedDetected = true;

      if (apiCC.myWebRTC_Event !== null) {
        apiCC.myWebRTC_Event.createMediaDeviceChangedEvent(diff, updateReason, firstMediaDeviceListInitialization);
      }

      logger.debug("fireMediaChangedEvent :", apiCC.mediaDeviceMgr.mediaSourceInfos);
    }

    if (apiCC.session && apiCC.session.apiCCWebRTCClient) {
      apiCC.session.apiCCWebRTCClient.webRTCClient.setGumConfigWithDevicePresent(); //Adding device information presence in userData / presence

      devicePresentInfo.audioDevicePresent = apiCC.mediaDeviceMgr.audioDevicePresent;
      devicePresentInfo.videoDevicePresent = apiCC.mediaDeviceMgr.videoDevicePresent;
      apiCC.session.setUserData(devicePresentInfo);
    } //Logger.setLogLevel(actualLogLevel);

  };

  this.getMediaDevices = function (updateReason) {
    logger.debug('MediaDeviceManager::getMediaDevices : updateReason :', updateReason);

    if (apiCC.browser === 'IE' && apiCC.browser_version > 8.0) {
      apiCC.getMediaDevicesWithCB(apiCC.mediaDeviceMgr.gotSources);
    } else {
      //Media device detection
      apiCC.getMediaDevices().then(function (sources) {
        apiCC.mediaDeviceMgr.gotSources(sources, updateReason);
      })["catch"](function () {
        logger.log("Error on MediaDeviceManager::getMediaDevices");
        apiCC.mediaDeviceMgr.gotSources(null, updateReason);
      });
    }
  };

  this.getMediaDeviceListsDiff = function (currentList, oldList) {
    if (oldList === undefined || !oldList) {
      oldList = {};
    }

    if (currentList === undefined || !currentList) {
      currentList = {};
    }

    var addedList = [];
    var removedList = [];
    var updatedList = []; // updatedList included only devices with changed 'label'

    for (var _i = 0, _Object$keys = Object.keys(oldList); _i < _Object$keys.length; _i++) {
      var typeKey = _Object$keys[_i];

      if (currentList[typeKey] === undefined) {
        removedList[typeKey] = oldList[typeKey];
      } else {
        for (var _i2 = 0, _Object$keys2 = Object.keys(oldList[typeKey]); _i2 < _Object$keys2.length; _i2++) {
          var deviceKey = _Object$keys2[_i2];

          if (currentList[typeKey][deviceKey] === undefined) {
            if (removedList[typeKey] === undefined) {
              removedList[typeKey] = {};
            }

            removedList[typeKey][deviceKey] = oldList[typeKey][deviceKey];
          }
        }
      }
    }

    for (var _i3 = 0, _Object$keys3 = Object.keys(currentList); _i3 < _Object$keys3.length; _i3++) {
      var _typeKey = _Object$keys3[_i3];

      for (var _i4 = 0, _Object$keys4 = Object.keys(currentList[_typeKey]); _i4 < _Object$keys4.length; _i4++) {
        var _deviceKey = _Object$keys4[_i4];

        // Added devices
        if (oldList[_typeKey] === undefined || oldList[_typeKey][_deviceKey] === undefined) {
          if (addedList[_typeKey] === undefined) {
            addedList[_typeKey] = {};
          }

          addedList[_typeKey][_deviceKey] = currentList[_typeKey][_deviceKey];
        } // Updated devices (only 'label' is checking)


        if (oldList[_typeKey] !== undefined && oldList[_typeKey][_deviceKey] !== undefined) {
          if (currentList[_typeKey][_deviceKey].label !== oldList[_typeKey][_deviceKey].label) {
            if (updatedList[_typeKey] === undefined) {
              updatedList[_typeKey] = {};
            }

            updatedList[_typeKey][_deviceKey] = currentList[_typeKey][_deviceKey];
          }
        }
      }
    }

    return {
      added: Object.keys(addedList).length > 0 ? addedList : null,
      removed: Object.keys(removedList).length > 0 ? removedList : null,
      updated: Object.keys(updatedList).length > 0 ? updatedList : null
    };
  };
}; //End MediaDeviceManager class




/***/ }),

/***/ "./src/Core/MediaFilter/Filters/MediaFilter.js":
/*!*****************************************************!*\
  !*** ./src/Core/MediaFilter/Filters/MediaFilter.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MediaFilter)
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * @class MediaFilter
 * @description Should be extended with a specific implementation, eg.: MediaFilterBackgroundSubtraction
 */
var MediaFilter = /*#__PURE__*/function () {
  function MediaFilter() {
    _classCallCheck(this, MediaFilter);
  }

  _createClass(MediaFilter, [{
    key: "applyFilter",
    value:
    /**
     * Applies filter to the media stream
     * @param {MediaStream} mediaStream 
     * @param {FilterDescriptor} descriptor 
     */
    function applyFilter(mediaStream, descriptor) {}
  }, {
    key: "release",
    value: function release() {}
  }]);

  return MediaFilter;
}();



/***/ }),

/***/ "./src/Core/MediaFilter/Filters/MediaFilterAIE.js":
/*!********************************************************!*\
  !*** ./src/Core/MediaFilter/Filters/MediaFilterAIE.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MediaFilterAIE)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _ImageProcessing_StreamAIE__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ImageProcessing/StreamAIE */ "./src/Core/MediaFilter/ImageProcessing/StreamAIE.js");
/* harmony import */ var _MediaFilter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MediaFilter */ "./src/Core/MediaFilter/Filters/MediaFilter.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* globals apiCC*/


var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('MediaFilterAIE');

/**
 * @class MediaFilterAIE
 * @description Implements an object detection filter based on a Tensorflow model
 */

var MediaFilterAIE = /*#__PURE__*/function (_MediaFilter) {
  _inherits(MediaFilterAIE, _MediaFilter);

  var _super = _createSuper(MediaFilterAIE);

  function MediaFilterAIE() {
    var _this;

    _classCallCheck(this, MediaFilterAIE);

    _this = _super.call(this);
    _this.userMediaStreamId = null;
    _this.streamAIE = null;
    return _this;
  }

  _createClass(MediaFilterAIE, [{
    key: "applyFilter",
    value: function applyFilter(mediaStream, descriptor) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        logger.debug('Apply filter with descriptor :', descriptor);

        if (descriptor.options === undefined) {
          reject('Filter options object required');
        }

        if (descriptor.options.modelName === undefined) {
          reject('modelName options required');
        } else {
          // Filter's software copies a stream so remove audio tracks to avoid unexpected sound
          // Then return tracks after filtration
          var audioTracks = mediaStream.getAudioTracks();

          if (audioTracks.length > 0) {
            audioTracks.forEach(function (audioTrack) {
              mediaStream.removeTrack(audioTrack);
            });
          }

          _this2.streamAIE = new _ImageProcessing_StreamAIE__WEBPACK_IMPORTED_MODULE_1__.StreamAIE(mediaStream, descriptor.options);

          _this2.streamAIE.loadModel().then(function (processedMediaStream) {
            // Return extracted audio tracks
            audioTracks.forEach(function (audioTrack) {
              processedMediaStream.addTrack(audioTrack);
            });
            resolve(processedMediaStream);
          })["catch"](function (e) {
            reject(e);
          });
        }
      });
    }
  }, {
    key: "release",
    value: function release() {
      this.streamAIE.release();
    }
  }]);

  return MediaFilterAIE;
}(_MediaFilter__WEBPACK_IMPORTED_MODULE_2__["default"]);



/***/ }),

/***/ "./src/Core/MediaFilter/Filters/MediaFilterBackgroundSubstraction.js":
/*!***************************************************************************!*\
  !*** ./src/Core/MediaFilter/Filters/MediaFilterBackgroundSubstraction.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MediaFilterBackgroundSubstraction)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _MediaFilter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MediaFilter */ "./src/Core/MediaFilter/Filters/MediaFilter.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* globals apiCC*/


var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('MediaFilterBackgroundSubstraction');
/**
 * @class MediaFilterBackgroundSubstraction
 * @description Implements an object detection filter based on a Tensorflow model
 */

var MediaFilterBackgroundSubstraction = /*#__PURE__*/function (_MediaFilter) {
  _inherits(MediaFilterBackgroundSubstraction, _MediaFilter);

  var _super = _createSuper(MediaFilterBackgroundSubstraction);

  function MediaFilterBackgroundSubstraction() {
    var _this;

    _classCallCheck(this, MediaFilterBackgroundSubstraction);

    _this = _super.call(this);
    _this.mediaStream = null;
    _this.mediaStreamSettings = null;
    _this.processedMediaStream = null;
    _this.net = null;
    _this.lossRatio = null;
    _this.processBackground = false;
    _this.bgImageData = null;
    _this.videoElement = document.createElement('video');
    _this.canvas = document.createElement('canvas');
    _this.canvasContext = _this.canvas.getContext("2d");
    return _this;
  }

  _createClass(MediaFilterBackgroundSubstraction, [{
    key: "applyFilter",
    value: function applyFilter(mediaStream, descriptor) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        // Filter's software copies a stream so remove audio tracks to avoid unexpected sound
        // Then return tracks after filtration
        var audioTracks = mediaStream.getAudioTracks();

        if (audioTracks.length > 0) {
          audioTracks.forEach(function (audioTrack) {
            mediaStream.removeTrack(audioTrack);
          });
        }

        _this2.loadTensorflow().then(function () {
          _this2.loadTensorflowModel().then(function () {
            _this2.videoElement.srcObject = mediaStream;
            var that = _this2;

            _this2.videoElement.addEventListener('loadeddata', function () {
              that.videoElement.play();
              that.mediaStream = mediaStream;
              that.descriptors = descriptor;
              that.processedMediaStream = that.canvas.captureStream();
              that.mediaStreamSettings = that.mediaStream.getVideoTracks()[0].getSettings();
              that.videoElement.height = 240;
              that.lossRatio = that.mediaStreamSettings.height / that.videoElement.height;
              that.videoElement.width = that.videoElement.height * that.mediaStreamSettings.aspectRatio;

              that.videoElement.onplaying = function () {
                that.canvas.height = that.videoElement.videoHeight;
                that.canvas.width = that.videoElement.videoWidth;
              };

              that.loadBodyPix().then(function () {
                audioTracks.forEach(function (audioTrack) {
                  that.processedMediaStream.addTrack(audioTrack);
                });
                resolve(that.processedMediaStream);
              })["catch"](function (e) {
                logger.error(e);
              });
            });
          })["catch"](function (e) {
            logger.error(e);
          });
        })["catch"](function (e) {
          logger.error(e);
        });
      });
    }
  }, {
    key: "loadTensorflow",
    value: function loadTensorflow() {
      logger.debug('Tensorflow script loading...');
      return new Promise(function (resolve, reject) {
        var args = {
          async: true,
          numRetries: 20,
          reqdelay: 200,
          success: function success() {
            logger.debug('Tensorflow script loaded');
            resolve();
          },
          error: function error(depsNotFound) {
            reject('Resources loading failed, depsNotFound: ' + depsNotFound);
          },
          retrycb: function retrycb(numTries, delayMsec) {
            logger.warn('Tensorflow loading retry :' + numTries + ' ,delay before retry :' + delayMsec);
          }
        };
        apiCC.resourcesLoader.loadjs(['https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.2'], 'tensorflow', args);
      });
    }
  }, {
    key: "loadTensorflowModel",
    value: function loadTensorflowModel() {
      logger.debug('Tensorflow model script loading...');
      return new Promise(function (resolve, reject) {
        var args = {
          async: true,
          numRetries: 20,
          reqdelay: 200,
          success: function success() {
            logger.debug('Tensorflow model script loaded');
            resolve();
          },
          error: function error(depsNotFound) {
            reject('Resources loading failed, depsNotFound: ' + depsNotFound);
          },
          retrycb: function retrycb(numTries, delayMsec) {
            logger.warn('Tensorflow model loading retry :' + numTries + ' ,delay before retry :' + delayMsec);
          }
        };
        apiCC.resourcesLoader.loadjs(['https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0'], 'tensorflow-model', args);
      });
    }
  }, {
    key: "loadBodyPix",
    value: function loadBodyPix() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var options = {
          multiplier: 0.75,
          stride: 32,
          quantBytes: 4
        };
        bodyPix.load(options).then(function (net) {
          _this3.net = net;

          _this3.perform();

          resolve();
        })["catch"](function (err) {
          return reject(err);
        });
      });
    }
  }, {
    key: "perform",
    value: function perform() {
      if (this.descriptors.options !== undefined && this.descriptors.options.backgroundMode !== undefined) {
        this.processBackground = true;

        switch (this.descriptors.options.backgroundMode) {
          case 'blur':
            logger.warn('This method is deprecated, please use Stream#blur method now.');
            this.videoElement.height = this.mediaStreamSettings.height;
            this.videoElement.width = this.mediaStreamSettings.width;
            this.canvas.height = this.videoElement.height;
            this.canvas.width = this.videoElement.width;
            this.blurBackground();
            break;

          case 'transparent':
            this.noBackground();
            break;

          case 'image':
            if (this.descriptors.options.image !== undefined) {
              this.resizeImageData(this.descriptors.options.image);
              this.imageBackground();
            } else {
              logger.error('image option is required when creating the filter');
            }

            break;

          default:
            logger.debug('The backgroundMode : ', this.descriptors.options.backgroundMode, ' is not implemented. Refer to documentation for accepted values.');
            this.blurBackground();
            break;
        }
      } else {
        logger.error('backgroundMode option is required');
      }
    }
  }, {
    key: "blurBackground",
    value: function blurBackground() {
      var _this4 = this;

      this.net.segmentPerson(this.videoElement).then(function (segmentation) {
        _this4.blurBackground();

        var backgroundBlurAmount = 9;
        var edgeBlurAmount = 2;
        var flipHorizontal = false;
        bodyPix.drawBokehEffect(_this4.canvas, _this4.videoElement, segmentation, backgroundBlurAmount, edgeBlurAmount, flipHorizontal);
      });
    }
  }, {
    key: "noBackground",
    value: function noBackground() {
      var _this5 = this;

      this.net.segmentPerson(this.videoElement).then(function (segmentation) {
        _this5.canvasContext.drawImage(_this5.videoElement, 0, 0, _this5.videoElement.width, _this5.videoElement.height);

        var imageData = _this5.canvasContext.getImageData(0, 0, _this5.videoElement.width, _this5.videoElement.height);

        var pixel = imageData.data;

        for (var p = 0; p < pixel.length; p += 4) {
          if (segmentation.data[p / 4] === 0) {
            pixel[p + 3] = 0;
          }
        }

        var scaledImageData = _this5.scaleImageData(imageData, _this5.lossRatio);

        _this5.canvasContext.imageSmoothingEnabled = true;

        _this5.canvasContext.putImageData(scaledImageData, 0, 0);

        if (_this5.processBackground) {
          _this5.noBackground();
        }
      });
    }
  }, {
    key: "imageBackground",
    value: function imageBackground() {
      var _this6 = this;

      this.net.segmentPerson(this.videoElement).then(function (segmentation) {
        _this6.canvasContext.putImageData(_this6.bgImageData, 0, 0, 0, 0, _this6.videoElement.width, _this6.videoElement.height);

        var bgImageData = _this6.canvasContext.getImageData(0, 0, _this6.videoElement.width, _this6.videoElement.height);

        _this6.canvasContext.drawImage(_this6.videoElement, 0, 0, _this6.videoElement.width, _this6.videoElement.height);

        var imageData = _this6.canvasContext.getImageData(0, 0, _this6.videoElement.width, _this6.videoElement.height);

        var pixel = imageData.data;

        for (var p = 0; p < pixel.length; p += 4) {
          if (segmentation.data[p / 4] === 0) {
            pixel[p] = bgImageData.data[p];
            pixel[p + 1] = bgImageData.data[p + 1];
            pixel[p + 2] = bgImageData.data[p + 2];
            pixel[p + 3] = bgImageData.data[p + 3];
          }
        }

        var scaledImageData = _this6.scaleImageData(imageData, _this6.lossRatio);

        _this6.canvasContext.imageSmoothingEnabled = true;

        _this6.canvasContext.putImageData(scaledImageData, 0, 0);

        if (_this6.processBackground) {
          _this6.imageBackground();
        }
      });
    }
  }, {
    key: "resizeImageData",
    value: function resizeImageData(imageData) {
      var wRatio = this.videoElement.width / imageData.width;
      var hRatio = this.videoElement.height / imageData.height;

      if (wRatio >= hRatio) {
        this.bgImageData = this.scaleImageData(imageData, wRatio);
      } else {
        this.bgImageData = this.scaleImageData(imageData, hRatio);
      }
    }
    /**
     * This method removes the background and apply the filter on the original resolution, not on a reduced one.
     * This method is unused for the moment.
     */

  }, {
    key: "noBackgroundWithFullResolution",
    value: function noBackgroundWithFullResolution() {
      var _this7 = this;

      this.net.segmentPerson(this.videoElement).then(function (segmentation) {
        _this7.canvasContext.drawImage(_this7.videoElement, 0, 0, _this7.canvas.width, _this7.canvas.height);

        var originalImageData = _this7.canvasContext.getImageData(0, 0, _this7.canvas.width, _this7.canvas.height);

        var k = new Uint8ClampedArray(4 * segmentation.width * segmentation.height);

        for (var p = 0; p < k.length; p += 4) {
          if (segmentation.data[p / 4] !== 0) {
            k[p + 3] = 255;
          }
        }

        var imageData = new ImageData(k, segmentation.width, segmentation.height);
        imageData = _this7.scaleImageData(imageData, _this7.lossRatio);

        for (var _p = 0; _p < originalImageData.data.length; _p += 4) {
          if (imageData.data[_p + 3] === 0) {
            originalImageData.data[_p + 3] = 0;
          }
        }

        _this7.canvasContext.imageSmoothingEnabled = true;

        _this7.canvasContext.putImageData(originalImageData, 0, 0);

        if (_this7.processBackground) {
          _this7.noBackgroundWithFullResolution();
        }
      });
    }
  }, {
    key: "scaleImageData",
    value: function scaleImageData(imageData, scale) {
      var newCanvas = document.createElement("canvas");
      newCanvas.width = imageData.width;
      newCanvas.height = imageData.height;
      newCanvas.getContext("2d").putImageData(imageData, 0, 0); // Second canvas, for scaling

      var scaleCanvas = document.createElement("canvas");
      scaleCanvas.width = this.canvas.width;
      scaleCanvas.height = this.canvas.height;
      var scaleCtx = scaleCanvas.getContext("2d");
      scaleCtx.scale(scale, scale);
      scaleCtx.drawImage(newCanvas, 0, 0);
      var scaledImageData = scaleCtx.getImageData(0, 0, scaleCanvas.width, scaleCanvas.height);
      return scaledImageData;
    }
  }, {
    key: "release",
    value: function release() {
      this.processedMediaStream = this.mediaStream;
      this.processBackground = false;
    }
  }]);

  return MediaFilterBackgroundSubstraction;
}(_MediaFilter__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/Core/MediaFilter/Filters/OldMediaFilterBackgroundSubtraction.js":
/*!*****************************************************************************!*\
  !*** ./src/Core/MediaFilter/Filters/OldMediaFilterBackgroundSubtraction.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OldMediaFilterBackgroundSubtraction)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _MediaFilter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MediaFilter */ "./src/Core/MediaFilter/Filters/MediaFilter.js");
/* harmony import */ var _ImageProcessing_StreamSegmentation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ImageProcessing/StreamSegmentation */ "./src/Core/MediaFilter/ImageProcessing/StreamSegmentation.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('OldMediaFilterBackgroundSubtraction');


/**
 * @class OldMediaFilterBackgroundSubtraction
 * @description Implements background subtraction algorithm base on Tensorflow model
 */

var OldMediaFilterBackgroundSubtraction = /*#__PURE__*/function (_MediaFilter) {
  _inherits(OldMediaFilterBackgroundSubtraction, _MediaFilter);

  var _super = _createSuper(OldMediaFilterBackgroundSubtraction);

  function OldMediaFilterBackgroundSubtraction() {
    var _this;

    _classCallCheck(this, OldMediaFilterBackgroundSubtraction);

    _this = _super.call(this);
    _this.streamSegmentation = null;
    _this.userMediaStreamId = null;
    return _this;
  }

  _createClass(OldMediaFilterBackgroundSubtraction, [{
    key: "applyFilter",
    value: function applyFilter(mediaStream, descriptor) {
      var _this2 = this;

      logger.debug('Apply filter with descriptor:', descriptor); // Filter's software copies a stream so remove audio tracks to avoid unexpected sound
      // Then return tracks after filtration

      var audioTracks = mediaStream.getAudioTracks();

      if (audioTracks.length > 0) {
        audioTracks.forEach(function (audioTrack) {
          mediaStream.removeTrack(audioTrack);
        });
      }

      var videoTracks = mediaStream.getVideoTracks();

      if (videoTracks.length === 0) {
        return Promise.reject('MediaStream has no video tracks');
      }

      var mediaSettings = videoTracks[0].getSettings();

      if (descriptor.options !== undefined && descriptor.options.userMediaStreamId !== undefined) {
        this.userMediaStreamId = descriptor.options.userMediaStreamId;
      }

      this.streamSegmentation = new _ImageProcessing_StreamSegmentation__WEBPACK_IMPORTED_MODULE_2__.StreamSegmentation(mediaStream, mediaSettings.width, mediaSettings.height, this.userMediaStreamId);
      return this.loadTensorflow().then(function (_) {
        return _this2.loadTensorflowModel();
      }).then(function (_) {
        return new Promise(function (resolve, _) {
          logger.debug('Model loading...');

          _this2.streamSegmentation.loadModel().then(function (_) {
            logger.debug('Model loaded');
            var backgroundMode = null;

            if (descriptor.options !== undefined && descriptor.options.backgroundMode !== undefined) {
              if (descriptor.options.backgroundMode === 'image' && descriptor.options.image instanceof ImageData) {
                _this2.streamSegmentation.setBackgroundImage(descriptor.options.image);
              }

              backgroundMode = descriptor.options.backgroundMode;
            }

            var mediaStream = _this2.streamSegmentation.activateBackgroundSubtraction(backgroundMode); // Return extracted audio tracks


            audioTracks.forEach(function (audioTrack) {
              mediaStream.addTrack(audioTrack);
            });
            resolve(mediaStream);
          });
        });
      })["catch"](function (err) {
        return Promise.reject(err);
      });
    }
  }, {
    key: "release",
    value: function release() {
      this.streamSegmentation.deactivateBackgroundSubtraction();
      this.streamSegmentation = null;
    }
  }, {
    key: "loadTensorflow",
    value: function loadTensorflow() {
      logger.debug('Tensorflow script loading...');
      return new Promise(function (resolve, reject) {
        var args = {
          async: true,
          numRetries: 20,
          reqdelay: 200,
          success: function success() {
            logger.debug('Tensorflow script loaded');
            resolve();
          },
          error: function error(depsNotFound) {
            reject('Resources loading failed, depsNotFound: ' + depsNotFound);
          },
          retrycb: function retrycb(numTries, delayMsec) {
            logger.warn('Tensorflow loading retry :' + numTries + ' ,delay before retry :' + delayMsec);
          }
        };
        apiCC.resourcesLoader.loadjs(['https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.2'], 'tensorflow', args);
      });
    }
  }, {
    key: "loadTensorflowModel",
    value: function loadTensorflowModel() {
      logger.debug('Tensorflow model script loading...');
      return new Promise(function (resolve, reject) {
        var args = {
          async: true,
          numRetries: 20,
          reqdelay: 200,
          success: function success() {
            logger.debug('Tensorflow model script loaded');
            resolve();
          },
          error: function error(depsNotFound) {
            reject('Resources loading failed, depsNotFound: ' + depsNotFound);
          },
          retrycb: function retrycb(numTries, delayMsec) {
            logger.warn('Tensorflow model loading retry :' + numTries + ' ,delay before retry :' + delayMsec);
          }
        };
        apiCC.resourcesLoader.loadjs(['https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0'], 'tensorflow-model', args);
      });
    }
  }]);

  return OldMediaFilterBackgroundSubtraction;
}(_MediaFilter__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/Core/MediaFilter/ImageProcessing/BackgroundSubtractor.js":
/*!**********************************************************************!*\
  !*** ./src/Core/MediaFilter/ImageProcessing/BackgroundSubtractor.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BackgroundSubtractor": () => (/* binding */ BackgroundSubtractor)
/* harmony export */ });
/* harmony import */ var _ImageProcessing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageProcessing */ "./src/Core/MediaFilter/ImageProcessing/ImageProcessing.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/***********************************************************************
 * Filename : backgroundSubtraction.js
 * Description : applies a background subraction method using the BodyPix
 * pre trained Segmentation Module: https://github.com/tensorflow/tfjs-models/tree/master/body-pix
 * Author : Brieg L'Hostis <brieg.lhostis1@gmail.com>
 * Copyright Apizee 2018 - All rights reserved
 ************************************************************************/

/**
 *@class BackgroundSubtractor
 *@description Computes the mask identifying the foreground in an image provided an image of the background and applies this mask to set the background as transparent.
 */

var BackgroundSubtractor = /*#__PURE__*/function () {
  /**
   *@method constructor
   *@description Initializes the object with the parameters of the mask filters.
   *param {bool} blurMask: true to blur the borders of the mask to avoid small artefacts.
   *param {bool} smoothBorder: true to get a mask with a smooth border if the mask was blurred (i.e. blurMask is true), else the mask will have a hard border.
   *param {int} blurFactor: if the mask needs to be blurred (i.e. blurMask is true) then the number of pixels defining the blur, else does not have any effect.
   *param {positive float} smoothingFactor: if the mask needs to be blurred and its border smoothed (i.e. blurMask and smoothBorder are true) then the parameter indicating the distance to the border of the value 128 (0 for as if blurMask is false and +infinity for an infinite border) 1 is recommended. For best efficiency, set to -1, but no filter will be applied.
   */
  function BackgroundSubtractor() {
    var blurMask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var smoothBorder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    var blurFactor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
    var smoothingFactor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    _classCallCheck(this, BackgroundSubtractor);

    this.blurMask = blurMask;
    this.smoothBorder = smoothBorder;
    this.blurFactor = blurFactor;
    this.smoothingFactor = smoothingFactor;
    this.maskImage = null;
    this.net = null;
  }
  /**
   *@method loadModel
   *@description Loads the Segmentation model
   */


  _createClass(BackgroundSubtractor, [{
    key: "loadModel",
    value: function loadModel() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        bodyPix.load({
          architecture: 'MobileNetV1',
          // Could be 'ResNet50' but too slow for real-time
          outputStride: 16,
          // To choose among 8, 16 (for MobileNetV1); 8 is slower but more accurate
          multiplier: 0.75,
          // To choose among 1, 0.75, 0.5; 1 is slower but more accurate
          quantBytes: 2 // To choose among 1, 2, 4; 4 is slower but more accurate

        }).then(function (net) {
          _this.net = net;
          resolve();
        });
      });
    }
    /**
     *@method computeMask
     *@description Computes the image of the mask that gives the delimitations between foreground and background in the image.
     *param {ImageData} frame: the ImageData defining the current frame.
     *return {ImageData} this.maskImage: the ImageData defining the mask, the pixels are black where the background was identified and white elsewhere.
     */

  }, {
    key: "computeMask",
    value: function computeMask(frame) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        _this2.net.segmentPerson(frame).then(function (segmentation) {
          _this2.width = segmentation.width;
          _this2.height = segmentation.height;
          _this2.length = _this2.width * _this2.height;
          var maskData = new Uint8ClampedArray(_this2.length * 4);

          for (var i = 0; i < _this2.length; i++) {
            var maskPixel = segmentation.data[i] * 255;
            maskData[i * 4 + 0] = maskPixel; // 255: White pixel, 0: Black pixel.

            maskData[i * 4 + 1] = maskPixel;
            maskData[i * 4 + 2] = maskPixel;
            maskData[i * 4 + 3] = 255; // Alpha (transparency) channel is set to 255 to make the mask opaque.
          } // Translate the mask data into an image of the mask.


          var canvas = document.createElement('canvas');
          var ctx = canvas.getContext('2d');
          canvas.width = _this2.width;
          canvas.height = _this2.height;
          var maskImage = new ImageData(maskData, _this2.width, _this2.height);
          ctx.putImageData(maskImage, 0, 0); // Blur the mask to remove the small artefacts (i.e. the small "islands" of white or black) from the mask.

          if (_this2.blurMask) {
            ctx.filter = 'blur(' + _this2.blurFactor + 'px)';
          }

          ctx.drawImage(canvas, 0, 0, _this2.width, _this2.height);
          _this2.maskImage = ctx.getImageData(0, 0, _this2.width, _this2.height); // If the mask was blurred and the border needs to be sharp then apply a treshold to the mask to keep a black or white image.

          if (_this2.blurMask) {
            if (_this2.smoothBorder) {
              if (_this2.smoothingFactor !== -1) {
                // If the mask was blurred and the border needs to be smooth then apply a sigmoid filter.
                var maskProcessing = new _ImageProcessing__WEBPACK_IMPORTED_MODULE_0__.ImageProcessing(_this2.maskImage, _this2.width, _this2.height);
                _this2.maskImage = maskProcessing.sigmoidFilter(_this2.smoothingFactor);
              }
            } else {
              // If the mask was blurred and the border needs to be sharp then apply a treshold to the mask to keep a black or white image.
              var _maskProcessing = new _ImageProcessing__WEBPACK_IMPORTED_MODULE_0__.ImageProcessing(_this2.maskImage, _this2.width, _this2.height);

              _this2.maskImage = _maskProcessing.threshold(40, 40, 40, 255, false);
            }
          }

          resolve(_this2.maskImage);
        });
      });
    }
    /**
     *@method applyTransparency
     *@description Applies the mask computed by the computeMask method to set the background of the current frame as transparent.
     *param {ImageData} frame: the ImageData defining the current frame.
     *return {ImageData} newImage: the ImageData defining the resulting frame where the background is transparent (channel alpha set as 0).
     */

  }, {
    key: "applyTransparency",
    value: function applyTransparency(frame) {
      var maskImage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (maskImage === null) {
        maskImage = this.maskImage;
      }

      var newImageData = new Uint8ClampedArray(frame.width * frame.height * 4);

      for (var i = 0; i < frame.width * frame.height; i++) {
        newImageData[i * 4 + 0] = frame.data[i * 4 + 0];
        newImageData[i * 4 + 1] = frame.data[i * 4 + 1];
        newImageData[i * 4 + 2] = frame.data[i * 4 + 2];
        newImageData[i * 4 + 3] = maskImage.data[i * 4]; // 0 => transparent, 255 => opaque
      }

      var newImage = new ImageData(newImageData, frame.width, frame.height);
      return newImage;
    }
    /**
     *@method superposeImages
     *@description Use the mask computed by the method computeMask to superpose a foreground over a background.
     *param {ImageData} frame: the ImageData defining the current frame.
     *param {ImageData} foreground: the ImageData defining the foreground.
     *param {ImageData} background: the ImageData defining the background.
     *return {ImageData} superposition: the ImageData defining the resulting image, superposition of the foreground over the background.
     */

  }, {
    key: "superposeImages",
    value: function superposeImages(frame, foreground, background) {
      var maskImage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      if (maskImage === null) {
        maskImage = this.maskImage;
      }

      var superpositionProcessing = new _ImageProcessing__WEBPACK_IMPORTED_MODULE_0__.ImageProcessing(foreground, frame.width, frame.height);
      var superposition = superpositionProcessing.weightedSumMask(background, maskImage);
      return superposition;
    }
    /**
     *@method superposeImages
     *@description Use the method superposeImages to set a background behind the current frame.
     *param {ImageData} frame: the ImageData defining the current frame.
     *param {ImageData} background: the ImageData defining the background.
     *return {ImageData}: the ImageData defining the resulting image, superposition of the current frame over the background.
     */

  }, {
    key: "setBackground",
    value: function setBackground(frame, background) {
      var maskImage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      return this.superposeImages(frame, frame, background, maskImage);
    }
    /**
     *@method blurBackground
     *@description Use the method setBackground to blur the background of the current frame.
     *param {ImageData} frame: the ImageData defining the current frame.
     *param {int} backgroundBlurFactor: the number of pixels defining the blur.
     *return {ImageData}: the ImageData defining current frame with its background blurred.
     */

  }, {
    key: "blurBackground",
    value: function blurBackground(frame) {
      var backgroundBlurFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
      var maskImage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var backgroundProcessing = new _ImageProcessing__WEBPACK_IMPORTED_MODULE_0__.ImageProcessing(frame, frame.width, frame.height);
      var background = backgroundProcessing.blur(backgroundBlurFactor);
      return this.setBackground(frame, background, maskImage);
    }
  }]);

  return BackgroundSubtractor;
}();

/***/ }),

/***/ "./src/Core/MediaFilter/ImageProcessing/ImageProcessing.js":
/*!*****************************************************************!*\
  !*** ./src/Core/MediaFilter/ImageProcessing/ImageProcessing.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageProcessing": () => (/* binding */ ImageProcessing)
/* harmony export */ });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/* globals OffscreenCanvas */

/***********************************************************************
* Filename : imageProcessing.js
* Description : Compute a collection of basic operations on images.
* Author : Brieg L'Hostis <brieg.lhostis1@gmail.com>
* Copyright Apizee 2018 - All rights reserved
************************************************************************/
// The homomorphic filter extends the image channels before processing it since the camera's natural reaction to light
// is naturally a compression (and thus not linear).
// See https://en.wikipedia.org/wiki/Homomorphic_filtering for further explainations.
// Compute the hyperbolic tangent of x.
function tanH(x) {
  var expX = Math.exp(x);
  var expMinusX = Math.exp(-x);
  return (expX - expMinusX) / (expX + expMinusX);
} // Apply a sigmoid filter to the pixel x, see https://en.wikipedia.org/wiki/Sigmoid_function .


function sigmoidRaw(x, gamma) {
  var tanX = Math.tan((x / 255 - 0.5) * Math.PI * 0.9999);
  var sigmoidX = (tanH(tanX) + 1) / 2;
  return Math.pow(sigmoidX, gamma) * 255;
} // Apply an approximation of the sigmoid computed by the function sigmoidRaw to the pixel x.
// Note: This version is actualy less efficient than the sigmoid function.


function sigmoidSwith(x, gamma) {
  var sigmoidX;
  x = x / 255;

  switch (Math.floor(x * 10)) {
    case 0:
      sigmoidX = 0.001857 / 0.09804 * x;
      break;

    case 1:
      sigmoidX = 0.05807 / 0.10196 * (x - 0.09804) + 0.001857;
      break;

    case 2:
      sigmoidX = 0.1267 / 0.09804 * (x - 0.2) + 0.05993;
      break;

    case 3:
      sigmoidX = 0.1564 / 0.10196 * (x - 0.2980) + 0.1866;
      break;

    case 4:
      sigmoidX = 0.1539 / 0.09804 * (x - 0.4) + 0.3430;
      break;

    case 5:
      sigmoidX = 0.1601 / 0.10196 * (x - 0.4980) + 0.4969;
      break;

    case 6:
      sigmoidX = 0.1506 / 0.09804 * (x - 0.6) + 0.6570;
      break;

    case 7:
      sigmoidX = 0.1325 / 0.10196 * (x - 0.6980) + 0.8076;
      break;

    case 8:
      sigmoidX = 0.05753 / 0.09804 * (x - 0.8) + 0.9401;
      break;

    case 9:
      sigmoidX = 0.002403 / 0.10196 * (x - 0.8980) + 0.9976;
      break;

    case 10:
      sigmoidX = 1;
      break;

    default:
      sigmoidX = 0;
  }

  return Math.pow(sigmoidX, gamma) * 255;
} // Apply an approximation of the sigmoid computed by the function sigmoidRaw to the pixel x.


function sigmoid(x, gamma) {
  var sigmoidX;
  x = x / 255;

  if (x < 0.09804) {
    sigmoidX = 0.001857 / 0.09804 * x;
  } else if (x < 0.2) {
    sigmoidX = 0.05807 / 0.10196 * (x - 0.09804) + 0.001857;
  } else if (x < 0.2980) {
    sigmoidX = 0.1267 / 0.09804 * (x - 0.2) + 0.05993;
  } else if (x < 0.4) {
    sigmoidX = 0.1564 / 0.10196 * (x - 0.2980) + 0.1866;
  } else if (x < 0.4980) {
    sigmoidX = 0.1539 / 0.09804 * (x - 0.4) + 0.3430;
  } else if (x < 0.6) {
    sigmoidX = 0.1601 / 0.10196 * (x - 0.4980) + 0.4969;
  } else if (x < 0.6980) {
    sigmoidX = 0.1506 / 0.09804 * (x - 0.6) + 0.6570;
  } else if (x < 0.8) {
    sigmoidX = 0.1325 / 0.10196 * (x - 0.6980) + 0.8076;
  } else if (x < 0.8980) {
    sigmoidX = 0.05753 / 0.09804 * (x - 0.8) + 0.9401;
  } else {
    sigmoidX = 0.002403 / 0.10196 * (x - 0.8980) + 0.9976;
  }

  return Math.pow(sigmoidX, gamma) * 255;
} // Raise the scaled pixel value of x to the power gamma.


function powerGamma(x, gamma) {
  return Math.pow(x / 255, gamma) * 255;
}

var ImageProcessing = /*#__PURE__*/function () {
  /**
  *@method constructor
  *@description Initializes the object with the image data and the width and length of the image.
  *param {ImageData} image: the ImageData object defining the image.
  *param {int} width: width of the image.
  *param {int} heigth: height of the image.
  */
  function ImageProcessing(image, width, height) {
    _classCallCheck(this, ImageProcessing);

    this.image = image;
    this.width = width;
    this.height = height;
    this.length = this.width * this.height;
  }
  /**
  *@method mean
  *@description Computes the mean values of the image on all three channels (RGB).
  *param {bool} homomorphicFilter: true to apply an homomorphic filter to the image before processing it (see commentary at the beginnig of this file).
  *return {float} this.meanR: the mean value of the red channel.
  *return {float} this.meanG: the mean value of the green channel.
  *return {float} this.meanB: the mean value of the blue channel.
  */


  _createClass(ImageProcessing, [{
    key: "mean",
    value: function mean() {
      var homomorphicFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var meanR = 0,
          meanG = 0,
          meanB = 0;

      if (homomorphicFilter) {
        for (var i = 0; i < this.length; i++) {
          meanR += Math.pow(this.image.data[i * 4 + 0], 2) / (this.length * 255);
          meanG += Math.pow(this.image.data[i * 4 + 1], 2) / (this.length * 255);
          meanB += Math.pow(this.image.data[i * 4 + 2], 2) / (this.length * 255);
        }
      } else {
        for (var _i = 0; _i < this.length; _i++) {
          meanR += this.image.data[_i * 4 + 0] / this.length;
          meanG += this.image.data[_i * 4 + 1] / this.length;
          meanB += this.image.data[_i * 4 + 2] / this.length;
        }
      }

      return [meanR, meanG, meanB];
    }
    /**
    *@method mad
    *@description Computes the Mean Absolute Deviation (MAD) values of the image on all three channels (RGB).
    *param {bool} homomorphicFilter: true to apply an homomorphic filter to the image before processing it (see commentary at the beginnig of this file).
    *return {float} this.madR: the MAD value of the red channel.
    *return {float} this.madG: the MAD value of the green channel.
    *return {float} this.madB: the MAD value of the blue channel.
    */

  }, {
    key: "mad",
    value: function mad() {
      var homomorphicFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var _this$mean = this.mean(homomorphicFilter),
          _this$mean2 = _slicedToArray(_this$mean, 3),
          meanR = _this$mean2[0],
          meanG = _this$mean2[1],
          meanB = _this$mean2[2];

      var madR = 0,
          madG = 0,
          madB = 0;

      if (homomorphicFilter) {
        for (var i = 0; i < this.length; i++) {
          madR += Math.abs(Math.pow(this.image.data[i * 4 + 0], 2) / 255 - meanR) / this.length;
          madG += Math.abs(Math.pow(this.image.data[i * 4 + 1], 2) / 255 - meanG) / this.length;
          madB += Math.abs(Math.pow(this.image.data[i * 4 + 2], 2) / 255 - meanB) / this.length;
        }
      } else {
        for (var _i2 = 0; _i2 < this.length; _i2++) {
          madR += Math.abs(this.image.data[_i2 * 4 + 0] - meanR) / this.length;
          madG += Math.abs(this.image.data[_i2 * 4 + 1] - meanG) / this.length;
          madB += Math.abs(this.image.data[_i2 * 4 + 2] - meanB) / this.length;
        }
      }

      return [madR, madG, madB];
    }
    /**
    *@method std
    *@description Computes the Standard Deviation values of the image on all three channels (RGB).
    *param {bool} homomorphicFilter: true to apply an homomorphic filter to the image before processing it (see commentary at the beginnig of this file).
    *return {float} this.stdR: the Standard Deviation value of the red channel.
    *return {float} this.stdG: the Standard Deviation value of the green channel.
    *return {float} this.stdB: the Standard Deviation value of the blue channel.
    */

  }, {
    key: "std",
    value: function std() {
      var homomorphicFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var _this$mean3 = this.mean(homomorphicFilter),
          _this$mean4 = _slicedToArray(_this$mean3, 3),
          meanR = _this$mean4[0],
          meanG = _this$mean4[1],
          meanB = _this$mean4[2];

      var stdR = 0,
          stdG = 0,
          stdB = 0;

      if (homomorphicFilter) {
        for (var i = 0; i < this.length; i++) {
          stdR += Math.pow(Math.pow(this.image.data[i * 4 + 0], 2) / 255 - meanR, 2) / this.length;
          stdG += Math.pow(Math.pow(this.image.data[i * 4 + 1], 2) / 255 - meanG, 2) / this.length;
          stdB += Math.pow(Math.pow(this.image.data[i * 4 + 2], 2) / 255 - meanB, 2) / this.length;
        }
      } else {
        for (var _i3 = 0; _i3 < this.length; _i3++) {
          stdR += Math.pow(this.image.data[_i3 * 4 + 0] - meanR, 2) / this.length;
          stdG += Math.pow(this.image.data[_i3 * 4 + 1] - meanG, 2) / this.length;
          stdB += Math.pow(this.image.data[_i3 * 4 + 2] - meanB, 2) / this.length;
        }
      }

      stdR = Math.sqrt(stdR);
      stdG = Math.sqrt(stdG);
      stdB = Math.sqrt(stdB);
      return [stdR, stdG, stdB];
    }
    /**
    *@method blur
    *@description Apply a blur on the image.
    *param {int} blurFactor: the number of pixels defining the blur.
    *return {ImageData} blurredImage: the ImageData object defining the blurred image.
    */

  }, {
    key: "blur",
    value: function blur() {
      var blurFactor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
      var canvas = new OffscreenCanvas(this.width, this.height);
      var ctx = canvas.getContext('2d');
      canvas.width = this.width;
      canvas.height = this.height;
      ctx.putImageData(this.image, 0, 0);
      ctx.filter = 'blur(' + blurFactor + 'px)';
      ctx.drawImage(canvas, 0, 0);
      var blurredImage = ctx.getImageData(0, 0, this.width, this.height);
      return blurredImage;
    }
    /**
    *@method threshold
    *@description Apply a threshold on all three RGB channels of the image.
    *param {float} thresholdR: the threshold to apply on the red channel.
    *param {float} thresholdG: the threshold to apply on the green channel.
    *param {float} thresholdB: the threshold to apply on the blue channel.
    *param {float} maxValue: the maximum value of the resulting image.
    *param {bool} inverseThreshold: if true, then the threshold will set the pixels over the thresholds as 0, else the pixels under the threholds are set as 0.
    *return {ImageData} thresholdedImage: the ImageData object defining the resulting image.
    */

  }, {
    key: "threshold",
    value: function threshold(thresholdR, thresholdG, thresholdB) {
      var maxValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 255;
      var inverseThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var thresholdedImage = new ImageData(this.image.data, this.width, this.height);
      var minValue = 0;

      if (inverseThreshold) {
        var tmpValue = minValue;
        minValue = maxValue;
        maxValue = tmpValue;
      }

      for (var i = 0; i < this.length; i++) {
        if (this.image.data[i * 4 + 0] < thresholdR) {
          thresholdedImage.data[i * 4 + 0] = minValue;
        } else {
          thresholdedImage.data[i * 4 + 0] = maxValue;
        }

        if (this.image.data[i * 4 + 1] < thresholdG) {
          thresholdedImage.data[i * 4 + 1] = minValue;
        } else {
          thresholdedImage.data[i * 4 + 1] = maxValue;
        }

        if (this.image.data[i * 4 + 2] < thresholdB) {
          thresholdedImage.data[i * 4 + 2] = minValue;
        } else {
          thresholdedImage.data[i * 4 + 2] = maxValue;
        }
      }

      return thresholdedImage;
    }
    /**
    *@method powerFilter
    *@description Raise the scaled pixel values in the image to the power gamma to compress or extend the image.
    *param {float} gamma: power to raise the pixel values.
    *return {ImageData} filteredImage: the ImageData object defining the compressed or extended image.
    */

  }, {
    key: "powerFilter",
    value: function powerFilter(gamma) {
      var filteredImageData = new Uint8ClampedArray(this.length * 4);

      if (gamma === 1) {
        return this.image;
      }

      for (var i = 0; i < this.length; i++) {
        filteredImageData[i * 4 + 0] = powerGamma(this.image.data[i * 4 + 0], gamma);
        filteredImageData[i * 4 + 1] = powerGamma(this.image.data[i * 4 + 1], gamma);
        filteredImageData[i * 4 + 2] = powerGamma(this.image.data[i * 4 + 2], gamma);
        filteredImageData[i * 4 + 3] = 255;
      }

      var filteredImage = new ImageData(filteredImageData, this.width, this.height);
      return filteredImage;
    }
    /**
    *@method sigmoidFilter
    *@description Apply a sigmoid filter to pixels in the image (see the sigmoidRaw function to see the function applied).
    *param {float} gamma: power to raise the pixel values after the sigmoid filter to extended or compress the filtered image.
    *return {ImageData} filteredImage: the ImageData object defining the filtered image.
    */

  }, {
    key: "sigmoidFilter",
    value: function sigmoidFilter(gamma) {
      var filteredImageData = new Uint8ClampedArray(this.length * 4);

      for (var i = 0; i < this.length; i++) {
        filteredImageData[i * 4 + 0] = sigmoid(this.image.data[i * 4 + 0], gamma);
        filteredImageData[i * 4 + 1] = sigmoid(this.image.data[i * 4 + 1], gamma);
        filteredImageData[i * 4 + 2] = sigmoid(this.image.data[i * 4 + 2], gamma);
        filteredImageData[i * 4 + 3] = 255;
      }

      var filteredImage = new ImageData(filteredImageData, this.width, this.height);
      return filteredImage;
    }
    /**
    *@method weightedSum
    *@description Computes the weighted sum of this.image and an other image: resultImage = alpha * this.image + (1-alpha) * otherImage.
    *param {ImageData} otherImage: the other image to add to the image in this.image.
    *param {float between 0 and 1} alpha: weight in the sum.
    *return {ImageData} sumImage: the ImageData object defining the resulting image.
    */

  }, {
    key: "weightedSum",
    value: function weightedSum(otherImage, alpha) {
      var sumImageData = new Uint8ClampedArray(this.length * 4);

      for (var i = 0; i < this.length; i++) {
        sumImageData[i * 4 + 0] = alpha * this.image.data[i * 4 + 0] + (1 - alpha) * otherImage.data[i * 4 + 0];
        sumImageData[i * 4 + 1] = alpha * this.image.data[i * 4 + 1] + (1 - alpha) * otherImage.data[i * 4 + 1];
        sumImageData[i * 4 + 2] = alpha * this.image.data[i * 4 + 2] + (1 - alpha) * otherImage.data[i * 4 + 2];
        sumImageData[i * 4 + 3] = 255;
      }

      var sumImage = new ImageData(sumImageData, this.width, this.height);
      return sumImage;
    }
    /**
    *@method weightedSumMask
    *@description Computes the weighted sum of this.image and an other image with a mask image as weights.
    *param {ImageData} otherImage: the other image to add to the image in this.image.
    *param {ImageData} maskImage: image defining the weights in the sum: weight = maskImage/255.
    *return {ImageData} sumImage: the ImageData object defining the resulting image.
    */

  }, {
    key: "weightedSumMask",
    value: function weightedSumMask(otherImage, maskImage) {
      var sumImageData = new Uint8ClampedArray(this.length * 4);

      for (var i = 0; i < this.length; i++) {
        var alpha = maskImage.data[i * 4] / 255;
        sumImageData[i * 4 + 0] = alpha * this.image.data[i * 4 + 0] + (1 - alpha) * otherImage.data[i * 4 + 0];
        sumImageData[i * 4 + 1] = alpha * this.image.data[i * 4 + 1] + (1 - alpha) * otherImage.data[i * 4 + 1];
        sumImageData[i * 4 + 2] = alpha * this.image.data[i * 4 + 2] + (1 - alpha) * otherImage.data[i * 4 + 2];
        sumImageData[i * 4 + 3] = 255;
      }

      var sumImage = new ImageData(sumImageData, this.width, this.height);
      return sumImage;
    }
  }]);

  return ImageProcessing;
}();

/***/ }),

/***/ "./src/Core/MediaFilter/ImageProcessing/StreamAIE.js":
/*!***********************************************************!*\
  !*** ./src/Core/MediaFilter/ImageProcessing/StreamAIE.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StreamAIE": () => (/* binding */ StreamAIE)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _StreamAIEUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StreamAIEUtils */ "./src/Core/MediaFilter/ImageProcessing/StreamAIEUtils.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/* globals apiCC*/

/***********************************************************************
* Filename : objectDetection.js
* Description : manages the application of the object detection on streams
* Author : Brieg L'Hostis <brieg.lhostis1@gmail.com>
* Copyright Apizee 2018 - All rights reserved
************************************************************************/


var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('StreamAIE');
var myWebRTC_Event = apiCC.myWebRTC_Event;
var StreamAIE = /*#__PURE__*/function () {
  /**
  *@method constructor
  *@description Initialize the object with the input stream and its resolution.
  *param {Stream} mediaStream: the input raw stream to process.
  *param {Stream} descriptorOptions: options related to the filter
  */
  function StreamAIE(mediaStream, descriptorOptions) {
    _classCallCheck(this, StreamAIE);

    this.mediaStream = mediaStream;
    this.descriptorOptions = descriptorOptions;
    this.modelName = descriptorOptions.modelName; // required

    this.maxBoxes = descriptorOptions.maxBoxes || null; //optional

    this.scoreThresh = descriptorOptions.scoreThresh || null; //optional

    this.forceReload = descriptorOptions.forceReload || false; //optional

    this.classFilter = this.descriptorOptions.classFilter || "all"; //optional

    this.drawingConfig = this.descriptorOptions.drawingConfig || {}; //optional

    this.userMediaStreamId = descriptorOptions.userMediaStreamId; // added by MediaFilterAIE.js

    this.clientId = descriptorOptions.clientId; // added by MediaFilterAIE.js

    var videoTracks = this.mediaStream.getVideoTracks();

    if (videoTracks.length === 0) {
      this.mediaSettings = null;
    }

    this.mediaSettings = videoTracks[0].getSettings();
    this.canvasWidth = this.mediaSettings.width || 480;
    this.canvasHeight = this.mediaSettings.height || 480;
    this.length = this.canvasWidth * this.canvasHeight;
    this.snapshot = false;
    this.log = false;
    this.minSnapshotPeriod = 0;
    this.memoryTime = 0;
    this.lastAnnotations = {
      'yolo': []
    };
    this.lastRawAnnotations = {
      'yolo': []
    };
    this.objectDetectionActivated = false;
    this.drawAnnotationsBool = false;
    this.aieUrl = null;
    this.token = null;
    this.loadedModel = null;
    this.promises = [];
    this.isReleased = false;
    this.resinzingSize = 416;
    this.callId = null;
  }

  _createClass(StreamAIE, [{
    key: "activateLogs",
    value: function activateLogs() {
      var memoryTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.memoryTime = memoryTime;
      this.log = true;
    }
  }, {
    key: "stopLogs",
    value: function stopLogs() {
      this.log = false;
      this.memoryTime = 0;
    }
  }, {
    key: "activateSnapshots",
    value: function activateSnapshots() {
      var minSnapshotPeriod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.snapshot = true;
      this.minSnapshotPeriod = minSnapshotPeriod;
    }
  }, {
    key: "stopSnapshots",
    value: function stopSnapshots() {
      this.snapshot = false;
      this.minSnapshotPeriod = 0;
    }
  }, {
    key: "activateAnnotations",
    value: function activateAnnotations() {
      this.lastAnnotations = {
        'yolo': []
      };
      this.drawAnnotationsBool = true;
      this.getAnnotations();
    }
  }, {
    key: "stopAnnotations",
    value: function stopAnnotations() {
      this.drawAnnotationsBool = false;
    }
    /**
    *@method getAnnotations
    *@description Calls the AIE to compute the annotations from the frames of the stream.
    *param {boolean} enhance: if true then the annotations will be enhance by increasing the objectness scores of reoccuring objects.
    */

  }, {
    key: "getAnnotations",
    value: function getAnnotations() {
      var enhance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var video = document.createElement('video');
      video.srcObject = this.mediaStream; // Insert the MediaStream object in a HTMLVideoElement to manipulate it in canvases.
      // CanvasIn stores the input frame

      var canvasIn = document.createElement('canvas');
      var ctxIn = canvasIn.getContext("2d");
      canvasIn.width = this.canvasWidth;
      canvasIn.height = this.canvasHeight; // CanvasOut stores the output mask

      var canvasOut = document.createElement('canvas');
      var ctxOut = canvasOut.getContext("2d");
      canvasOut.width = this.canvasWidth;
      canvasOut.height = this.canvasHeight;
      var that = this;
      video.addEventListener('loadeddata', function () {
        video.play(); // Start playing

        requestAnimationFrame(function () {
          update(that.aieUrl, that.token, that.loadedModel);
        }); // Start rendering
      }); // function dataURItoBlob(dataURI) {
      // 	var binary = atob(dataURI.split(',')[1]);
      // 	var array = [];
      // 	for(var i = 0; i < binary.length; i++) {
      // 		array.push(binary.charCodeAt(i));
      // 	}
      // 	return new Blob([new Uint8Array(array)], {type: 'image/jpeg'});
      // }

      function dataURLtoFile(dataurl, filename) {
        var arr = dataurl.split(','),
            mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]),
            n = bstr.length,
            u8arr = new Uint8Array(n);

        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }

        return new File([u8arr], filename, {
          type: mime
        });
      }

      var firstAnnotationsCall = true;
      var loggedObjects = {};
      var startTime = null;
      var lastSavingTime = new Date();

      function postImageFile(url, token, modelName) {
        var imageDataURL = canvasIn.toDataURL('image/jpeg');
        var imageFile = dataURLtoFile(imageDataURL);
        var callId = that.getOrCreatePipeline();
        var data = {
          pipelineCallId: callId,
          file: imageFile,
          transferType: 'plugin',
          pluginName: 'httpPost',
          pluginData: {
            url: url,
            headers: {
              'Authorization': 'Token ' + token
            },
            formData: {
              file: '$DATA',
              angled: 1,
              model: modelName,
              size: that.resinzingSize
            }
          }
        };
        apiCC.session.apiCCWebRTCClient.webRTCClient.pushData(null, data, null, {
          success: function success(e) {
            var endTime = new Date();
            var timeElapsed = (endTime - startTime) / 1000; // in seconds

            var fps = 1 / timeElapsed;
            logger.debug('Computation time:', timeElapsed, 's ,FPS:', fps);
            update(url, token, modelName);

            if (e.data.error !== undefined) {
              return logger.error("http post error :", e.data.error);
            }

            if (e.data.result === undefined) {
              return logger.error("An error occured when trying to annotate a snapshot");
            }

            drawAnnotationFromResponse(e.data);
          },
          failure: function failure(monitor, idx, err) {
            logger.error('## pushData:failure', idx, err, monitor);
          }
        });
      }

      function drawAnnotationFromResponse(data) {
        var resultsJson = data.result;

        if (!that.isReleased) {
          that.lastRawAnnotations = resultsJson;

          if (resultsJson.yolo !== undefined) {
            drawYoloAnnotationsFromResponse(resultsJson);
          }

          if (resultsJson.ocr !== undefined || resultsJson.codes !== undefined) {
            drawTextDetectionAnnotationsFromResponse(resultsJson);
          }
        }
      }

      function drawTextDetectionAnnotationsFromResponse(resultsJson) {
        that.lastAnnotations = {
          'ocr': resultsJson.ocr,
          'codes': resultsJson.codes
        };
        var newLog = "";

        if (resultsJson.ocr.length > 1) {
          newLog = newLog + "Words found : ";

          for (var i = 0; i < resultsJson.ocr.length; i++) {
            newLog = newLog + resultsJson.ocr[i].text + ", ";
          }
        }

        if (resultsJson.codes.length > 1) {
          newLog = newLog + "Codes found : ";

          for (var _i = 0; _i < resultsJson.codes.length; _i++) {
            newLog = newLog + resultsJson.codes[_i].code + ", ";
          }
        }

        createLog(newLog);
        createSnapshot();
      }

      function drawYoloAnnotationsFromResponse(resultsJson) {
        // Enhance the annotations by increasing the objectness scores of reoccuring objects
        if (resultsJson.yolo.length > 0) {
          if (enhance) {
            resultsJson = (0,_StreamAIEUtils__WEBPACK_IMPORTED_MODULE_1__.enhanceAnnotations)(that.lastRawAnnotations, resultsJson);
          }

          if (that.scoreThresh !== null) {
            resultsJson = (0,_StreamAIEUtils__WEBPACK_IMPORTED_MODULE_1__.applyThreshold)(resultsJson, that.scoreThresh);
          }
        } // Filter the annotations with the class filter


        var filteredJson = {
          "yolo": []
        };
        var objectDict = {};
        var classFilterList = that.classFilter.split(", ");

        for (var i = 0; i < resultsJson.yolo.length; i++) {
          var obj = resultsJson.yolo[i];

          if (that.classFilter === "all" || classFilterList.includes(obj["class"])) {
            if (!(obj["class"] in objectDict)) {
              objectDict[obj["class"]] = 0;
            }

            objectDict[obj["class"]] += 1;
            filteredJson.yolo.push(obj);
          }
        }

        resultsJson = filteredJson;
        that.lastAnnotations = resultsJson; // Save frame and/or write detection summary in chat

        if (that.log || that.snapshot) {
          var currentTime = new Date(); //let printLog = false;

          var newLogList = [];

          for (var _i2 = 0, _Object$entries = Object.entries(objectDict); _i2 < _Object$entries.length; _i2++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
                _obj = _Object$entries$_i[0],
                count = _Object$entries$_i[1];

            newLogList.push(count + " " + _obj + "(s) detected."); // Add object and its count to the log list
            // If the object has not already been displayed in a recent log then the current log can be displayed

            if (!(_obj in loggedObjects) || currentTime - loggedObjects[_obj] > that.memoryTime * 1000) {
              //printLog = true;
              loggedObjects[_obj] = currentTime;
            }
          }

          var newLog = newLogList.sort().join(" "); // Generate a formalized string for every possible resulting dictionary

          if (newLog !== "") {
            createLog(newLog);
            createSnapshot();
          }
        }
      }

      function createLog(newLog) {
        if (that.log) {
          myWebRTC_Event.createAIELogEvent(that.userMediaStreamId, newLog);
        }
      }

      function createSnapshot() {
        if (that.snapshot) {
          var currentTime = new Date();
          var imageData = ctxIn.getImageData(0, 0, canvasIn.width, canvasIn.height); // Retrieve the current frame from the input canvas.

          if (currentTime - lastSavingTime > that.minSnapshotPeriod * 1000) {
            ctxOut.putImageData(imageData, 0, 0);
            that.drawAnnotations(that.lastAnnotations, ctxOut, that.drawingConfig); // Draw bounding boxes

            var dataURL = canvasOut.toDataURL('image/png');
            var newImage = new Image();
            newImage.src = dataURL;
            myWebRTC_Event.createAIESnapshotEvent(that.userMediaStreamId, newImage);
            lastSavingTime = currentTime;
          }
        }
      }

      function update(url, token, modelName) {
        ctxIn.drawImage(video, 0, 0, canvasIn.width, canvasIn.height); // Draw the current frame on the input canvas.

        if (firstAnnotationsCall || that.drawAnnotationsBool) {
          if (firstAnnotationsCall) {
            firstAnnotationsCall = false; // Compute the mask at first call because of initial inertia.
          }

          startTime = new Date();
          postImageFile(url, token, modelName);
        }
      }
    }
  }, {
    key: "getOrCreatePipeline",
    value: function getOrCreatePipeline() {
      if (this.callId !== null) {
        return this.callId;
      } else {
        var that = this;
        this.callId = apiCC.session.apiCCWebRTCClient.webRTCClient.pushData(null, {
          transferType: 'pipeline'
        }, null, {
          failure: function failure(err) {
            if (err === "dataChannelClosed") {
              logger.debug("dataChannelClosed : no activity on dataChannel timeout");
              that.callId = null;
            } else {
              logger.error("dataChannel failure", err);
            }
          }
        });
        return this.callId;
      }
    }
    /**
    *@method drawAnnotations
    *@description Draws the annotations on a canvas.
    *param {object} annotations: the object corresponding to annotation JSON to draw.
    *param {CanvasRenderingContext2D} ctx: 2D rendering context of the canvas to draw on.
    *param {object} drawingConfig: object containing the parameters for bounding box drawing. The expected (but optional) fields are the following:
    	- color {string}: the default color used for bounding boxes and text backgrounds;
    	- textColor {string}: the default color used for text;
    	- colorMap {object}: object which fields are classes to detect and which values are the color to use to draw the respecting class.
    	- lineWidth {float}: width of the bounding boxes' lines;
    	- font {string}: the font of the canvas rendering context.
    *return {object} objectDict: an object which keys are the classes detected and the values are the number of occurences of the corresponding class in the detection.
    */

  }, {
    key: "drawAnnotations",
    value: function drawAnnotations(annotations, ctx) {
      var drawingConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var defaultColor = drawingConfig.color || "#ED5131";
      var textColor = drawingConfig.textColor || "#FFFFFF";
      var colorMap = drawingConfig.colorMap || null;
      var lineWidth = Object.prototype.hasOwnProperty.call(drawingConfig, lineWidth) ? drawingConfig.lineWidth : 3.0;
      var font = drawingConfig.font || "15px Arial";

      if (annotations.yolo !== undefined && annotations.yolo.length > 0) {
        for (var i = 0; i < annotations.yolo.length; i++) {
          var obj = annotations.yolo[i];
          var bndbox = obj.bounding_box;
          var x = bndbox[0];
          var y = bndbox[1];
          var width = bndbox[2];
          var height = bndbox[3];

          if (this.modelName === "mask_augmented_refined") {
            width = width - x;
            height = height - y;
          }

          var color = defaultColor; // "#3ABAEE";

          if (colorMap !== null && obj["class"] in colorMap) {
            color = colorMap[obj["class"]];
          } // Draw the bounding box


          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color;
          ctx.strokeRect(x, y, width, height); // Draw the text above the bounding box

          ctx.font = font;
          var fontSize = parseInt(font, 10);
          var annotationText = obj["class"]; // + " - " + obj.objectness;

          var textWidth = ctx.measureText(annotationText).width;
          ctx.fillStyle = color;
          ctx.fillRect(x - lineWidth / 2, y - Math.round(fontSize * 4 / 3), textWidth + fontSize + lineWidth, Math.round(fontSize * 4 / 3));
          ctx.fillStyle = textColor;
          ctx.fillText(annotationText, x + Math.round(fontSize / 2) - lineWidth / 2, y - Math.round(fontSize / 2));
        }
      }

      if (annotations.ocr !== undefined && annotations.ocr.length > 0) {
        font = drawingConfig.font || "25px Arial";

        for (var _i3 = 0; _i3 < annotations.ocr.length; _i3++) {
          var _obj2 = annotations.ocr[_i3];
          var _bndbox = _obj2.bounding_box;
          var _x = _bndbox[0];
          var _y = _bndbox[1];
          var _width = _bndbox[2];
          var _height = _bndbox[3];

          if (this.modelName === "mask_augmented_refined") {
            _width = _width - _x;
            _height = _height - _y;
          } // Draw the bounding box


          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = defaultColor;
          ctx.strokeRect(_x, _y, _width, _height); // Draw the text above the bounding box

          ctx.font = font;

          var _fontSize = parseInt(font, 10);

          var _annotationText = _obj2.text;
          var _textWidth = ctx.measureText(_annotationText).width;
          ctx.fillStyle = defaultColor;
          ctx.fillRect(_x - lineWidth / 2, _y - Math.round(_fontSize * 4 / 3), _textWidth + _fontSize + lineWidth, Math.round(_fontSize * 4 / 3));
          ctx.fillStyle = textColor;
          ctx.fillText(_annotationText, _x + Math.round(_fontSize / 2) - lineWidth / 2, _y - Math.round(_fontSize / 2));
        }
      }

      if (annotations.codes !== undefined && annotations.codes.length > 0) {
        font = drawingConfig.font || "25px Arial";

        for (var _i4 = 0; _i4 < annotations.codes.length; _i4++) {
          var _obj3 = annotations.codes[_i4];
          var _bndbox2 = _obj3.bounding_box;
          var _x2 = _bndbox2[0];
          var _y2 = _bndbox2[1];
          var _width2 = _bndbox2[2];
          var _height2 = _bndbox2[3];

          if (this.modelName === "mask_augmented_refined") {
            _width2 = _width2 - _x2;
            _height2 = _height2 - _y2;
          } // Draw the bounding box


          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = defaultColor;
          ctx.strokeRect(_x2, _y2, _width2, _height2); // Draw the text above the bounding box

          ctx.font = font;

          var _fontSize2 = parseInt(font, 10);

          var _annotationText2 = _obj3.code;
          var _textWidth2 = ctx.measureText(_annotationText2).width;
          ctx.fillStyle = defaultColor;
          ctx.fillRect(_x2 - lineWidth / 2, _y2 - Math.round(_fontSize2 * 4 / 3), _textWidth2 + _fontSize2 + lineWidth, Math.round(_fontSize2 * 4 / 3));
          ctx.fillStyle = textColor;
          ctx.fillText(_annotationText2, _x2 + Math.round(_fontSize2 / 2) - lineWidth / 2, _y2 - Math.round(_fontSize2 / 2));
        }
      }
    }
    /**
    *@method activateObjectDetection
    *@description Draws the annotations on the stream.
    */

  }, {
    key: "activateObjectDetection",
    value: function activateObjectDetection() {
      if (this.objectDetectionActivated) {
        return this.processedMediaStream; // Object detection already activated
      }

      var video = document.createElement('video');
      video.srcObject = this.mediaStream; // Insert the MediaStream object in a HTMLVideoElement to manipulate it in canvases.
      // CanvasIn stores the input frame and mask

      var canvasIn = document.createElement('canvas');
      var ctxIn = canvasIn.getContext("2d");
      canvasIn.width = this.canvasWidth;
      canvasIn.height = this.canvasHeight; // CanvasOut stores the output processed frame

      var canvasOut = document.createElement('canvas');
      var ctxOut = canvasOut.getContext("2d");
      canvasOut.width = this.canvasWidth;
      canvasOut.height = this.canvasHeight;
      var that = this;
      video.addEventListener('loadeddata', function () {
        video.play(); // Start playing

        requestAnimationFrame(update); // Start rendering
      });

      function update() {
        ctxIn.drawImage(video, 0, 0, canvasIn.width, canvasIn.height); // Draw the current frame on the input canvas.

        var imageData = ctxIn.getImageData(0, 0, canvasIn.width, canvasIn.height); // Retrieve the current frame from the input canvas.

        ctxOut.putImageData(imageData, 0, 0);

        if (that.drawAnnotationsBool) {
          that.drawAnnotations(that.lastAnnotations, ctxOut, that.drawingConfig); // Draw bounding boxes
        }

        requestAnimationFrame(update); // Wait for the browser to be ready to present another animation frame.
      }

      this.processedMediaStream = canvasOut.captureStream();
      this.objectDetectionActivated = true;
      return this.processedMediaStream;
    }
  }, {
    key: "loadModel",
    value: function loadModel() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        logger.debug("loading model");
        var msg = {
          modelName: _this.modelName,
          maxBoxes: _this.maxBoxes,
          scoreThresh: _this.scoreThresh,
          forceReload: _this.forceReload
        };

        _this.sendMessage(msg, "AIELoadModel", resolve, reject);
      });
    }
  }, {
    key: "sendMessage",
    value: function sendMessage(msg, type, resolve, reject) {
      var timeout = setTimeout(reject, 5000);
      this.promises.push({
        timeout: timeout,
        resolve: resolve
      });
      msg.timeout = timeout;
      this.sendMessageToCCS(msg, type);
    }
  }, {
    key: "sendMessageToCCS",
    value: function sendMessageToCCS(msg, type) {
      msg.userMediaStreamId = this.userMediaStreamId;
      msg.clientId = this.clientId;
      msg.data = {
        pubSub: "AieConnector"
      };
      msg.type = type;

      if (apiCC !== undefined) {
        var socket = apiCC.session.apiCCWebRTCClient.webRTCClient.socket;

        try {
          var messageToSendJson = JSON.stringify(msg);
          socket.emit(type, messageToSendJson);
        } catch (error) {
          logger.error("JSON Stringify error : ", error);
        }
      }
    }
  }, {
    key: "modelLoaded",
    value: function modelLoaded(message) {
      logger.debug("Loaded model name :", message.modelName);
      this.aieUrl = message.url;
      this.loadedModel = message.modelName;
      this.token = message.token;
      var stream = this.activateObjectDetection();
      this.promises.forEach(function (promise) {
        if (message.timeout === promise.timeout) {
          clearTimeout(promise.timeout);
          promise.resolve(stream);
        }
      });
    }
  }, {
    key: "release",
    value: function release() {
      this.isReleased = true;
      this.stopLogs();
      this.stopSnapshots();
      this.stopAnnotations();
      this.sendMessageToCCS({}, "AIELogout");
    }
  }]);

  return StreamAIE;
}();

/***/ }),

/***/ "./src/Core/MediaFilter/ImageProcessing/StreamAIEUtils.js":
/*!****************************************************************!*\
  !*** ./src/Core/MediaFilter/ImageProcessing/StreamAIEUtils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyThreshold": () => (/* binding */ applyThreshold),
/* harmony export */   "enhanceAnnotations": () => (/* binding */ enhanceAnnotations)
/* harmony export */ });
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/***********************************************************************
* Filename : utils.js
* Description : utility functions for object detection
* Author : Brieg L'Hostis <brieg.lhostis1@gmail.com>
* Copyright Apizee 2018 - All rights reserved
************************************************************************/

/**
*@function area_
*@description Compute the area of a bounding box.
*@author Brieg L'Hostis <brieg.lhostis1@gmail.com>
*param {int quadruplet} bndbox: the bounding box coordinates.
*return {int}: the bounding box area.
*/
function area_(bndbox) {
  return (bndbox[2] - bndbox[0]) * (bndbox[3] - bndbox[1]);
}
/**
*@function intersectionOverUnion
*@description Compute the IoU (Intersection over Union) between two bounding boxes.
*@author Brieg L'Hostis <brieg.lhostis1@gmail.com>
*param {int quadruplet} bndbox1: first bounding box coordinates.
*param {int quadruplet} bndbox2: second bounding box coordinates.
*return {float}: IoU between the two bounding boxes.
*/


function intersectionOverUnion(bndbox1, bndbox2) {
  var xmin1 = bndbox1[0];
  var ymin1 = bndbox1[1];
  var xmax1 = bndbox1[2];
  var ymax1 = bndbox1[3];
  var xmin2 = bndbox2[0];
  var ymin2 = bndbox2[1];
  var xmax2 = bndbox2[2];
  var ymax2 = bndbox2[3];
  var inter = [Math.max(xmin1, xmin2), Math.max(ymin1, ymin2), Math.min(xmax1, xmax2), Math.min(ymax1, ymax2)];
  var interArea = area_(inter);
  var unionArea = area_(bndbox1) + area_(bndbox2) - interArea;
  return interArea / unionArea;
}
/**
*@function applyThreshold
*@description Apply a threshold on the objectness scores of the json response.
*@author Brieg L'Hostis <brieg.lhostis1@gmail.com>
*param {object} json: json response object.
*param {float} scoreThreshold: threshold to apply on objectness score.
*param {float} iouThreshold: threshold to apply on IoU.
*return {object} thresholdedJson: thesholded json response object.
*/


function applyThreshold(json) {
  var scoreThreshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.2;
  var iouThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var objects = json.yolo;
  var thresholdedJson = {
    'yolo': []
  };

  var _iterator = _createForOfIteratorHelper(objects),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var object = _step.value;
      var objectness = object.objectness;

      if (objectness > scoreThreshold) {
        if (iouThreshold !== null) {
          var objectBoundingBox = object.bounding_box;
          var objectArea = area_(objectBoundingBox);
          var maxIou = 0;
          var closestObject = null;
          var closestObjectArea = 0;

          var _iterator2 = _createForOfIteratorHelper(objects),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var object2 = _step2.value;
              var object2BoundingBox = object2.bounding_box;
              var iou = intersectionOverUnion(objectBoundingBox, object2BoundingBox);

              if (iou !== 1 && iou > maxIou) {
                maxIou = iou;
                closestObject = object2;
                closestObjectArea = area_(object2.bounding_box);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          if (closestObject === null || maxIou < iouThreshold || closestObjectArea < objectArea) {
            thresholdedJson.yolo.push(object);
          }
        } else {
          thresholdedJson.yolo.push(object);
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return thresholdedJson;
}
/**
*@function jsonEquality
*@description Check the equality between two json responses.
*@author Brieg L'Hostis <brieg.lhostis1@gmail.com>
*param {object} json1: first json response object.
*param {object} json2: second json response object.
*return {boolean}: true if the json responses are equal.
*/


function jsonEquality(json1, json2) {
  var objects1 = json1.yolo;
  var objects2 = json2.yolo;

  if (objects1.length !== objects2.length) {
    return false;
  }

  var _iterator3 = _createForOfIteratorHelper(objects1),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var object1 = _step3.value;
      var objects2ConstainsObject1 = false;

      var _iterator4 = _createForOfIteratorHelper(objects2),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var object2 = _step4.value;

          if (object1.objectness === object2.objectness && object1.bounding_box[0] === object2.bounding_box[0] && object1.bounding_box[1] === object2.bounding_box[1] && object1.bounding_box[2] === object2.bounding_box[2] && object1.bounding_box[3] === object2.bounding_box[3] && object1["class"] === object2["class"]) {
            objects2ConstainsObject1 = true;
            break;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      if (!objects2ConstainsObject1) {
        return false;
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return true;
}
/**
*@function enhanceAnnotations
*@description Augment the objetness scores if the object was already present in the last anntoations.
*@author Brieg L'Hostis <brieg.lhostis1@gmail.com>
*param {object} oldJson: old json response object.
*param {object} newJson: new json response object.
*return {object} enhancedAnnotations: enhanced annotation object.
*/


function enhanceAnnotations(oldJson, newJson) {
  var oldObjects = oldJson.yolo;
  var newObjects = newJson.yolo;
  var enhancedAnnotations = {
    'yolo': []
  };

  var _iterator5 = _createForOfIteratorHelper(newObjects),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var newObject = _step5.value;
      var objectClass = newObject["class"];
      var objectBoundingBox = newObject.bounding_box;
      var maxIou = 0;
      var rawObjectness = newObject.objectness;
      var enhancedObjectness = rawObjectness;

      var _iterator6 = _createForOfIteratorHelper(oldObjects),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var oldObject = _step6.value;

          if (oldObject["class"] === objectClass) {
            var iou = intersectionOverUnion(oldObject.bounding_box, objectBoundingBox);

            if (iou > maxIou) {
              enhancedObjectness = rawObjectness + (1 - rawObjectness) * 0.75 * iou * oldObject.objectness;
            }
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      var enhancedObject = {
        "class": objectClass,
        "objectness": enhancedObjectness,
        "bounding_box": objectBoundingBox
      };
      enhancedAnnotations.yolo.push(enhancedObject);
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  return enhancedAnnotations;
}



/***/ }),

/***/ "./src/Core/MediaFilter/ImageProcessing/StreamSegmentation.js":
/*!********************************************************************!*\
  !*** ./src/Core/MediaFilter/ImageProcessing/StreamSegmentation.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StreamSegmentation": () => (/* binding */ StreamSegmentation)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _BackgroundSubtractor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BackgroundSubtractor */ "./src/Core/MediaFilter/ImageProcessing/BackgroundSubtractor.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/***********************************************************************
* Filename : streamSegmentation.js
* Description : manages the application of the background subtraction on streams
* Author : Brieg L'Hostis <brieg.lhostis1@gmail.com>
* Copyright Apizee 2018 - All rights reserved
************************************************************************/

/* globals apiCC*/


var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('StreamSegmentation');
var myWebRTC_Event = apiCC.myWebRTC_Event;
var StreamSegmentation = /*#__PURE__*/function () {
  /**
  *@method constructor
  *@description Initialize the object with the input stream and its resolution.
  *param {Stream} stream: the input raw stream to process.
  *param {int} canvasWidth: the width of the frame to process (could be different from the actual width of the stream).
  *param {int} canvasHeight: the height of the frame to process (could be different from the actual height of the stream).
  */
  function StreamSegmentation(mediaStream) {
    var canvasWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 480;
    var canvasHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 360;
    var userMediaStreamId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, StreamSegmentation);

    this.mediaStream = mediaStream;
    this.backgroundMode = "none";
    this.backgroundBlurFactor = 10;
    this.canvasWidth = canvasWidth;
    this.canvasHeight = canvasHeight;
    this.length = this.canvasWidth * this.canvasHeight;
    this.userMediaStreamId = userMediaStreamId; // Create a white background image as default background image

    var whiteImageData = new Uint8ClampedArray(this.length * 4);

    for (var i = 0; i < this.length * 4; i++) {
      whiteImageData[i] = 255;
    }

    this.backgroundImage = new ImageData(whiteImageData, this.canvasWidth, this.canvasHeight);
    var blurMask = true,
        smoothBorder = true,
        blurFactor = 5,
        smoothingFactor = -1;
    this.backSub = new _BackgroundSubtractor__WEBPACK_IMPORTED_MODULE_1__.BackgroundSubtractor(blurMask, smoothBorder, blurFactor, smoothingFactor);
    this.modelLoaded = false;
    this.maskStreamLaunched = false;
    this.backgroundSubtractionActivated = false;
  }
  /**
  *@method setBackgroundMode
  *@description Change the background mode.
  *param {string} backgroundMode: the new background mode, could be "none", "blur", "image" or "transparent".
  */


  _createClass(StreamSegmentation, [{
    key: "setBackgroundMode",
    value: function setBackgroundMode(backgroundMode) {
      this.backgroundMode = backgroundMode;
    }
    /**
    *@method setBackgroundImage
    *@description Change the background image to use when replacing the background.
    *param {Image} backgroundImage: the new background image.
    */

  }, {
    key: "setBackgroundImage",
    value: function setBackgroundImage(backgroundImage) {
      this.backgroundImage = backgroundImage;
    }
    /**
    *@method setBackgroundBlurFactor
    *@description Change the background blur factor to use when blurring the background.
    *param {int} backgroundBlurFactor: the new background blur factor.
    */

  }, {
    key: "setBackgroundBlurFactor",
    value: function setBackgroundBlurFactor(backgroundBlurFactor) {
      this.backgroundBlurFactor = backgroundBlurFactor;
    }
    /**
    *@method loadModel
    *@description Loads the Segmentation model
    */

  }, {
    key: "loadModel",
    value: function loadModel() {
      logger.debug("Loading model");
      var that = this;
      return new Promise(function (resolve, reject) {
        that.backSub.loadModel().then(function (_) {
          that.modelLoaded = true;
          logger.debug("Model loaded");
          resolve();
        });
      });
    }
    /**
    *@method getMaskStream
    *@description Start computing the background subtraction mask.
    *return {MediaStream} this.maskMediaStream: the MediaStream object containing the background subtraction mask.
    */

  }, {
    key: "getMaskStream",
    value: function getMaskStream() {
      var video = document.createElement('video');
      video.srcObject = this.mediaStream; // Insert the MediaStream object in a HTMLVideoElement to manipulate it in canvases.
      // CanvasIn stores the input frame

      var canvasIn = document.createElement('canvas');
      var ctxIn = canvasIn.getContext("2d");
      canvasIn.width = this.canvasWidth;
      canvasIn.height = this.canvasHeight; // CanvasOut stores the output mask

      var canvasOut = document.createElement('canvas');
      var ctxOut = canvasOut.getContext("2d");
      canvasOut.width = this.canvasWidth;
      canvasOut.height = this.canvasHeight;
      var that = this;
      video.addEventListener('loadeddata', function () {
        video.play(); // Start playing

        requestAnimationFrame(update); // Start rendering

        if (!that.modelLoaded) {
          that.loadModel().then(function (_) {
            processCanBeHandled = true;
          });
        } else {
          processCanBeHandled = true;
        }
      });
      var maskComputed = true;
      var whiteMaskData = new Uint8ClampedArray(this.length * 4);

      for (var i = 0; i < this.length * 4; i++) {
        whiteMaskData[i] = 255;
      }

      var whiteMask = new ImageData(whiteMaskData, this.canvasWidth, this.canvasHeight);
      ctxOut.putImageData(whiteMask, 0, 0); // No foreground is detected yet

      var processCanBeHandled = false; // Turns to false when the background subtraction proccess cannot be handled anymore.

      var processCanBeHandledPatience = 10; // Number of times the fps must be lower than 1 FPS before the process stops

      var processCanBeHandledCount = 0;
      var firstMaskCall = true;
      this.continueMaskComputation = true;

      function update() {
        ctxIn.drawImage(video, 0, 0, canvasIn.width, canvasIn.height); // Draw the current frame on the input canvas.

        var imageData = ctxIn.getImageData(0, 0, canvasIn.width, canvasIn.height); // Retrieve the current frame from the input canvas.

        if (that.modelLoaded && maskComputed && processCanBeHandled && (firstMaskCall || that.backgroundMode !== "none")) {
          if (firstMaskCall) {
            firstMaskCall = false; // Compute the mask at first call because of initial inertia.
          }

          var startTime = new Date();
          maskComputed = false;
          that.backSub.computeMask(imageData).then(function (maskImage) {
            maskComputed = true;
            var endTime = new Date();
            var timeElapsed = (endTime - startTime) / 1000; // in seconds

            var fps = 1 / timeElapsed; //logger.debug('Computation time:', timeElapsed, 's ,FPS:', fps);

            if (fps < 1) {
              processCanBeHandledCount++;

              if (processCanBeHandledCount >= processCanBeHandledPatience) {
                processCanBeHandled = false;
                logger.error('The segmentation process cannot be handled');
                myWebRTC_Event.createBackgroundSubstractionStopComputeTimeEvent(that.userMediaStreamId);
              }
            }
          });
        }

        if (!that.modelLoaded || that.backSub.maskImage === null || !processCanBeHandled) {
          ctxOut.putImageData(whiteMask, 0, 0); // No foreground is detected yet
        } else {
          ctxOut.putImageData(that.backSub.maskImage, 0, 0); // Display the mask
        }

        if (that.continueMaskComputation) {
          requestAnimationFrame(update); // Wait for the browser to be ready to present another animation frame.
        } else {
          logger.debug("Mask computation stoped");
          that.continueMaskComputation = true;
        }
      }

      this.maskMediaStream = canvasOut.captureStream();
      this.maskStreamLaunched = true;
      return this.maskMediaStream;
    }
    /**
    *@method activateBackgroundSubtraction
    *@description Apply the background subtraction mask on the stream to replace the background with an image, a blur or a transparent background.
    *return {MediaStream} this.processedMediaStream: the MediaStream object containing the processed stream.
    */

  }, {
    key: "activateBackgroundSubtraction",
    value: function activateBackgroundSubtraction() {
      var backgroundMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (backgroundMode !== null) {
        this.setBackgroundMode(backgroundMode);
      }

      if (this.backgroundSubtractionActivated) {
        return this.processedMediaStream; // Background subtraction already activated
      }

      if (!this.maskStreamLaunched) {
        this.getMaskStream();
      }

      var video = document.createElement('video');
      video.srcObject = this.mediaStream; // Insert the MediaStream object in a HTMLVideoElement to manipulate it in canvases.

      var videoMask = document.createElement('video');
      videoMask.srcObject = this.maskMediaStream; // CanvasIn stores the input frame and mask

      var canvasIn = document.createElement('canvas');
      var ctxIn = canvasIn.getContext("2d");
      canvasIn.width = this.canvasWidth;
      canvasIn.height = this.canvasHeight; // CanvasOut stores the output processed frame

      var canvasOut = document.createElement('canvas');
      var ctxOut = canvasOut.getContext("2d");
      canvasOut.width = this.canvasWidth;
      canvasOut.height = this.canvasHeight;
      this.continueBackgroundSubtraction = true;
      var that = this;
      video.addEventListener('loadeddata', function () {
        video.play(); // Start playing

        videoMask.play(); // Start playing mask stream

        requestAnimationFrame(update); // Start rendering
      });

      function update() {
        ctxIn.drawImage(video, 0, 0, canvasIn.width, canvasIn.height); // Draw the current frame on the input canvas.

        var imageData = ctxIn.getImageData(0, 0, canvasIn.width, canvasIn.height); // Retrieve the current frame from the input canvas.

        if (that.backgroundMode === "none") {
          ctxOut.putImageData(imageData, 0, 0);
        } else {
          ctxIn.drawImage(videoMask, 0, 0, canvasIn.width, canvasIn.height); // Draw the current mask on the input canvas.

          var maskImage = ctxIn.getImageData(0, 0, canvasIn.width, canvasIn.height); // Retrieve the current mask from the input canvas.

          var processedImageData = null;

          switch (that.backgroundMode) {
            case "image":
              processedImageData = that.backSub.setBackground(imageData, that.backgroundImage, maskImage); // Replace the background with an image

              break;

            case "blur":
              processedImageData = that.backSub.blurBackground(imageData, that.backgroundBlurFactor, maskImage); // Blur the background

              break;

            case "transparent":
              processedImageData = that.backSub.applyTransparency(imageData, maskImage); // Set the background as transparent

              break;

            default:
              processedImageData = that.backSub.blurBackground(imageData, that.backgroundBlurFactor, maskImage);
            // Blur the background
          }

          ctxOut.putImageData(processedImageData, 0, 0); // Display the processed frame
        }

        if (that.continueBackgroundSubtraction) {
          requestAnimationFrame(update); // Wait for the browser to be ready to present another animation frame.
        } else {
          logger.debug("Mask application stoped");
          that.continueBackgroundSubtraction = true;
        }
      }

      this.processedMediaStream = canvasOut.captureStream(30);
      this.backgroundSubtractionActivated = true;
      return this.processedMediaStream;
    }
    /**
    *@method deactivateBackgroundSubtraction
    *@description Stop the process of application of the mask as well as the computation of the mask.
    */

  }, {
    key: "deactivateBackgroundSubtraction",
    value: function deactivateBackgroundSubtraction() {
      this.setBackgroundMode("none"); // Stop mask application

      this.processedMediaStream = this.mediaStream;
      this.backgroundSubtractionActivated = false;
      this.continueBackgroundSubtraction = false; // Stop mask computation

      this.maskMediaStream = null;
      this.maskStreamLaunched = false;
      this.continueMaskComputation = false;
    }
  }]);

  return StreamSegmentation;
}();

/***/ }),

/***/ "./src/Core/MediaFilter/MediaFilterManager.js":
/*!****************************************************!*\
  !*** ./src/Core/MediaFilter/MediaFilterManager.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MediaFilterManager)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _Filters_OldMediaFilterBackgroundSubtraction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Filters/OldMediaFilterBackgroundSubtraction */ "./src/Core/MediaFilter/Filters/OldMediaFilterBackgroundSubtraction.js");
/* harmony import */ var _Filters_MediaFilterAIE__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Filters/MediaFilterAIE */ "./src/Core/MediaFilter/Filters/MediaFilterAIE.js");
/* harmony import */ var _Filters_MediaFilterBackgroundSubstraction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Filters/MediaFilterBackgroundSubstraction */ "./src/Core/MediaFilter/Filters/MediaFilterBackgroundSubstraction.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('MediaFilterManager');



var myWebRTC_Event = apiCC.myWebRTC_Event; // Filter types
// Add new filter type-class here

var filterTypes = {
  oldBackgroundSubtraction: _Filters_OldMediaFilterBackgroundSubtraction__WEBPACK_IMPORTED_MODULE_1__["default"],
  AIEFilter: _Filters_MediaFilterAIE__WEBPACK_IMPORTED_MODULE_2__["default"],
  backgroundSubtraction: _Filters_MediaFilterBackgroundSubstraction__WEBPACK_IMPORTED_MODULE_3__["default"]
};
/**
 * @class MediaFilterManager
 * @description Helps to create and manage different types of filters 
 */

var MediaFilterManager = /*#__PURE__*/function () {
  /**
   * Init with the descriptors describing filters that will be applied to this media stream
   * @param {MediaStream} mediaStream
   * @param {Array<FilterDescriptor>} descriptors
   */
  function MediaFilterManager(mediaStream, descriptors, userMediaStreamId) {
    _classCallCheck(this, MediaFilterManager);

    this.mediaStream = mediaStream;
    this.descriptors = descriptors;
    this.userMediaStreamId = userMediaStreamId;
    this.filters = {};
  }
  /**
   * @param {FilterDescriptor} descriptor
   * @return {MediaFilter}
   */


  _createClass(MediaFilterManager, [{
    key: "getOrCreateFilter",
    value: function getOrCreateFilter(descriptor) {
      if (this.filters[descriptor.type] !== undefined) {
        return this.filters[descriptor.type];
      }

      var FilterClass = filterTypes[descriptor.type];

      if (FilterClass === undefined) {
        logger.error('Unknown filter type: ' + descriptor.type);
        return null;
      }

      var filter = new FilterClass();
      this.filters[filter] = filter;
      return filter;
    }
    /**
     * Creates and apply all filters
     * @return {MediaStream} Filtered stream
     */

  }, {
    key: "applyFilters",
    value: function applyFilters() {
      var _this = this;

      logger.info('Apply filters', this.descriptors);

      if (!Array.isArray(this.descriptors) || this.descriptors.length === 0) {
        logger.error('No filter can be applied, filter descriptors have wrong format, it should be an array and contain at least one element', this.descriptors);
        return Promise.reject(this.mediaStream);
      } // Chain promises sequentially


      var promise = Promise.resolve(this.mediaStream);
      this.descriptors.forEach(function (descriptor) {
        var filter = _this.getOrCreateFilter(descriptor);

        if (filter === null) {
          logger.error('Filter ' + descriptor.type + ' will be skipped. No implemented filter has this type');
          return;
        }

        if (descriptor.options !== undefined) {
          descriptor.options.userMediaStreamId = _this.userMediaStreamId;
          descriptor.options.clientId = apiCC.session.apiCCWebRTCClient.webRTCClient.clientId;
        }

        promise = promise.then(function (filteredStream) {
          return filter.applyFilter(filteredStream, descriptor);
        });
      });
      logger.info('Filters attached');
      document.addEventListener('visibilitychange', function () {
        _this.createBackgroundSubstractionStopVisibilityChangeEvent(_this.userMediaStreamId);
      });
      promise["catch"](function (e) {
        return logger.error(e);
      });
      return promise;
    }
  }, {
    key: "createBackgroundSubstractionStopVisibilityChangeEvent",
    value: function createBackgroundSubstractionStopVisibilityChangeEvent(userMediaStreamId) {
      if (document.hidden) {
        myWebRTC_Event.createBackgroundSubstractionStopVisibilityChangeEvent(userMediaStreamId);
      }
    }
    /**
     * Stops and releases all filters
     */

  }, {
    key: "release",
    value: function release() {
      Object.values(this.filters).forEach(function (filter) {
        filter.release();
      });
      document.removeEventListener('visibilitychange', this.createBackgroundSubstractionStopVisibilityChangeEvent);
      this.filters = null;
      this.mediaStream = null;
    }
  }]);

  return MediaFilterManager;
}();



/***/ }),

/***/ "./src/Core/PerceivedQualityScore.js":
/*!*******************************************!*\
  !*** ./src/Core/PerceivedQualityScore.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PerceivedQualityScore": () => (/* binding */ PerceivedQualityScore)
/* harmony export */ });
/*
* @constructor
* @this {PerceptivedQualityScore}
/*
* This is the description for my class PerceptivedQualityScore.
*
* @module PerceptivedQualityScore
*/
var PerceivedQualityScore = function PerceivedQualityScore() {
  /*
      * Evaluate Speech quality for NarrowBand signals.
      *
      * @method NarrowBandSpeechQuality
      * @param {object} Ts - Speech delay (ms)
      * @param {object} ppls - Speech packet loss rate (%)
      * @return {number} a score of quality between 1(worse) and 5(excellent)
      */
  this.NarrowBandSpeechQuality = function (Ts, ppls) {
    var TELR = 65,
        //Talker Echo Loudness Rating
    Ies = 0,
        //for G.711 audio codec
    bpls = 4.3,
        //for G.711 audio codec
    TERV,
        Re,
        Idte,
        Ieff,
        Q = 1,
        Sq = 1;
    var c1 = 1 + Ts / 10;
    var c2 = 1 + Ts / 150;
    TERV = TELR - 40 * Math.log10(c1 / c2) + 6 * Math.exp(-0.3 * (Ts * Ts));
    Re = 80 + 2.5 * (TERV - 14);
    var a = (94.769 - Re) / 2;
    var b = (94.769 - Re) * (94.769 - Re) / 4 + 100;
    Idte = (a + Math.sqrt(b) - 1) * (1 - Math.exp(-Ts));
    Ieff = Ies + (95 - Ies) * (ppls / (ppls + bpls));
    Q = 93.193 - Idte - Ieff;

    if (Q < 0) {
      Sq = 1;
    }

    if (Q < 100 & Q > 0) {
      Sq = 1 + 0.035 * Q + Q * (Q - 60) * (100 - Q) * 7 * 0.000001;
    }

    if (Q > 100) {
      Sq = 4.5;
    }

    return Sq;
  };
  /*
      * Evaluate Speech quality for Wideband signals.
      *
      * @method WideBandspeechQuality
      * @param {object} Ts - Speech delay (ms)
      * @param {object} ppls - Speech packet loss rate (%)
      * @return {number} a score of quality between 1(worse) and 5(excellent)
      */


  this.WideBandspeechQuality = function (Ts, ppls) {
    var TELR = 65,
        IesW = 0,
        //for G.711 audio codec
    bpls = 4.3,
        //for G.711 audio codec
    TERVW,
        IdteW,
        IeffW,
        ReW,
        k = 0,
        Q = 1,
        Qx = 1,
        Sq = 1;

    if (Ts < 100) {
      k = 0.08 - Ts + 10;
    }

    if (Ts >= 100) {
      k = 18;
    } //TELR = SLR + RLR+ERL;


    var c1 = 1 + Ts / 10;
    var c2 = 1 + Ts / 150;
    TERVW = TELR + k - 40 * Math.log10(c1 / c2) + 6 * Math.exp(-0.3 * (Ts * Ts));
    ReW = 80 + 3 * (TERVW - 14);
    var a = (129 - ReW) / 2;
    var b = (129 - ReW) * (129 - ReW) / 4 + 100;
    IdteW = (a + Math.sqrt(b) - 1) * (1 - Math.exp(-Ts));
    IeffW = IesW + (95 - IesW) * (ppls / (ppls + bpls));
    Q = 129 - IdteW - IeffW;
    Qx = Q / 1.29;

    if (Qx <= 0) {
      Sq = 1;
    }

    if (Qx < 100 & Qx > 0) {
      Sq = 1 + 0.035 * Q + Q * (Q - 60) * (100 - Q) * 7 * 0.000001;
    }

    if (Qx >= 100) {
      Sq = 4.5;
    }

    return Sq; //return de la valeur estime de la qualit perue du flux relatif  la parole
  };
  /*
      * Evaluate video quality.
      *
      * @method videoQuality
      * @param {object} Tv - Video delay (ms)
      * @param {object} pplv - Video packet loss rate (%)
      * @param {object} Brv - Video bit rate at an encoder (kbits/s)
      * @param {object} Frv - Video frame rate (fps)
      * @return {number} a score of quality between 1(worse) and 5(excellent)
      */


  this.videoQuality = function (width, height, pplv, Brv, Frv) {
    var Iofr,
        Ofr,
        Dfrv,
        Icoding,
        Dpplv,
        c1,
        c2,
        c3,
        v = [],
        Vq = 1;

    if (height > 720) {
      // Better than HD, e.g. full HD (1080p)
      v = [0, 2.77, 0.009, 3.95, 460, 1.28, 2.12, 0.00032, 1.28, 262, 1.98, 22.84, 7.999];
    } else if (height > 576) {
      // Better than 4CIF (PAL TV, 704x576), e.g. HD (720p)
      v = [0, 6.31, 0.008, 3.68, 262, 1.28, 1.97, 0.00033, 1.24, 343, 2.76, 6.25, 6.013];
    } else if (height > 480) {
      // Better than VGA, e.g. 4CIF (704x576)
      v = [0, 6.96, 0.007, 3.58, 214, 1.2, 1.75, 0.00063, 1.13, 171, 4.25, 7.98, 12.001];
    } else if (height > 288) {
      // Better than CIF, e.g. VGA (640x480)
      v = [0, 5.61, 0.01, 3.38, 182, 1.31, 2.23, 0.00075, 1.51, 136, 4.05, 20.16, 22.332];
    } else {
      // Lowest resolution
      v = [0, 3.988, 0.013, 3.625, 89.25, 1.125, 0.713, 0, 1.542, 245.5, 3.011, 39.31, 16.67];
    }

    c1 = 1 + Math.pow(Brv / v[4], v[5]);
    Iofr = v[3] - v[3] / c1;
    Ofr = v[1] + v[2] * Brv;
    Dfrv = v[6] + v[7] * Brv;
    c2 = Math.pow(Math.log(Frv) - Math.log(Ofr), 2);
    c3 = 2 * Math.pow(Dfrv, 2);
    Icoding = Iofr * Math.exp(-c2 / c3);
    Dpplv = v[10] + v[11] * Math.exp(-Frv / v[8]) + v[12] * Math.exp(-Brv / v[9]);
    Vq = 1 + Icoding * Math.exp(-pplv / Dpplv);
    return Vq; // return de la valeur estime de la qualit perue du flux vido
  };
  /*
      * Evaluate audiovisual quality.
      *
      * @method videoQuality
      * @param {object} Tv - Video delay (ms)
      * @param {object} Ts - Speech delay (ms)
      * @param {object} Sq - Speech quality
      * @param {object} Vq - Video quality
      * @return {number} a score of quality between 1(worse) and 5(excellent)
      */


  this.audiovisualQuality = function (Sq, Vq, Ts, Tv) {
    if (Sq > 0 && Vq > 0) {
      var AD = 0,
          MS,
          MMt,
          MMsv,
          m = [],
          MMq = 1;
      m = [0, -0.6966, -0.8127, 0.4562, 3.003, -0.1638, 0.3626, 0.1291, 0.5457, -0.0001251, 3.763, -0.001065, 0.01465, -0.001002, 0];
      AD = m[9] * (Ts + Tv) + m[10];

      if (Ts >= Tv) {
        MS = Math.min(m[11] * (Ts - Tv) + m[12], 0);
      }

      if (Ts < Tv) {
        MS = Math.min(m[13] * (Tv - Ts) + m[14], 0);
      }

      MMt = Math.max(AD + MS, 1);
      MMsv = m[5] * Sq + m[6] * Vq + m[7] * Sq * Vq + m[8];
      MMq = m[1] * MMsv + m[2] * MMt + m[3] * MMsv * MMt + m[4];
      return MMq; // return de la valeur estime de la qualit globale perue du flux multimdia
    } else {
      return "NoAudiovisualStream";
    }
  };
};



/***/ }),

/***/ "./src/Core/PreCallTest.js":
/*!*********************************!*\
  !*** ./src/Core/PreCallTest.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PreCallTest": () => (/* binding */ PreCallTest)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('PreCallTest');
var INTERVAL_DELAY = 1000;
var OBSERVATION_THRESHOLD = 30;
var PUBLISH_STATS_THRESHOLD = 5;
var SUBSCRIBE_STATS_THRESHOLD = 15;
var PUBLISH_AUDIO_BITRATE_THRESHOLD = 20000;
var PUBLISH_VIDEO_BITRATE_THRESHOLD = 125000;
var SUBSCRIBE_AUDIO_BITRATE_THRESHOLD = 30000;
var timeoutOut = 20000;
var RECORDING_DURATION = 10000;
var myWebRTC_Event = apiCC.myWebRTC_Event;
/*
* @constructor
* @this {PreCallTest}
* This is the description for my class PreCallTest.
* @module PreCallTest
*/

var PreCallTest = function PreCallTest(config, enableCamResolutionTest, maxVideoBandwidth, audioSourceId, videoSourceId) {
  var _this = this;

  this.webRTCClient = config.webRTCClient;
  this.notifyTerminated = config.notifyTerminated;
  this.audioSourceId = audioSourceId;
  this.videoSourceId = videoSourceId; // Defines the current test.
  // Either: initial, audio-and-video-600, audio-and-video-250, resolutuion-test and terminated.

  this.testId = 'initial'; // Defines the current step within the current test.
  // Either: initial, joining-mcu-session, stream-publishing, stream-published,
  //         stream-subscribing and stream-subscribed.

  this.stepId = 'initial'; // Holds the final report.

  this.report = {
    'tests': [],
    'resolutions': [],
    'failurCause': ''
  };
  this.maxHeight = 240;
  this.maxWidth = 320;
  this.resolutions = [[320, 240, 'QVGA'], [640, 480, 'VGA'], [1024, 576, 'SD'], [1280, 720, 'HD 720p'], [1920, 1080, 'HD 1080p']];
  this.currentResolution = 0;
  this.userMediastreamId = null;

  if (maxVideoBandwidth === "simpleVideoRecordTest") {
    logger.warn("Simple video record test is activated");
    this.simpleVideoRecordTest = true;
  }

  if (apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.meshModeEnabled === true) {
    logger.debug("Forcing meshModeEnabled to false for precall test");
    apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.meshModeEnabled = false;
    this.modifyMeshModeEnabledValueBeforePreCall = true;
  }
  /*
   * Creates a new ID of a given length.
   *
   * @method generateId
   * @param {number} len - Length of result ID.
   * @return {string} New ID.
   */


  this.generateId = function (len) {
    var ret = "";
    var pool = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

    for (var i = 0; i < len; i += 1) {
      ret += pool.charAt(Math.floor(Math.random() * pool.length));
    }

    return ret;
  };
  /*
   * Creates a new room ID.
   *
   * @method generateRoomId
   * @return {string} New room ID.
   */


  this.generateRoomId = function () {
    return 'PC-' + this.generateId(4) + '-' + this.generateId(4) + '-' + this.generateId(4);
  };
  /*
   * Utility method to push sample into holder array.
   *
   * @method pushStats
   * @param {object} holder - Array holder.
   * @param {stats} object - Sample to be pushed.
   * @return {boolean} True if given sample bas been pushed, false otherwise.
   */


  this.pushStats = function (holder, stats) {
    //var lastIdx = holder.data.length - 1;
    //if (lastIdx < 0 || holder.data[lastIdx].timestamp < stats.timestamp){
    holder.data.push(stats);
    return true; //}
    //return false;
  };
  /*
   * Evaluates the five-number summary (min, firstQuartile, median, thirdQuartile, max).
   *
   * @method evalQuartiles
   * @param {object} data - Array of objects.
   * @param {string} label - Label to summarize.
   * @param {function} convert - Optional function to convert values.
   * @return {object} The five-number summary (min, firstQuartile, median, thirdQuartile, max).
   */


  this.evalQuartiles = function (data, label, convert) {
    var values = [];

    if (convert === undefined) {
      data.forEach(function (d) {
        if (typeof d[label] === 'number') {
          values.push(d[label]);
        }
      });
    } else {
      data.forEach(function (d) {
        values.push(convert(d[label]));
      });
    }

    values.sort(function (a, b) {
      return a < b ? -1 : a === b ? 0 : 1;
    });

    if (values.length % 2 === 0) {
      var mIdx = values.length / 2;
      var median = Math.floor((values[mIdx - 1] + values[mIdx]) / 2);

      if (mIdx % 2 === 0) {
        var lIdx = mIdx / 2;
        var firstQuartile = Math.floor((values[lIdx - 1] + values[lIdx]) / 2);
        var uIdx = mIdx + lIdx;
        var thirdQuartile = Math.floor((values[uIdx - 1] + values[uIdx]) / 2);
        return {
          'min': values[0],
          'firstQuartile': firstQuartile,
          'median': median,
          'thirdQuartile': thirdQuartile,
          'max': values[values.length - 1]
        };
      } else {
        var _lIdx = Math.floor(mIdx / 2);

        var _firstQuartile = values[_lIdx];

        var _uIdx = mIdx + _lIdx;

        var _thirdQuartile = values[_uIdx];
        return {
          'min': values[0],
          'firstQuartile': _firstQuartile,
          'median': median,
          'thirdQuartile': _thirdQuartile,
          'max': values[values.length - 1]
        };
      }
    } else {
      var _mIdx = Math.floor(values.length / 2);

      var _median = values[_mIdx];

      if ((_mIdx + 1) % 2 === 0) {
        var _lIdx2 = (_mIdx + 1) / 2;

        var _firstQuartile2 = Math.floor((values[_lIdx2 - 1] + values[_lIdx2]) / 2);

        var _uIdx2 = _mIdx + _lIdx2;

        var _thirdQuartile2 = Math.floor((values[_uIdx2 - 1] + values[_uIdx2]) / 2);

        return {
          'min': values[0],
          'firstQuartile': _firstQuartile2,
          'median': _median,
          'thirdQuartile': _thirdQuartile2,
          'max': values[values.length - 1]
        };
      } else {
        var _lIdx3 = Math.floor(_mIdx / 2);

        var _firstQuartile3 = values[_lIdx3];

        var _uIdx3 = _mIdx + _lIdx3;

        var _thirdQuartile3 = values[_uIdx3];
        return {
          'min': values[0],
          'firstQuartile': _firstQuartile3,
          'median': _median,
          'thirdQuartile': _thirdQuartile3,
          'max': values[values.length - 1]
        };
      }
    }
  };
  /*
   * Starts the test represented by this one.
   */


  this.runBitRateTest = function () {
    if (apiCC.webRTCCompliant) {
      logger.debug("Run bitrate test");

      if (this.testId === 'initial') {
        // Adding event listeners.
        this.handlers = [{
          'type': 'joinMCUSessionAnswer',
          'callback': this.handleJoinMCUSessionAnswer.bind(this)
        }, {
          'type': 'MCUAvailableStream',
          'callback': this.handleMCUAvailableStream.bind(this)
        }, {
          'type': 'onCallStatsUpdate',
          'callback': this.handleOnCallStatsUpdate.bind(this)
        }, {
          'type': 'remoteStreamAdded',
          'callback': this.handleRemoteStreamAdded.bind(this)
        }, {
          'type': 'userMediaSuccess',
          'callback': this.handleuserMediaSuccess.bind(this)
        }, {
          'type': 'MCURecordedStreamsAvailable',
          'callback': this.handleRecordingStreamAvailable.bind(this)
        }];
        this.handlers.forEach(function (h) {
          apiRTC.addEventListener(h.type, h.callback);
        }); // Configuring WebRTC client.

        this.webRTCClient.setMCUConnector('mcu4.apizee.com');
        this.webRTCClient.setAllowMultipleCalls(true);
        this.webRTCClient.enableCallStatsMonitoring(true, 1000);
        this.webRTCClient.enableQualityEvaluating(true, 1000);
        this.startNextTest();
      }
    } else {
      this.report.failurCause = 'Your device is not WebRTC Compliant';
      this.terminate();
    }
  };

  this.startNextTest = function () {
    if (this.simpleVideoRecordTest === true) {
      //Process added to simplify PreCall test with composant
      //In this case we only establish one video call and then a record 
      if (this.testId === 'initial') {
        logger.debug("initial simple test");

        if (enableCamResolutionTest) {
          this.runResolutionTest();
        } else {
          this.startTestAudioNlVideo(2000);
        }
      } else if (this.testId === 'resolution-test') {
        logger.debug("resolution-test simple");
        this.startTestAudioNlVideo(2000);
      } else if (this.testId === 'audio-and-video-' + 2000) {
        logger.debug("Before recordThenTerminate simple");
        this.recordThenTerminate();
      }
    } else {
      if (this.testId === 'initial') {
        if (enableCamResolutionTest) {
          this.runResolutionTest();
        } else {
          this.startTestAudioNlVideo(maxVideoBandwidth);
        }
      } else if (this.testId === 'resolution-test') {
        this.startTestAudioNlVideo(maxVideoBandwidth);
      } else if (this.testId === 'audio-and-video-' + maxVideoBandwidth) {
        if (this.report[this.testId].status === 'success') {
          var callId = this.report[this.testId].subscribeCallIds[0];
          var videoReceived = this.stats[callId].videoReceived; // received video bandwith is superior to the limited bandwidth or inferior to 10% of it.

          if (typeof videoReceived.bitsReceivedPerSecond.max !== 'undefined' && videoReceived.bitsReceivedPerSecond.max + 0.15 * this.videoBandwidth * 1000 >= this.videoBandwidth * 1000) {
            // Complete success
            this.recordThenTerminate();
          } else if (videoReceived.bitsReceivedPerSecond.max >= 1500000) {
            this.startTestAudioNlVideo(1500);
          } else if (videoReceived.bitsReceivedPerSecond.max >= 1000000) {
            this.startTestAudioNlVideo(1000);
          } else if (videoReceived.bitsReceivedPerSecond.max >= 600000) {
            this.startTestAudioNlVideo(600);
          } else if (videoReceived.bitsReceivedPerSecond.max >= 250000) {
            this.startTestAudioNlVideo(250);
          } else {
            this.startTestAudioNlOnly();
          }
        } else {
          this.startTestAudioNlOnly();
        }
      } else if (this.testId === 'audio-and-video-1500') {
        if (this.report[this.testId].status === 'success') {
          var _callId = this.report[this.testId].subscribeCallIds[0];
          var _videoReceived = this.stats[_callId].videoReceived;

          if (typeof _videoReceived.bitsReceivedPerSecond.max !== 'undefined' && _videoReceived.bitsReceivedPerSecond.max + 0.15 * this.videoBandwidth * 1000 >= this.videoBandwidth * 1000) {
            // Complete success.
            this.recordThenTerminate();
          } else if (_videoReceived.bitsReceivedPerSecond.max >= 1000000) {
            this.startTestAudioNlVideo(1000);
          } else if (_videoReceived.bitsReceivedPerSecond.max >= 600000) {
            this.startTestAudioNlVideo(600);
          } else if (_videoReceived.bitsReceivedPerSecond.max >= 250000) {
            this.startTestAudioNlVideo(250);
          } else {
            this.startTestAudioNlOnly();
          }
        } else {
          this.startTestAudioNlOnly();
        }
      } else if (this.testId === 'audio-and-video-1000') {
        if (this.report[this.testId].status === 'success') {
          var _callId2 = this.report[this.testId].subscribeCallIds[0];
          var _videoReceived2 = this.stats[_callId2].videoReceived;

          if (typeof _videoReceived2.bitsReceivedPerSecond.max !== 'undefined' && _videoReceived2.bitsReceivedPerSecond.max + 0.15 * this.videoBandwidth * 1000 >= this.videoBandwidth * 1000) {
            // Complete success.
            this.recordThenTerminate();
          } else if (_videoReceived2.bitsReceivedPerSecond.max >= 600000) {
            this.startTestAudioNlVideo(600);
          } else if (_videoReceived2.bitsReceivedPerSecond.max >= 250000) {
            this.startTestAudioNlVideo(250);
          } else {
            this.startTestAudioNlOnly();
          }
        } else {
          this.startTestAudioNlOnly();
        }
      } else if (this.testId === 'audio-and-video-600') {
        if (this.report[this.testId].status === 'success') {
          var _callId3 = this.report[this.testId].subscribeCallIds[0];
          var _videoReceived3 = this.stats[_callId3].videoReceived;

          if (typeof _videoReceived3.bitsReceivedPerSecond.max !== 'undefined' && _videoReceived3.bitsReceivedPerSecond.max + 0.15 * this.videoBandwidth * 1000 >= this.videoBandwidth * 1000) {
            // Complete success.
            this.recordThenTerminate();
          } else if (_videoReceived3.bitsReceivedPerSecond.max >= 250000) {
            this.startTestAudioNlVideo(250);
          } else {
            this.startTestAudioNlOnly();
          }
        } else {
          this.startTestAudioNlOnly();
        }
      } else if (this.testId === 'audio-and-video-250') {
        if (this.report[this.testId].status === 'success') {
          var _callId4 = this.report[this.testId].subscribeCallIds[0];
          var _videoReceived4 = this.stats[_callId4].videoReceived;

          if (typeof _videoReceived4.bitsReceivedPerSecond.max !== 'undefined' && _videoReceived4.bitsReceivedPerSecond.max + 0.15 * this.videoBandwidth * 1000 >= this.videoBandwidth * 1000) {
            // Complete success.
            this.recordThenTerminate();
          } else {
            this.startTestAudioNlOnly();
          }
        } else {
          this.startTestAudioNlOnly();
        }
      } else {
        this.recordThenTerminate();
      }
    }
  };

  this.startTestAudioNlVideo = function (maxVideoBandwidth) {
    this.prepareEnvForNewTest();
    logger.debug('%ctestAudioNlVideo' + maxVideoBandwidth);
    this.testId = 'audio-and-video-' + maxVideoBandwidth;
    this.report.tests.push(this.testId);
    this.audioEnabled = true;
    this.videoEnabled = true;
    this.videoBandwidth = maxVideoBandwidth;
    this.webRTCClient.setRemoteVideoBandwidth(this.videoBandwidth); // Preparing stats.

    this.stats = {}; // Preparing report section.

    this.report[this.testId] = {
      'audioEnabled': true,
      'audioLimited': false,
      'videoEnabled': true,
      'videoLimited': true,
      'videoBandwidth': this.videoBandwidth,
      'stats': this.stats
    }; // Creating MCU session.

    this.mcuSession = {};
    this.mcuSession.roomId = this.generateRoomId();
    this.report[this.testId].roomId = this.mcuSession.roomId;
    this.webRTCClient.joinMCUSession(this.mcuSession.roomId);
    this.stepId = 'joining-mcu-session';
    this.timeoutId = setTimeout(this.abortJoinMCUSession.bind(this), timeoutOut);
  };

  this.startTestAudioNlOnly = function () {
    this.prepareEnvForNewTest();
    logger.debug('%cstartTestAudioNlOnly');
    this.testId = 'audio-only';
    this.report.tests.push(this.testId);
    this.audioEnabled = true;
    this.videoEnabled = false;
    this.webRTCClient.setRemoteVideoBandwidth(null); // Preparing stats.

    this.stats = {}; // Preparing report section.

    this.report[this.testId] = {
      'audioEnabled': true,
      'audioLimited': false,
      'videoEnabled': false,
      'stats': this.stats
    }; // Creating MCU session.

    this.mcuSession = {};
    this.mcuSession.roomId = this.generateRoomId();
    this.report[this.testId].roomId = this.mcuSession.roomId;
    this.webRTCClient.joinMCUSession(this.mcuSession.roomId);
    this.stepId = 'joining-mcu-session';
    this.timeoutId = setTimeout(this.abortJoinMCUSession.bind(this), timeoutOut);
  };

  this.startTestVideoNlOnly = function () {
    this.prepareEnvForNewTest();
    logger.debug('%cstartTestVideoNlOnly');
    this.testId = 'video-only';
    this.report.tests.push(this.testId);
    this.audioEnabled = false;
    this.videoEnabled = true;
    this.videoBandwidth = 600;
    this.webRTCClient.setRemoteVideoBandwidth(this.videoBandwidth); // Preparing stats.

    this.stats = {}; // Preparing report section.

    this.report[this.testId] = {
      'audioEnabled': false,
      'audioLimited': false,
      'videoEnabled': true,
      'stats': this.stats
    }; // Creating MCU session.

    this.mcuSession = {};
    this.mcuSession.roomId = this.generateRoomId();
    this.report[this.testId].roomId = this.mcuSession.roomId;
    this.webRTCClient.joinMCUSession(this.mcuSession.roomId);
    this.stepId = 'joining-mcu-session';
    this.timeoutId = setTimeout(this.abortJoinMCUSession.bind(this), timeoutOut);
  };

  this.recordThenTerminate = function () {
    if (_this.modifyMeshModeEnabledValueBeforePreCall === true) {
      logger.debug("Restoring meshModeEnabled to true, as it was modified for precall test");
      apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.meshModeEnabled = true;
    }

    var recType = null;

    if (_this.videoEnabled && _this.audioEnabled) {
      recType = 'AUDIO-VIDEO';
    } else if (_this.audioEnabled) {
      recType = 'AUDIO-ONLY';
    } else if (_this.videoEnabled) {
      recType = 'VIDEO-ONLY';
    }

    if (!recType) {
      logger.error("Can't define record type");

      _this.terminate();

      return;
    }

    logger.debug('Start recording with type:', recType);

    _this.webRTCClient.startRecording(recType, 'recordPreCall', null, null, {
      ttl: 900
    });

    setTimeout(function () {
      logger.debug("Stop recording");

      _this.webRTCClient.stopRecording();
    }, RECORDING_DURATION);
  };

  this.terminate = function () {
    logger.debug("Terminate");
    this.testId = 'terminated';

    if (this.handlers) {
      this.handlers.forEach(function (h) {
        apiRTC.removeEventListener(h.type, h.callback);
      });
    }

    this.notifyTerminated(this.report);
    this.leaveSession();
  };

  this.succeed = function () {
    myWebRTC_Event.createEvent({
      "eventType": "preCallTestStatus",
      "testId": this.testId,
      "status": 'success',
      "stepId": this.stepId
    });
    this.report[this.testId].status = 'success';
    this.startNextTest();
  };

  this.fail = function () {
    logger.debug("fail");
    myWebRTC_Event.createEvent({
      "eventType": "preCallTestStatus",
      "testId": this.testId,
      "status": 'failure',
      "stepId": this.stepId
    });
    this.report[this.testId].status = 'failure';
    this.report[this.testId].stepId = this.stepId;
    this.leaveSession();
    this.startNextTest();
  };

  this.prepareEnvForNewTest = function () {
    if (_this.mcuSession !== undefined) {
      _this.leaveSession();
    }
  };

  this.abortJoinMCUSession = function () {
    logger.debug("abortJoinMCUSession");
    this.fail();
  };

  this.abortStreamPublishing = function () {
    logger.debug("abortStreamPublishing");
    this.fail();
  };

  this.abortStreamSubscribing = function () {
    logger.debug("abortStreamSubscribing");
    this.fail();
  };

  this.observeStreamPublished = function () {
    logger.debug("observeStreamPublished");

    if (apiRTC.browser === "Safari" || apiRTC.browser === "Mobile Safari") {
      logger.info("Safari");
      logger.error("observeStreamPublished not supported on Safari");
      clearInterval(this.intervalId);
      this.fail();
      return;
    } // Observation management.


    this.intervalCounter += 1;

    if (this.intervalCounter > OBSERVATION_THRESHOLD) {
      clearInterval(this.intervalId);
      this.fail();
      return;
    }

    if (this.audioEnabled && this.videoEnabled) {
      var okCnt = 0;

      if (this.stats[this.publishCallId] !== undefined) {
        if (this.stats[this.publishCallId].audioSent !== undefined && this.stats[this.publishCallId].audioSent.bitsSentPerSecond !== undefined) {
          if (this.stats[this.publishCallId].audioSent.bitsSentPerSecond.thirdQuartile >= PUBLISH_AUDIO_BITRATE_THRESHOLD) {
            okCnt += 1;
          }
        }

        if (this.stats[this.publishCallId].videoSent !== undefined && this.stats[this.publishCallId].videoSent.bitsSentPerSecond !== undefined) {
          if (this.stats[this.publishCallId].videoSent.bitsSentPerSecond.thirdQuartile >= PUBLISH_VIDEO_BITRATE_THRESHOLD) {
            okCnt += 1;
          }
        }
      }

      if (okCnt === 2) {
        clearInterval(this.intervalId);
        var stream = this.streams[0];
        this.subscribeToUserStream(stream.attributes.callerId, stream.id, 'VIDEO');
        this.stepId = 'stream-subscribing';
        this.timeoutId = setTimeout(this.abortStreamSubscribing.bind(this), timeoutOut);
      } else {
        logger.debug("okCnt !== 2");
      }
    } else if (this.audioEnabled) {
      if (this.stats[this.publishCallId] !== undefined) {
        if (this.stats[this.publishCallId].audioSent !== undefined && this.stats[this.publishCallId].audioSent.bitsSentPerSecond !== undefined) {
          if (this.stats[this.publishCallId].audioSent.bitsSentPerSecond.thirdQuartile >= PUBLISH_AUDIO_BITRATE_THRESHOLD) {
            clearInterval(this.intervalId);
            var _stream = this.streams[0];
            this.subscribeToUserStream(_stream.attributes.callerId, _stream.id, 'AUDIOONLY');
            this.stepId = 'stream-subscribing';
            this.timeoutId = setTimeout(this.abortStreamSubscribing.bind(this), timeoutOut);
          } else {
            logger.debug("no stats audio 1 ");
          }
        } else {
          logger.debug("no stats audio 2");
        }
      } else {
        logger.debug("no stats audio 3");
      }
    } else if (this.videoEnabled) {
      if (this.stats[this.publishCallId] !== undefined) {
        if (this.stats[this.publishCallId].videoSent !== undefined && this.stats[this.publishCallId].videoSent.bitsSentPerSecond !== undefined) {
          if (this.stats[this.publishCallId].videoSent.bitsSentPerSecond.thirdQuartile >= PUBLISH_VIDEO_BITRATE_THRESHOLD) {
            clearInterval(this.intervalId);
            var _stream2 = this.streams[0];
            this.subscribeToUserStream(_stream2.attributes.callerId, _stream2.id, 'VIDEOONLY');
            this.stepId = 'stream-subscribing';
            this.timeoutId = setTimeout(this.abortStreamSubscribing.bind(this), timeoutOut);
          } else {
            logger.debug("no stats video 1 ");
          }
        } else {
          logger.debug("no stats video 2");
        }
      } else {
        logger.debug("no stats video 3");
      }
    } else {
      logger.debug("no audio or video");
      clearInterval(this.intervalId);
      this.fail();
    }
  };

  this.observeStreamSubscribed = function () {
    // Observation management.
    this.intervalCounter += 1;

    if (this.intervalCounter > OBSERVATION_THRESHOLD) {
      clearInterval(this.intervalId);
      this.succeed();
      return;
    }

    var audioSent = null,
        videoSent = null,
        succeedCnt = 0,
        failCnt = 0;

    if (this.audioEnabled) {
      audioSent = this.stats[this.publishCallId].audioSent;
    }

    if (this.videoEnabled) {
      videoSent = this.stats[this.publishCallId].videoSent;
    }

    for (var idx = 0; idx < this.subscribeCallIds.length; idx += 1) {
      var callId = this.subscribeCallIds[idx];

      if (this.audioEnabled && this.videoEnabled) {
        var okCnt = 0;

        if (this.stats[callId] !== undefined) {
          if (this.stats[callId].audioReceived !== undefined && this.stats[callId].audioReceived.bitsReceivedPerSecond !== undefined) {
            if (audioSent !== undefined && audioSent !== null && audioSent.bitsSentPerSecond !== undefined) {
              if (this.stats[callId].audioReceived.bitsReceivedPerSecond.thirdQuartile >= audioSent.bitsSentPerSecond.firstQuartile - 2000) {
                okCnt += 1;
              }
            }
          }

          if (this.stats[callId].videoReceived !== undefined && this.stats[callId].videoReceived.bitsReceivedPerSecond !== undefined) {
            if (videoSent !== null && videoSent !== undefined && videoSent.bitsSentPerSecond !== undefined) {
              if (this.stats[callId].videoReceived.bitsReceivedPerSecond.thirdQuartile >= videoSent.bitsSentPerSecond.firstQuartile) {
                okCnt += 1;
              }
            }
          }
        }

        if (okCnt === 2) {
          succeedCnt += 1;
        }
      } else if (this.audioEnabled) {
        if (this.stats[callId] !== undefined && this.stats[callId].audioReceived !== undefined && this.stats[callId].audioReceived.bitsReceivedPerSecond !== undefined) {
          if (audioSent !== undefined && audioSent !== null && audioSent.bitsSentPerSecond !== undefined) {
            if (this.stats[callId].audioReceived.bitsReceivedPerSecond.thirdQuartile >= audioSent.bitsSentPerSecond.firstQuartile) {
              succeedCnt += 1;
            }
          }
        }
      } else {
        failCnt += 1;
      }
    } // for


    if (failCnt > 0) {
      clearInterval(this.intervalId);
      this.fail();
    } else if (succeedCnt === this.subscribeCallIds.length) {
      clearInterval(this.intervalId);
      this.succeed();
    }
  };

  this.handleJoinMCUSessionAnswer = function (e) {
    if (this.stepId === 'joining-mcu-session') {
      myWebRTC_Event.createEvent({
        "eventType": "preCallTestStatus",
        "testId": this.testId,
        "status": 'start',
        "stepId": this.stepId
      });
      clearTimeout(this.timeoutId);
      this.mcuSession.sessionId = e.detail.sessionId;
      this.mcuSession.token = e.detail.token;

      if (this.audioEnabled && this.videoEnabled) {
        var self = this;
        var constraints = {
          audio: {},
          video: {}
        };
        constraints = apiCC.setResolutionInConstraint(this.maxWidth, this.maxHeight, constraints);
        logger.debug("constraints :", constraints);
        apiRTC.createUserMediaStream({
          'type': 'media',
          'audioSourceId': this.audioSourceId,
          'videoSourceId': this.videoSourceId,
          'gum_config': constraints,
          'release': function release(userMediaStream) {
            logger.debug('createUserMediaStream release', userMediaStream.userMediaStreamId); // When the stream has been released, in addition of userMediaStop event.
          },
          'success': function success(userMediaStream) {
            logger.debug('createUserMediaStream success', userMediaStream.userMediaStreamId);
            logger.debug('audioSourceId', audioSourceId);
            logger.debug('videoSourceId', videoSourceId); // In case of success, in addition of userMediaSuccess event.
          },
          'failure': function failure(userMediaStream, error) {
            logger.error('createUserMediaStream failure', userMediaStream.userMediaStreamId); // In case of failure, in addition of userMediaError event.

            logger.error('failure; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
            logger.error('failure; error: ' + error);
            myWebRTC_Event.createEvent({
              "eventType": "preCallTestStatus",
              "testId": this.testId,
              "status": 'failure',
              "stepId": this.stepId,
              "createUserMediaStreamError": error
            });
            self.terminate();
          }
        });
      } else if (this.audioEnabled) {
        var callConfiguration = {
          'audioOnly': true
        };
        this.publishCallId = this.webRTCClient.publish(this.mcuSession.roomId, this.mcuSession.sessionId, this.mcuSession.token, callConfiguration);
      } else if (this.videoEnabled) {
        var _callConfiguration = {
          'videoOnly': true,
          qos: {
            videoStartQuality: 'upper'
          }
        };
        this.publishCallId = this.webRTCClient.publish(this.mcuSession.roomId, this.mcuSession.sessionId, this.mcuSession.token, _callConfiguration);
      } else {
        this.fail();
        return;
      }

      this.subscribeCallIds = [];
      this.report[this.testId].publishCallId = this.publishCallId;
      this.report[this.testId].subscribeCallIds = [];
      this.streams = [];
      this.stepId = 'stream-publishing';
      this.timeoutId = setTimeout(this.abortStreamPublishing.bind(this), timeoutOut);
    }
  };

  this.handleuserMediaSuccess = function (e) {
    var callConfiguration = {
      'userMediaStreamId': e.detail.userMediaStreamId,
      qos: {
        videoStartQuality: 'upper'
      }
    };
    this.userMediastreamId = e.detail.userMediaStreamId;
    this.publishCallId = this.webRTCClient.publish(this.mcuSession.roomId, this.mcuSession.sessionId, this.mcuSession.token, callConfiguration);
    this.report[this.testId].publishCallId = this.publishCallId;
  };

  this.handleRecordingStreamAvailable = function (e) {
    logger.debug("handleRecordingStreamAvailable");
    this.terminate();
  };

  this.handleMCUAvailableStream = function (e) {
    if (this.stepId === 'stream-publishing') {
      if (e.detail.isRemoteStream === false) {
        for (var i = 0; i < e.detail.streams.length; i += 1) {
          var stream = e.detail.streams[i];

          if (stream.room === this.mcuSession.roomId && stream.attributes.callId === this.publishCallId) {
            if (this.stepId === 'stream-publishing') {
              clearTimeout(this.timeoutId);
              this.stepId = 'stream-published';
              this.streams.push(stream);

              if (this.simpleVideoRecordTest === true) {
                var mediaType = 'VIDEO';

                if (stream.audio === false) {
                  mediaType = 'VIDEOONLY';
                }

                if (stream.video === false) {
                  mediaType = 'AUDIOONLY';
                }

                this.subscribeToUserStream(stream.attributes.callerId, stream.id, mediaType);
                this.stepId = 'stream-subscribing';
              } else {
                this.intervalId = setInterval(this.observeStreamPublished.bind(this), INTERVAL_DELAY);
              }

              this.intervalCounter = 0;
            }
          }
        } // for

      }
    }
  };

  this.handleRemoteStreamAdded = function (e) {
    if (this.stepId === 'stream-subscribing') {
      var callId = this.subscribeCallIds.find(function (i) {
        return i === e.detail.callId;
      });

      if (callId !== undefined) {
        clearTimeout(this.timeoutId);
        this.stepId = 'stream-subscribed';
        this.intervalId = setInterval(this.observeStreamSubscribed.bind(this), INTERVAL_DELAY);
        this.intervalCounter = 0;
      }
    }
  };

  this.handleOnCallStatsUpdate = function (e) {
    var _this2 = this;

    if (this.stepId === 'stream-published' || this.stepId === 'stream-subscribing' || this.stepId === 'stream-subscribed') {
      if (this.stats[this.publishCallId] === undefined) {
        this.stats[this.publishCallId] = {};
      }

      if (e.detail.stats.audioSent !== undefined) {
        if (this.stats[this.publishCallId].audioSent === undefined) {
          this.stats[this.publishCallId].audioSent = {
            'startTime': e.detail.stats.audioSent.timestamp,
            'data': []
          };
        } //logger.error('pushStats audio pour this.publishCallId :', this.publishCallId);


        var added = this.pushStats(this.stats[this.publishCallId].audioSent, e.detail.stats.audioSent);

        if (added) {
          if (this.stats[this.publishCallId].audioSent.data.length >= PUBLISH_STATS_THRESHOLD) {
            ['bitsSentPerSecond', 'packetsSentPerSecond'].forEach(function (l) {
              var q = _this2.evalQuartiles(_this2.stats[_this2.publishCallId].audioSent.data, l);

              q.sampleCount = _this2.stats[_this2.publishCallId].audioSent.data.length;
              q.time = e.detail.stats.audioSent.timestamp - _this2.stats[_this2.publishCallId].audioSent.startTime;
              _this2.stats[_this2.publishCallId].audioSent[l] = q;
            });
          }
        } else {
          logger.debug('audio stats not pushed for :', this.publishCallId);
        }
      }

      if (e.detail.stats.videoSent !== undefined) {
        if (this.stats[this.publishCallId].videoSent === undefined) {
          this.stats[this.publishCallId].videoSent = {
            'startTime': e.detail.stats.videoSent.timestamp,
            'data': []
          };
        } //logger.error('pushStats video pour this.publishCallId :', this.publishCallId);


        var _added = this.pushStats(this.stats[this.publishCallId].videoSent, e.detail.stats.videoSent);

        if (_added) {
          if (this.stats[this.publishCallId].videoSent.data.length >= PUBLISH_STATS_THRESHOLD) {
            ['bitsSentPerSecond', 'packetsSentPerSecond', 'framesEncodedPerSecond'].forEach(function (l) {
              var q = _this2.evalQuartiles(_this2.stats[_this2.publishCallId].videoSent.data, l);

              q.sampleCount = _this2.stats[_this2.publishCallId].videoSent.data.length;
              q.time = e.detail.stats.videoSent.timestamp - _this2.stats[_this2.publishCallId].videoSent.startTime;
              _this2.stats[_this2.publishCallId].videoSent[l] = q;
            });
            this.stats[this.publishCallId].videoSent.width = e.detail.stats.videoSent.width;
            this.stats[this.publishCallId].videoSent.height = e.detail.stats.videoSent.height;
          }
        } else {
          logger.debug('video stats not pushed for :', this.publishCallId);
        }
      }
    }

    if (this.stepId === 'stream-subscribed') {
      var _loop = function _loop(idx) {
        statsCount = 0;
        var callId = _this2.subscribeCallIds[idx];

        if (_this2.stats[callId] === undefined) {
          _this2.stats[callId] = {};
        }

        if (e.detail.stats.audioReceived !== undefined) {
          if (_this2.stats[callId].audioReceived === undefined) {
            _this2.stats[callId].audioReceived = {
              'startTime': e.detail.stats.audioReceived.timestamp,
              'data': []
            };
          } //logger.error('pushStats audio pour callId :', callId);


          var _added2 = _this2.pushStats(_this2.stats[callId].audioReceived, e.detail.stats.audioReceived);

          if (_added2) {
            statsCount = _this2.stats[callId].audioReceived.data.length;

            if (_this2.stats[callId].audioReceived.data[statsCount - 1].mosS === undefined) {
              _this2.stats[callId].audioReceived.data[statsCount - 1].mosS = {};
            }

            _this2.stats[callId].audioReceived.data[statsCount - 1].mosS = e.detail.stats.quality.mosS;

            if (_this2.stats[callId].audioReceived.data.length >= SUBSCRIBE_STATS_THRESHOLD) {
              ['bitsReceivedPerSecond', 'packetsReceivedPerSecond', 'delay'].forEach(function (l) {
                var q = _this2.evalQuartiles(_this2.stats[callId].audioReceived.data, l);

                q.sampleCount = _this2.stats[callId].audioReceived.data.length;
                q.time = e.detail.stats.audioReceived.timestamp - _this2.stats[callId].audioReceived.startTime;
                _this2.stats[callId].audioReceived[l] = q;
              });

              if (_this2.stats[callId].audioReceived.data[0].jitter !== undefined) {
                ['jitter'].forEach(function (l) {
                  var q = _this2.evalQuartiles(_this2.stats[callId].audioReceived.data, l, function (v) {
                    return Math.floor(v * 1000);
                  });

                  q.sampleCount = _this2.stats[callId].audioReceived.data.length;
                  q.time = e.detail.stats.audioReceived.timestamp - _this2.stats[callId].audioReceived.startTime;
                  _this2.stats[callId].audioReceived[l] = q;
                });
              }

              _this2.stats[callId].audioReceived.packetsLost = {
                'max': e.detail.stats.audioReceived.packetsLost,
                'sampleCount': _this2.stats[callId].audioReceived.data.length,
                'time': e.detail.stats.audioReceived.timestamp - _this2.stats[callId].audioReceived.startTime
              };
              ['packetsLostRatio'].forEach(function (l) {
                var q = _this2.evalQuartiles(_this2.stats[callId].audioReceived.data, l);

                q.sampleCount = _this2.stats[callId].audioReceived.data.length;
                q.time = e.detail.stats.audioReceived.timestamp - _this2.stats[callId].audioReceived.startTime;
                _this2.stats[callId].audioReceived[l] = q;
              });

              if (_this2.stats[callId].audioReceived.mosS === undefined) {
                _this2.stats[callId].audioReceived.mosS = {};
              }

              ['mosS'].forEach(function (l) {
                var q = _this2.evalQuartiles(_this2.stats[callId].audioReceived.data, l);

                q.sampleCount = _this2.stats[callId].audioReceived.data.length;
                _this2.stats[callId].audioReceived[l] = q;
              });
            }
          } else {
            logger.error('audio stats not pushed for callId :', callId);
          }
        }

        if (e.detail.stats.videoReceived !== undefined) {
          if (_this2.stats[callId].videoReceived === undefined) {
            _this2.stats[callId].videoReceived = {
              'startTime': e.detail.stats.videoReceived.timestamp,
              'data': []
            };
          } //logger.error('pushStats video pour callId :', callId);


          var _added3 = _this2.pushStats(_this2.stats[callId].videoReceived, e.detail.stats.videoReceived);

          if (_added3) {
            statsCount = _this2.stats[callId].videoReceived.data.length;

            if (_this2.stats[callId].videoReceived.data[statsCount - 1].mosV === undefined) {
              _this2.stats[callId].videoReceived.data[statsCount - 1].mosV = {};
            }

            if (_this2.stats[callId].videoReceived.data[statsCount - 1].mosAV === undefined) {
              _this2.stats[callId].videoReceived.data[statsCount - 1].mosAV = {};
            }

            _this2.stats[callId].videoReceived.data[statsCount - 1].mosV = e.detail.stats.quality.mosV;
            _this2.stats[callId].videoReceived.data[statsCount - 1].mosAV = e.detail.stats.quality.mosAV;

            if (_this2.stats[callId].videoReceived.data.length >= SUBSCRIBE_STATS_THRESHOLD) {
              ['bitsReceivedPerSecond', 'packetsReceivedPerSecond', 'framesDecodedPerSecond'].forEach(function (l) {
                var q = _this2.evalQuartiles(_this2.stats[callId].videoReceived.data, l);

                q.sampleCount = _this2.stats[callId].videoReceived.data.length;
                q.time = e.detail.stats.videoReceived.timestamp - _this2.stats[callId].videoReceived.startTime;
                _this2.stats[callId].videoReceived[l] = q;
              });

              if (_this2.stats[callId].videoReceived.data[0].jitter !== undefined) {
                ['jitter'].forEach(function (l) {
                  var q = _this2.evalQuartiles(_this2.stats[callId].videoReceived.data, l, function (v) {
                    return Math.floor(v * 1000);
                  });

                  q.sampleCount = _this2.stats[callId].videoReceived.data.length;
                  q.time = e.detail.stats.videoReceived.timestamp - _this2.stats[callId].videoReceived.startTime;
                  _this2.stats[callId].videoReceived[l] = q;
                });
              }

              _this2.stats[callId].videoReceived.packetsLost = {
                'max': e.detail.stats.videoReceived.packetsLost,
                'sampleCount': _this2.stats[callId].videoReceived.data.length,
                'time': e.detail.stats.videoReceived.timestamp - _this2.stats[callId].videoReceived.startTime
              };
              ['packetsLostRatio'].forEach(function (l) {
                var q = _this2.evalQuartiles(_this2.stats[callId].videoReceived.data, l);

                q.sampleCount = _this2.stats[callId].videoReceived.data.length;
                q.time = e.detail.stats.videoReceived.timestamp - _this2.stats[callId].videoReceived.startTime;
                _this2.stats[callId].videoReceived[l] = q;
              });

              if (_this2.stats[callId].videoReceived.mosV === undefined) {
                _this2.stats[callId].videoReceived.mosV = {};
              }

              ['mosV'].forEach(function (l) {
                var q = _this2.evalQuartiles(_this2.stats[callId].videoReceived.data, l);

                q.sampleCount = _this2.stats[callId].videoReceived.data.length;
                _this2.stats[callId].videoReceived[l] = q;
              });

              if (_this2.stats[callId].videoReceived.mosAV === undefined) {
                _this2.stats[callId].videoReceived.mosAV = {};
              }

              ['mosAV'].forEach(function (l) {
                var q = _this2.evalQuartiles(_this2.stats[callId].videoReceived.data, l);

                q.sampleCount = _this2.stats[callId].videoReceived.data.length;
                _this2.stats[callId].videoReceived[l] = q;
              });
              _this2.stats[callId].videoReceived.width = e.detail.stats.videoReceived.width;
              _this2.stats[callId].videoReceived.height = e.detail.stats.videoReceived.height;
            }
          } else {
            logger.error('video stats not pushed for callId :', callId);
          }
        }
      };

      //logger.debug('this.stepId stream-subscribed :');
      for (var idx = 0; idx < this.subscribeCallIds.length; idx += 1) {
        var statsCount;

        _loop(idx);
      } // for

    }
  };

  this.subscribeToUserStream = function (userId, streamId, mediaType) {
    var _this3 = this;

    var stream = this.webRTCClient.getStreamFromList(streamId);

    if (stream !== undefined && stream !== null) {
      var streams = [];
      streams.push(stream);
      this.webRTCClient.subscribe(streams, mediaType).forEach(function (i) {
        _this3.subscribeCallIds.push(i);

        _this3.report[_this3.testId].subscribeCallIds.push(i);
      });
    }
  };

  this.leaveSession = function () {
    logger.debug('leaveSession'); // Unsubscribing.

    if (this.streams !== undefined && typeof this.streams[0] === 'number') {
      this.webRTCClient.unsubscribe(this.streams[0]);
    }

    if (this.userMediastreamId !== null) {
      apiRTC.releaseUserMediaStream(this.userMediastreamId);
    }

    delete this.streams;
    delete this.subscribeCallIds; // Unpublishing.

    if (typeof this.publishCallId === 'string') {
      this.webRTCClient.unpublish(this.publishCallId);
    }

    delete this.publishCallId; // Leaving MCU session.

    if (this.mcuSession !== undefined && this.mcuSession.sessionId !== undefined) {
      this.webRTCClient.leaveMCUSession();
      delete this.mcuSession.sessionId;
    }

    delete this.mcuSession;
    apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.sessionMCUs.splice(0, apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.sessionMCUs.length);
    apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.joinSessionReqs.splice(0, apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.joinSessionReqs.length);
    logger.debug('leaveSession done');
  };

  this.runResolutionTest = function () {
    this.testId = 'resolution-test';
    this.stepId = 'resolution-test';
    myWebRTC_Event.createEvent({
      "eventType": "preCallTestStatus",
      "testId": this.testId,
      "status": 'start',
      "stepId": this.stepId
    });
    logger.debug('Run resolution test');
    this.startGetUserMedia(this.resolutions[this.currentResolution]);
  };

  this.startGetUserMedia = function (resolution) {
    logger.debug('startGetUserMedia :', resolution);
    var constraints = {
      audio: false,
      video: {}
    };
    constraints = apiCC.setVideoSourceIdInConstraint(this.videoSourceId, constraints);
    constraints = apiCC.setResolutionInConstraint(resolution[0], resolution[1], constraints);
    logger.debug('startGetUserMedia constraints:', constraints);
    apiCC.getUserMedia(constraints).then(function (stream) {
      if (this.resolutions.length > 1) {
        this.report.resolutions.push(resolution[2] + ':   ' + resolution[0] + 'x' + resolution[1]);
        this.maxWidth = resolution[0];
        this.maxHeight = resolution[1];
        stream.getTracks().forEach(function (track) {
          track.stop();
        });
        this.maybeContinueGetUserMedia();
      } else {
        logger.debug('No video track in returned stream.');
      }
    }.bind(this))["catch"](function (error) {
      logger.debug('startGetUserMedia catch error:', error);

      if (this.resolutions.length > 1) {
        logger.debug(resolution[0] + 'x' + resolution[1] + ' not supported');
      } else {
        logger.error('getUserMedia failed with error: ' + error.name);
      }

      this.maybeContinueGetUserMedia();
    }.bind(this));
  };

  this.maybeContinueGetUserMedia = function () {
    if (this.currentResolution === this.resolutions.length - 1) {
      //logger.error('Fin test Rso : this.resolutions : ', this.resolutions);
      this.startNextTest(); //this.terminate();
      //this.done();

      return;
    } else {
      this.currentResolution++;
      this.startGetUserMedia(this.resolutions[this.currentResolution]);
    }
  };
};



/***/ }),

/***/ "./src/Core/QoSMonitor.js":
/*!********************************!*\
  !*** ./src/Core/QoSMonitor.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QoSMonitor": () => (/* binding */ QoSMonitor)
/* harmony export */ });
/* jshint eqeqeq: false*/

/* globals MY_GLOBAL */
//TODO replace console.log
//TODO enlever jshint eqeqeq: false

/*
* This is the description for my class QoSMonitor.
* Class for QoS Monitoring
* @module QoSMonitor
*/

/*
Stats storage : Every this.interval qosScore, audioQosScore & videoQosScore are computed.
Every this.cptDb, 12 datasets are sent to ccs2 (node server) for archiving.
*/
var QoSMonitor = function QoSMonitor(interval, onQosChange, onQosAudioChange, onQosVideoChange, callId, apiKey, clientId, socket) {
  // holds the extracted values from getStat
  this.rawStats = {};
  this.rawStats.connectedPair = [];
  this.rawStats.audio_send = [];
  this.rawStats.audio_recv = [];
  this.rawStats.video_send = [];
  this.rawStats.video_recv = [];
  this.instantRTT = 0;
  this.moyRttCP = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  this.moyRttAS = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  this.moyRttVS = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  this.tauxPacketLossAS = [0];
  this.oldLostAS = this.oldSentAS = 0;
  this.oldLostVS = this.oldLostVS = 0;
  this.cptTaux = 0;
  this.tauxPacketLossVS = [0];
  this.oldBandwidthAS = 0;
  this.oldBandwidthVS = 0;
  this.oldBandwidthAR = 0;
  this.oldBandwidthVR = 0;
  this.bandwidthAS = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  this.bandwidthAR = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  this.bandwidthVS = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  this.bandwidthVR = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // Qos scores

  this.qosIn = 0;
  this.qosInAverage = 0;
  this.qosInAverageCount = 0;
  this.qosAudioIn = 0;
  this.qosAudioInAverage = 0;
  this.qosAudioInAverageCount = 0;
  this.qosVideoIn = 0;
  this.qosVideoInAverage = 0;
  this.qosVideoInAverageCount = 0;
  this.qosOut = 0;
  this.qosOutAverage = 0;
  this.qosOutAverageCount = 0;
  this.qosAudioOut = 0;
  this.qosAudioOutAverage = 0;
  this.qosAudioOutAverageCount = 0;
  this.qosVideoOut = 0;
  this.qosVideoOutAverage = 0;
  this.qosVideoOutAverageCount = 0; // callbacks

  this.onQosChange = onQosChange;
  this.onQosAudioChange = onQosAudioChange;
  this.onQosVideoChange = onQosVideoChange; // mongo storage

  this.cpt = 0;
  this.cptRes = 5; // save qos data locally every 5s

  this.cptDb = 60; // save to mongodb server every 60s

  this.saveStatsFlag = true;
  this.tabQosIn = [];
  this.tabQosAudioIn = [];
  this.tabQosVideoIn = [];
  this.tabQosOut = [];
  this.tabQosAudioOut = [];
  this.tabQosVideoOut = [];
  this.tabTimestamp = [];
  this.tabDelay = [];
  this.tabJitterBufferAudio = [];
  this.tabJitterBufferVideo = [];
  this.tabAudioRtt = [];
  this.tabVideoRtt = [];
  this.tabAudioBW = [];
  this.tabVideoBW = [];
  this.clientId = clientId;
  this.callId = callId;
  this.apiKey = apiKey;
  this.socket = socket;
  this.interval = interval; // Inserts the stats data from getStats() into the qosMonitor object
  // This is required to use getRawStat, getComputedStat et getIndex

  this.insertStats = function (statsTab, sdpLocal, sdpRemote, remoteVideoDiv) {
    // console.log('insertStats', statsTab, sdpLocal, sdpRemote, remoteVideoDiv);
    var i,
        j,
        k,
        names = null;
    this.cpt = this.cpt + this.interval;

    for (i = 0; i < statsTab.length; ++i) {
      var res = statsTab[i];

      switch (res.type) {
        case "googCandidatePair":
          // Candidate pair
          names = res.names();

          for (k = 0; k < names.length; ++k) {
            if (names[k] == "googActiveConnection" && res.stat(names[k]) == "true") {
              for (j = 0; j < names.length; ++j) {
                if (names[j] == "bytesSent" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.connectedPair.bytesSent = res.stat(names[j]);
                }

                if (names[j] == "bytesReceived" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.connectedPair.bytesReceived = res.stat(names[j]);
                }

                if (names[j] == "googRtt" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.connectedPair.googRtt = res.stat(names[j]);
                }
              }
            }
          }

          break;

        case "ssrc":
          names = res.names();

          for (k = 0; k < names.length; ++k) {
            if (names[k] == "audioOutputLevel") {
              // audio recv
              for (j = 0; j < names.length; ++j) {
                if (names[j] == "packetsLost" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.audio_recv.packetsLost = res.stat(names[j]);
                }

                if (names[j] == "googDecodingPLC" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.audio_recv.googDecodingPLC = res.stat(names[j]);
                }

                if (names[j] == "googJitterReceived" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.audio_recv.googJitterReceived = res.stat(names[j]);
                }

                if (names[j] == "googJitterBufferMs" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.audio_recv.googJitterBufferMs = res.stat(names[j]);
                }

                if (names[j] == "googCurrentDelayMs" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.audio_recv.googCurrentDelayMs = res.stat(names[j]);
                }

                if (names[j] == "bytesReceived" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.audio_recv.bytesReceived = res.stat(names[j]);
                }
              }
            }

            if (names[k] == "audioInputLevel") {
              // audio send
              for (j = 0; j < names.length; ++j) {
                if (names[j] == "googRtt" && typeof res.stat(names[j]) !== "undefined" && res.stat(names[j]) != -1) {
                  this.rawStats.audio_send.googRtt = res.stat(names[j]);
                }

                if (names[j] == "packetsLost" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.audio_send.packetsLost = res.stat(names[j]);
                }

                if (names[j] == "packetsSent" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.audio_send.packetsSent = res.stat(names[j]);
                }

                if (names[j] == "bytesSent" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.audio_send.bytesSent = res.stat(names[j]);
                }

                if (names[j] == "googJitterReceived" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.audio_send.googJitterReceived = res.stat(names[j]);
                }
              }
            }

            if (names[k] == "googFrameHeightReceived") {
              // video recv
              for (j = 0; j < names.length; ++j) {
                if (names[j] == "googFrameHeightReceived" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_recv.FrameHeight = res.stat(names[j]);
                }

                if (names[j] == "googFrameWidthReceived" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_recv.FrameWidth = res.stat(names[j]);
                }

                if (names[j] == "googCurrentDelayMs" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_recv.delay = res.stat(names[j]);
                }

                if (names[j] == "packetsLost" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_recv.packetsLost = res.stat(names[j]);
                }

                if (names[j] == "googNacksSent" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_recv.googNacksSent = res.stat(names[j]);
                }

                if (names[j] == "googJitterBufferMs" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_recv.googJitterBufferMs = res.stat(names[j]);
                }

                if (names[j] == "bytesReceived" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_recv.bytesReceived = res.stat(names[j]);
                }

                if (names[j] == "googFrameRateReceived" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_recv.googFrameRateReceived = res.stat(names[j]);
                }
              }
            }

            if (names[k] == "googFrameHeightSent") {
              // video send
              for (j = 0; j < names.length; ++j) {
                if (names[j] == "googFrameHeightSent" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_send.FrameHeight = res.stat(names[j]);
                }

                if (names[j] == "googFrameWidthSent" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_send.FrameWidth = res.stat(names[j]);
                }

                if (names[j] == "packetsLost" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_send.packetsLost = res.stat(names[j]);
                }

                if (names[j] == "googNacksReceived" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_send.googNacksReceived = res.stat(names[j]);
                }

                if (names[j] == "googRtt" && typeof res.stat(names[j]) !== "undefined" && res.stat(names[j]) != -1) {
                  this.rawStats.video_send.googRtt = res.stat(names[j]);
                }

                if (names[j] == "packetsSent" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_send.packetsSent = res.stat(names[j]);
                }

                if (names[j] == "bytesSent" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_send.bytesSent = res.stat(names[j]);
                } // statistics related to device performance


                if (names[j] == "googEncodeUsagePercent" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_send.googEncodeUsagePercent = res.stat(names[j]);
                }

                if (names[j] == "googCpuLimitedResolution" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_send.googCpuLimitedResolution = res.stat(names[j]);
                }

                if (names[j] == "googBandwidthLimitedResolution" && typeof res.stat(names[j]) !== "undefined") {
                  this.rawStats.video_send.googBandwidthLimitedResolution = res.stat(names[j]);
                }
              }
            }
          }

          break;
      }
    }

    this.computeStats(sdpLocal, sdpRemote, remoteVideoDiv);

    if (this.cpt % this.cptRes === 0) {
      this.saveStatsLocal();
    }

    if (this.cpt % this.cptDb === 0) {
      this.saveStatsToDb(false);
    }
  };
  /*
  Saves current stats in data arrays of the local object.
  */


  this.saveStatsLocal = function () {
    if (this.saveStatsFlag) {
      var now = Date.now();
      this.tabTimestamp.push(now);
      this.tabQosIn.push(this.qosIn);
      this.tabQosAudioIn.push(this.qosAudioIn);

      if (this.qosVideoIn !== 0) {
        this.tabQosVideoIn.push(this.qosVideoIn);
      }

      this.tabQosOut.push(this.qosOut);
      this.tabQosAudioOut.push(this.qosAudioOut);

      if (this.qosVideoOut !== 0) {
        this.tabQosVideoOut.push(this.qosVideoOut);
      } // Jitter


      this.tabJitterBufferAudio.push(this.rawStats.audio_recv.googJitterBufferMs);

      if (typeof this.rawStats.video_recv.googJitterBufferMs !== "undefined") {
        this.tabJitterBufferVideo.push(this.rawStats.video_recv.googJitterBufferMs);
      } // Round trip time


      if (typeof this.rawStats.video_send.googRtt !== "undefined") {
        this.tabVideoRtt.push(this.rawStats.video_send.googRtt);
      }

      this.tabAudioRtt.push(this.rawStats.audio_send.googRtt); // Bandwidth in kbits/s

      if (typeof this.bandwidthAS !== "undefined") {
        this.tabVideoBW.push(8 * this.Average(this.bandwidthAS) / 1024);
      }

      if (typeof this.bandwidthVS !== "undefined") {
        this.tabVideoBW.push(8 * this.Average(this.bandwidthVS) / 1024);
      }

      if (typeof this.bandwidthAR !== "undefined") {
        this.tabVideoBW.push(8 * this.Average(this.bandwidthAR) / 1024);
      }

      if (typeof this.bandwidthVR !== "undefined") {
        this.tabVideoBW.push(8 * this.Average(this.bandwidthVR) / 1024);
      }
    }
  };
  /*
  saves local stats to mongodb through ccs server.
  */


  this.saveStatsToDb = function (isCallEnded) {
    return; //disable save cdr for now

    /*
            console.log("saveStatsToDb - callEnded:"+ isCallEnded);
    
            var messageToSend = null,
                msgString = null;
            if (this.tabQosVideoIn.length != 0) {
                messageToSend = {
                    clientId: this.clientId,
                    callId: this.callId,
                    apiKey: this.apiKey,
                    tabTimestamp: this.tabTimestamp,
                    tabQosIn: this.tabQosIn,
                    tabQosOut: this.tabQosOut,
                    tabQosAudioIn: this.tabQosAudioIn,
                    tabQosVideoIn: this.tabQosVideoIn,
                    tabQosAudioOut: this.tabQosAudioOut,
                    tabQosVideoOut: this.tabQosVideoOut,
                    tabJitterBufferAudio: this.tabJitterBufferAudio,
                    tabJitterBufferVideo: this.tabJitterBufferVideo,
                    tabAudioRtt: this.tabAudioRtt,
                    tabVideoRtt: this.tabVideoRtt,
                    tabAudioBW: this.tabAudioBW,
                    tabVideoBW: this.tabVideoBW
                };
            } else { // audio only
                messageToSend = {
                    clientId: this.clientId,
                    callId: this.callId,
                    tabTimestamp: this.tabTimestamp,
                    apiKey: this.apiKey,
                    tabQosIn: this.tabQosIn,
                    tabQosOut: this.tabQosOut,
                    tabQosAudioIn: this.tabQosAudioIn,
                    tabQosAudioOut: this.tabQosAudioOut,
                    tabJitterBufferAudio: this.tabJitterBufferAudio,
                    tabAudioRtt: this.tabAudioRtt,
                    tabAudioBW: this.tabAudioBW
                };
            }
            msgString = JSON.stringify(messageToSend);
            this.socket.emit('stats', msgString);
    
            this.tabTimestamp = [];
            this.tabQosIn = [];
            this.tabQosAudioIn = [];
            this.tabQosVideoIn = [];
            this.tabQosOut = [];
            this.tabQosAudioOut = [];
            this.tabQosVideoOut = [];
            this.tabAudioRtt = [];
            this.tabVideoRtt = [];
            this.tabAudioBW = [];
            this.tabVideoBW = [];
            this.tabJitterBufferAudio = [];
            this.tabJitterBufferVideo = [];
    
    
            // if call is ended, compute Qos averages and send them
            if (isCallEnded) {
                messageToSend = null;
                msgString = null;
                messageToSend = {
                    clientId : this.clientId,
                    callId: this.callId,
                    qosInAverage: Math.ceil(this.qosInAverage),
                    qosOutAverage: Math.ceil(this.qosOutAverage),
                    qosAudioInAverage: Math.ceil(this.qosAudioInAverage),
                    qosVideoInAverage: Math.ceil(this.qosVideoInAverage),
                    qosVideoOutAverage: Math.ceil(this.qosVideoOutAverage),
                    qosAudioOutAverage: Math.ceil(this.qosAudioOutAverage)
                };
                msgString = JSON.stringify(messageToSend);
                this.socket.emit('statsAverage', msgString);
            }
    */
  };

  this.saveStatsToDb = function (bool) {
    this.saveStatsFlag = bool;
  }; // computeStats(sdpLocal,sdpRemote,remoteVideoDiv)
  // compute stats averages


  this.computeStats = function (sdpLocal, sdpRemote, remoteVideoDiv) {
    var lossRate = 0;

    if (this.rawStats.connectedPair.googRtt !== -1 && this.rawStats.connectedPair.googRtt !== 0 && typeof this.rawStats.connectedPair.googRtt !== "undefined") {
      this.add(this.rawStats.connectedPair.googRtt, this.moyRttCP);
    }

    if (this.rawStats.video_send.googRtt !== -1 && this.rawStats.video_send.googRtt !== 0 && typeof this.rawStats.video_send.googRtt !== "undefined") {
      this.add(this.rawStats.video_send.googRtt, this.moyRttVS);
      this.instantRTT = this.rawStats.video_send.googRtt;
    }

    if (this.rawStats.audio_send.googRtt !== -1 && this.rawStats.audio_send.googRtt !== 0 && typeof this.rawStats.audio_send.googRtt !== "undefined") {
      this.add(this.rawStats.audio_send.googRtt, this.moyRttAS);
    } //if (this.cptTaux == 4) {
    //   this.cptTaux = 0;


    if (this.rawStats.audio_send.packetsLost !== -1 && typeof this.rawStats.audio_send.packetsLost !== "undefined" && this.rawStats.audio_send.packetsSent !== -1 && this.rawStats.audio_send.packetsSent !== 0 && typeof this.rawStats.audio_send.packetsSent !== "undefined") {
      //console.log("Lost/Sent: " + this.rawStats.audio_send.packetsLost + "/" + this.rawStats.audio_send.packetsSent)
      //var lossRate = ((100 * this.rawStats.audio_send.packetsLost) / this.rawStats.audio_send.packetsSent);
      lossRate = 100 * (this.rawStats.audio_send.packetsLost - this.oldLostAS) / (this.rawStats.audio_send.packetsSent - this.oldSentAS);
      this.oldLostAS = this.rawStats.audio_send.packetsLost;
      this.oldSentAS = this.rawStats.audio_send.packetsSent; //console.log("LossRate " + lossRate);

      this.add(lossRate, this.tauxPacketLossAS);
    } else {//console.log("AS Can't compute loss with Lost/Sent: " + this.rawStats.audio_send.packetsLost + "/" + this.rawStats.audio_send.packetsSent)
    }

    if (this.rawStats.video_send.packetsLost !== -1 && typeof this.rawStats.video_send.packetsLost !== "undefined" && this.rawStats.video_send.packetsSent !== -1 && this.rawStats.video_send.packetsSent !== 0 && typeof this.rawStats.video_send.packetsSent !== "undefined") {
      //var lossRate = ((100 * this.rawStats.video_send.packetsLost) / this.rawStats.video_send.packetsSent);
      lossRate = 100 * (this.rawStats.video_send.packetsLost - this.oldLostVS) / (this.rawStats.video_send.packetsSent - this.oldSentVS);
      this.oldLostVS = this.rawStats.video_send.packetsLost;
      this.oldSentVS = this.rawStats.video_send.packetsSent; //console.log("LossRate " + lossRate);

      this.add(lossRate, this.tauxPacketLossVS);
    } else {//console.log("VS Can't compute loss with Lost/Sent: " + this.rawStats.video_send.packetsLost + "/" + this.rawStats.video_send.packetsSent)
    } //} else {
    //  this.cptTaux++;
    //}
    // Calcul du dbit instantan sur 1s : ATTENTION dpend de la frquence d'appel de insertStats


    if (this.rawStats.audio_recv.bytesReceived !== -1 && typeof this.rawStats.audio_recv.bytesReceived !== "undefined") {
      if (typeof this.oldBandwidthAR === "undefined") {
        this.oldBandwidthAR = 0;
      }

      this.add((this.rawStats.audio_recv.bytesReceived - this.oldBandwidthAR) / this.interval, this.bandwidthAR);
      this.oldBandwidthAR = this.rawStats.audio_recv.bytesReceived;
    } // Calcul du dbit instantan sur 1s : ATTENTION dpend de la frquence d'appel de insertStats


    if (this.rawStats.video_recv.bytesReceived !== -1 && typeof this.rawStats.video_recv.bytesReceived !== "undefined") {
      if (typeof this.oldBandwidthVR === "undefined") {
        this.oldBandwidthVR = 0;
      }

      this.add((this.rawStats.video_recv.bytesReceived - this.oldBandwidthVR) / this.interval, this.bandwidthVR);
      this.oldBandwidthVR = this.rawStats.video_recv.bytesReceived;
    } // Calcul du dbit instantan sur 1s : ATTENTION dpend de la frquence d'appel de insertStats


    if (this.rawStats.audio_send.bytesSent !== -1 && typeof this.rawStats.audio_send.bytesSent !== "undefined") {
      if (typeof this.oldBandwidthAS === "undefined") {
        this.oldBandwidthAS = 0;
      }

      this.add((this.rawStats.audio_send.bytesSent - this.oldBandwidthAS) / this.interval, this.bandwidthAS);
      this.oldBandwidthAS = this.rawStats.audio_send.bytesSent;
    } // Calcul du dbit instantan sur 1s : ATTENTION dpend de la frquence d'appel de insertStats


    if (this.rawStats.video_send.bytesSent !== -1 && typeof this.rawStats.video_send.bytesSent !== "undefined") {
      if (typeof this.oldBandwidthVS === "undefined") {
        this.oldBandwidthVS = 0;
      }

      this.add((this.rawStats.video_send.bytesSent - this.oldBandwidthVS) / this.interval, this.bandwidthVS);
      this.oldBandwidthVS = this.rawStats.video_send.bytesSent;
    } // compute Qos Indexes


    var audioInBwIndex = 0;
    var audioInJitterIndex = 0;
    var audioInDelayIndex = 0;
    var videoInBwIndex = 0;
    var videoInJitterIndex = 0;
    var audioOutLossIndex = 0;
    var audioOutDelayIndex = 0;
    var audioOutJitterIndex = 0;
    var videoOutLossIndex = 0;
    var videoOutDelayIndex = 0;
    var remoteCodecs = this.getCodecs(sdpRemote); //console.log("audio codec :"+remoteCodecs[0]+" video codec"+remoteCodecs[1]);
    // DOWNLINK
    // Audio
    // opus codec
    // bitrate : 6 kbits/s to 510 kbits/s

    var AudioBandwidth = 8 * this.Average(this.bandwidthAS) / 1024;

    if (AudioBandwidth < 5) {
      audioInBwIndex = 1;
    } else if (AudioBandwidth >= 5 && AudioBandwidth < 10) {
      audioInBwIndex = 2;
    } else if (AudioBandwidth >= 10) {
      audioInBwIndex = 3;
    } // Video
    // vp8 bitrate : 100 kbits/s to 2000 kbits/s
    // 720p@30fps, 1.2 Mbps
    // 360p@30fps, 500 kbps
    // 180p@30fps, 100 kbps


    if (remoteCodecs !== null && !!remoteCodecs[1]) {
      var videoBandwidth = 8 * this.Average(this.bandwidthVS) / 1024; // var videoHeight = remoteVideoDiv.offsetHeight;
      // var videoWidth = remoteVideoDiv.offsetWidth;
      //console.log("Remote video "+videoWidth+"x"+videoHeight);
      // if (remoteCodecs[1].indexOf("VP8") != -1) {getCodec
      //     if (videoHeight < 360) { // 180 to 360p
      //         expectedVideoBandwidth = 100;
      //     } else if (videoHeight >= 360 && videoHeight < 720) {
      //         expectedVideoBandwidth = 300;
      //     } else if (videoHeight >= 720) {
      //         expectedVideoBandwidth = 1000;
      //     }
      // } else {
      //     console.log("Unknow video codec :" + remoteCodecs[1]);
      // }

      var expectedVideoBandwidth = 300; //FIXME resolution must be detected on video stats
      //console.log("Expected Video bandwidth :"+expectedVideoBandwidth);

      if (videoBandwidth < expectedVideoBandwidth * 0.8) {
        videoInBwIndex = 1;
      } else if (videoBandwidth >= expectedVideoBandwidth * 0.8 && videoBandwidth < expectedVideoBandwidth * 1.1) {
        videoInBwIndex = 2;
      } else if (videoBandwidth >= expectedVideoBandwidth * 1.1) {
        videoInBwIndex = 3;
      }
    }

    if (this.rawStats.audio_recv.googJitterBufferMs < 60) {
      audioInJitterIndex = 3;
    } else if (this.rawStats.audio_recv.googJitterBufferMs >= 60 && this.rawStats.audio_recv.googJitterBufferMs < 100) {
      audioInJitterIndex = 2;
    } else if (this.rawStats.audio_recv.googJitterBufferMs >= 100) {
      audioInJitterIndex = 1;
    }

    if (this.rawStats.audio_recv.googCurrentDelayMs < 100) {
      audioInDelayIndex = 3;
    } else if (this.rawStats.audio_recv.googCurrentDelayMs >= 100 && this.rawStats.audio_recv.googCurrentDelayMs < 200) {
      audioInDelayIndex = 2;
    } else if (this.rawStats.audio_recv.googCurrentDelayMs >= 200) {
      audioInDelayIndex = 1;
    }

    if (remoteCodecs !== null && !!remoteCodecs[1]) {
      if (this.rawStats.video_recv.googJitterBufferMs < 100) {
        videoInJitterIndex = 3;
      } else if (this.rawStats.video_recv.googJitterBufferMs >= 100 && this.rawStats.video_recv.googJitterBufferMs < 200) {
        videoInJitterIndex = 2;
      } else if (this.rawStats.video_recv.googJitterBufferMs >= 200) {
        videoInJitterIndex = 1;
      }
    }

    var notifyQosChange = false;
    var notifyQosAudioChange = false;
    var notifyQosVideoChange = false;

    if (remoteCodecs !== null && !!remoteCodecs[1]) {
      //console.log("audioInBwIndex " + audioInBwIndex + "videoInBwIndex" + videoInBwIndex + "videoInJitterIndex" + videoInJitterIndex + "audioInJitterIndex" + audioInJitterIndex + "audioInDelayIndex" + audioInDelayIndex);
      if (Math.ceil((audioInBwIndex + 2 * videoInBwIndex + videoInJitterIndex + audioInJitterIndex + audioInDelayIndex) / 6) != this.qosIn) {
        notifyQosChange = true;
      }

      this.qosIn = Math.ceil((audioInBwIndex + 2 * videoInBwIndex + videoInJitterIndex + audioInJitterIndex + audioInDelayIndex) / 6);
      this.qosInAverage = (this.qosInAverage * this.qosInAverageCount + this.qosIn) / (this.qosInAverageCount + 1);
      this.qosInAverageCount++;

      if (Math.ceil((audioInBwIndex + audioInJitterIndex + audioInDelayIndex) / 3) != this.qosAudioIn) {
        notifyQosAudioChange = true;
      }

      this.qosAudioIn = Math.ceil((audioInBwIndex + audioInJitterIndex + audioInDelayIndex) / 3);
      this.qosAudioInAverage = (this.qosAudioInAverage * this.qosAudioInAverageCount + this.qosAudioIn) / (this.qosAudioInAverageCount + 1);
      this.qosAudioInAverageCount++;

      if (Math.ceil((2 * videoInBwIndex + videoInJitterIndex) / 3) != this.qosVideoIn) {
        notifyQosVideoChange = true;
      }

      this.qosVideoIn = Math.ceil((2 * videoInBwIndex + videoInJitterIndex) / 3);
      this.qosVideoInAverage = (this.qosVideoInAverage * this.qosVideoInAverageCount + this.qosVideoIn) / (this.qosVideoInAverageCount + 1);
      this.qosVideoInAverageCount++;
    } else {
      // audio only
      //console.log("audioInBwIndex " + audioInBwIndex + "audioInJitterIndex" + audioInJitterIndex + "audioInDelayIndex" + audioInDelayIndex);
      if (Math.ceil((audioInBwIndex + audioInJitterIndex + audioInDelayIndex) / 3) != this.qosOut) {
        notifyQosChange = true;
      }

      this.qosIn = Math.ceil((audioInBwIndex + audioInJitterIndex + audioInDelayIndex) / 3);
      this.qosInAverage = (this.qosInAverage * this.qosInAverageCount + this.qosIn) / (this.qosInAverageCount + 1);
      this.qosInAverageCount++;

      if (Math.ceil((audioInBwIndex + audioInJitterIndex + audioInDelayIndex) / 3) != this.qosAudioIn) {
        notifyQosAudioChange = true;
      }

      this.qosAudioIn = Math.ceil((audioInBwIndex + audioInJitterIndex + audioInDelayIndex) / 3);
      this.qosAudioInAverage = (this.qosAudioInAverage * this.qosAudioInAverageCount + this.qosAudioIn) / (this.qosAudioInAverageCount + 1);
      this.qosAudioInAverageCount++;
    } // UPLINK
    // audio


    if (this.RttAverage(this.moyRttAS) < 80) {
      audioOutDelayIndex = 3;
    } else if (this.RttAverage(this.moyRttAS) >= 80 && this.RttAverage(this.moyRttAS) < 150) {
      audioOutDelayIndex = 2;
    } else if (this.RttAverage(this.moyRttAS) >= 150) {
      audioOutDelayIndex = 1;
    }

    if (this.tauxPacketLossAS <= 5) {
      audioOutLossIndex = 3;
    } else if (this.tauxPacketLossAS > 5 && this.tauxPacketLossAS < 10) {
      audioOutLossIndex = 2;
    } else if (this.tauxPacketLossAS >= 10) {
      audioOutLossIndex = 1;
    }

    if (this.rawStats.audio_recv.googJitterReceived < 80) {
      audioOutJitterIndex = 3;
    } else if (this.rawStats.audio_recv.googJitterReceived >= 80 && this.rawStats.audio_recv.googJitterReceived < 150) {
      audioOutJitterIndex = 2;
    } else if (this.rawStats.audio_recv.googJitterReceived >= 150) {
      audioOutJitterIndex = 1;
    } // video


    if (remoteCodecs !== null && !!remoteCodecs[1]) {
      if (this.tauxPacketLossVS <= 5) {
        videoOutLossIndex = 3;
      } else if (this.tauxPacketLossVS > 5 && this.tauxPacketLossVS < 10) {
        videoOutLossIndex = 2;
      } else if (this.tauxPacketLossVS >= 10) {
        videoOutLossIndex = 1;
      }

      if (this.RttAverage(this.moyRttVS) < 80) {
        videoOutDelayIndex = 3;
      } else if (this.RttAverage(this.moyRttVS) >= 80 && this.RttAverage(this.moyRttVS) < 150) {
        videoOutDelayIndex = 2;
      } else if (this.RttAverage(this.moyRttVS) >= 150) {
        videoOutDelayIndex = 1;
      }
    } // qos computing


    if (remoteCodecs !== null && !!remoteCodecs[1]) {
      //console.log("audioOutDelayIndex" + audioOutDelayIndex + "audioOutLossIndex" + audioOutLossIndex + "audioOutJitterIndex" + audioOutJitterIndex + "videoOutLossIndex" + videoOutLossIndex + "videoOutDelayIndex" + videoOutDelayIndex);
      if (Math.ceil((audioOutDelayIndex + 2 * audioOutLossIndex + audioOutJitterIndex + 2 * videoOutLossIndex + videoOutDelayIndex) / 7) != this.qosOut) {
        notifyQosChange = true;
      }

      this.qosOut = Math.ceil((audioOutDelayIndex + 2 * audioOutLossIndex + audioOutJitterIndex + 2 * videoOutLossIndex + videoOutDelayIndex) / 7);
      this.qosOutAverage = (this.qosOutAverage * this.qosOutAverageCount + this.qosOut) / (this.qosOutAverageCount + 1);
      this.qosOutAverageCount++;

      if (Math.ceil((audioOutDelayIndex + 2 * audioOutLossIndex + audioOutJitterIndex) / 4) != this.qosAudioOut) {
        notifyQosAudioChange = true;
      }

      this.qosAudioOut = Math.ceil((audioOutDelayIndex + 2 * audioOutLossIndex + audioOutJitterIndex) / 4);
      this.qosAudioOutAverage = (this.qosAudioOutAverage * this.qosAudioOutAverageCount + this.qosAudioOut) / (this.qosAudioOutAverageCount + 1);
      this.qosAudioOutAverageCount++;

      if (Math.ceil((2 * videoOutLossIndex + videoOutDelayIndex) / 3) != this.qosVideoOut) {
        notifyQosVideoChange = true;
      }

      this.qosVideoOut = Math.ceil((2 * videoOutLossIndex + videoOutDelayIndex) / 3);
      this.qosVideoOutAverage = (this.qosVideoOutAverage * this.qosVideoOutAverageCount + this.qosVideoOut) / (this.qosVideoOutAverageCount + 1);
      this.qosVideoOutAverageCount++;
    } else {
      // audio only
      //console.log("audioOutDelayIndex" + audioOutDelayIndex + "audioOutLossIndex" + audioOutLossIndex + "audioOutJitterIndex" + audioOutJitterIndex);
      if (Math.ceil((audioOutDelayIndex + 2 * audioOutLossIndex + audioOutJitterIndex) / 4) != this.qosOut) {
        notifyQosChange = true;
      }

      this.qosOut = Math.ceil((audioOutDelayIndex + 2 * audioOutLossIndex + audioOutJitterIndex) / 4);
      this.qosOutAverage = (this.qosOutAverage * this.qosOutAverageCount + this.qosOut) / (this.qosOutAverageCount + 1);
      this.qosOutAverageCount++;

      if (Math.ceil((audioOutDelayIndex + 2 * audioOutLossIndex + audioOutJitterIndex) / 4) != this.qosAudioOut) {
        notifyQosAudioChange = true;
      }

      this.qosAudioOut = Math.ceil((audioOutDelayIndex + 2 * audioOutLossIndex + audioOutJitterIndex) / 4);
      this.qosAudioOutAverage = (this.qosAudioOutAverage * this.qosAudioOutAverageCount + this.qosAudioOut) / (this.qosAudioOutAverageCount + 1);
      this.qosAudioOutAverageCount++;
    }

    if (notifyQosChange) {
      this.onQosChange(this.qosIn, this.qosOut); //notifyQosChange = false;
    }

    if (notifyQosAudioChange) {
      this.onQosAudioChange(this.qosAudioIn, this.qosAudioOut); //notifyQosAudioChange = false;
    }

    if (notifyQosVideoChange) {
      this.onQosVideoChange(this.qosVideoIn, this.qosVideoOut); //notifyQosVideoChange = false;
    }
    /*console.log("Audio IN:" + this.qosAudioIn + " Video IN:" + this.qosVideoIn + " Audio OUT:" + this.qosAudioOut + " Video OUT:" + this.qosVideoOut);
    console.log("IN:" + this.qosMonitorIn + "OUT:" + this.qosMonitorOut);
    */

  }; // extracts audio/video codec from sdp


  this.getCodecs = function (sdp) {
    var flagAudio = false;
    var flagVideo = false;
    var audioCodec = null;
    var videoCodec = null;

    if (sdp !== null && typeof sdp !== 'undefined' && typeof sdp.sdp !== 'undefined') {
      var sdpContent = sdp.sdp;
      var lignes = sdpContent.split("\n");

      for (var i = 0; i < lignes.length; i++) {
        // dbut section audio
        if (lignes[i].indexOf("a=mid:audio") != -1) {
          flagAudio = true;
        } // video section start


        if (lignes[i].indexOf("a=mid:video") != -1) {
          flagVideo = true;
        }

        if (flagAudio) {
          if (lignes[i].indexOf("a=rtpmap:") != -1) {
            audioCodec = lignes[i];
            flagAudio = false;
          }
        }

        if (flagVideo) {
          if (lignes[i].indexOf("a=rtpmap:") != -1) {
            videoCodec = lignes[i];
            flagVideo = false;
          }
        }
      }

      return [audioCodec, videoCodec];
    }

    return null;
  }; // Return 6 qos indicators : uplink A/V, downlink A/V and uplink&downlink
  // qosMonitorIn,qosMonitorOut,qosAudioIn,qosAudioOut,qosVideoIn,qosVideoOut
  // qos = {1,2,3}
  // 1 : unsuable or lost connection
  // 2 : perturbations are perceptible but communication is possible
  // 3 : good or perfect connection


  this.getQosScore = function () {
    return [this.qosIn, this.qosOut, this.qosAudioIn, this.qosAudioOut, this.qosVideoIn, this.qosVideoOut];
  };
  /*
  getStat(statName)
  Returns a specific stat, statName should be one of the following :
  AudioInBandwidth, VideoInBandwidth, AudioInJitterReceived, AudioInJitterBufferMs, AudioInDelay, AudioOutLossRate
  AudioOutRtt, AudioOutJitterReceived, AudioOutJitterReceived, VideoInJitterBufferMs, VideoOutLossRate, VideoOutRtt
  */


  this.getStat = function (statName) {
    switch (statName) {
      case "AudioOutBandwidth":
        return 8 * this.Average(this.bandwidthAS) / 1024;
      //break;

      case "VideoOutBandwidth":
        return 8 * this.Average(this.bandwidthVS) / 1024;
      //break;

      case "AudioInBandwidth":
        return 8 * this.Average(this.bandwidthAR) / 1024;
      //break;

      case "VideoInBandwidth":
        return 8 * this.Average(this.bandwidthVR) / 1024;
      //break;

      case "AudioInJitterReceived":
        return this.rawStats.audio_recv.googJitterReceived;
      //break;

      case "AudioInJitterBufferMs":
        return this.rawStats.audio_recv.googJitterBufferMs;
      //break;

      case "AudioInDelay":
        return this.rawStats.audio_recv.googCurrentDelayMs;
      //break;

      case "AudioOutLossRate":
        return this.tauxPacketLossAS;
      //break;

      case "AudioOutRtt":
        return this.RttAverage(this.moyRttAS);
      //break;

      case "AudioOutJitterReceived":
        return this.rawStats.audio_send.googJitterReceived;
      //break;

      case "VideoInJitterBufferMs":
        return this.rawStats.video_recv.googJitterBufferMs;
      //break;

      case "VideoOutLossRate":
        return this.tauxPacketLossVS;
      //break;

      case "VideoOutRtt":
        return this.RttAverage(this.moyRttVS);
      //break;
    }
  };
  /*
  getAllStats()
  Returns all of qosMonitor stats in an object divided between the following properties :
  AudioRecv VideoRecv AudioSend VideoSend
  */


  this.getAllStats = function () {
    var stats = {
      AudioRecv: {},
      AudioSend: {},
      VideoRecv: {},
      VideoSend: {}
    };
    var statTypes = {
      AudioRecv: "audio_recv",
      VideoRecv: "video_recv",
      AudioSend: "audio_send",
      VideoSend: "video_send"
    };
    var statKeys = Object.keys(statTypes); //adding raw stats first

    for (var i = 0; i < statKeys.length; i++) {
      var keys = Object.keys(this.rawStats[statTypes[statKeys[i]]]);

      for (var j = 0; j < keys.length; j++) {
        stats[statKeys[i]][keys[j]] = this.rawStats[statTypes[statKeys[i]]][keys[j]];
      }
    }

    stats.AudioRecv.bandwidth = 8 * this.Average(this.bandwidthAR) / 1024;
    stats.VideoRecv.bandwidth = 8 * this.Average(this.bandwidthVR) / 1024;
    stats.AudioSend.bandwidth = 8 * this.Average(this.bandwidthAS) / 1024;
    stats.VideoSend.bandwidth = 8 * this.Average(this.bandwidthVS) / 1024;
    stats.AudioRecv.jitterReceived = this.rawStats.audio_recv.googJitterReceived;
    stats.AudioRecv.jitterBufferMs = this.rawStats.audio_recv.googJitterBufferMs;
    stats.VideoRecv.jitterBufferMs = this.rawStats.video_recv.googJitterBufferMs;
    stats.AudioRecv.delay = this.rawStats.audio_recv.googCurrentDelayMs;
    stats.AudioSend.rtt = this.RttAverage(this.moyRttAS);
    stats.VideoSend.moyRtt = this.RttAverage(this.moyRttVS);
    stats.VideoSend.rtt = this.instantRTT;
    stats.VideoSend.FrameHeight = this.rawStats.video_send.FrameHeight;
    stats.VideoSend.FrameWidth = this.rawStats.video_send.FrameWidth;
    stats.AudioSend.packetLostRatio = this.tauxPacketLossAS[this.tauxPacketLossAS.length - 1];
    stats.VideoSend.packetLostRatio = this.tauxPacketLossVS[this.tauxPacketLossVS.length - 1];
    stats.VideoSend.googEncodeUsagePercent = this.rawStats.video_send.googEncodeUsagePercent;
    stats.VideoSend.googCpuLimitedResolution = this.rawStats.video_send.googCpuLimitedResolution;
    stats.VideoSend.googBandwidthLimitedResolution = this.rawStats.video_send.googBandwidthLimitedResolution;
    /*
    stats.VideoRecv.bitsReceivedPerSecond = this.rawStats.video_recv["bitsReceivedPerSecond"];
    stats.VideoSend.bitsSentPerSecond = this.rawStats.video_send["bitsSentPerSecond"];
    stats.AudioRecv.bitsReceivedPerSecond = this.rawStats.audio_recv["bitsReceivedPerSecond"];
    stats.AudioSend.bitsSentPerSecond = this.rawStats.audio_send["bitsSentPerSecond"];
    */
    //delete redundant stats

    delete stats.AudioRecv.googCurrentDelayMs;
    delete stats.AudioRecv.googJitterReceived;
    delete stats.AudioRecv.googJitterBufferMs;
    delete stats.VideoRecv.googJitterBufferMs;
    delete stats.AudioSend.googRtt;
    delete stats.VideoSend.googRtt;
    return stats;
  }; // display all computed stats to the console


  this.displayComputedStats = function () {
    console.log("Audio IN JitterReceived:" + this.rawStats.audio_recv.googJitterReceived + " jitterbufferMs:" + this.rawStats.audio_recv.googJitterBufferMs + " delay:" + this.rawStats.audio_recv.googCurrentDelayMs + " bandwidth :" + 8 * this.Average(this.bandwidthAS) / 1024 + " kBits/s");
    console.log("Audio OUT  lossRate:" + this.tauxPacketLossAS + " rtt:" + this.RttAverage(this.moyRttAS) + " googJitterReceived:" + this.rawStats.audio_recv.googJitterReceived);
    console.log("Video IN jitter buffer ms:" + this.rawStats.video_recv.googJitterBufferMs + " bandwidth:" + 8 * this.Average(this.bandwidthVS) / 1024 + " kBits/s");
    console.log("Video OUT loss rate:" + this.tauxPacketLossVS + " rtt:" + this.RttAverage(this.moyRttVS));
  }; // Average computation without 0 values


  this.RttAverage = function (tab) {
    var sum = 0;
    var i = 0;

    for (var k = 0; k < tab.length; ++k) {
      if (tab[k] !== 0 && tab[k] !== -1 && typeof tab[k] !== "undefined") {
        sum += parseInt(tab[k], 10);
        i++;
      }
    }

    return parseInt(sum / i, 10);
  }; // Average computation


  this.Average = function (tab) {
    var sum = 0;
    var i = 0;

    for (var k = 0; k < tab.length; ++k) {
      if (tab[k] != -1 && typeof tab[k] !== "undefined") {
        sum += parseInt(tab[k], 10);
        i++;
      }
    }

    return parseInt(sum / i, 10);
  };

  this.add = function (num, tab) {
    tab.pop();
    tab.unshift(num);
  };

  this.displayTab = function (tab) {
    for (var key in tab) {
      console.log(key + " = " + tab[key]);
    }
  };
};



/***/ }),

/***/ "./src/Core/RecordManager.js":
/*!***********************************!*\
  !*** ./src/Core/RecordManager.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RecordManager": () => (/* binding */ RecordManager)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('RecordManager');


/*
* This is the RecordManager
*
* @module RecordManager
*/

var RecordManager = function RecordManager() {
  logger.debug('RecordManager creation');
  this.mediaRecorder = null;
  this.recordedBlobs = [];
  this.mimeType = null;

  this.record = function (stream, options) {
    var _this = this;

    logger.info("record");
    logger.log("stream :" + stream);
    logger.log("stream :", stream);
    return new Promise(function (resolve, reject) {
      var selectedContentType = null;

      if (MediaRecorder === undefined) {
        logger.debug("MediaRecorder is not supported on this browser, leaving recordStream process");
        reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, 'MediaRecorder is not supported on this browser, leaving recordStream process', logger));
        return;
      }

      if (stream === null) {
        logger.debug("Stream has no data, cannot record");
        reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, "Stream has no data, cannot record", logger));
        return;
      }

      if (_this.mediaRecorder !== null) {
        logger.log("this.mediaRecorder.state :" + _this.mediaRecorder.state); //inactive, recording, or paused.

        if (_this.mediaRecorder.state === 'recording' || _this.mediaRecorder.state === 'paused') {
          logger.log("mediaRecorder is already ongoing, use stopRecordStream before trying another record"); //inactive, recording, or paused.

          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, 'mediaRecorder is already ongoing, use stopRecordStream before trying another record', logger));
          return;
        }
      }

      logger.debug('checking MediaRecorderOptions mimeType support');

      if (options !== null && options !== undefined) {
        logger.debug('options is defined :', options);

        if (options.mimeType !== null && options.mimeType !== undefined) {
          logger.debug('contentType is defined :', options.mimeType);

          if (MediaRecorder.isTypeSupported(options.mimeType)) {
            selectedContentType = options.mimeType;
          }
        }
      } else {
        options = {};
      }

      if (selectedContentType === null) {
        var contentTypeOptions = 'video/webm;codecs=vp8,opus';

        if (!MediaRecorder.isTypeSupported(contentTypeOptions)) {
          logger.debug(contentTypeOptions + ' is not Supported');
          contentTypeOptions = 'video/webm;codecs=vp9,opus';

          if (!MediaRecorder.isTypeSupported(contentTypeOptions)) {
            logger.debug(contentTypeOptions + ' is not Supported');
            contentTypeOptions = 'video/webm';

            if (!MediaRecorder.isTypeSupported(contentTypeOptions)) {
              logger.debug(contentTypeOptions + ' is not Supported');
              contentTypeOptions = '';
            }
          }
        }

        options.mimeType = contentTypeOptions;
      }

      _this.mimeType = options.mimeType;
      logger.debug('Start record with MediaRecorderOptions :', options);

      try {
        _this.recordedBlobs = [];
        _this.mediaRecorder = new MediaRecorder(stream, options);
      } catch (e) {
        logger.error('Exception while creating MediaRecorder: ' + e + '. mimeType: ' + options.mimeType);
        reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, 'Exception while creating MediaRecorder: ' + e + '. mimeType: ' + options.mimeType, logger));
        return;
      } //Adding mediaRecorder event handler


      _this.mediaRecorder.onstart = function (e) {
        logger.log("onstart :" + e);
        this.onerror = null;
        resolve();
      };

      _this.mediaRecorder.ondataavailable = function (e) {
        //logger.log("ondataavailable :" + e);
        //logger.log("this.mediaRecorder.mimeType :" + this.mimeType);
        //logger.log("this.mediaRecorder.audioBitsPerSecond :" + this.audioBitsPerSecond);
        //logger.log("this.mediaRecorder.videoBitsPerSecond :" + this.videoBitsPerSecond);
        if (e.data && e.data.size > 0) {
          apiCC.recordMgr.recordedBlobs.push(e.data);
        }
      };

      _this.mediaRecorder.onerror = function (e) {
        logger.log("onerror :" + e);
        reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, 'mediaRecorder error :' + e, logger));
        this.onerror = null;
      };

      _this.mediaRecorder.start(10); // collect 10ms of data


      logger.log('MediaRecorder started', _this.mediaRecorder);
    });
  };

  this.stop = function () {
    var _this2 = this;

    logger.info("stop");
    return new Promise(function (resolve, reject) {
      _this2.mediaRecorder.onstop = function (e) {
        logger.log("mediaRecorder onstop :" + e);
        this.onstart = null;
        this.onstop = null;
        this.onerror = null;
        this.onpause = null;
        this.onresume = null;
        this.ondataavailable = null;
        var blob = new Blob(apiCC.recordMgr.recordedBlobs, {
          type: this.mimeType
        });
        resolve(blob);
      };

      if (MediaRecorder === undefined) {
        logger.debug("MediaRecorder is not supported on this browser, leaving recordStream process");
        reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, 'MediaRecorder is not supported on this browser, leaving recordStream process', logger));
        return;
      }

      if (_this2.mediaRecorder !== null) {
        logger.log("this.mediaRecorder.state :" + _this2.mediaRecorder.state); //inactive, recording, or paused.

        if (_this2.mediaRecorder.state === 'inactive') {
          logger.log("mediaRecorder is already inactive");
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, "mediaRecorder is already inactive", logger));
          return;
        }
      } else {
        logger.log("mediaRecorder is not running, use startRecordStream before trying to stop");
        reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, "mediaRecorder is not running, use startRecordStream before trying to stop", logger));
        return;
      }

      _this2.mediaRecorder.stop();
    });
  };

  this.pause = function () {
    var _this3 = this;

    logger.info("pause");
    return new Promise(function (resolve, reject) {
      if (_this3.mediaRecorder !== null) {
        logger.log("this.mediaRecorder.state :" + _this3.mediaRecorder.state); //inactive, recording, or paused.

        if (_this3.mediaRecorder.state === 'paused') {
          logger.log("mediaRecorder is already paused");
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, "mediaRecorder is already paused", logger));
          return;
        }

        if (_this3.mediaRecorder.state === 'inactive') {
          logger.log("mediaRecorder is inactive");
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, "mediaRecorder is inactive", logger));
          return;
        }
      } else {
        logger.log("mediaRecorder is not running, use startRecordStream before trying to pause");
        reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, "mediaRecorder is not running, use startRecordStream before trying to pause", logger));
        return;
      }

      _this3.mediaRecorder.onerror = function (e) {
        logger.log("onerror :" + e);
        reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, 'mediaRecorder error :' + e, logger));
        this.onerror = null;
      };

      _this3.mediaRecorder.onpause = function (e) {
        logger.log("onpause :" + e);
        this.onerror = null;
        resolve();
      };

      _this3.mediaRecorder.pause();
    });
  };

  this.resume = function () {
    var _this4 = this;

    logger.info("resume");
    return new Promise(function (resolve, reject) {
      if (_this4.mediaRecorder !== null) {
        logger.log("this.mediaRecorder.state :" + _this4.mediaRecorder.state); //inactive, recording, or paused.

        if (_this4.mediaRecorder.state === 'recording') {
          logger.log("mediaRecorder is already recording");
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, "mediaRecorder is already recording", logger));
          return;
        }

        if (_this4.mediaRecorder.state === 'inactive') {
          logger.log("mediaRecorder is inactive");
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, "mediaRecorder is inactive", logger));
          return;
        }
      } else {
        logger.log("mediaRecorder is not running, use startRecordStream before trying to resume");
        reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, "mediaRecorder is not running, use startRecordStream before trying to resume", logger));
        return;
      }

      _this4.mediaRecorder.onerror = function (e) {
        logger.log("onerror :" + e);
        reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_2__.Constants.ERROR_STREAM_RECORD, 'mediaRecorder error :' + e, logger));
        this.onerror = null;
      };

      _this4.mediaRecorder.onresume = function (e) {
        logger.log("onresume :" + e);
        this.onerror = null;
        resolve();
      };

      _this4.mediaRecorder.resume();
    });
  };
};



/***/ }),

/***/ "./src/Core/ResourcesLoader.js":
/*!*************************************!*\
  !*** ./src/Core/ResourcesLoader.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResourcesLoader)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }


var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ResourcesLoader');
/*
 * @class ResourceLoader
 * @description Implements wrappers around resource loaders to check if the resource already loaded
 */

var ResourcesLoader = /*#__PURE__*/function () {
  function ResourcesLoader() {
    _classCallCheck(this, ResourcesLoader);

    this.loadedJsLinks = [];
  }
  /*
   * loadjs wrapper
   * @param {Array<string>} paths - file paths
   * @param {string} bundleId - bundleId
   * @param {Object} args - Args, success, retry error callbacks
   */


  _createClass(ResourcesLoader, [{
    key: "loadjs",
    value: function (_loadjs) {
      function loadjs(_x, _x2, _x3) {
        return _loadjs.apply(this, arguments);
      }

      loadjs.toString = function () {
        return _loadjs.toString();
      };

      return loadjs;
    }(function (paths, bundleId, args) {
      var _this = this;

      logger.info('Load js resources', paths);
      logger.debug('Already loaded js', this.loadedJsLinks);
      var successCallback = args.success;
      paths = paths.filter(function (path) {
        return !_this.loadedJsLinks.includes(path);
      });

      if (paths.length === 0) {
        logger.debug('Skip resources loading, all resources previously loaded');

        if (successCallback instanceof Function) {
          successCallback();
        }

        return;
      }

      logger.debug('Filtered resources to load', paths);

      var successCallbackWrap = function successCallbackWrap() {
        _this.loadedJsLinks.push.apply(_this.loadedJsLinks, paths);

        if (successCallback instanceof Function) {
          successCallback();
        }
      };

      args.success = successCallbackWrap;
      loadjs(paths, bundleId, args);
    }
    /*
     * Unloads scripts from page
     * Note that it doesn't remove script from memory
     * @param {Array<string>} paths - script paths
     */
    )
  }, {
    key: "unloadjs",
    value: function unloadjs(paths) {
      var _this2 = this;

      logger.info('Unload js', paths);
      paths.forEach(function (path) {
        var script = document.querySelector('script[src="' + path + '"]');

        if (script !== undefined) {
          script.remove();
          _this2.loadedJsLinks = _this2.loadedJsLinks.filter(function (e) {
            return e !== path;
          });
        }
      });
      logger.debug('Scripts unloaded, currently loaded js', this.loadedJsLinks);
    }
  }, {
    key: "reset",
    value: function reset() {
      unloadjs(this.loadedJsLinks);
      this.loadedJsLinks = [];
    }
  }]);

  return ResourcesLoader;
}();



/***/ }),

/***/ "./src/Core/RoomManager.js":
/*!*********************************!*\
  !*** ./src/Core/RoomManager.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoomManager": () => (/* binding */ RoomManager)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* globals apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('RoomManager');
/*
* This is the RoomManager. This enables creating a room on server side and then broadcasting messages.
* This class is done to manage different type of room (Chatgroup, whiteboard). Customisation has to done on eventHandler function.
* This is an internal ApiRTC Class which is hidden on API : access is given throught other class depending of roomType (whiteBoard, GroupChat ...)
* @module RoomManager
* @param {String} session ApiRTC Session
* @param {String} EventHandler function that enble to customize behavior depending of roomMnager events
* Example :
* this.roomManagerEventHandler = function (msg) {
*
* logger.log('roomManagerEventHandler, roomId :' + msg.roomId);
* logger.log('type :' + msg.type);
* logger.log('roomType :' + msg.roomType);
* }
* this.roomMgr = new RoomManager(this, this.callback(this, 'roomManagerEventHandler'));
*/

var RoomManager = function RoomManager(session, eventHandler) {
  logger.debug('RoomManager');
  this.myWebRTC_Event = apiCC.myWebRTC_Event;
  /*
   * <b>Description</b>
   * <p>This method enables you to create a room on server</p>
   * <b>Associated events :</b>
   * <li>roomCreation</li>
   * @method createRoom
   * @param {string} roomType - Type of the created room (for instance: whiteBoard).
   * @param {object} options
   * @param {string} options.convId - Optional Cloud Conversation ID.
   * @param {boolean} options.webconf - If true, the room is linked to a conference.
   */

  this.createRoom = function (roomType) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    logger.info('RoomManager:createRoom with roomType : ' + roomType);
    var messageToSend = {
      type: 'createRoom',
      roomType: roomType,
      nickname: session.nickname,
      photoURL: session.photoURL
    };

    if (options.convId) {
      if (!messageToSend.data) {
        messageToSend.data = {};
      }

      messageToSend.data.cloudConvId = options.convId;
    }

    if (options.webconf === true) {
      if (!messageToSend.data) {
        messageToSend.data = {};
      }

      messageToSend.data.webconf = true;
    }

    var msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    session.channel.socket.emit('createRoom', msgString);
  };

  this.roomCreation = function (msg) {
    logger.info('RoomManager:roomCreation'); //Calling eventHandler. This is the function where you can customize behavior depending of the room type

    this.myWebRTC_Event.createRoomCreationEvent(msg.status, msg.roomId, msg.roomType);
    eventHandler(msg);
  };

  this.roomJoin = function (msg) {
    logger.info('RoomManager:roomJoin'); //Calling eventHandler. This is the function where you can customize behavior depending of the room type

    this.myWebRTC_Event.createRoomJoinedEvent(msg.status, msg.roomId, msg.roomType);
    eventHandler(msg);
  };
  /*
   * Sends an invitation.
   * @ignore
   * @method inviteInRoom
   * @param {string} roomId - ID of the room.
   * @param {string} contactId - ID of the contact to invite.
   * @param {string} roomType - Either 'whiteBoard', 'pointerSharing' or 'coBrowsing'.
   * @param {object} context - Context to send to invited user.
   * @param {object} options
   * @param {string} options.convId - Optional Cloud Conversation ID.
   * @param {boolean} options.webconf - If true, the room is linked to a conference.
   */


  this.inviteInRoom = function (roomId, contactId, roomType, context) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    logger.info('RoomManager:inviteInRoom with roomType:', roomType);
    var messageToSend = {
      type: 'inviteInRoom',
      roomId: roomId,
      contactId: contactId,
      roomType: roomType,
      nickname: session.nickname,
      photoURL: session.photoURL,
      context: context
    };

    if (options.convId) {
      if (!messageToSend.data) {
        messageToSend.data = {};
      }

      messageToSend.data.cloudConvId = options.convId;
    }

    if (options.webconf === true) {
      if (!messageToSend.data) {
        messageToSend.data = {};
      }

      messageToSend.data.webconf = true;
    }

    var msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    session.channel.socket.emit('inviteInRoom', msgString);
  };

  this.inviteInRoomStatus = function (msg) {
    logger.info('inviteInRoomStatus');
    eventHandler(msg);
  };

  this.roomInvitation = function (msg) {
    logger.info('roomInvitation', msg);
    var opts = {};

    if (msg.data) {
      if (msg.data.cloudConvId) {
        opts.cloudConvId = msg.data.cloudConvId;
      }

      if (msg.data.webconf === true) {
        opts.webconf = true;
      }
    }

    this.myWebRTC_Event.createRoomInvitationEvent(msg.roomId, msg.senderId, msg.senderNickname, msg.senderPhotoURL, msg.contactList, msg.roomType, opts);
    eventHandler(msg);
  };
  /*
  * <b>Description</b>
  * <p>This method returns the contact list in a room</p>
  * @method requestContactListInRoom
  * @param {String} roomId roomId
  */


  this.requestContactListInRoom = function (roomId) {
    logger.info('requestContactListInRoom :' + roomId);
    var messageToSend = {
      type: 'requestContactListInRoom',
      roomId: roomId
    };
    var msgString = JSON.stringify(messageToSend);
    session.channel.socket.emit('requestContactListInRoom', msgString);
  };

  this.onContactListInRoom = function (msg) {
    logger.info('onContactListInRoom :' + msg);
    this.myWebRTC_Event.createContactListInRoomEvent(msg.roomId, msg.contactList, msg.roomType);
    eventHandler(msg);
  };
  /*
  * <b>Description</b>
  * <p>This method enables you to answer to a room invitation</p>
  * @method answerToRoomInvitation
  * @param {String} roomId Id of the room
  * @param {Boolean} accept true if user agreed to join the romm
  */


  this.answerToRoomInvitation = function (roomId, accept, roomType) {
    logger.info('answerToRoomInvitation:', roomId, accept);

    if (accept === true || accept === false) {
      var messageToSend = {
        type: 'roomInvitationAnswer',
        roomId: roomId,
        senderId: session.apiCCId,
        nickname: session.nickname,
        photoURL: session.photoURL,
        accept: accept,
        roomType: roomType
      };
      var msgString = JSON.stringify(messageToSend);
      logger.log('C->S: ' + msgString);
      session.channel.socket.emit('roomInvitationAnswer', msgString);
    } else {
      logger.log('accept value is not correct');
    }
  };

  this.roomMemberUpdate = function (msg) {
    logger.info('roomMemberUpdate');
    this.myWebRTC_Event.createRoomMemberUpdateEvent(msg.roomId, msg.contactList, msg.status, msg.roomType);
    eventHandler(msg);
  };
  /*
  * <b>Description</b>
  * <p>This method enables you to send text message to group chat</p>
  * @method sendMessageToRoom
  * @param {String} groupChatId Id of the group chat
  * @param {String} data sended text message
  */


  this.sendMessageToRoom = function (roomId, roomType, data) {
    logger.info('Call sending message to Room .... from :' + session.apiCCId + ' message :' + data); //TODO: vrifier que le groupChat existe avant envoi message???

    var messageToSend = {
      type: 'roomMessage',
      roomId: roomId,
      senderId: session.apiCCId,
      nickname: session.nickname,
      roomType: roomType,
      data: data
    };
    var msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    session.channel.socket.emit('roomMessage', msgString);
  };

  this.receiveRoomMessage = function (msg) {
    logger.info('receiveRoomMessage');
    this.myWebRTC_Event.createReceiveRoomMessageEvent(msg.roomId, msg.senderId, msg.nickname, msg.data, msg.roomType);
    eventHandler(msg);
  };
  /*
   * @ignore
   * @param {string} roomId
   * @param {string} roomType - Like 'whiteBoard'.
   * @param {object} options
   * @param {string} options.convId - Optional Cloud Conversation ID.
   * @param {boolean} options.webconf - If true, the room is linked to a conference.
   */


  this.joinRoom = function (roomId, roomType) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    logger.info('Join Room with Id:', roomId);
    var messageToSend = {
      type: 'joinRoom',
      roomId: roomId,
      nickname: session.nickname,
      photoURL: session.photoURL,
      roomType: roomType
    };

    if (options.convId) {
      if (!messageToSend.data) {
        messageToSend.data = {};
      }

      messageToSend.data.cloudConvId = options.convId;
    }

    if (options.webconf === true) {
      if (!messageToSend.data) {
        messageToSend.data = {};
      }

      messageToSend.data.webconf = true;
    }

    var msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    session.channel.socket.emit('joinRoom', msgString);
  };

  this.leaveRoom = function (roomId, roomType) {
    logger.info('Leave Room with Id:', roomId);
    var messageToSend = {
      type: 'leaveRoom',
      roomId: roomId,
      nickname: session.nickname,
      photoURL: session.photoURL,
      roomType: roomType
    };
    var msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    session.channel.socket.emit('leaveRoom', msgString);
  };
}; //End RoomManager class




/***/ }),

/***/ "./src/Core/SDPManager.js":
/*!********************************!*\
  !*** ./src/Core/SDPManager.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SDPManager": () => (/* binding */ SDPManager)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* harmony import */ var _SDPUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SDPUtils */ "./src/Core/SDPUtils.js");
/* globals RTCSessionDescription, SessionDescription */

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('SDPManager');


/*
* This is the description for my class SDPManager.
* Class for SDP Management
* @module SDPManager
*/
//SDP description available here :
//http://www.ietf.org/rfc/rfc2327.txt

var SDPManager = function SDPManager() {
  logger.debug("SDPManager"); //TODO function description

  /*
  * <b>Description</b>
  * <p>This method will initialize the communication history function</p>
  * @method init
  * @return
  */

  this.getSDPLines = function (sdp) {
    logger.debug("SDPManager::getSDPLines"); //logger.log("sdp : " + sdp);
    //Dcoupage en ligne

    var sdpLines = sdp.split('\r\n'),
        i;

    for (i = 0; i < sdpLines.length; i += 1) {
      logger.log("sdpLines[i] : " + sdpLines[i]);
    }

    return sdpLines;
  };

  this.getAudioMediaDescriptionPart = function (sdp) {
    logger.debug("SDPManager::getAudioMediaDescriptionPart"); //Dcoupage  partir m=video

    var sdpMediaPart = sdp.split('m=audio'),
        sdpMediaPart2 = null;

    if (sdpMediaPart[1] !== undefined && sdpMediaPart[1] !== null) {
      //m=audio is present in SDP
      sdpMediaPart2 = sdpMediaPart[1].split('m=video');
      logger.log("SDP audio part : " + sdpMediaPart2[0]);
      return sdpMediaPart2[0];
    } else {
      //m=audio is not present in SDP
      return null;
    }
  };

  this.getVideoMediaDescriptionPart = function (sdp) {
    logger.debug("SDPManager::getVideoMediaDescriptionPart"); //Dcoupage  partir m=video

    var sdpMediaPart = sdp.split('m=video'),
        i;

    for (i = 0; i < sdpMediaPart.length; i += 1) {
      logger.log("sdpMediaPart[i] : " + sdpMediaPart[i]);
    }

    return sdpMediaPart[1];
  };

  this.searchMediaDescriptionForRecvOnly = function (mediaDescription) {
    logger.debug("searchMediaDescriptionForRecvOnly");

    if (mediaDescription.search('a=recvonly') !== -1) {
      logger.log("recvonly found in media description");
      return true;
    }

    logger.log("recvonly not found in media description");
    return false;
  };

  this.searchSDPForRecvOnly = function (sdpPart) {
    //var sdpVideoPart = this.getVideoMediaDescriptionPart(sdp),
    //sdpLines = null,
    //i = 0;
    if (sdpPart !== undefined) {
      logger.log("sdpPart !== undefined");
      return this.searchMediaDescriptionForRecvOnly(sdpPart);
    }

    logger.log("recvonly not found in SDP");
    return false;
  };

  this.searchMediaDescriptionForSendOnly = function (mediaDescription) {
    logger.debug("searchMediaDescriptionForSendOnly");

    if (mediaDescription.search('a=sendonly') !== -1) {
      logger.log("sendonly found in media description");
      return true;
    }

    logger.log("sendonly not found in media description");
    return false;
  };

  this.searchSDPForSendOnly = function (sdpPart) {
    if (sdpPart !== undefined) {
      logger.log("sdpPart !== undefined");
      return this.searchMediaDescriptionForSendOnly(sdpPart);
    }

    logger.log("sendonly not found in SDP");
    return false;
  };

  this.searchMediaDescriptionForInactive = function (mediaDescription) {
    logger.debug("searchMediaDescriptionForInactive");

    if (mediaDescription.search('a=inactive') !== -1) {
      logger.log("inactive found in media description");
      return true;
    }

    logger.log("inactive not found in media description");
    return false;
  };

  this.searchSDPForInactive = function (sdpPart) {
    if (sdpPart !== undefined) {
      logger.log("sdpPart !== undefined");
      return this.searchMediaDescriptionForInactive(sdpPart);
    }

    logger.log("inactive not found in SDP");
    return false;
  };

  this.stripAudioMediaDescriptionFromSDP = function (sdp) {
    logger.debug("SDPManager::stripAudioMediaDescriptionFromSDP");
    var guideline = this.createGuideline(sdp);

    if (!guideline.audio) {
      return sdp;
    }

    guideline.audio.direction = 'inactive';
    return guideline.generate({
      stripInactiveMLines: true
    });
  };

  this.stripVideoMediaDescriptionFromSDP = function (sdp) {
    logger.debug("SDPManager::stripVideoMediaDescriptionFromSDP");
    var guideline = this.createGuideline(sdp);

    if (!guideline.video) {
      return sdp;
    }

    guideline.video.direction = 'inactive';
    return guideline.generate({
      stripInactiveMLines: true
    });
  };
  /*
      this.removeBandwidth = function (sdp, bandwidth) {
          logger.log("SDPManager::removeBandwidth");
          return sdp.replace(/a=mid:audio\r\n/g, 'a=mid:audio\r\nb=AS:' + bandwidth + '\r\n');
      };
  */


  this.setAudioBandwidth = function (sdp, maxAudioBW) {
    logger.info("SDPManager::setAudioBandwidth", maxAudioBW);

    if (!maxAudioBW) {
      logger.warn("No maxAudioBW !");
      return sdp;
    }

    sdp = sdp.replace(/a=mid:audio\r\n/g, 'a=mid:audio\r\nb=AS:' + maxAudioBW + '\r\n');
    return sdp;
  };

  this.setVideoBandwidth = function (sdp, maxVideoBW) {
    logger.info("SDPManager::setVideoBandwidth", maxVideoBW);

    if (!maxVideoBW) {
      logger.warn("No maxVideoBW !");
      return sdp;
    }

    var output = [],
        splitted = sdp.split('\r\n'),
        idx = 0,
        curr = null,
        mline = null;

    while (idx < splitted.length) {
      curr = splitted[idx];

      if (curr.length === 0) {
        // skip: blank.
        idx += 1;
        continue;
      } else if (mline === null) {
        // top
        var res = curr.match(/^m=([a-z]+)(.+)$/);

        if (res && res[1] === 'video') {
          // the mline we are interested in.
          mline = 'video';
          output.push(curr);
          output.push('\r\n');
          idx += 1;
          continue;
        } else {
          // global.
          output.push(curr);
          output.push('\r\n');
          idx += 1;
          continue;
        }
      } else {
        // mline
        if (curr.match(/^m=/)) {
          // new mline: for next iteration.
          mline = null;
          continue;
        } else if (curr.match(/^a=mid:(\w+)$/)) {
          // putting limit after mid.
          output.push(curr);
          output.push('\r\n');
          output.push('b=AS:');
          output.push(maxVideoBW);
          output.push('\r\n');
          output.push('b=TIAS:');
          output.push(maxVideoBW);
          output.push('000');
          output.push('\r\n');
          idx += 1;
          continue;
        } else if (curr.match(/^b=([A-Z]+):(\w+)$/)) {
          // skip: already set.
          idx += 1;
          continue;
        } else {
          // copy.
          output.push(curr);
          output.push('\r\n');
          idx += 1;
          continue;
        }
      }
    } // while


    return output.join('');
  };

  this.setDataBandwidth = function (sdp, maxDataBW) {
    logger.info("SDPManager::setDataBandwidth", maxDataBW);

    if (!maxDataBW) {
      logger.warn("No maxDataBW !");
      return sdp;
    }

    sdp = sdp.replace(/a=mid:data\r\n/g, 'a=mid:data\r\nb=AS:' + maxDataBW + '\r\n');
    return sdp;
  };

  this.setSendOnlyForAudio = function (sdp) {
    logger.debug("SDPManager::setSendOnlyForAudio");
    var guideline = this.createGuideline(sdp);

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isPropertyTypeof)(guideline, 'audio', 'object')) {
      guideline.audio.direction = 'sendonly';
    }

    return guideline.generate();
  };

  this.setSendOnlyForVideo = function (sdp) {
    logger.debug("SDPManager::setSendOnlyForVideo");
    var guideline = this.createGuideline(sdp);

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isPropertyTypeof)(guideline, 'video', 'object')) {
      guideline.video.direction = 'sendonly';
    }

    return guideline.generate();
  };

  this.setSendOnly = function (sdp) {
    logger.debug("SDPManager::setSendOnly : global");
    var guideline = this.createGuideline(sdp);

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isPropertyTypeof)(guideline, 'audio', 'object')) {
      guideline.audio.direction = 'sendonly';
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isPropertyTypeof)(guideline, 'video', 'object')) {
      guideline.video.direction = 'sendonly';
    }

    return guideline.generate();
  };

  this.setRecvOnlyForAudio = function (sdp) {
    logger.debug("SDPManager::setRecvOnlyForAudio");
    var guideline = this.createGuideline(sdp);

    if (guideline.audio && guideline.audio.direction !== 'inactive') {
      guideline.audio.direction = 'recvonly';
    }

    return guideline.generate();
  };

  this.setRecvOnlyForVideo = function (sdp) {
    logger.debug("SDPManager::setRecvOnlyForVideo");
    var guideline = this.createGuideline(sdp);

    if (guideline.video && guideline.video.direction !== 'inactive') {
      guideline.video.direction = 'recvonly';
    }

    return guideline.generate();
  };

  this.setRecvOnly = function (sdp) {
    logger.debug("SDPManager::setRecvOnly : global");
    var guideline = this.createGuideline(sdp);

    if (guideline.audio && guideline.audio.direction !== 'inactive') {
      guideline.audio.direction = 'recvonly';
    }

    if (guideline.video && guideline.video.direction !== 'inactive') {
      guideline.video.direction = 'recvonly';
    }

    return guideline.generate();
  };
  /*
      * @summary Updates SDP keeping user selected codecs.
      * @param {string} sdpoffer SDP
      * @param {string} sdpType  'offer' or 'answer'
      * @param {string} mediaType 'audio' or 'video'
      * @param {string} availableCodecSet Comma delimited list of available codecs (codec/rate[/chans])
      * @private
      */


  this.updateSDPcodecs = function (sdpoffer, sdpType, mediaType, availableCodecSet) {
    var i,
        j,
        sdpstr,
        changed = false,
        keepCodec,
        eolPattern = new RegExp("\r\n$"),
        removeExtraCrLf = false,
        lines = null,
        payloadTypes = null,
        codecRateChan = '',
        rtpmapLinePrefix = '',
        indexOfRtpmap,
        indexOfEndofRtpmapLine,
        rtpmapStripExp = '',
        fmtpStripExp = '',
        mLinePtStripExp1 = '',
        mLinePtStripExp2 = '',
        mediaAttrLines,
        ptPortion,
        rtcpFbStripExp = '',
        ssrcGrpStripExp = '';
    logger.log("updateSDPcodecs():\n" + "\tsdpType = " + sdpType + "\n" + "\tmediaType = " + mediaType + "\n" + "\tavailableCodecSet = " + availableCodecSet + "\n");

    if (availableCodecSet == '') {
      return sdpoffer;
    }

    if (RTCSessionDescription && sdpoffer instanceof RTCSessionDescription) {
      sdpstr = sdpoffer.sdp;
    } else if (window.SessionDescription && sdpoffer instanceof SessionDescription) {
      sdpstr = sdpoffer.toSdp();
    } else {
      sdpstr = sdpoffer;
    }
    /*
        *  Strip codecs not listed in User specified
        *  codecs to include in offers and answers per UI Config.
        */


    sdpstr = sdpstr.split("\r\nm=");
    /*
        *  The above split is used because splitting on "m=" alone
        *  can create problems if a crypto sdp attribute happens to carry
        *  a key-info parameter with "m=" embedded within it.
        *  However, after the split above, the second to last element
        *  will be missing "\r\n" at the end.  So we'll want to temporarily add this back
        *  so that the last attribute line in that stream also ends in "\r\n"
        *  and can be processed just like other attributes.
        *  This will later be removed just before we rejoin the streams.
        */

    if (eolPattern.test(sdpstr[sdpstr.length - 2]) === false) {
      sdpstr[sdpstr.length - 2] = sdpstr[sdpstr.length - 2] + "\r\n";
      removeExtraCrLf = true;
    } // Isolate the stream attributes of interest


    for (i = 0; i < sdpstr.length; i++) {
      if (sdpstr[i].indexOf(mediaType) === 0) {
        /*
            *  Walk the payloadTypes and remove any not associated
            *  with codecs that are not specified to be kept.
            */
        lines = sdpstr[i].split("\r\n");
        payloadTypes = lines[0].split(" ");
        /*
            *  Skip past the media type, the portId and the transports
            *  and walk the numeric payloadTypes.
            */

        for (j = 3; j < payloadTypes.length; j++) {
          //logger.debug("PT(" + j + ") = " + payloadTypes[j] + "\n");
          keepCodec = true; // Verify we have a numeric payloadType

          if (isNaN(payloadTypes[j]) === false) {
            //codecRateChan = '';
            rtpmapLinePrefix = "a=rtpmap:" + payloadTypes[j] + " ";
            indexOfRtpmap = sdpstr[i].indexOf(rtpmapLinePrefix);

            if (indexOfRtpmap !== -1) {
              indexOfEndofRtpmapLine = sdpstr[i].indexOf("\r\n", indexOfRtpmap);
            }
            /*
                *  Get the codec/samplingRate/Chan string
                *  associated with the payloadType so that we can check
                *  for it in the configured codecs set.
                */


            switch (payloadTypes[j]) {
              case 0:
                // G711u
                codecRateChan = "PCMU/8000";
                break;

              case 8:
                // G711A
                codecRateChan = "PCMA/8000";
                break;

              case 9:
                // G722
                codecRateChan = "G722/8000";
                break;

              case 13:
                // ComfortNoise
                codecRateChan = "CN/8000";
                break;

              case 18:
                // G729
                codecRateChan = "G729/8000";
                break;

              default:
                // dynamic payloadType or unknown static
                //  (get codecRateChan from rtpmap line)
                if (indexOfRtpmap !== -1) {
                  codecRateChan = sdpstr[i].substring(indexOfRtpmap + rtpmapLinePrefix.length, indexOfEndofRtpmapLine);
                } //else {
                //codecRateChan = '';
                //}


                break;
            } // Check if the codec is to be kept


            if (codecRateChan != '' && availableCodecSet.indexOf(codecRateChan) !== -1) {
              logger.log("PT(" + payloadTypes[j] + "): " + codecRateChan + " FOUND in availableCodecSet.\n");
            } else {
              keepCodec = false;
              logger.log("PT(" + payloadTypes[j] + "): " + codecRateChan + " NOT FOUND in availableCodecSet.\n");
            }

            if (!keepCodec) {
              /*
                  *  We will strip this codec's payloadType from the m= line
                  *  and remove any rtpmap line and associated fmtp attribute lines.
                  */
              rtpmapStripExp = rtpmapLinePrefix + ".*\r\n";
              fmtpStripExp = "a=fmtp:" + payloadTypes[j] + " " + ".*\r\n";
              rtcpFbStripExp = "a=rtcp-fb:" + payloadTypes[j] + " " + ".*\r\n";
              mLinePtStripExp1 = " " + payloadTypes[j] + " ";
              mLinePtStripExp2 = " " + payloadTypes[j] + "\r"; // strip rtpmap lines

              sdpstr[i] = sdpstr[i].replace(new RegExp(rtpmapStripExp, "g"), ""); // strip fmtp lines

              sdpstr[i] = sdpstr[i].replace(new RegExp(fmtpStripExp, "g"), ""); // strip rtcp-fb lines

              sdpstr[i] = sdpstr[i].replace(new RegExp(rtcpFbStripExp, "g"), "");
              /*
                  *  The payloadType number to be stripped from the m-line may
                  *  happen to also be the portId number.
                  *  For example:
                  *        m=audio 9 RTP/SAVPF 109 9 0 8 101
                  *  When we need to strip payloadType 9, we don't want to
                  *  touch the portId.
                  *  So we'll be sure to do the replacements only in the
                  *  portion of the m-line that actually contains payloadTypes.
                  */

              mediaAttrLines = sdpstr[i].split("\n");
              ptPortion = mediaAttrLines[0].split("RTP");
              ptPortion[1] = ptPortion[1].replace(mLinePtStripExp1, " ");
              ptPortion[1] = ptPortion[1].replace(mLinePtStripExp2, "\r");
              mediaAttrLines[0] = ptPortion.join("RTP");
              sdpstr[i] = mediaAttrLines.join("\n");

              if (mediaType === 'video') {
                // strip rtcp feedback capability attribute lines
                rtcpFbStripExp = "a=rtcp-fb:" + payloadTypes[j] + " " + ".*\r\n";
                sdpstr[i] = sdpstr[i].replace(new RegExp(rtcpFbStripExp, "g"), "");

                if (codecRateChan != '' && codecRateChan.substr(0, 4) === 'rtx/') {
                  /*
                      *  If rtx is is being removed, we'll
                      *  need to remove an ssrc-group line
                      *  and the first set of 4 ssrc lines.
                      */
                  ssrcGrpStripExp = "a=ssrc-group:FID " + ".*\r\n";
                  sdpstr[i] = sdpstr[i].replace(new RegExp(ssrcGrpStripExp, "g"), "");
                  mediaAttrLines = sdpstr[i].split("\r\na=");
                  mediaAttrLines.splice(mediaAttrLines.length - 8, 4);
                  sdpstr[i] = mediaAttrLines.join("\r\na=");
                }
              }

              changed = true;
            }
          }
        }

        break;
      }
    } // restore sdpstr


    if (removeExtraCrLf) {
      sdpstr[sdpstr.length - 2] = sdpstr[sdpstr.length - 2].substr(0, sdpstr[sdpstr.length - 2].length - 2);
    }

    sdpstr = sdpstr.join("\r\nm=");

    if (changed === true) {
      logger.log("updateSDPcodecs(), SDP has been updated."); //logger.debug("updateSDPcodecs(): UPDATED SDP = \n" + sdpstr + "\n\n");

      if (RTCSessionDescription && sdpoffer instanceof RTCSessionDescription) {
        return new RTCSessionDescription({
          type: sdpType,
          sdp: sdpstr
        });
      } else if (window.SessionDescription && sdpoffer instanceof SessionDescription) {
        return new SessionDescription(sdpstr);
      }

      return sdpstr;
    }

    logger.log("updateSDPcodecs(), SDP has not been updated.");
    return sdpoffer;
  }; // Set Opus as the default audio codec if it's present.


  this.preferOpus = function (sdp) {
    var sdpLines = sdp.split('\r\n'),
        i,
        mLineIndex = 0,
        opusPayload = null; // Search for m line.

    for (i = 0; i < sdpLines.length; i += 1) {
      if (sdpLines[i].search('m=audio') !== -1) {
        mLineIndex = i;
        break;
      }
    }

    if (mLineIndex === 0) {
      return sdp;
    } // If Opus is available, set it as the default in m line.


    for (i = 0; i < sdpLines.length; i += 1) {
      if (sdpLines[i].search('opus/48000') !== -1) {
        opusPayload = this.extractSdp(sdpLines[i], /:(\d+) opus\/48000/i);

        if (opusPayload) {
          sdpLines[mLineIndex] = this.setDefaultCodec(sdpLines[mLineIndex], opusPayload);
        }

        break;
      }
    } // Remove CN in m line and sdp.


    sdpLines = this.removeCN(sdpLines, mLineIndex);
    sdp = sdpLines.join('\r\n');
    return sdp;
  }; // Strip CN from sdp before CN constraints is ready.


  this.removeCN = function (sdpLines, mLineIndex) {
    var i = 0,
        mLineElements = sdpLines[mLineIndex].split(' '),
        payload = null,
        cnPos = 0; // Scan from end for the convenience of removing an item.

    for (i = sdpLines.length - 1; i >= 0; i--) {
      payload = this.extractSdp(sdpLines[i], /a=rtpmap:(\d+) CN\/\d+/i);

      if (payload) {
        cnPos = mLineElements.indexOf(payload);

        if (cnPos !== -1) {
          // Remove CN payload from m line.
          mLineElements.splice(cnPos, 1);
        } // Remove CN line in sdp


        sdpLines.splice(i, 1);
      }
    }

    sdpLines[mLineIndex] = mLineElements.join(' ');
    return sdpLines;
  };

  this.extractSdp = function (sdpLine, pattern) {
    var result = sdpLine.match(pattern);
    return result && result.length == 2 ? result[1] : null; //return (result && result.length === 2) ? result[1] : null;
  }; // Set the selected codec to the first in m line


  this.setDefaultCodec = function (mLine, payload) {
    var i = 0,
        elements = mLine.split(" "),
        newLine = elements.slice(0, 3);
    newLine.push(payload);

    for (i = 3; i < elements.length; i++) {
      if (elements[i] !== payload) {
        newLine.push(elements[i]);
      }
    }

    return newLine.join(" ");
  }; // Find the line in sdpLines[startLine...endLine - 1] that starts with |prefix|
  // and, if specified, contains |substr| (case-insensitive search).


  this.findLineInRange = function (sdpLines, startLine, endLine, prefix, substr) {
    var realEndLine = endLine !== -1 ? endLine : sdpLines.length,
        i;

    for (i = startLine; i < realEndLine; ++i) {
      if (sdpLines[i].indexOf(prefix) === 0) {
        if (!substr || sdpLines[i].toLowerCase().indexOf(substr.toLowerCase()) !== -1) {
          return i;
        }
      }
    }

    return null;
  }; // Find the line in sdpLines that starts with |prefix|, and, if specified,
  // contains |substr| (case-insensitive search).


  this.findLine = function (sdpLines, prefix, substr) {
    return this.findLineInRange(sdpLines, 0, -1, prefix, substr);
  }; // Gets the codec payload type from sdp lines.


  this.getCodecPayloadType = function (sdpLines, codec) {
    var index = this.findLine(sdpLines, 'a=rtpmap', codec);
    return index ? this.getCodecPayloadTypeFromLine(sdpLines[index]) : null;
  }; // Gets the codec payload type from an a=rtpmap:X line.


  this.getCodecPayloadTypeFromLine = function (sdpLine) {
    var pattern = new RegExp('a=rtpmap:(\\d+) \\w+\\/\\d+'),
        result = sdpLine.match(pattern);
    return result && result.length === 2 ? result[1] : null;
  }; // Find fmtp attribute for |codec| in |sdpLines|.


  this.findFmtpLine = function (sdpLines, codec) {
    // Find payload of codec.
    var payload = this.getCodecPayloadType(sdpLines, codec); // Find the payload in fmtp line.

    return payload ? this.findLine(sdpLines, 'a=fmtp:' + payload.toString()) : null;
  }; // Split an fmtp line into an object including 'pt' and 'params'.


  function parseFmtpLine(fmtpLine) {
    var fmtpObj = {},
        spacePos = fmtpLine.indexOf(' '),
        keyValues = fmtpLine.substring(spacePos + 1).split('; '),
        pattern = new RegExp('a=fmtp:(\\d+)'),
        result = fmtpLine.match(pattern),
        i,
        params = {},
        pair = null;

    if (result && result.length === 2) {
      fmtpObj.pt = result[1];
    } else {
      return null;
    }

    for (i = 0; i < keyValues.length; ++i) {
      pair = keyValues[i].split('=');

      if (pair.length === 2) {
        params[pair[0]] = pair[1];
      }
    }

    fmtpObj.params = params;
    return fmtpObj;
  } // Generate an fmtp line from an object including 'pt' and 'params'.


  this.writeFmtpLine = function (fmtpObj) {
    if (!fmtpObj.hasOwnProperty('pt') || !fmtpObj.hasOwnProperty('params')) {
      return null;
    }

    var pt = fmtpObj.pt,
        params = fmtpObj.params,
        keyValues = [],
        i = 0,
        key = null;

    for (key in params) {
      keyValues[i] = key + '=' + params[key];
      ++i;
    }

    if (i === 0) {
      return null;
    }

    return 'a=fmtp:' + pt.toString() + ' ' + keyValues.join('; ');
  }; // Set fmtp param to specific codec in SDP. If param does not exists, add it.


  this.setCodecParam = function (sdp, codec, param, value) {
    var sdpLines = sdp.split('\r\n'),
        fmtpLineIndex = this.findFmtpLine(sdpLines, codec),
        fmtpObj = {},
        payload = null,
        index = null;

    if (fmtpLineIndex === null) {
      index = this.findLine(sdpLines, 'a=rtpmap', codec);

      if (index === null) {
        return sdp;
      }

      payload = this.getCodecPayloadTypeFromLine(sdpLines[index]);
      fmtpObj.pt = payload.toString();
      fmtpObj.params = {};
      fmtpObj.params[param] = value;
      sdpLines.splice(index + 1, 0, this.writeFmtpLine(fmtpObj));
    } else {
      fmtpObj = parseFmtpLine(sdpLines[fmtpLineIndex]);
      fmtpObj.params[param] = value;
      sdpLines[fmtpLineIndex] = this.writeFmtpLine(fmtpObj);
    }

    sdp = sdpLines.join('\r\n');
    return sdp;
  }; // Sets |codec| as the default |type| codec if it's present.
  // The format of |codec| is 'NAME/RATE', e.g. 'opus/48000'.


  this.maybePreferCodec = function (sdp, type, codec) {
    //logger.log("maybePreferCodec :", sdp);
    var str = type + ' codec',
        sdpLines = null,
        mLineIndex = null,
        payload = null;

    if (!codec) {
      logger.log('No preference on ' + str + '.');
      return sdp;
    }

    logger.log('Prefer ' + str + ': ' + codec);
    sdpLines = sdp.split('\r\n'); // Search for m line.

    mLineIndex = this.findLine(sdpLines, 'm=', type); //logger.log('mLineIndex : ' + mLineIndex);

    if (mLineIndex === null) {
      logger.log('mLineIndex === null');
      return sdp;
    } // If the codec is available, set it as the default in m line.


    payload = this.getCodecPayloadType(sdpLines, codec); //logger.log('payload : ' + payload);

    if (payload) {
      sdpLines[mLineIndex] = this.setDefaultCodec(sdpLines[mLineIndex], payload);
    }

    sdp = sdpLines.join('\r\n'); //logger.log("End of maybePreferCodec :", sdp);

    return sdp;
  };
  /*
   * Parses a given SDP offer/answer and returns a guideline.
   *
   * @method createGuideline
   * @param {string} sdp - SDP offer/answer.
   *
   * @return {SDPGuideline} guideline.
   */


  this.createGuideline = _SDPUtils__WEBPACK_IMPORTED_MODULE_2__.createGuideline;
}; //End of SDPManager Class




/***/ }),

/***/ "./src/Core/SDPUtils.js":
/*!******************************!*\
  !*** ./src/Core/SDPUtils.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createGuideline": () => (/* binding */ createGuideline),
/* harmony export */   "isMLineActive": () => (/* binding */ isMLineActive)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*
 * @typedef {object} SDP
 * @property {string} original - Original SDP.
 * @property {object} global - Array(s) of String(s).
 * @property {object} mlines - Array of Array(s) of String(s).
 */

/*
 * @typedef {object} SDPGuidelineMLine
 * @property {string} type - Either 'audio' or 'video'.
 * @property {number} port
 * @property {string} proto
 * @property {object} payload_types - Array of string(s).
 * @property {string} direction - Either 'recvonly', 'sendonly', 'sendrecv' or 'inactive'.
 * @property {string} mid
 * @property {number} bandwidth - Positive integer to enable or 0 to disable.
 * @property {object} codecs
 * @property {object} ssrc_groups
 * @property {object} ssrc_groups.sim - Array
 * @property {object} ssrc_groups.fid - Array
 * @property {object} ssrcs
 * @property {string} ssrcs.cname
 * @property {string} ssrcs.msid
 * @property {string} ssrcs.mslabel
 * @property {string} ssrcs.label
 */

/*
 * @typedef {object} SDPGuideline
 * @property {SDP} sdp
 * @property {object} mlines - Array of SDPGuidelineMLine(s).
 * @property {SDPGuidelineMLine} audio
 * @property {SDPGuidelineMLine} video
 * @property {boolean} unifiedPlan
 * @property {boolean} simulcasting
 */
function SDPGuideline() {
  this.sdp = {
    original: null,
    global: [],
    mlines: [] // same length as this.mlines

  };
  this.mlines = []; // same length as this.sdp.mlines
}
/*
 * Munges the SDP represented by this one to enable simulcasting.
 * @method mungeForSimulcasting
 */


SDPGuideline.prototype.mungeForSimulcasting = function () {
  if (this.simulcasting === true) {
    return;
  }

  this.simulcasting = true;

  for (var mlineIdx = 0; mlineIdx < this.mlines.length; mlineIdx += 1) {
    var mline = this.mlines[mlineIdx];

    if (mline.type !== 'video') {
      continue;
    }

    var cname = mline.ssrcs[0].content.cname;
    var msid = mline.ssrcs[0].content.msid;
    var mslabel = mline.ssrcs[0].content.mslabel;
    var label = mline.ssrcs[0].content.label;
    var sim_ssrcs = [];
    sim_ssrcs.push(mline.ssrcs[0].ssrc);

    for (var times = 2; --times >= 0;) {
      var ssrc1 = Math.floor(Math.random() * 0xffffffff);
      mline.ssrcs.push({
        original: ssrc1,
        ssrc: ssrc1,
        content: {
          cname: cname,
          msid: msid,
          mslabel: mslabel,
          label: label
        }
      });
      var ssrc2 = Math.floor(Math.random() * 0xffffffff);
      mline.ssrcs.push({
        original: ssrc2,
        ssrc: ssrc2,
        content: {
          cname: cname,
          msid: msid,
          mslabel: mslabel,
          label: label
        }
      });
      mline.ssrc_groups.fid.push([ssrc1, ssrc2]);
      sim_ssrcs.push(ssrc1);
    } // for


    mline.ssrc_groups.sim.push(sim_ssrcs);
  } // for

};
/*
 * Generates an SDP offer/answer from the guideline represented by this one.
 * @method generate
 * @param {object} options
 * @param {boolean} options.stripInactiveMLines
 * @return {string} SDP
 */


SDPGuideline.prototype.generate = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var output = [];

  for (var idx = 0; idx < this.sdp.global.length; idx += 1) {
    var curr = this.sdp.global[idx];
    var res = curr.match(/^a=group:BUNDLE([\w ]+)$/);

    if (res) {
      output.push('a=group:BUNDLE');

      for (var mi = 0; mi < this.mlines.length; mi += 1) {
        if (this.mlines[mi].direction !== 'inactive' || options.stripInactiveMLines !== true) {
          output.push(' ');
          output.push(this.mlines[mi].mid);
        }
      } // for


      output.push('\r\n');
    } else {
      output.push(curr);
      output.push('\r\n');
    }
  } // for


  for (var mlineIdx = 0; mlineIdx < this.sdp.mlines.length; mlineIdx += 1) {
    var mline = this.mlines[mlineIdx];

    if (mline.direction === 'inactive' && options.stripInactiveMLines === true) {
      continue;
    }

    var ssrcAdded = false;
    var sdp = this.sdp.mlines[mlineIdx];

    for (var _idx = 0; _idx < sdp.length; _idx += 1) {
      var _curr = sdp[_idx];

      if (_curr.match(/^m=/)) {
        output.push('m=');
        output.push(mline.type);
        output.push(' ');
        output.push(mline.port);
        output.push(' ');
        output.push(mline.proto);
        output.push(' ');
        output.push(mline.payload_types.join(' '));
        output.push('\r\n');
        continue;
      } else if (_curr.match(/^a=/)) {
        // attribute.
        var _res = _curr.match(/^a=([\w-]+):(\d+) (.+)$/);

        if (_res && (_res[1] === 'rtpmap' || _res[1] === 'rtcp-fb' || _res[1] === 'fmtp')) {
          // attribute for payload type.
          if (_res[1] === 'rtpmap') {
            // rtpmap.
            var pt = _res[2];

            if (mline.codecs[pt]) {
              // rtpmap.
              output.push('a=rtpmap:');
              output.push(pt);
              output.push(' ');
              output.push(mline.codecs[pt].rtpmap);
              output.push('\r\n'); // rtcp-fb.

              var rs = mline.codecs[pt]['rtcp-fb'];

              if (rs) {
                for (var ri = 0; ri < rs.length; ri += 1) {
                  output.push('a=rtcp-fb:');
                  output.push(pt);
                  output.push(' ');
                  output.push(rs[ri]);
                  output.push('\r\n');
                } // for

              } // fmtp.


              var fs = mline.codecs[pt].fmtp;

              if (fs) {
                var list = [];

                for (var fi = 0; fi < fs.length; fi += 1) {
                  list.push(fs[fi].join('='));
                } // for


                if (list.length > 0) {
                  output.push('a=fmtp:');
                  output.push(pt);
                  output.push(' ');
                  output.push(list.join(';'));
                  output.push('\r\n');
                }
              }

              continue;
            } else {
              // skip: payload type not present.
              continue;
            }
          } else if (_res[1] === 'rtcp-fb' || _res[1] === 'fmtp') {
            // skip: already been taken care of.
            continue;
          }

          throw new Error('internal error');
        } else if (_curr.match(/^a=mid:(\w+)$/)) {
          // not attribute for payload type.
          // mid.
          output.push('a=mid:');
          output.push(mline.mid);
          output.push('\r\n');

          if (mline.bandwidth > 0) {
            output.push('b=AS:');
            output.push(mline.bandwidth);
            output.push('\r\n');
            output.push('b=TIAS:');
            output.push(mline.bandwidth);
            output.push('000');
            output.push('\r\n');
          }

          continue;
        } else if (_curr === 'a=sendrecv' || _curr === 'a=recvonly' || _curr === 'a=sendonly' || _curr === 'a=inactive') {
          // direction.
          output.push('a=');
          output.push(mline.direction);
          output.push('\r\n');
          continue;
        } else if (_curr.match(/^a=ssrc-group:SIM (.+)$/)) {// skip: already been taken care of.
        } else if (_curr.match(/^a=ssrc-group:FID (.+)$/)) {// skip: already been taken care of.
        } else if (_curr.match(/^a=ssrc:(\d+) (.+)$/)) {
          // ssrc
          if (ssrcAdded) {
            continue;
          }

          ssrcAdded = true; // a=ssrc-group:SIM

          for (var si = 0; si < mline.ssrc_groups.sim.length; si += 1) {
            output.push('a=ssrc-group:SIM ');
            output.push(mline.ssrc_groups.sim[si].join(' '));
            output.push('\r\n');
          } // for
          // a=ssrc-group:FID


          for (var _si = 0; _si < mline.ssrc_groups.fid.length; _si += 1) {
            output.push('a=ssrc-group:FID ');
            output.push(mline.ssrc_groups.fid[_si].join(' '));
            output.push('\r\n');
          } // for
          // a=ssrc


          var _loop = function _loop(_si2) {
            var ssrc = mline.ssrcs[_si2];
            ['cname', 'msid', 'mslabel', 'label'].forEach(function (e) {
              // jshint ignore:line
              if (Object.prototype.hasOwnProperty.call(ssrc.content, e)) {
                output.push('a=ssrc:');
                output.push(ssrc.ssrc);
                output.push(' ');
                output.push(e);
                output.push(':');
                output.push(ssrc.content[e]);
                output.push('\r\n');
              }
            });
          };

          for (var _si2 = 0; _si2 < mline.ssrcs.length; _si2 += 1) {
            _loop(_si2);
          } // for


          continue;
        } else {
          // something else
          output.push(_curr);
          output.push('\r\n');
          continue;
        }
      } else if (_curr.match(/^b=/)) {
        // bandwidth.
        // skip: already been taken care of.
        continue;
      } else {
        // something else.
        output.push(_curr);
        output.push('\r\n');
        continue;
      }
    } // for

  } // for


  return output.join('');
};
/*
 * Parses a given SDP offer/answer and returns a guideline.
 * @method createGuideline
 * @param {string} sdp - SDP offer/answer.
 * @return {SDPGuideline} guideline.
 */


function createGuideline(sdp) {
  var ret = new SDPGuideline();
  var splitted = sdp.split('\r\n');
  var idx = 0;
  var curr = null;
  var output = null;
  var mline = null;
  var res = null;
  ret.sdp.original = sdp;

  while (idx < splitted.length) {
    curr = splitted[idx];

    if (curr.length === 0) {
      // blank.
      idx += 1;
      continue;
    } else if (mline === null) {
      // top
      res = curr.match(/^m=([a-z]+) (\d+) ([A-Z/]+) ([0-9 ]+)$/);

      if (res) {
        // new mline.
        output = [];
        ret.sdp.mlines.push(output);
        output.push(curr);
        mline = {
          type: res[1],
          port: parseInt(res[2], 10),
          proto: res[3],
          payload_types: [],
          direction: 'sendrecv',
          mid: res[1],
          bandwidth: 0,
          codecs: {},
          ssrc_groups: {
            sim: [],
            fid: []
          },
          ssrcs: []
        };
        var pts = res[4].split(' ');

        for (var pti = 0; pti < pts.length; pti += 1) {
          mline.payload_types.push(pts[pti]);
          mline.codecs[pts[pti]] = {};
        } // for


        ret.mlines.push(mline);
        idx += 1;
        continue;
      } else {
        // global.
        ret.sdp.global.push(curr);
        idx += 1;
        continue;
      }
    } else {
      // mline
      if (curr.match(/^m=/)) {
        // new mline.
        output = null;
        mline = null;
        continue;
      } else if (curr.match(/^a=/)) {
        // attribute.
        output.push(curr);
        res = curr.match(/^a=([\w-]+):(\d+) (.+)$/);

        if (res && (res[1] === 'rtpmap' || res[1] === 'rtcp-fb' || res[1] === 'fmtp')) {
          // attribute for payload type.
          if (res[1] === 'rtpmap') {
            mline.codecs[res[2]].codec = res[3].split('/')[0].toLowerCase();
            mline.codecs[res[2]].rtpmap = res[3];
          } else if (res[1] === 'rtcp-fb') {
            if (!mline.codecs[res[2]]['rtcp-fb']) {
              mline.codecs[res[2]]['rtcp-fb'] = [];
            }

            mline.codecs[res[2]]['rtcp-fb'].push(res[3]);
          } else if (res[1] === 'fmtp') {
            mline.codecs[res[2]].fmtp = [];
            var pairs = res[3].split(';');

            for (var pi = 0; pi < pairs.length; pi += 1) {
              var p = pairs[pi].split('=');

              if (p.length === 2) {
                mline.codecs[res[2]].fmtp.push(p);
              }
            } // for

          }
        } else if (res = curr.match(/^a=mid:(\w+)$/)) {
          // eslint-disable-line
          // mid.
          mline.mid = res[1];
        } else if (curr === 'a=sendrecv') {
          // direction.
          mline.direction = 'sendrecv';
        } else if (curr === 'a=recvonly') {
          // direction.
          mline.direction = 'recvonly';
        } else if (curr === 'a=sendonly') {
          // direction.
          mline.direction = 'sendonly';
        } else if (curr === 'a=inactive') {
          // direction.
          mline.direction = 'inactive';
        } else if (res = curr.match(/^a=ssrc-group:SIM (.+)$/)) {
          // eslint-disable-line
          // ssrc-group:SIM
          var ssrcs = res[1].split(' ');
          mline.ssrc_groups.sim.push(ssrcs.slice());
        } else if (res = curr.match(/^a=ssrc-group:FID (.+)$/)) {
          // eslint-disable-line
          // ssrc-group:FID
          var _ssrcs = res[1].split(' ');

          mline.ssrc_groups.fid.push(_ssrcs.slice());
        } else if (res = curr.match(/^a=ssrc:(\d+) (.+)$/)) {
          // eslint-disable-line
          // ssrc
          var ssrc = mline.ssrcs.find(function (e) {
            return e.original === res[1];
          }); // jshint ignore:line

          if (!ssrc) {
            ssrc = {
              original: res[1],
              ssrc: res[1],
              content: {}
            };
            mline.ssrcs.push(ssrc);
          }

          var ssrc_res = res[2].match(/^(\w+):(.+)$/);

          if (ssrc_res) {
            if (ssrc_res[1] === 'cname') {
              ssrc.content.cname = ssrc_res[2];
            } else if (ssrc_res[1] === 'msid') {
              ssrc.content.msid = ssrc_res[2];
            } else if (ssrc_res[1] === 'mslabel') {
              ssrc.content.mslabel = ssrc_res[2];
            } else if (ssrc_res[1] === 'label') {
              ssrc.content.label = ssrc_res[2];
            } else {
              throw new Error('cannot parse ssrc parameters (wrong attribute): ' + ssrc_res[1]);
            }
          } else {
            throw new Error('cannot parse ssrc parameters (regex failure): ' + res[2]);
          }
        }

        idx += 1;
        continue;
      } else if (curr.match(/^b=/)) {
        // bandwidth.
        output.push(curr);
        res = curr.match(/^b=AS:(\d+)$/);

        if (res) {
          // application specific bandwidth.
          mline.bandwidth = parseInt(res[1], 10);
          idx += 1;
          continue;
        } else {
          // something else.
          idx += 1;
          continue;
        }
      } else {
        // something else.
        output.push(curr);
        idx += 1;
        continue;
      }
    }
  } // while
  // Searching for an active audio and an active video.
  // Searching for proof of unified plan.


  ret.unifiedPlan = true;

  for (idx = ret.mlines.length; --idx >= 0;) {
    if (ret.mlines[idx].type === 'audio' && !ret.audio) {
      ret.audio = ret.mlines[idx];
    } else if (ret.mlines[idx].type === 'video' && !ret.video) {
      ret.video = ret.mlines[idx];
    }

    if (ret.unifiedPlan === true && ret.mlines[idx].mid !== String(idx)) {
      ret.unifiedPlan = false;
    }
  } // for


  ret.isAudioActive = isMLineActive.bind(null, ret, 'audio');
  ret.isVideoActive = isMLineActive.bind(null, ret, 'video');
  return ret;
}
/*
 * Tests whether a given mline is active (present and not inactive) in a given SDP guideline.
 * @method isMLineActive
 * @param {object} guideline - SDP guideline
 * @param {string} mline - 'audio', 'video'.
 * @return {boolean}
 */


function isMLineActive(guideline, mline) {
  if ((mline === 'audio' || mline === 'video') && guideline !== null && _typeof(guideline) === 'object' && Object.prototype.hasOwnProperty.call(guideline, mline) && guideline[mline] !== null && _typeof(guideline[mline]) === 'object') {
    return guideline[mline].direction === 'sendrecv' || guideline[mline].direction === 'sendonly' || guideline[mline].direction === 'recvonly';
  }

  return false;
}



/***/ }),

/***/ "./src/Core/Utils.js":
/*!***************************!*\
  !*** ./src/Core/Utils.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assignObject": () => (/* binding */ assignObject),
/* harmony export */   "base64Binary": () => (/* binding */ base64Binary),
/* harmony export */   "browserDetails": () => (/* binding */ browserDetails),
/* harmony export */   "equals": () => (/* binding */ equals),
/* harmony export */   "isHTTP": () => (/* binding */ isHTTP),
/* harmony export */   "isHTTPS": () => (/* binding */ isHTTPS),
/* harmony export */   "isPropertyTypeof": () => (/* binding */ isPropertyTypeof),
/* harmony export */   "isTypeof": () => (/* binding */ isTypeof),
/* harmony export */   "is_numeric": () => (/* binding */ is_numeric),
/* harmony export */   "jsonToQueryString": () => (/* binding */ jsonToQueryString),
/* harmony export */   "mergeJSON": () => (/* binding */ mergeJSON),
/* harmony export */   "parseQueryString": () => (/* binding */ parseQueryString)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/* globals apiRTC_React*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('Utils');

function is_numeric(num) {
  var exp = new RegExp('^[0-9-.]*$', 'g');
  return exp.test(num);
}

function isHTTPS() {
  if (typeof apiRTC_React !== 'undefined') {
    return true;
  } else {
    return window.location.protocol === 'https:';
  }
}

function isHTTP() {
  if (typeof apiRTC_React !== 'undefined') {
    return false;
  } else {
    return window.location.protocol === 'http:';
  }
}

function parseQueryString(queryString) {
  var params = {},
      queries,
      temp,
      i,
      l; // Split into key/value pairs

  queries = queryString.split("&"); // Convert the array of strings into an object

  for (i = 0, l = queries.length; i < l; i++) {
    temp = queries[i].split('=');
    params[temp[0]] = temp[1];
  }

  return params;
}

function jsonToQueryString(json) {
  /*
      return '?' +
          Object.keys(json).map(function (key) {
              return encodeURIComponent(key) + '=' +
                  encodeURIComponent(json[key]);
          }).join('&');
  */
  return Object.keys(json).map(function (key) {
    return key + '=' + json[key];
  }).join('&');
}

function mergeJSON(source1, source2) {
  /*
   * Properties from the Souce1 object will be copied to Source2 Object.
   * Note: This method will return a new merged object, Source1 and Source2 original values will not be replaced.
   * */
  logger.debug("mergeJSON");
  var mergedJSON = {},
      key = null;

  if (source1) {
    for (key in source1) {
      if (source1.hasOwnProperty(key)) {
        mergedJSON[key] = source1[key];
      }
    }
  }

  if (source2) {
    for (key in source2) {
      if (source2.hasOwnProperty(key)) {
        mergedJSON[key] = source2[key];
      }
    }
  }

  logger.log(mergedJSON);
  return mergedJSON;
}

var assignObject = function assignObject(target, source) {
  var idx, key, from;

  if (target === undefined || target === null) {
    target = {};
  }

  for (idx = 1; idx < arguments.length; idx += 1) {
    from = arguments[idx];

    for (key in from) {
      if (from.hasOwnProperty(key)) {
        target[key] = from[key];
      }
    }
  }

  return target;
};

var browserDetails = function () {
  var extractVersion = function extractVersion(uastring, expr, pos) {
    var match = uastring.match(expr);
    return match && match.length >= pos && parseInt(match[pos], 10);
  };

  var result = {};

  if (typeof apiRTC_React !== 'undefined') {
    result.type = 'react-native';
    return result;
  }

  if (window !== undefined && window.navigator !== undefined) {
    if (window.navigator.mozGetUserMedia) {
      // Firefox.
      result.type = 'firefox';
      result.version = extractVersion(window.navigator.userAgent, /Firefox\/(\d+)\./, 1);
    } else if (window.navigator.webkitGetUserMedia) {
      // Chrome, Chromium, Webview, Opera, all use the chrome shim for now
      if (window.webkitRTCPeerConnection) {
        result.type = 'chrome';
        result.version = extractVersion(window.navigator.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
      } else if (window.navigator.userAgent.match(/Version\/(\d+).(\d+)/)) {
        // Safari (in an unpublished version) or unknown webkit-based.
        result.type = 'safari';
        result.version = extractVersion(window.navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
      } else {
        return result;
      }
    } else if (window.navigator.mediaDevices && window.navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)) {
      // Edge.
      result.type = 'edge';
      result.version = extractVersion(window.navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2);
    } else if (window.navigator.mediaDevices && window.navigator.userAgent.match(/AppleWebKit\/(\d+)\./)) {
      // Safari, with webkitGetUserMedia removed.
      result.type = 'safari';
      result.version = extractVersion(window.navigator.userAgent, /AppleWebKit\/(\d+)\./, 1);
    } else {
      return result;
    }
  }

  return result;
}();

var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-/=';
var base64Binary = {
  decode: function decode(input) {
    //get last chars to see if are valid
    var padding1 = encodings.indexOf(input.charAt(input.length - 1)),
        padding2 = encodings.indexOf(input.charAt(input.length - 2)),
        bytes = input.length / 4 * 3,
        chr1 = null,
        chr2 = null,
        chr3 = null,
        enc1 = null,
        enc2 = null,
        enc3 = null,
        enc4 = null,
        i,
        j = 0,
        arr = null;

    if (padding1 === 64) {
      bytes--; //padding chars, so skip
    }

    if (padding2 === 64) {
      bytes--; //padding chars, so skip
    }

    arr = new Uint8Array(bytes);

    for (i = 0; i < bytes; i += 3) {
      //get the 3 octets in 4 ascii chars
      enc1 = encodings.indexOf(input.charAt(j++));
      enc2 = encodings.indexOf(input.charAt(j++));
      enc3 = encodings.indexOf(input.charAt(j++));
      enc4 = encodings.indexOf(input.charAt(j++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      arr[i] = chr1;

      if (enc3 !== 64) {
        arr[i + 1] = chr2;
      }

      if (enc4 !== 64) {
        arr[i + 2] = chr3;
      }
    }

    return arr;
  },
  // Converts an ArrayBuffer directly to base64, without any intermediate 'convert to string then
  // use window.btoa' step. According to my tests, this appears to be a faster approach:
  // http://jsperf.com/encoding-xhr-image-data/5
  encode: function encode(arrayBuffer) {
    var base64 = '',
        bytes = new Uint8Array(arrayBuffer),
        byteLength = bytes.byteLength,
        byteRemainder = byteLength % 3,
        mainLength = byteLength - byteRemainder,
        a = null,
        b = null,
        c = null,
        d = null,
        chunk = null,
        i; // Main loop deals with bytes in chunks of 3

    for (i = 0; i < mainLength; i = i + 3) {
      // Combine the three bytes into a single integer
      chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2]; // Use bitmasks to extract 6-bit segments from the triplet

      a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18

      b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12

      c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6

      d = chunk & 63; // 63       = 2^6 - 1
      // Convert the raw binary segments to the appropriate ASCII encoding

      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
    } // Deal with the remaining bytes and padding


    if (byteRemainder === 1) {
      chunk = bytes[mainLength];
      a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
      // Set the 4 least significant bits to zero

      b = (chunk & 3) << 4; // 3   = 2^2 - 1

      base64 += encodings[a] + encodings[b] + '==';
    } else if (byteRemainder === 2) {
      chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];
      a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10

      b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4
      // Set the 2 least significant bits to zero

      c = (chunk & 15) << 2; // 15    = 2^4 - 1

      base64 += encodings[a] + encodings[b] + encodings[c] + '=';
    }

    return base64;
  }
};
/*
 * Tests whether a given variable is not null and matches a given type.
 * The type argument may be 'null' to match null type.
 * The type argument may be 'undefined' to match missing property.
 * The type argument may be 'array' to match array type.
 * The type argument may be 'object', 'number' or 'string'.
 * See JanusConnector/utils.js for original implementation.
 * See JanusConnector/test/utilsTests.js for test suite.
 *
 * @method isTypeof
 * @param v {any} variable.
 * @param t {string} type.
 * @return {boolean} true if variable is not undefined/null and matches given type, false otherwise.
 */

function isTypeof(v, t) {
  if (arguments.length === 3) {
    return isPropertyTypeof(arguments[0], arguments[1], arguments[2]);
  }

  if (t === 'null') {
    return v === null;
  }

  if (t === 'array') {
    return v !== null && _typeof(v) === 'object' && Array.isArray(v);
  }

  return v !== null && _typeof(v) === t;
}
/*
 * Tests whether a given object property exists, is not null and matches a given type.
 * The property argument may be an array of string values representing a property path.
 * The type argument may be 'null' to match null type.
 * The type argument may be 'undefined' to match missing property.
 * The type argument may be 'array' to match array type.
 * The type argument may be 'object', 'number' or 'string'.
 * See JanusConnector/utils.js for original implementation.
 * See JanusConnector/test/utilsTests.js for test suite.
 *
 * @method isPropertyTypeof
 * @param o {object} object.
 * @param p {string} property.
 * @param t {string} type.
 * @return {boolean} true if property exists, is not null and matches given type, false otherwise.
 */


function isPropertyTypeof(v, p, t) {
  if (p !== null && _typeof(p) === 'object' && Array.isArray(p) && p.length >= 1) {
    var f = p[0];

    if (p.length > 1) {
      return isTypeof(v, 'object') && isTypeof(f, 'string') && v.hasOwnProperty(f) && isTypeof(v[f], 'object') && isPropertyTypeof(v[f], p.slice(1), t);
    }

    p = f;
  }

  if (t === 'undefined') {
    return isTypeof(v, 'object') && isTypeof(p, 'string') && !v.hasOwnProperty(p) && isTypeof(v[p], t);
  }

  return isTypeof(v, 'object') && isTypeof(p, 'string') && v.hasOwnProperty(p) && isTypeof(v[p], t);
}
/*
 * Tests whether JSON objects are equal
 *
 * @method equals
 * @param x {object} JSON
 * @param y {object} JSON
 * @return {boolean} true if JSON are equals
 */


function equals(x, y) {
  // If both x and y are null or undefined and exactly the same
  if (x === y) {
    return true;
  } // If they are not strictly equal, they both need to be Objects


  if (!(x instanceof Object) || !(y instanceof Object)) {
    return false;
  } // They must have the exact same prototype chain, the closest we can do is
  // test the constructor.


  if (x.constructor !== y.constructor) {
    return false;
  }

  for (var p in x) {
    // Inherited properties were tested using x.constructor === y.constructor
    if (x.hasOwnProperty(p)) {
      // Allows comparing x[ p ] and y[ p ] when set to undefined
      if (!y.hasOwnProperty(p)) {
        return false;
      } // If they have the same strict value or identity then they are equal


      if (x[p] === y[p]) {
        continue;
      } // Numbers, Strings, Functions, Booleans must be strictly equal


      if (_typeof(x[p]) !== "object") {
        return false;
      } // Objects and Arrays must be tested recursively


      if (!equals(x[p], y[p])) {
        return false;
      }
    }
  }

  for (p in y) {
    // allows x[ p ] to be set to undefined
    if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)) {
      return false;
    }
  }

  return true;
}



/***/ }),

/***/ "./src/Core/WebRTC_Adapter.js":
/*!************************************!*\
  !*** ./src/Core/WebRTC_Adapter.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebRTC_Adapter": () => (/* binding */ WebRTC_Adapter)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* globals RTCSessionDescription, RTCIceCandidate, RTCPeerConnection, getUserMedia, cordova*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('WebRTC_Stack');
/*
* WebRTC_Adapter manage compatibility with brower : ie : Chrome & Firefox.
*
* @module WebRTC_Adapter
*/

var WebRTC_Adapter = function WebRTC_Adapter() {
  this.adaptForIoSCordova = function () {
    if (apiRTC.osName === 'iOS' && typeof cordova !== 'undefined') {
      logger.log("Modification for iOS cordova");

      if (cordova.plugins === undefined) {
        logger.log("cordova.plugins not defined");
        return;
      }

      if (cordova.plugins.iosrtc === undefined) {
        logger.log("cordova.plugins.iosrtc not defined");
        return;
      }

      this.RTCPeerConnection = cordova.plugins.iosrtc.RTCPeerConnection;
      this.RTCSessionDescription = cordova.plugins.iosrtc.RTCSessionDescription;
      this.RTCIceCandidate = cordova.plugins.iosrtc.RTCIceCandidate;
    }
  };
  /*
  //TODO Fred : check if this is still used :
      this.webrtcDetectedBrowser = 'undefined';
      this.webrtcDetectedVersion = 0;
  
      if ((typeof (apiRTC_React) === 'undefined') && (typeof adapter.browserDetails !== 'undefined')) {
          logger.log("adapter.browserDetails.browser :", adapter.browserDetails.browser);
          logger.log("adapter.browserDetails.version :", adapter.browserDetails.version);
  
          this.webrtcDetectedBrowser = adapter.browserDetails.browser;
          this.webrtcDetectedVersion = adapter.browserDetails.version;
      }
  */


  if (typeof RTCSessionDescription !== 'undefined') {
    this.RTCSessionDescription = RTCSessionDescription;
  } else {
    logger.log("RTCSessionDescription is undefined");
  }

  if (typeof RTCIceCandidate !== 'undefined') {
    this.RTCIceCandidate = RTCIceCandidate;
  } else {
    logger.log("RTCIceCandidate is undefined");
  }

  if (typeof RTCPeerConnection !== 'undefined') {
    this.RTCPeerConnection = RTCPeerConnection;
  } else {
    logger.log("RTCPeerConnection is undefined");
  }

  if (typeof navigator.getUserMedia !== 'undefined') {
    this.getUserMedia = navigator.getUserMedia;
  } else if (typeof getUserMedia !== 'undefined') {
    this.getUserMedia = getUserMedia;
  } else {
    logger.log("getUserMedia is undefined");
  }
};



/***/ }),

/***/ "./src/Core/WebRTC_Call.js":
/*!*********************************!*\
  !*** ./src/Core/WebRTC_Call.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebRTC_Call": () => (/* binding */ WebRTC_Call)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* harmony import */ var _WebRTC_Stack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WebRTC_Stack */ "./src/Core/WebRTC_Stack.js");
/* harmony import */ var _QoSMonitor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./QoSMonitor */ "./src/Core/QoSMonitor.js");
/* harmony import */ var _DataChannelFileSender__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DataChannelFileSender */ "./src/Core/DataChannelFileSender.js");
/* harmony import */ var _CallStatsMonitor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CallStatsMonitor */ "./src/Core/CallStatsMonitor.js");
/* harmony import */ var _PerceivedQualityScore__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./PerceivedQualityScore */ "./src/Core/PerceivedQualityScore.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/* globals apiCC, alert, cordova, apiRTC_React*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('WebRTC_Call');

var myWebRTC_Event = apiCC.myWebRTC_Event;






/*
* This is the description for my class WebRTC_Call.
*
* @module webRTC_Call
*/

var WebRTC_Call = function WebRTC_Call(webRTCClient) {
  this.dest_roomId = '';
  this.pc = null;
  this.callId = 0;
  this.callee = false;
  this.callerId = 0;
  this.calleeId = 0;
  this.started = false;
  this.localDescriptionSetted = false;
  this.remoteDescriptionSetted = false;
  this.sendedSdpOfferMessage = null;
  this.receivedSdpOfferMessage = null;
  this.myWebRTC_Stack = new _WebRTC_Stack__WEBPACK_IMPORTED_MODULE_3__.WebRTC_Stack(webRTCClient.socket); // Remote media streams.

  this.remoteMediaStreams = []; // Result of PeerConnection.addTrack.

  this.rtpSenders = {
    'audio': [],
    'video': []
  }; // For update media on call.

  this.addingUserMedia = false; //TEMP_APIRTCV4 a voir
  //Voir doublon this.myWebRTC_Event et myWebRTC_Event

  this.myWebRTC_Event = apiCC.myWebRTC_Event;
  this.dtmfSender = null;
  this.incomingcandidatesQueue = [];

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox') {
    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version > 43) {
      this.mediaConstraintsAudioOnly = {
        'offerToReceiveAudio': true,
        'offerToReceiveVideo': false
      };
      this.mediaConstraints = {
        "offerToReceiveAudio": 1,
        "offerToReceiveVideo": 1
      };
    } else {
      this.mediaConstraintsAudioOnly = {
        'mandatory': {
          'offerToReceiveAudio': true,
          'offerToReceiveVideo': false
        }
      };
      this.mediaConstraints = {
        'mandatory': {
          'offerToReceiveAudio': true,
          'offerToReceiveVideo': true
        }
      };
    }
  } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome') {
    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55) {
      this.mediaConstraintsAudioOnly = {
        'mandatory': {
          'OfferToReceiveAudio': true,
          'OfferToReceiveVideo': true
        }
      };
      this.mediaConstraints = {
        'mandatory': {
          'OfferToReceiveAudio': true,
          'OfferToReceiveVideo': true
        }
      };
    } else {
      this.mediaConstraintsAudioOnly = {
        offerToReceiveAudio: 1,
        offerToReceiveVideo: 1
      };
      this.mediaConstraints = {
        offerToReceiveAudio: 1,
        offerToReceiveVideo: 1
      };
    }
  } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Edge") {
    this.mediaConstraintsAudioOnly = {
      'offerToReceiveAudio': true,
      'offerToReceiveVideo': false
    };
    this.mediaConstraints = {
      "offerToReceiveAudio": 1,
      "offerToReceiveVideo": 1
    };
  } else {
    this.mediaConstraintsAudioOnly = {
      offerToReceiveAudio: 1,
      offerToReceiveVideo: 1
    };
    this.mediaConstraints = {
      offerToReceiveAudio: 1,
      offerToReceiveVideo: 1
    };
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osUAParser.name === "iOS") {
    logger.log("Defining mediaConstraints for iOS ");
    this.mediaConstraints = {
      'offerToReceiveAudio': true,
      'offerToReceiveVideo': true
    };
  }

  this.trickleIce = webRTCClient.trickleIce;
  this.callLocalStream = null;
  this.generatedLocalStream = false;
  this.audioOnly = false;
  this.inviteSended = false;
  this.sendInviteTrickleIceFalseTimeOutId = 0;
  this.sendInviteTrickleIceFalseTimer = 5000;
  this.message200OKSended = false;
  this.send200OKTrickleIceFalseTimeOutId = 0;
  this.send200OKTrickleIceFalseTimer = 5000;
  this.message200OKReceived = false;
  this.callCancelled = false;
  this.screenSharing = false;
  this.desktopId = 0;
  this.pc_config = webRTCClient.pc_config;
  this.pc_constraints = webRTCClient.pc_constraints;
  this.audioFileMediaElement = null; // has to be a multiple of qosMonitor.cptRes and qosMonitor.cptDb
  // and getStatsInterval<= qosMonitor.cptRes
  //resolution

  this.videoReceivedWidth = 640;
  this.videoReceivedHeight = 480;
  this.videoSendWidth = 640;
  this.videoSendHeight = 480; //Audio and Video Delay

  this.videoReceivedDelay = 0;
  this.audioReceivedDelay = 0;
  this.audioSendDelay = 0;
  this.videoSendDelay = 0;
  this.videoSendPacketLossRatio = 0;
  this.audioSendPacketLossRatio = 0;
  this.getStatsInterval = webRTCClient.qosInterval; // milliseconds

  this.qm = null;
  this.statisticId = null;
  this.csmIntervalMs = webRTCClient.csmIntervalMs;
  this.csmIntervalId = null;
  this.remoteId = 0;
  this.callType = "media"; // Call profile for local stream sent to remote.

  this.localCallProfile = {
    audio: false,
    // whether an audio mline exists in SDP.
    audioActive: false,
    // whether an audio mline exists in SDP and its direction is not inactive (simplified).
    video: false,
    // whether a video mline exists in SDP.
    videoActive: false // whether a video mline exists in SDP and its direction is not inactive (simplified).

  }; // Call profile for remote stream received from remote.

  this.remoteCallProfile = {
    audio: false,
    // whether an audio mline exists in SDP.
    audioActive: false,
    // whether an audio mline exists in SDP and its direction is not inactive (simplified).
    video: false,
    // whether a video mline exists in SDP.
    videoActive: false // whether a video mline exists in SDP and its direction is not inactive (simplified).

  };
  this.disconnectionTimeoutId = 0; //used to keep timeOutId on disconnection detection

  this.disconnectionTimer = 40000; //Timer for call end after disconnection detection

  this.disconnectionWarningDelay = 9000; //Time between dc warnings

  this.disconnectionWarningInterval = 0; //keep track of dc warning interval function

  this.disconnectionWarningTimeout = 0; //keep track of dc warning timeout function

  this.disconnectionWarningCount = 0; //To avoid dc warning just before call end

  this.checkCandidateTypesTimer = 10000; //Timer for checkCandidateTypes : this is done on (iceConnectedState = connected or completed) + timer

  this.checkCandidateTypesTimeoutId = 0;
  this.checkCandidateTypesTimeoutTable = [];
  this.data = {};
  this.screenStream = null;
  this.screenIsDisplayed = false; // datachannel

  this.addingDataChannelOnCallOngoing = false;
  this.sendDataChannel = null;
  this.receiveDataChannel = null;
  this.receiveChunkNb = {};
  this.firstDataPacket = {};
  this.receivedSize = {};
  this.receiveArrayToStoreChunks = {};
  this.destCallType = "media";
  this.mcuRemoteStream = null; // Denotes whether access to user media is required.

  this.userMediaAccessRequired = true; // Denotes the setting-up mode (either normal or passive).

  this.settingUpMode = "normal";
  this.remoteType = "web";
  this.mediaTypeForIncomingCall = webRTCClient.mediaTypeForIncomingCall; //value can be : VIDEO, AUDIO, VIDEOONLY, NONE

  this.mediaTypeForOutgoingCall = webRTCClient.mediaTypeForOutgoingCall; //value can be : VIDEO, AUDIO, VIDEOONLY, NONE

  this.mediaRoutingMode = webRTCClient.mediaRoutingMode; //this.internetConnectionLost = false;

  this.stripAudioSDPActivated = false;
  this.stripVideoSDPActivated = false;
  this.iceState = 'notdefined';
  this.restarted = false;
  this.audioSdpDirection = null; // Local description direction for audio mline.

  this.videoSdpDirection = null; // Local description direction for video mline.
  // Mute state for local stream.

  this.isLocalAudioMuted = false;
  this.isLocalVideoMuted = false; // Mute state for remote stream.

  this.isRemoteAudioMuted = false;
  this.isRemoteVideoMuted = false;
  this.isRemoteAudioSilent = false;
  this.isRemoteVideoSilent = false;
  this.isAccepted = false;
  this.accessToMedia = false;
  this.callConfiguration = null;
  this.captureSourceType = null;
  this.preferH264Codec = false;
  this.preferVP8Codec = false;
  this.preferVP9Codec = false;
  this.candidateNb = 0; // The sessionMCU this one has been established into. Keep null for 1-to-1 call.

  this.sessionMCU = null; //InstanceId for call restart

  this.instanceId = 0;
  this.retryUpdateMedia = false; //Used to set that an updateMedia has been cancelled as signalingState was not stable and that we will retry when stable

  this.updateMediaOngoing = false; //Used to indicate if an updateMedia is ongoing

  this.setCallTurnServer = function (turnServerAddress) {
    logger.info("setCallTurnServer :", turnServerAddress);
    var stringified_pc_config = JSON.stringify(this.pc_config);
    stringified_pc_config = stringified_pc_config.replace(/mp1.apizee.com/g, turnServerAddress);
    this.pc_config = JSON.parse(stringified_pc_config);
  };

  this.setCallMediaRoutingMode = function (mediaRoutingMode) {
    logger.info("setCallMediaRoutingMode :", mediaRoutingMode);

    if (mediaRoutingMode === "hostOnly") {
      this.mediaRoutingMode = webRTCClient.mediaRoutingModeEnum.hostOnly;
    } else if (mediaRoutingMode === "stun") {
      this.mediaRoutingMode = webRTCClient.mediaRoutingModeEnum.stun;
    } else if (mediaRoutingMode === "stunOnly") {
      this.mediaRoutingMode = webRTCClient.mediaRoutingModeEnum.stunOnly;
    } else if (mediaRoutingMode === "turn") {
      this.mediaRoutingMode = webRTCClient.mediaRoutingModeEnum.turn;
    } else if (mediaRoutingMode === "turnOnly") {
      this.mediaRoutingMode = webRTCClient.mediaRoutingModeEnum.turnOnly;
    } else {
      logger.log("parameter error when calling function : setCallMediaRoutingMode()");
      this.myWebRTC_Event.createErrorEvent('parameter error when calling function : setCallMediaRoutingMode()', 'PARAMETER_ERROR_SETCALLMEDIAROUTINGMODE');
    }
  };

  this.checkDTLSCompliancy = function () {
    logger.debug("checkDTLSCompliancy");

    if (apiCC.session.isDeviceDTLSCompliant() === false) {
      logger.log("Device not DTLS compliant, setting DtlsSrtpKeyAgreement: false");
      this.pc_constraints = {
        "optional": [{
          "DtlsSrtpKeyAgreement": false
        }]
      };
    } else {
      //Checking if callingParty is DTLS compliant
      var isRemoteUserDTLSCompliant = apiCC.session.isClientDTLSCompliant(this.remoteId);

      if (isRemoteUserDTLSCompliant === false || isRemoteUserDTLSCompliant === 'false') {
        logger.log("Remote Device not DTLS compliant, setting DtlsSrtpKeyAgreement: false");
        this.pc_constraints = {
          "optional": [{
            "DtlsSrtpKeyAgreement": false
          }]
        };
      }
    }
  };

  this.sendData = function (data, onProgress) {
    // file : fileToSend, name : file.name, type : file.type }
    logger.info("datachannel - sendData"); //logger.log("data.file :" + data.file);
    //logger.log("data.name :" + data.name);

    var reader = null,
        self = null,
        myDataChannelFileSender = null;

    if (data.file instanceof File) {
      logger.log("File");
      this.contentType = data.file.type;
      this.originalDataType = "File";
      reader = new FileReader();
      self = this;

      reader.onload = function (e) {
        var fileToSend = e.target.result || reader.result; //logger.log("fileToSend :" + fileToSend);

        self.sendData({
          "file": fileToSend,
          "name": data.name,
          "type": data.type
        }, onProgress);
      };

      reader.readAsArrayBuffer(data.file);
      return;
    }

    myDataChannelFileSender = new _DataChannelFileSender__WEBPACK_IMPORTED_MODULE_5__.DataChannelFileSender(this);
    myDataChannelFileSender.send(data, this.sendDataChannel, onProgress);
  };

  logger.log('New Call for client with Id :' + webRTCClient.clientId);

  this.generateCallId = function () {
    this.callId = apiCC.generateCallId();
    logger.info('new call with callId :' + this.callId);
  };

  this.sendInviteTrickleIceFalse = function () {
    logger.log('sendInviteTrickleIceFalse');
    logger.log('sendInvite on candidate timer reached');
    this.myWebRTC_Stack.sendInvite(this.callId, this.callerId, webRTCClient.nickname, this.dest_roomId, this.dest_roomId, this.callType, {
      offer: this.pc.localDescription,
      data: this.data,
      stream: this.mcuRemoteStream,
      "volatile": !!this.restarted
    });
    this.inviteSended = true;
  };

  this.send200OkTrickleIceFalse = function () {
    logger.log('send200OkTrickleIceFalse');
    this.myWebRTC_Stack.send200OK(this.callId, this.callerId, this.calleeId, webRTCClient.nickname, this.dest_roomId, this.pc.localDescription, this.data);
    this.message200OKSended = true;
  };

  this.onSetLocalDescriptionSuccess = function () {
    logger.info('onSetLocalDescriptionSuccess');
    this.localDescriptionSetted = true;

    if (this.asyncCallbacks) {
      if (this.asyncCallbacks.type === 'subscribe') {
        delete this.asyncCallbacks;
      }
    }

    if (this.trickleIce === false) {
      //TriclkeIce is desactivated
      if (this.callee === true) {
        //Need to set a timeout to send 200OK in the case the time before the end of candidate is too long
        logger.info('starting send200OKTrickleIceFalseTimeOutId');
        this.send200OKTrickleIceFalseTimeOutId = setTimeout(this.callback(this, 'send200OkTrickleIceFalse'), this.send200OKTrickleIceFalseTimer);
      } else {
        //Need to set a timeout to send Invite in the case the time before the end of candidate is too long
        logger.info('starting sendInviteTrickleIceFalseTimeOutId');
        this.sendInviteTrickleIceFalseTimeOutId = setTimeout(this.callback(this, 'sendInviteTrickleIceFalse'), this.sendInviteTrickleIceFalseTimer);
      }
    }

    if (webRTCClient.rtpSenderSetParamatersCapable) {
      // Need to wait for the local description to be applied before evaluate the video cap and change the bitrate.
      webRTCClient.evaluateVideoCap(this);
    }
  };

  this.onSetLocalDescriptionFailure = function (e) {
    logger.warn('onSetLocalDescriptionFailure', e);
    var roomName = null,
        settingUpType = null;

    if (this.callControl) {
      roomName = this.callControl.roomName;
      settingUpType = this.callControl.type;
    }

    myWebRTC_Event.createErrorEvent('Set local Description Failure', 'SET_LOCAL_DESCRIPTION_FAILURE', this.callId, roomName, settingUpType);
    webRTCClient.onHangup(this.callId, 'Local_Description_Failure');
  };

  this.onSetRemoteDescriptionSuccess = function () {
    logger.info('onSetRemoteDescriptionSuccess');
    var msg = null;
    this.remoteDescriptionSetted = true;

    if (this.restarting === true) {
      delete this.restarting;
    }

    if (!this.data || !this.data.mesh && !this.data.subscribeOrder) {
      // callEstablished event is hidden from upper level in mesh configuration.
      myWebRTC_Event.createCallEstablishedEvent(this.calleeId, this.callType, this.callId, this.destCallType);
    } //Checking if there are some bufferized candidate


    while (this.incomingcandidatesQueue.length) {
      msg = this.incomingcandidatesQueue.shift();
      this.processCandidateMsg(msg);
    } //Checking if there are some bufferized candidate at client level


    if (webRTCClient.clientIncomingCandidatesQueue[this.callId + '-' + this.instanceId] !== undefined) {
      logger.debug('Restoring candidate from client, this.callId :' + this.callId + " , instanceId :" + this.instanceId);

      while (webRTCClient.clientIncomingCandidatesQueue[this.callId + '-' + this.instanceId].length) {
        msg = webRTCClient.clientIncomingCandidatesQueue[this.callId + '-' + this.instanceId].shift(); //logger.debug('Restoring candidate :', msg);

        this.processCandidateMsg(msg);
      }

      delete webRTCClient.clientIncomingCandidatesQueue[this.callId + '-' + this.instanceId];
    }

    if (this.asyncCallbacks) {
      if (this.asyncCallbacks.type === 'addingUserMedia') {
        // Preceding addMedia requires a promise to be resolved.
        this.asyncCallbacks.resolve(this.callConfiguration.userMediaStreamId);

        if (this.asyncCallbacks.timeoutId) {
          clearTimeout(this.asyncCallbacks.timeoutId);
          delete this.asyncCallbacks.timeoutId;
        }

        delete this.asyncCallbacks;
      } else if (this.asyncCallbacks.type === 'updateCallConfiguration') {
        // Preceding updateCallConfigurationOnCall requires a promise to be resolved.
        this.asyncCallbacks.resolve();

        if (this.asyncCallbacks.timeoutId) {
          clearTimeout(this.asyncCallbacks.timeoutId);
          delete this.asyncCallbacks.timeoutId;
        }

        delete this.asyncCallbacks;
      }
    }

    this.updateMediaOngoing = false; //Setting updateMediaOngoing to false

    if (this.retryUpdateMedia === true) {
      logger.debug('an updateMedia was waiting for sig stable state or an other updateMedia end, updating Media now ...');
      this.retryUpdateMedia = false;
      var updateMediaResult = this.updateMedia(false);
      logger.debug('Retried updateMediaResult :', updateMediaResult); //We don't retry updateMedia a second time
    }
  };

  this.processCandidateMsg = function (msg) {
    logger.info("processCandidateMsg :", msg);
    var candidate = null;

    if (this.pc !== null) {
      if (msg.completeCandidate !== undefined) {
        //new behavior of 2.13.8
        logger.trace("new behavior of 2.13.8");
        candidate = new apiCC.myWebRTC_Adapter.RTCIceCandidate(msg.completeCandidate);
      } else {
        //should be DEPRECATED Since 2.13.8 : but this is useful for IE/Temasys
        //sendCandidate will need to be cleaned : removing label, id and candidate
        logger.log("old behavior < 2.13.8");
        candidate = new apiCC.myWebRTC_Adapter.RTCIceCandidate({
          sdpMLineIndex: msg.label,
          candidate: msg.candidate
        });
      }

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
        logger.log("addIceCandidate");
        this.pc.addIceCandidate(candidate, function () {
          logger.trace("addIceCandidate success");
        }, function (e) {
          logger.warn("addIceCandidate failure: " + e);
          e = null;
        });
      } else {
        logger.log("addIceCandidate - Promise version");
        this.pc.addIceCandidate(candidate).then(function () {
          logger.trace("addIceCandidate success");
        })["catch"](function (e) {
          logger.warn("addIceCandidate failure: " + e);
          e = null;
        });
      }
    } else {
      logger.error('Error, call is not null but pc is null');
    }
  };

  this.onSetRemoteDescriptionFailure = function (e) {
    logger.warn('onSetRemoteDescriptionFailure :', e);
    var roomName = null,
        settingUpType = null;

    if (this.callControl) {
      roomName = this.callControl.roomName;
      settingUpType = this.callControl.type;
    }

    myWebRTC_Event.createErrorEvent('Set remote Description Failure', 'SET_REMOTE_DESCRIPTION_FAILURE', this.callId, roomName, settingUpType);
    webRTCClient.onHangup(this.callId, 'Remote_Description_Failure');
  };

  this.getUserMediaOnCall = function () {
    var _this = this;

    var videoOnly = false;
    logger.info('getUserMediaOnCall, audio Only :' + this.audioOnly);
    logger.info('getUserMediaOnCall, screenSharing activated :' + this.screenSharing);
    logger.log("webRTCClient.gum_config :", webRTCClient.gum_config);

    if (this.callerId === webRTCClient.clientId) {
      logger.log("outgoing call");

      if (this.mediaTypeForOutgoingCall === 'VIDEO' || this.mediaTypeForOutgoingCall === 'VIDEOONLY') {
        logger.log("mediaTypeForOutgoingCall :" + this.mediaTypeForOutgoingCall);

        if (this.mediaTypeForOutgoingCall === 'VIDEOONLY') {
          videoOnly = true;
        }

        if (this.screenSharing !== true) {
          if (apiCC.mediaDeviceMgr.videoDevicePresent === false) {
            if (apiCC.mediaDeviceMgr.audioDevicePresent === false) {
              logger.log("getUserMediaOnCall without any device, calling without device");
              this.onUserMediaSuccessOnCall();
              return;
            } else {
              logger.log("video is not present :" + this.callType);

              if (this.callType === 'media') {
                logger.log("callType is media, but no webcam present, forcing callType to audio");
                this.callType = 'audio';
                this.audioOnly = true;
              }
            }
          }
        } else {
          logger.log("screenSharing, no device checking");
        }
      } else if (this.mediaTypeForOutgoingCall === 'AUDIO') {
        logger.log("mediaTypeForOutgoingCall is AUDIO, setting call to audioOnly"); //Considering call as audioOnly

        this.callType = 'audio';
        this.audioOnly = true;
      } else if (this.mediaTypeForOutgoingCall === 'NONE' || this.mediaTypeForOutgoingCall === 'DATA') {
        logger.log("mediaTypeForOutgoingCall is NONE, call will be recvOnly");
        this.onUserMediaSuccessOnCall();
        return;
      }
    } else {
      logger.log("incoming call");

      if (this.mediaTypeForIncomingCall === 'VIDEO' || this.mediaTypeForIncomingCall === 'VIDEOONLY') {
        logger.log("mediaTypeForIncomingCall :" + this.mediaTypeForIncomingCall);

        if (this.mediaTypeForIncomingCall === 'VIDEOONLY') {
          videoOnly = true;
        }

        if (apiCC.mediaDeviceMgr.videoDevicePresent === false) {
          if (apiCC.mediaDeviceMgr.audioDevicePresent === false) {
            logger.log("getUserMediaOnCall without any device, calling without device");
            this.onUserMediaSuccessOnCall();
            return;
          } else {
            logger.log("video is not present :" + this.callType);

            if (this.callType === 'media') {
              logger.log("callType is media, but no webcam present, forcing callType to audio");
              this.callType = 'audio';
              this.audioOnly = true;
            }
          }
        }
      } else if (this.mediaTypeForIncomingCall === 'AUDIO') {
        logger.log("mediaTypeForIncomingCall is AUDIO, setting call to audioOnly"); //Considering call as audioOnly

        this.callType = 'audio';
        this.audioOnly = true;
      } else if (this.mediaTypeForIncomingCall === 'NONE' || this.mediaTypeForIncomingCall === 'DATA') {
        logger.log("mediaTypeForIncomingCall is NONE, call will be recvOnly");
        this.onUserMediaSuccessOnCall();
        return;
      }
    }

    webRTCClient.getUserMediaOnGoing = true;
    var localUserMediaConstraint = null,
        modifiedConstraint = null;
    logger.log("this.screenSharing :" + this.screenSharing);
    logger.log("this.audioOnly :" + this.audioOnly);

    if (this.screenSharing === true) {
      logger.log("getScreenMedia");

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome") {
        logger.log("this.desktopId :" + this.desktopId);
        localUserMediaConstraint = {
          /*
          audio: {
              mandatory: {
                  chromeMediaSource: 'system',
                  chromeMediaSourceId: this.desktopId//,
                  //,
                  //googDisableLocalEcho: false
              }
          },
          */
          video: {
            mandatory: {
              //maxWidth: 1920,
              //maxHeight: 1080,
              //minAspectRatio: 1.77,
              chromeMediaSource: "desktop",
              chromeMediaSourceId: this.desktopId
            }
          }
        };
      } else {
        //Browser is Firefox
        logger.log("this.captureSourceType :" + this.captureSourceType);

        if (this.captureSourceType !== 'screen' && this.captureSourceType !== 'window' && this.captureSourceType !== 'application') {
          logger.error("captureSourceType value is not correct");
          return;
        }

        localUserMediaConstraint = {
          video: {
            mediaSource: this.captureSourceType
          }
        };
      }
    } else if (this.audioOnly === true) {
      logger.log("this.audioOnly = true");
      webRTCClient.gum_config = apiCC.setAudioSourceIdInConstraint(webRTCClient.audioSourceId, webRTCClient.gum_config);
      modifiedConstraint = JSON.parse(JSON.stringify(webRTCClient.gum_config)); //Cloning object to avoid modification of webRTCClient.gum_config

      if (webRTCClient.allowAsymetricMediaCalls === false) {
        //If allowAsymetricMediaCalls = false, on incoming audio call, we answers with an audio call
        modifiedConstraint.video = false;
      } else {
        logger.log('allow AsymetricMediaCalls is activated');
      }

      localUserMediaConstraint = modifiedConstraint;
    } else {
      logger.log("audio and video call");
      localUserMediaConstraint = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.assignObject)({}, webRTCClient.gum_config);

      if (videoOnly) {
        localUserMediaConstraint.audio = false;
      } else {
        localUserMediaConstraint = apiCC.setAudioSourceIdInConstraint(webRTCClient.audioSourceId, localUserMediaConstraint);
      }

      localUserMediaConstraint = apiCC.setVideoSourceIdInConstraint(webRTCClient.videoSourceId, localUserMediaConstraint);
      localUserMediaConstraint = apiCC.setVideoFacingModeInConstraint(webRTCClient.facingMode, localUserMediaConstraint);

      if (typeof apiRTC_React !== 'undefined') {
        //TODO Voir selection camra in React
        //var isFront = true;
        localUserMediaConstraint = {
          audio: true,
          video: {
            mandatory: {
              minWidth: 500,
              // Provide your own width, height and frame rate here
              minHeight: 300,
              minFrameRate: 30
            },
            facingMode: "user" //,
            //facingMode: (isFront ? "user" : "environment")//,
            //optional: (videoSourceId ? [{sourceId: videoSourceId}] : [])

          }
        };
      }
    }

    apiCC.createUserMediaStream({
      'callId': this.callId,
      'type': this.callType,
      'gum_config': localUserMediaConstraint,
      'success': function success(userMediaStream) {
        logger.debug('[getUserMediaOnCall] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);

        if (_this.callConfiguration === undefined || _this.callConfiguration === null) {
          _this.callConfiguration = {};
        }

        _this.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;

        _this.onUserMediaSuccessOnCall(userMediaStream.stream);
      },
      'failure': function failure(userMediaStream, error) {
        logger.debug('[getUserMediaOnCall] failure; userMediaStreamId: ' + userMediaStream.userMediaStreamId);

        _this.onUserMediaErrorOnCall(error);
      }
    });
  };

  this.handleToneChangeEvent = function (event) {
    logger.debug("handleToneChangeEvent :", event.tone);

    if (event.tone !== "") {
      logger.debug("Tone played: " + event.tone);
    } else {
      logger.debug("All tones have played.");
    }
  };

  this.sendTones = function (tones, duration, gap) {
    logger.debug("sendTones :");

    if (this.dtmfSender) {
      logger.debug('sendTones : Tones, duration, gap: ', tones, duration, gap);
      this.dtmfSender.insertDTMF(tones, duration, gap);
    }
  };
  /*
   * @param {MediaStream} stream - the media stream to add to the peer connection.
   * @return {Promise}
   */


  this.addStream = function (stream) {
    var tracks = null,
        i,
        senders = null,
        si = 0,
        found = false,
        newSender = null,
        newTransceiver = null,
        promises = [];

    if (typeof apiRTC_React !== 'undefined' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 51 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 65 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Safari" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version < 12.1 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Mobile Safari" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version < 12.1 || apiRTC.osName === 'iOS' && typeof cordova !== 'undefined' && typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.iosrtc !== 'undefined') {
      logger.info("using addStream method");
      this.pc.addStream(stream);
      logger.debug("end addStream method");
    } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 59 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Edge") {
      logger.info("using addTrack method");
      tracks = stream.getTracks();

      for (i = 0; i < tracks.length; i += 1) {
        this.pc.addTrack(tracks[i], stream);
      }

      logger.debug("end addTrack method");
    } else {
      logger.info("using addTrack/replaceTrack method");
      tracks = stream.getTracks();

      for (i = 0; i < tracks.length; i += 1) {
        found = false;
        senders = this.rtpSenders[tracks[i].kind];

        for (si = 0; si < senders.length; si += 1) {
          if (senders[si].track === null) {
            found = true;
            break;
          }
        }

        if (found === true) {
          promises.push(senders[si].replaceTrack(tracks[i]));
          logger.debug('addStream -> replaceTrack', senders[si]);
        } else {
          if (this.simulcast === 'RID' && tracks[i].kind === 'video' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome') {
            // simulcast for video
            var sendEncodings = [{
              rid: 'h',
              active: true,
              maxBitrate: 900000
            }, {
              rid: 'm',
              active: true,
              maxBitrate: 300000,
              scaleResolutionDownBy: 2
            }, {
              rid: 'l',
              active: true,
              maxBitrate: 100000,
              scaleResolutionDownBy: 4
            }];

            if (this.callControl.callConfiguration.simulcast && this.callControl.callConfiguration.simulcast.sendEncodings) {
              sendEncodings = this.callControl.callConfiguration.simulcast.sendEncodings.slice();
            }

            newTransceiver = this.pc.addTransceiver(tracks[i], {
              direction: 'sendonly',
              streams: [stream],
              sendEncodings: sendEncodings
            });
            newSender = newTransceiver.sender;
          } else {
            newSender = this.pc.addTrack(tracks[i], stream);

            if (this.simulcast === 'RID' && tracks[i].kind === 'video' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
              // simulcast for video
              var parameters = newSender.getParameters();

              if (!parameters) {
                parameters = {};
              }

              if (this.callControl.callConfiguration.simulcast && this.callControl.callConfiguration.simulcast.sendEncodings) {
                parameters.encodings = this.callControl.callConfiguration.simulcast.sendEncodings.slice();
              } else {
                parameters.encodings = [{
                  rid: 'h',
                  active: true,
                  maxBitrate: 900000
                }, {
                  rid: 'm',
                  active: true,
                  maxBitrate: 300000,
                  scaleResolutionDownBy: 2
                }, {
                  rid: 'l',
                  active: true,
                  maxBitrate: 100000,
                  scaleResolutionDownBy: 4
                }];
              }

              promises.push(newSender.setParameters(parameters));
            }
          }

          logger.debug('addStream -> addTrack', newSender);
          this.rtpSenders[tracks[i].kind].push(newSender);
        }
      }

      logger.debug("end addTrack/replaceTrack method"); //DTMF Process

      if (this.rtpSenders.audio.length > 0) {
        this.dtmfSender = this.rtpSenders.audio[0].dtmf;

        if (this.dtmfSender) {
          this.dtmfSender.ontonechange = this.handleToneChangeEvent;
        }
      }

      return new Promise(function (resolve, reject) {
        Promise.all(promises).then(function (values) {
          resolve();
        })["catch"](reject);
      });
    }

    return Promise.resolve();
  };
  /*
   * @param {MediaStream} stream - the media stream to remove from the peer connection.
   * @return {Promise}
   */


  this.removeStream = function (stream) {
    var i,
        senders = null,
        promises = [];
    logger.info("removeStream in call", stream.id);

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 51 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 65 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Safari" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version < 12.1 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Mobile Safari" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version < 12.1 || apiRTC.osName === 'iOS' && typeof cordova !== 'undefined' && typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.iosrtc !== 'undefined') {
      logger.info("using removeStream method");
      this.pc.removeStream(stream);
      logger.debug("end removeStream method");
    } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 59 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Edge") {
      logger.info("using removeTrack method");
      senders = this.pc.getSenders();
      logger.debug("senders :", senders); //TODO we remove all stream/sender : see how to limit to sender linked to the stream in parameter

      for (i = 0; i < senders.length; i += 1) {
        this.pc.removeTrack(senders[i]);
      }

      logger.debug("end removeTrack method");
    } else {
      logger.info("using replaceTrack method");

      for (i = 0; i < this.rtpSenders.audio.length; i += 1) {
        promises.push(this.rtpSenders.audio[i].replaceTrack(null));
      }

      for (i = 0; i < this.rtpSenders.video.length; i += 1) {
        promises.push(this.rtpSenders.video[i].replaceTrack(null));
      }

      logger.debug("end replaceTrack method");
      return new Promise(function (resolve, reject) {
        Promise.all(promises).then(function (values) {
          resolve();
        })["catch"](reject);
      });
    }

    return Promise.resolve();
  };

  this.stopStream = function (stream) {
    logger.info("stopStream in call");
    var i,
        tracks = null;

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 45 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 44 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Opera" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 34 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chromium" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 44 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome WebView" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 45) {
      logger.log("... using MediaStream.stop");
      stream.stop();
    } else {
      logger.log("... using MediaStreamTrack.stop");
      tracks = stream.getTracks();

      for (i = 0; i < tracks.length; i += 1) {
        tracks[i].stop();
      }

      logger.log('... tracks stopped');
    }

    stream = null;
  };

  this.addVideoMedia = function () {
    var _this2 = this;

    logger.info('addVideoMedia'); //Creating a new Stream : audio + video

    var localUserMediaConstraint = webRTCClient.gum_config;
    apiCC.createUserMediaStream({
      'callId': this.callId,
      'type': 'media',
      'gum_config': localUserMediaConstraint,
      'success': function success(userMediaStream) {
        logger.debug('[addVideoMedia] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
        var actualUserMediaStream = apiCC.getUserMediaStream(_this2.callConfiguration.userMediaStreamId);
        var prerequistite = Promise.resolve(); //Removing actual stream

        if (actualUserMediaStream) {
          prerequistite = _this2.removeStream(actualUserMediaStream.stream).then(function () {
            webRTCClient.myWebRTC_Event.createLocalStreamRemovedEvent(_this2.callType, _this2.callId, actualUserMediaStream.stream, _this2.remoteId, _this2.destCallType);
            apiCC.releaseUserMediaStream(actualUserMediaStream.userMediaStreamId, _this2.callId);
          });
        }

        prerequistite.then(function () {
          //Adding new stream
          _this2.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
          _this2.callLocalStream = userMediaStream.stream;

          _this2.addStream(userMediaStream.stream); //start Renegociation with peer


          _this2.updateMediaWithRetryManagement(false);
        })["catch"](function (err) {
          logger.error('Failed to addVideoMedia', err);
          var roomName = null,
              settingUpType = null;

          if (_this2.callControl) {
            roomName = _this2.callControl.roomName;
            settingUpType = _this2.callControl.type;
          }

          webRTCClient.myWebRTC_Event.createErrorEvent('Failed to addVideoMedia', 'MEDIA_UPDATE_ERROR', _this2.callId, roomName, settingUpType);
        });
      },
      'failure': function failure(userMediaStream, error) {
        logger.debug('[addVideoMedia] failure; userMediaStreamId: ' + userMediaStream.userMediaStreamId);

        _this2.onUserMediaErrorOnCall(error);
      }
    });
  };

  this.stopScreenSharing = function () {
    logger.info("stopScreenSharing detected");
    webRTCClient.removeCallFromTableWithCallIdAndSendBye(this.callId, 'stop_ScreenSharing');
  };

  this.checkingMutingState = function () {
    var _this3 = this;

    var userMediaStream = null;
    logger.debug('checkingMutingState');

    var setStreamVideoMuted = function setStreamVideoMuted() {
      if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(_this3, 'mcuRemoteStream', 'object')) {
        _this3.mcuRemoteStream = {};
      }

      _this3.mcuRemoteStream.videoMuted = true;
    };

    var setStreamAudioMuted = function setStreamAudioMuted() {
      if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(_this3, 'mcuRemoteStream', 'object')) {
        _this3.mcuRemoteStream = {};
      }

      _this3.mcuRemoteStream.audioMuted = true;
    };

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.callConfiguration, 'userMediaStreamId', 'string')) {
      userMediaStream = apiCC.getUserMediaStream(this.callConfiguration.userMediaStreamId);

      if (userMediaStream) {
        // Setting the initial values of isLocalVideoMuted and isLocalAudioMuted to match
        // the ones of the userMediaStream. After that the userMediaStream will update
        // the values of isLocalVideoMuted and isLocalAudioMuted.
        if (userMediaStream.videoMuted) {
          setStreamVideoMuted();
          this.isLocalVideoMuted = true;
        } else {
          this.isLocalVideoMuted = false;
        }

        if (userMediaStream.audioMuted) {
          setStreamAudioMuted();
          this.isLocalAudioMuted = true;
        } else {
          this.isLocalAudioMuted = false;
        }
      }
    }

    var muteVideo = function muteVideo() {
      if (!_this3.isLocalVideoMuted) {
        if (userMediaStream) {
          if (userMediaStream.video && !userMediaStream.videoMuted) {
            userMediaStream.muteVideoOnStreams("enabled");
          }
        } else if (_this3.callLocalStream) {
          webRTCClient.muteTracks(_this3.callLocalStream.getVideoTracks());
          _this3.isLocalVideoMuted = true;
        }

        setStreamVideoMuted();
      }
    };

    var muteAudio = function muteAudio() {
      if (!_this3.isLocalAudioMuted) {
        if (userMediaStream) {
          if (userMediaStream.audio && !userMediaStream.audioMuted) {
            userMediaStream.muteAudioOnStreams("enabled");
          }
        } else if (_this3.callLocalStream) {
          webRTCClient.muteTracks(_this3.callLocalStream.getAudioTracks());
          _this3.isLocalAudioMuted = true;
        }

        setStreamAudioMuted();
      }
    }; //Checking if muted is already apply at client level


    if (webRTCClient.isVideoMuted === true) {
      logger.log('Client is video muted, applying to call');
      muteVideo();
    }

    if (webRTCClient.isAudioMuted === true) {
      logger.log('Client is audio muted, applying to call');
      muteAudio();
    } //Checking if muted is setted in callConfiguration


    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.callConfiguration, 'muted', 'string')) {
      logger.log('callConfiguration muted is set :', this.callConfiguration.muted);

      if (this.callConfiguration.muted === 'VIDEO') {
        //Muting audio & video
        muteVideo();
        muteAudio();
      }

      if (this.callConfiguration.muted === 'AUDIOONLY') {
        //Muting audio only
        muteAudio();
      }

      if (this.callConfiguration.muted === 'VIDEOONLY') {
        //Muting video only
        muteVideo();
      }

      delete this.callConfiguration.muted;
    }
  }; //TODO Voir pour capitaliser code avec Client


  this.onUserMediaSuccessOnCall = function (stream) {
    logger.info('onUserMediaSuccessOnCall');
    /*
            var audioIsAvailable = false,
                audioDeviceLabel = "Unknown",
                videoIsAvailable = false,
                videoDeviceLabel = "Unknown",
    */

    var HTTPSprotocol = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isHTTPS)(),
        userMediaErrorDetectedInfo = {}; //Adding userMediaErrorDetectedInfo in userData / presence

    if (webRTCClient.userMediaErrorDetected === true) {
      webRTCClient.userMediaErrorDetected = false;
      userMediaErrorDetectedInfo.userMediaErrorDetected = webRTCClient.userMediaErrorDetected;
      apiCC.session.setUserData(userMediaErrorDetectedInfo);
    }

    logger.log('isHTTPS()' + HTTPSprotocol);
    webRTCClient.getUserMediaOnGoing = false;
    logger.log('User has granted access to local media.');
    webRTCClient.accessToLocalMedia = true;
    this.accessToMedia = true;

    if (this.screenSharing === true) {
      this.callType = "screenSharing";

      if (stream !== null && stream !== undefined) {
        stream.onended = this.callback(this, 'stopScreenSharing');

        if (stream.getVideoTracks().length > 0) {
          stream.getVideoTracks()[0].onended = this.callback(this, 'stopScreenSharing');
        }
      }
    } else if (this.audioOnly === true) {
      this.callType = "audio";
    }

    if (stream !== undefined) {
      this.callLocalStream = stream;
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isHTTP)()) {
      logger.log('isHTTP true');
      this.establishCall();
    } else {
      logger.log('webRTCClient.userAcceptOnIncomingCall :' + webRTCClient.userAcceptOnIncomingCall);
      logger.log('this.callee :' + this.callee);

      if (this.data !== undefined) {
        logger.log('this.data.MCUType :' + this.data.MCUType);
      }

      if (webRTCClient.userAcceptOnIncomingCall === true && (this.callee === true || this.data.MCUType === 'MCU-Callee') && this.isAccepted === false) {
        logger.log('Stand-by :: wait for establishCall');
      } else {
        if (this.calleeId !== 'LOCAL') {
          this.establishCall();
        } else {
          //this is a local stream request : probably for media recording
          logger.log('call is not established as this is a LOCAL stream request');
        }
      }
    }
  };

  this.establishCall = function () {
    var _this4 = this;

    logger.debug('establishCall()');

    if (this.started === true && this.addingUserMedia === true && this.belongsToRoom() && this.settingUpType === 'publish' && (!this.data || !this.data.hasOwnProperty('MCUType')) && this.sessionMCU && !this.sessionMCU.hasOwnProperty('roomMode')) {
      // Special case for update of publish call in conference: restarting the peer connection.
      this.restarting = true;
      this.pc.close();
      this.pc = null;
      this.started = false;
      this.localDescriptionSetted = false;
      this.remoteDescriptionSetted = false;
      this.sendedSdpOfferMessage = null;
      this.receivedSdpOfferMessage = null;
      this.rtpSenders = {
        'audio': [],
        'video': []
      };
      this.addingUserMedia = false;
      this.updateUserMedia = false;
      this.updateCause = null;
      this.incomingcandidatesQueue = [];
      this.message200OKReceived = false;

      if (this.statisticId) {
        clearInterval(this.statisticId);
        this.statisticId = null;
      }

      if (this.csmIntervalId) {
        clearInterval(this.csmIntervalId);
        this.csmIntervalId = null;
      } // Generate a new instanceId for this call


      this.instanceId = apiCC.generateInstanceId();
      this.data.instanceId = this.instanceId;
    }

    if (this.dataCall !== true) {
      this.checkingMutingState();
    }

    this.maybeStart();
    var offerMessage = null;

    if (this.callee && this.addingUserMedia !== true && this.updateUserMedia !== true) {
      offerMessage = new apiCC.myWebRTC_Adapter.RTCSessionDescription(this.receivedSdpOfferMessage);
      logger.log('Avant setRemote pour le callee :', offerMessage);

      if (this.pc !== null) {
        //setRemoteDescription
        if (webRTCClient.preferSendingH264Codec) {
          logger.log("Modification of SDP to set H264 as prefered sending codec");
          offerMessage.sdp = webRTCClient.mySDPManager.maybePreferCodec(offerMessage.sdp, 'video', 'H264');
        }

        if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
          logger.log("establishCall : before setRemoteDescription for callee");
          this.pc.setRemoteDescription(offerMessage, this.callback(this, 'onSetRemoteDescriptionSuccess'), this.callback(this, 'onSetRemoteDescriptionFailure'));
        } else {
          logger.log("establishCall : before setRemoteDescription for callee - Promise version");
          this.pc.setRemoteDescription(offerMessage).then(this.callback(this, 'onSetRemoteDescriptionSuccess'))["catch"](this.callback(this, 'onSetRemoteDescriptionFailure'));
        }
      } else {
        logger.log('Error : PC is null');
      }

      this.doAnswer();
    } else {
      if (this.addingUserMedia === true) {
        logger.log('Adding local stream 1.');

        if (this.pc !== null) {
          if (this.callLocalStream === null && webRTCClient.localStream !== null) {
            this.callLocalStream = webRTCClient.localStream;
          }

          if (this.callLocalStream !== null) {
            logger.log('Add Stream of callLocalStream');
            this.addStream(this.callLocalStream).then(function () {
              _this4.updateMediaWithRetryManagement(false);
            })["catch"](function (err) {
              logger.error('failed to add stream', err);
            });
          } else {
            logger.log('No Stream to addStream');
            this.updateMediaWithRetryManagement(false);
          }
        } else {
          logger.error('Error : PC is null');
        }
      } else if (this.updateUserMedia === true) {
        this.updateMediaWithRetryManagement(false);
      }
    }

    logger.log('End of establishCall()');
  };

  this.onUserMediaSuccessTestUni = function () {
    //TODO voir pour factoriser avec establishCall :   que accessToLocalMedia = true en plus ????
    webRTCClient.getUserMediaOnGoing = false;
    logger.info('onUserMediaSuccessTestUni : User has not granted access to local media.');
    var offerMessage = null,
        userMediaErrorDetectedInfo = {}; //Adding userMediaErrorDetectedInfo in userData / presence

    if (webRTCClient.userMediaErrorDetected === true) {
      webRTCClient.userMediaErrorDetected = false;
      userMediaErrorDetectedInfo.userMediaErrorDetected = webRTCClient.userMediaErrorDetected;
      apiCC.session.setUserData(userMediaErrorDetectedInfo);
    }

    webRTCClient.accessToLocalMedia = true;
    this.maybeStart();

    if (this.callee) {
      offerMessage = new apiCC.myWebRTC_Adapter.RTCSessionDescription(this.receivedSdpOfferMessage); //setRemoteDescription

      if (webRTCClient.preferSendingH264Codec) {
        logger.log("Modification of SDP to set H264 as prefered sending codec");
        offerMessage.sdp = webRTCClient.mySDPManager.maybePreferCodec(offerMessage.sdp, 'video', 'H264');
      }

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
        logger.log("onUserMediaSuccessTestUni : before setRemoteDescription for callee");
        this.pc.setRemoteDescription(offerMessage, this.callback(this, 'onSetRemoteDescriptionSuccess'), this.callback(this, 'onSetRemoteDescriptionFailure'));
      } else {
        logger.log("onUserMediaSuccessTestUni : before setRemoteDescription for callee - Promise version");
        this.pc.setRemoteDescription(offerMessage).then(this.callback(this, 'onSetRemoteDescriptionSuccess'))["catch"](this.callback(this, 'onSetRemoteDescriptionFailure'));
      }

      this.doAnswer();
    }
  };

  this.onUserMediaErrorOnCall = function (error) {
    var _this5 = this;

    logger.log("onUserMediaErrorOnCall"); //var callType = 'media';

    var userMediaErrorDetectedInfo = {};
    webRTCClient.getUserMediaOnGoing = false;
    setTimeout(function () {
      myWebRTC_Event.createErrorEvent(error, 'USER_MEDIA_ERROR', _this5.callId);
    });
    logger.error('Failed to get access to local media. Error code was ' + error.code);
    logger.error(error);
    error = null;

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.applicationType !== 'electron' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version > 47) {
      logger.log("browser_version > 47");

      if (window.location.protocol !== "https:") {
        logger.error("HTTPS is now mandatory to use getUserMedia()");
      }
    }

    if (this.screenSharing === true) {
      this.callType = "screenSharing";

      if (window.location.protocol !== "https:") {
        logger.log("You need to be connected using HTTPS for screenSharing");
        myWebRTC_Event.createDesktopCaptureEvent("UserMediaError_HTTPS_needed", this.callId, this.remoteId);
      } else {
        logger.log("screenSharing UserMediaError");
        myWebRTC_Event.createDesktopCaptureEvent("UserMediaError", this.callId, this.remoteId);
      }
    }

    if (this.callee === true) {
      //Send Bye message
      this.myWebRTC_Stack.sendBye(this.callId, this.calleeId, this.dest_roomId, this.callerId, 'User_Media_Error', this.data);
      webRTCClient.removeCallFromTableWithCallIdandRemoteId(this.callId, this.callerId, 'User_Media_Error');
    } else {
      if (this.data !== undefined && this.data !== null) {
        if (this.data.MCUType === 'MCU-Callee') {
          this.myWebRTC_Stack.sendBye(this.callId, this.callerId, this.dest_roomId, this.calleeId, 'User_Media_Error', this.data);
        }
      }

      webRTCClient.removeCallFromTableWithCallIdandRemoteId(this.callId, this.calleeId, 'User_Media_Error');
    }

    if (this.screenSharing === false) {
      //Adding userMediaErrorDetectedInfo in userData / presence
      webRTCClient.userMediaErrorDetected = true;
      userMediaErrorDetectedInfo.userMediaErrorDetected = webRTCClient.userMediaErrorDetected;
      apiCC.session.setUserData(userMediaErrorDetectedInfo);
    }
  }; //initiates a peer connection for a call if able


  this.maybeStart = function () {
    logger.debug('maybeStart');

    if (!this.started && webRTCClient.channelReady && (webRTCClient.accessToLocalMedia || this.dataCall)) {
      logger.log('Creating PeerConnection.');
      this.createPeerConnection();

      if (webRTCClient.unidirectionelCallOnly || this.screenSharing === true) {
        if (this.callee === false) {
          logger.log('Adding local stream 2.');

          if (this.callLocalStream !== null) {
            logger.log('Add Stream of callLocalStream');
            this.addStream(this.callLocalStream);
          } else {
            if (webRTCClient.localStream !== null) {
              logger.log('Add Stream of client.localStream');
              this.addStream(webRTCClient.localStream);
              this.callLocalStream = webRTCClient.localStream; //TODO a voir
            } else {
              logger.log('No Stream to add');
            }
          }
        }
      } else if (!this.dataCall) {
        logger.log('Adding local stream 3.');

        if (this.callLocalStream !== null) {
          logger.log('Add Stream of callLocalStream');
          this.addStream(this.callLocalStream);
        } else {
          if (webRTCClient.localStream !== null) {
            logger.log('Add Stream of client.localStream');
            this.addStream(webRTCClient.localStream);
            this.callLocalStream = webRTCClient.localStream; //TODO a voir
          } else {
            logger.log('No Stream to add');

            if (!this.belongsToRoom() && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'safari' && typeof this.pc.addTransceiver === 'function') {
              // Special case for Safari when calling without sending any media (APIRTC-938).
              logger.debug('add transceivers');
              this.pc.addTransceiver('audio', {
                direction: 'recvonly'
              });
              this.pc.addTransceiver('video', {
                direction: 'recvonly'
              });
            }
          }
        }
      }

      this.started = true; // Caller initiates offer to peer.

      if (this.callee === false) {
        logger.log('Before doCall()');
        this.doCall();
      }
    }

    logger.log('End of maybeStart');
  };

  this.createDataChannel = function () {
    logger.info('createDataChannel');

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Edge' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 79) {
      logger.warn('Cannot create DataChannel as it is not supported on Edge');
      return;
    }

    if (this.sendDataChannel === null) {
      try {
        //this.sendDataChannel = this.pc.createDataChannel("apiRTCDataChannel", {reliable : true, ordered : true});
        this.sendDataChannel = this.pc.createDataChannel("apiRTCDataChannel", {});
        this.sendDataChannel.binaryType = 'arraybuffer';
        logger.log('Created data channel');
        logger.log("Subscribing to dc events");
        this.sendDataChannel.onopen = this.callback(this, 'onSendDataChannelOpen');
        this.sendDataChannel.onclose = this.callback(this, 'onSendDataChannelClose');
        this.sendDataChannel.onmessage = this.callback(this, 'onSendDataChannelMessage');
        this.sendDataChannel.onerror = this.callback(this, 'onSendDataChannelError');
      } catch (e) {
        logger.log('createDataChannel() failed with exception: ' + e.message);
      }
    } else {
      logger.log('Datachannel already exist');
    }
  };

  this.createPeerConnection = function () {
    logger.info('createPeerConnection');

    try {
      logger.log('createPeerConnection with pc_config:', JSON.stringify(this.pc_config));
      logger.log('and pc_constraints:', JSON.stringify(this.pc_constraints));

      if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 72 && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version < 78) {
        logger.debug('Chrome 72=+ and 78-, force sdpSemantics plan-b');
        this.pc_config.sdpSemantics = 'plan-b';
      } else if (apiRTC.osName === 'iOS' && typeof cordova !== 'undefined' && typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.iosrtc !== 'undefined') {
        logger.debug('Cordova, force sdpSemantics plan-b');
        this.pc_config.sdpSemantics = 'plan-b';
      } else {
        logger.debug('sdpSemantics unified-plan is being used');
      }

      this.pc = new apiCC.myWebRTC_Adapter.RTCPeerConnection(this.pc_config, this.pc_constraints);

      if (this.dataCall) {
        this.createDataChannel();
      }

      this.pc.onicecandidate = this.callback(this, 'onIceCandidate');
    } catch (e2) {
      logger.log('Failed to create PeerConnection, exception: ' + e2.message);
      logger.error('Cannot create RTCPeerConnection object; WebRTC is not supported by this browser.');
      return;
    }

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 53 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Edge' || _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 64) {
      // Listening to both types of event. It is the only way I manage
      // to get working the renegotiation between chrome and firefox.
      // However, the right one is the ontrack event.
      this.pc.ontrack = this.callback(this, 'onRemoteTrackAdded');
      this.pc.onaddstream = this.callback(this, 'onRemoteStreamAdded');
    } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 12 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Mobile Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 12) {
      this.pc.ontrack = this.callback(this, 'onRemoteTrackAdded');
    } else {
      this.pc.onaddstream = this.callback(this, 'onRemoteStreamAdded');
    }

    this.pc.onremovestream = this.callback(this, 'onRemoteStreamRemoved');
    this.pc.onnegotiationneeded = this.callback(this, 'onNegotiationNeeded');
    this.pc.onsignalingstatechange = this.callback(this, 'onSignalingStateChange');
    this.pc.oniceconnectionstatechange = this.callback(this, 'onIceConnectionStateChange');
    this.pc.ondatachannel = this.callback(this, 'onDataChannel'); //this.pc.onicecandidateerror = this.callback(this, 'onIcecandidateError');

    this.pc.onicegatheringstatechange = this.callback(this, 'onIceGatheringStateChange');
    this.pc.onconnectionstatechange = this.callback(this, 'onConnectionStateChange'); // stats

    if (webRTCClient.qosEnable) {
      // start stats gathering
      this.statisticId = setInterval(this.callback(this, 'getStatistics'), this.getStatsInterval);
    }

    if (webRTCClient.csmEnable) {
      this.csmLastResults = {};
      this.csmIntervalId = setInterval(this.callback(this, 'csmHandler'), this.csmIntervalMs);
    }
  }; //this.onIcecandidateError = function (evt) {
  //    logger.error("onIcecandidateError event :", evt);
  //}


  this.onIceGatheringStateChange = function (evt) {
    logger.log('onIceGatheringStateChange');

    if (this.pc !== null) {
      logger.info('onIceGatheringStateChange, Ice Gathering State is now : ' + this.pc.iceGatheringState);

      if (this.pc.iceGatheringState === 'complete') {
        if (this.candidateNb === 0) {
          logger.warn("Warning, no candidate where retrieved for this call on client");
        }
      }
    }
  };

  this.onConnectionStateChange = function (evt) {
    logger.log("onConnectionStateChange event :", evt);
  };

  this.onDataChannel = function (evt) {
    logger.info("onDataChannel event");
    this.receiveDataChannel = evt.channel;
    this.receiveDataChannel.binaryType = 'arraybuffer';

    if (this.sendDataChannel === null) {
      logger.log("Setting this.sendDataChannel with receivedDataChannel");
      this.sendDataChannel = evt.channel;
      this.sendDataChannel.onopen = this.callback(this, 'onSendDataChannelOpen');
      this.sendDataChannel.onclose = this.callback(this, 'onSendDataChannelClose');
      this.sendDataChannel.onmessage = this.callback(this, 'onSendDataChannelMessage');
      this.sendDataChannel.onerror = this.callback(this, 'onSendDataChannelError');
    }

    logger.log("got dataChannel", evt.channel.label);
    logger.log("Subscribing to dc events");
    this.receiveDataChannel.onopen = this.callback(this, 'onReceiveDataChannelOpen');
    this.receiveDataChannel.onclose = this.callback(this, 'onReceiveDataChannelClose');
    this.receiveDataChannel.onmessage = this.callback(this, 'onReceiveDataChannelMessage');
    this.receiveDataChannel.onerror = this.callback(this, 'onReceiveDataChannelError');
  };

  this.onSendDataChannelOpen = function (evt) {
    logger.info("onSendDataChannelOpen");

    if (this.callType === 'data' && this.calleeId === 'dataChannelConnector') {
      if (this.pushDataStatus && this.pushDataStatus.type === 'pipeline') {
        // Special case: pipeline. Schedule next pushData.
        this.pushDataStatus.state = 'ready';
        setTimeout(function () {
          webRTCClient.startNextPushData();
        });
      } else if (this.transferStarted !== true) {
        // Normal case. Start transfer.
        this.startTransfer();
      }
    }

    myWebRTC_Event.createEvent({
      "eventType": "sendDataChannelOpen",
      "callId": this.callId,
      "remoteId": this.remoteId,
      "details": evt
    });
  };

  this.onSendDataChannelClose = function (evt) {
    logger.info("onSendDataChannelClose");
    this.sendDataChannel = null;

    if (myWebRTC_Event !== null) {
      myWebRTC_Event.createEvent({
        "eventType": "sendDataChannelClose",
        "callId": this.callId,
        "remoteId": this.remoteId,
        "details": evt
      });
    }
  };

  this.processOnDataChannelMessage = function (evt) {
    var data = null,
        received = null,
        uuid = null,
        base64photo = '',
        i,
        receivedSize = 0;
    logger.info("processOnDataChannelMessage"); //logger.log("evt.data :", evt.data);

    data = JSON.parse(evt.data);
    logger.log("data.uuid :" + data.uuid);
    logger.log("data.messageSize :" + data.messageSize);
    logger.log("data.originalDataType :" + data.originalDataType);
    uuid = data.uuid;

    if (data.originalDataType === "ArrayBuffer") {
      logger.log("ArrayBuffer conversion"); //Conversion

      data.message = _Utils__WEBPACK_IMPORTED_MODULE_2__.base64Binary.decode(data.message);
    }

    logger.log("data :" + data);
    logger.log("data.uuid :" + uuid);
    logger.log("receiveChunkNb[uuid] :" + this.receiveChunkNb[uuid]);

    if (this.receiveChunkNb[uuid] === undefined) {
      logger.log("receiving first packet for uuid :" + uuid);
      logger.log("evt.data.message :" + evt.data);
      this.firstDataPacket[uuid] = data;
      this.receiveChunkNb[uuid] = 1;
      this.receivedSize[uuid] = 0;
      this.startingDate = new Date();
      this.transferDuration = 0;
      myWebRTC_Event.createEvent({
        "eventType": "onFileReceiving",
        "remoteId": this.remoteId,
        "callId": this.callId,
        "name": data.name,
        "uuid": uuid
      });
      myWebRTC_Event.createEvent({
        "eventType": "onFileProgress",
        sendChunkNb: this.receiveChunkNb[uuid],
        fileSize: this.firstDataPacket[uuid].size,
        remainingSize: this.firstDataPacket[uuid].size,
        callId: this.callId,
        uuid: uuid,
        remoteId: this.remoteId,
        lastPacket: false,
        startingDate: this.startingDate,
        transferDuration: this.transferDuration,
        percentage: 0,
        transferEnded: false
      });
    } else {
      logger.log("new packet for uuid :" + uuid);
      this.receiveChunkNb[uuid] += 1;
      logger.log("data.messageSize :" + data.messageSize);
      logger.log("data.message.length :" + data.message.length); //logger.error("data.sendChunkNb :" + data.sendChunkNb);

      receivedSize = data.messageSize || data.message.length; //logger.error("receivedSize :" + receivedSize);
      //receivedSize = data.message.length || data.message.size || data.message.byteLength;

      logger.log("receivedSize :" + receivedSize);

      if (!this.receiveArrayToStoreChunks[uuid]) {
        this.receiveArrayToStoreChunks[uuid] = [];
      }

      this.receiveArrayToStoreChunks[uuid].push(data.message);
      this.receivedSize[uuid] += receivedSize; //logger.error("this.receivedSize[uuid] :" + this.receivedSize[uuid]);

      this.transferDuration = new Date() - this.startingDate;

      if (this.receivedSize[uuid] === this.firstDataPacket[uuid].size) {
        logger.log("End of data transfert");
        logger.log("this.firstDataPacket.type :" + this.firstDataPacket[uuid].type);

        if (this.firstDataPacket[uuid].type === 'image/png-dataUrl') {
          logger.log("Photo received from a takeSnapshot"); //Photo received from a takeSnapshot

          for (i = 0; i < this.receiveArrayToStoreChunks[uuid].length; i += 1) {
            base64photo += this.receiveArrayToStoreChunks[uuid][i];
          }

          received = base64photo;
        } else {
          received = new window.Blob(this.receiveArrayToStoreChunks[uuid]);
        }

        myWebRTC_Event.createEvent({
          "eventType": "onFileProgress",
          sendChunkNb: this.receiveChunkNb[uuid],
          fileSize: this.firstDataPacket[uuid].size,
          remainingSize: 0,
          callId: this.callId,
          uuid: uuid,
          remoteId: this.remoteId,
          lastPacket: false,
          startingDate: this.startingDate,
          transferDuration: this.transferDuration,
          percentage: 100,
          transferEnded: true
        });
        myWebRTC_Event.createEvent({
          "eventType": "onFileReceived",
          "callId": this.callId,
          "uuid": uuid,
          "remoteId": this.remoteId,
          "callerId": this.callerId,
          "calleeId": this.calleeId,
          "data": {
            "file": received,
            "name": this.firstDataPacket[uuid].name,
            "type": this.firstDataPacket[uuid].type,
            "uuid": uuid
          },
          "details": evt
        });
        delete this.receiveArrayToStoreChunks[uuid];
        delete this.receivedSize[uuid];
        delete this.receiveChunkNb[uuid];
        delete this.firstDataPacket[uuid];
      } else {
        myWebRTC_Event.createEvent({
          "eventType": "onFileProgress",
          sendChunkNb: this.receiveChunkNb[uuid],
          fileSize: this.firstDataPacket[uuid].size,
          remainingSize: this.firstDataPacket[uuid].size - this.receivedSize[uuid],
          callId: this.callId,
          uuid: uuid,
          remoteId: this.remoteId,
          lastPacket: false,
          startingDate: this.startingDate,
          transferDuration: this.transferDuration,
          percentage: parseInt(100 * this.receivedSize[uuid] / this.firstDataPacket[uuid].size, 10),
          transferEnded: false
        });
      }
    }
  };

  this.onSendDataChannelMessage = function (evt) {
    logger.info("onSendDataChannelMessage :", evt);
    this.processOnDataChannelMessage(evt);
  };

  this.onSendDataChannelError = function (evt) {
    logger.info("onSendDataChannelError");
    this.sendDataChannel = null;
    myWebRTC_Event.createEvent({
      "eventType": "sendDataChannelError",
      "callId": this.callId,
      "remoteId": this.remoteId,
      "details": evt
    });
  };

  this.onReceiveDataChannelOpen = function (evt) {
    logger.info("onReceiveChannelOpen");
    myWebRTC_Event.createEvent({
      "eventType": "receiveDataChannelOpen",
      "callId": this.callId,
      "remoteId": this.remoteId,
      "details": evt
    });
  };

  this.onReceiveDataChannelClose = function (evt) {
    logger.info("onReceiveDataChannelClose");
    this.receiveDataChannel = null;

    if (myWebRTC_Event !== null) {
      myWebRTC_Event.createEvent({
        "eventType": "receiveDataChannelClose",
        "callId": this.callId,
        "remoteId": this.remoteId,
        "details": evt
      });
    }
  };

  this.onReceiveDataChannelMessage = function (evt) {
    logger.info("onReceiveChannelMessage");
    this.processOnDataChannelMessage(evt);
  };

  this.onReceiveDataChannelError = function (evt) {
    logger.info("onReceiveChannelError");
    myWebRTC_Event.createEvent({
      "eventType": "receiveDataChannelError",
      "callId": this.callId,
      "remoteId": this.remoteId,
      "details": evt
    });
  };
  /*
   * @ignore
   * @method startTransfer
   * @param {object} options
   * @param {number} options.delay
   */


  this.startTransfer = function () {
    var _this6 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var delay = options.hasOwnProperty('delay') ? options.delay : 100;

    if (this.transferStarted !== true) {
      logger.info('startTransfer', delay);
      this.transferStarted = true;
      setTimeout(function () {
        if (!_this6.dcfs) {
          _this6.dcfs = new _DataChannelFileSender__WEBPACK_IMPORTED_MODULE_5__.DataChannelFileSender(_this6);

          if (_this6.data.offset > 0) {
            _this6.dcfs.transfer(_this6.fileContent.buffer, _this6.data.offset, _this6.sendDataChannel, {
              delay: delay
            });
          } else {
            _this6.dcfs.transfer(_this6.fileContent.buffer, 0, _this6.sendDataChannel, {
              delay: delay
            });
          }
        }
      }, delay);
    }
  };
  /*
  * statisticsAnswer
  * Function called every getStatsInterval milliseconds.
  * Creates a qosMonitor object if not already created
  * then sends the results of getStats to the qosMonitor object for processing.
  */


  this.statisticsAnswer = function (stats) {
    var results = stats.result(),
        allStats = null;

    if (!this.qm) {
      this.qm = new _QoSMonitor__WEBPACK_IMPORTED_MODULE_4__.QoSMonitor(this.getStatsInterval / 1000, this.callback(this, 'onQosChange'), this.callback(this, 'onQosAudioChange'), this.callback(this, 'onQosVideoChange'), this.callId, webRTCClient.apiKey, webRTCClient.clientId, webRTCClient.socket);
    }

    if (results) {
      this.qm.insertStats(results, this.sendedSdpOfferMessage, this.receivedSdpOfferMessage, webRTCClient.remoteVideo);
      allStats = this.qm.getAllStats();

      if (webRTCClient.qosEnable) {
        myWebRTC_Event.createEvent({
          "eventType": "onQosStatsUpdate",
          "callId": this.callId,
          "remoteId": this.remoteId,
          "stats": allStats
        });
      } // this.qm.displayComputedStats();
      // logger.info(this.qm.getQosScore());


      this.videoReceivedWidth = allStats.VideoRecv.FrameWidth;
      this.videoReceivedHeight = allStats.VideoRecv.FrameHeight;
      this.videoSendWidth = allStats.VideoSend.FrameWidth;
      this.videoSendHeight = allStats.VideoSend.FrameHeight;
      this.videoReceivedDelay = allStats.VideoRecv.delay;
      this.audioReceivedDelay = allStats.AudioRecv.delay;
      this.audioSendDelay = allStats.AudioSend.rtt;
      this.videoSendDelay = allStats.VideoSend.rtt;
      this.videoSendMoyDelay = allStats.VideoSend.moyRtt;
      this.videoSendPacketLossRatio = allStats.VideoSend.packetLostRatio;
      this.audioSendPacketLossRatio = allStats.AudioSend.packetLostRatio;
      this.videoSendEncodeUsagePercent = allStats.VideoSend.googEncodeUsagePercent;
      this.videoSendCpuLimitedResolution = allStats.VideoSend.googCpuLimitedResolution;
      this.videoSendBandwidthLimitedResolution = allStats.VideoSend.googBandwidthLimitedResolution;

      if (this.videoSendCpuLimitedResolution !== undefined) {
        if (JSON.parse(this.videoSendCpuLimitedResolution) === true) {
          myWebRTC_Event.createEvent({
            "eventType": "cpuLimited",
            "callId": this.callId,
            "encodeUsagePercent": this.videoSendEncodeUsagePercent
          });
        }
      }

      if (this.videoSendBandwidthLimitedResolution !== undefined) {
        if (JSON.parse(this.videoSendBandwidthLimitedResolution) === true) {
          myWebRTC_Event.createEvent({
            "eventType": "bandwidthLimited",
            "callId": this.callId
          });
        }
      }
    }
  };

  this.csmGetStatsHandler = function (stats) {
    var _this7 = this;

    var results = {},
        tracks = null,
        videoSettings = null,
        callbacks = {};

    if (!this.csm) {
      this.csm = new _CallStatsMonitor__WEBPACK_IMPORTED_MODULE_6__.CallStatsMonitor(this.csmIntervalMs / 1000, _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type, _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version, 'standard');
      this.csm.browserInfo = {
        browserAbout: '' + _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser + ' ' + _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version,
        browserType: _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type,
        browserVersion: _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version
      };

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.mcuRemoteStream, 'attributes', 'object')) {
        // Adding feed info to stats event.
        if (this.mcuRemoteStream.replay === true) {
          // Replay
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.mcuRemoteStream.attributes.callerId, 'string') && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.mcuRemoteStream.attributes.callId, 'string') && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.mcuRemoteStream.attributes.recId, 'string')) {
            this.csm.callFeed = {
              clientId: this.mcuRemoteStream.attributes.callerId,
              callId: this.mcuRemoteStream.attributes.callId,
              modifier: 'replay',
              recId: this.mcuRemoteStream.attributes.recId
            };
          }
        } else {
          // Regular call
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.mcuRemoteStream.attributes.callerId, 'string') && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.mcuRemoteStream.attributes.callId, 'string')) {
            this.csm.callFeed = {
              clientId: this.mcuRemoteStream.attributes.callerId,
              callId: this.mcuRemoteStream.attributes.callId
            };
          }
        }
      }
    } // Add post treatment to evaluate MOS score.


    callbacks.post = function (results) {
      if (!_this7.mos) {
        _this7.mos = new _PerceivedQualityScore__WEBPACK_IMPORTED_MODULE_7__.PerceivedQualityScore();
      }

      results.quality = {};
      /*-----------------------------------------*/

      /* Received quality estimation             */

      /*-----------------------------------------*/

      if (results.audioReceived) {
        if (!_this7.isRemoteAudioMuted) {
          if (results.audioReceived.bitsReceivedPerSecond !== 0) {
            results.audioReceived.delay = parseInt(_this7.audioReceivedDelay, 10); //MOS score of the Received Speech stream

            results.quality.mosS = _this7.mos.NarrowBandSpeechQuality(results.audioReceived.delay, results.audioReceived.packetLossRatio);
          } else {
            results.quality.mosS = "NoStream";
          }
        } else {
          results.quality.mosS = "Muted";
        }
      } else {
        results.quality.mosS = "NoStream";
      }

      if (results.videoReceived) {
        if (!_this7.isRemoteVideoMuted) {
          if (results.videoReceived.bitsReceivedPerSecond !== 0) {
            results.videoReceived.width = _this7.videoReceivedWidth;
            results.videoReceived.height = _this7.videoReceivedHeight;
            results.videoReceived.delay = parseInt(_this7.videoReceivedDelay, 10); //MOS score of the Received Video stream

            results.quality.mosV = _this7.mos.videoQuality(results.videoReceived.width, results.videoReceived.height, results.videoReceived.packetLossRatio, Math.floor(results.videoReceived.bitsReceivedPerSecond / 1000), results.videoReceived.framesDecodedPerSecond);
          } else {
            results.quality.mosV = "NoStream";
          }
        } else {
          results.quality.mosV = "Muted";
        }
      } else {
        results.quality.mosV = "NoStream";
      }

      if (results.audioReceived && results.videoReceived) {
        //MOS score of the Received AudioVisual stream
        results.quality.mosAV = _this7.mos.audiovisualQuality(results.quality.mosS, results.quality.mosV, results.audioReceived.delay, results.videoReceived.delay);
      }
      /*-----------------------------------------*/

      /* local quality estimation                */

      /*-----------------------------------------*/


      if (results.audioSent) {
        if (!_this7.isLocalAudioMuted) {
          if (results.audioSent.bitsSentPerSecond !== 0) {
            results.audioSent.delay = parseInt(_this7.audioSendDelay, 10);
            results.audioSent.packetLossRatio = _this7.audioSendPacketLossRatio; //MOS score of the Sent Speech stream

            results.quality.mosSS = _this7.mos.NarrowBandSpeechQuality(results.audioSent.delay, results.audioSent.packetLossRatio);
          } else {
            results.quality.mosSS = "NoStream";
          }
        } else {
          results.quality.mosSS = "Muted";
        }
      } else {
        results.quality.mosSS = "NoStream";
      }

      if (results.videoSent) {
        if (!_this7.isLocalVideoMuted) {
          if (results.videoSent.bitsSentPerSecond !== 0) {
            results.videoSent.width = _this7.videoSendWidth;
            results.videoSent.height = _this7.videoSendHeight;
            results.videoSent.delay = parseInt(_this7.videoSendDelay, 10);
            results.videoSent.moyDelay = parseInt(_this7.videoSendMoyDelay, 10);
            results.videoSent.packetLossRatio = _this7.videoSendPacketLossRatio; // device performance indicators

            results.videoSent.encodeUsagePercent = _this7.videoSendEncodeUsagePercent; // usage percent of CPU

            results.videoSent.cpuLimitedResolution = _this7.videoSendCpuLimitedResolution; //limitation of resolution due to high CPU usage

            results.videoSent.bandwidthLimitedResolution = _this7.videoSendBandwidthLimitedResolution; //limitation of resolution due to limited bandwidth
            //MOS score of the Sent Video stream

            results.quality.mosSV = _this7.mos.videoQuality(results.videoSent.width, results.videoSent.height, results.videoSent.packetLossRatio, Math.floor(results.videoSent.bitsSentPerSecond / 1000), results.videoSent.framesEncodedPerSecond);
          } else {
            results.quality.mosSV = "NoStream";
          }
        } else {
          results.quality.mosSV = "Muted";
        }
      } else {
        results.quality.mosSV = "NoStream";
      }

      if (results.audioSent && results.videoSent) {
        //MOS score of the Sent AudioVisual stream
        results.quality.mosSAV = _this7.mos.audiovisualQuality(results.quality.mosSS, results.quality.mosSV, results.audioSent.delay, results.videoSent.delay);
      }
    };

    results = this.csm.addCallStats(stats, callbacks);

    if (Object.keys(results).length === 0) {
      return;
    }
    /*-----------------------------------------*/

    /* Create onCallScoreUpdate event          */

    /*-----------------------------------------*/


    if (results.quality && (results.quality.mosS !== "Muted" || results.quality.mosV !== "Muted" || results.quality.mosSS !== "Muted" || results.quality.mosSV !== "Muted")) {
      if (webRTCClient.qualityScoreEnable) {
        myWebRTC_Event.createEvent({
          "eventType": "onCallScoreUpdate",
          "callId": this.callId,
          "score": results.quality
        });
      }
    }

    this.csmLastResults = results; // Attempt to get video settings.

    if (this.callLocalStream) {
      if (typeof this.callLocalStream.getVideoTracks === 'function') {
        tracks = this.callLocalStream.getVideoTracks();

        if (tracks && tracks[0] && typeof tracks[0].getSettings === 'function') {
          videoSettings = tracks[0].getSettings();
        }
      }
    } // Send message to send to CCS.


    var dataToSend = {
      save: true,
      // Tell CCS to save stats (MongoDB)
      clientId: webRTCClient.clientId,
      callId: this.callId,
      instanceId: this.instanceId,
      browserInfo: this.csm.browserInfo,
      stats: results
    };

    if (this.sessionMCU) {
      dataToSend.roomId = this.sessionMCU.roomName;
      dataToSend.pubSub = webRTCClient.MCUClient.pubConnector;
    }

    if (this.csm.callFeed) {
      dataToSend.callFeed = this.csm.callFeed;
    }

    if (videoSettings) {
      dataToSend.videoSettings = videoSettings;
    }

    if (this.data.mesh) {
      dataToSend.mesh = this.data.mesh;
    }

    this.myWebRTC_Stack.sendInfo('callStats', dataToSend);

    if (webRTCClient.csmEnable) {
      if (this.data && this.data.mesh && (this.data.mesh.calleeCompositeUserId ? this.data.mesh.calleeCompositeUserId === webRTCClient.compositeClientId : this.data.mesh.calleeId === webRTCClient.clientId)) {
        // publisher in mesh mode
        myWebRTC_Event.createEvent({
          "eventType": "onCallStatsUpdate",
          "callId": this.data.mesh.calleeCallId,
          "userId": this.data.mesh.callerId,
          "stats": results
        });
      } else {
        // normal
        myWebRTC_Event.createEvent({
          "eventType": "onCallStatsUpdate",
          "callId": this.callId,
          "stats": results
        });
      }
    }
  };
  /*
   * Callback qosMonitor qosChange event
   */


  this.onQosChange = function (qosIn, qosOut) {
    myWebRTC_Event.createEvent({
      "eventType": "onQosChange",
      "callId": this.callId,
      "remoteId": this.remoteId,
      "qosIn": qosIn,
      "qosOut": qosOut
    });
  };

  this.onQosAudioChange = function (qosAudioIn, qosAudioOut) {
    myWebRTC_Event.createEvent({
      "eventType": "onQosAudioChange",
      "callId": this.callId,
      "remoteId": this.remoteId,
      "qosAudioIn": qosAudioIn,
      "qosAudioOut": qosAudioOut
    });
  };

  this.onQosVideoChange = function (qosVideoIn, qosVideoOut) {
    myWebRTC_Event.createEvent({
      "eventType": "onQosVideoChange",
      "callId": this.callId,
      "remoteId": this.remoteId,
      "qosVideoIn": qosVideoIn,
      "qosVideoOut": qosVideoOut
    });
  }; // dummy function to fix context problem


  this.getStatistics = function () {
    if (this.pc) {
      if (this.pc.getStats && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser !== 'Firefox') {
        this.pc.getStats(this.callback(this, 'statisticsAnswer'));
      }
    }
  };
  /*
      function success (report) {
          logger.log("success :",  report);
      }
      function failure (report) {
          logger.log("failure :",  report);
      }
  */
  //TEMP_APIRTCV4 a voir
  //ONGOING


  this.csmHandler = function () {
    if (!this.statisticId) {
      // Get proprietary stats (chrome).
      this.getStatistics();
    }

    if (this.pc) {
      if (typeof this.pc.getStats === 'function') {
        this.pc.getStats(null).then(this.callback(this, 'csmGetStatsHandler'))["catch"](function (err) {
          logger.warn('failed to get stats', err);
        });
      }
    }
  };

  this.doCall = function () {
    var mediaConstraints = null;
    logger.log('Sending offer to peer');

    if (this.audioOnly) {
      logger.log('audioOnly call :', this.mediaConstraintsAudioOnly);

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
        logger.log("createOffer");
        this.pc.createOffer(this.callback(this, 'setLocalAndSendMessageonOffer'), this.callback(this, 'onCreateOfferFailure'), this.mediaConstraintsAudioOnly);
      } else {
        logger.log("createOffer - Promise version");
        this.pc.createOffer(this.mediaConstraintsAudioOnly).then(this.callback(this, 'setLocalAndSendMessageonOffer'))["catch"](this.callback(this, 'onCreateOfferFailure'));
      }
    } else if (this.screenSharing === true) {
      logger.log('screenSharing call : one way media :', mediaConstraints);
      mediaConstraints = {
        'mandatory': {
          'OfferToReceiveAudio': false,
          'OfferToReceiveVideo': false
        }
      };

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
        logger.log("createOffer");
        this.pc.createOffer(this.callback(this, 'setLocalAndSendMessageonOffer'), this.callback(this, 'onCreateOfferFailure'), mediaConstraints);
      } else {
        logger.log("createOffer - Promise version");
        this.pc.createOffer(mediaConstraints).then(this.callback(this, 'setLocalAndSendMessageonOffer'))["catch"](this.callback(this, 'onCreateOfferFailure'));
      }
    } else if (this.dataCall === true) {
      logger.log('call is data only :', mediaConstraints);

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox') {
        if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version > 43) {
          mediaConstraints = {
            'offerToReceiveAudio': false,
            'offerToReceiveVideo': false
          };
        } else {
          mediaConstraints = {
            'mandatory': {
              'OfferToReceiveAudio': false,
              'OfferToReceiveVideo': false
            }
          };
        }
      } else {
        mediaConstraints = {
          'mandatory': {
            'OfferToReceiveAudio': false,
            'OfferToReceiveVideo': false
          }
        };
      }

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
        logger.log("createOffer");
        this.pc.createOffer(this.callback(this, 'setLocalAndSendMessageonOffer'), this.callback(this, 'onCreateOfferFailure'), mediaConstraints);
      } else {
        logger.log("createOffer - Promise version");
        this.pc.createOffer(mediaConstraints).then(this.callback(this, 'setLocalAndSendMessageonOffer'))["catch"](this.callback(this, 'onCreateOfferFailure'));
      }
    } else {
      logger.log('call is audio & video :', this.mediaConstraints);

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
        logger.log("createOffer");
        this.pc.createOffer(this.callback(this, 'setLocalAndSendMessageonOffer'), this.callback(this, 'onCreateOfferFailure'), this.mediaConstraints);
      } else {
        logger.log("createOffer - Promise version");
        this.pc.createOffer(this.mediaConstraints).then(this.callback(this, 'setLocalAndSendMessageonOffer'))["catch"](this.callback(this, 'onCreateOfferFailure'));
      }
    }
  };

  this.doAnswer = function () {
    logger.info('doAnswer');
    var mediaConstraints = null;

    if (this.audioOnly) {
      logger.log('audioOnly call');
      mediaConstraints = this.mediaConstraintsAudioOnly;
    } else {
      mediaConstraints = this.mediaConstraints;
    }

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
      logger.log("createAnswer");
      this.pc.createAnswer(this.callback(this, 'setLocalAndSendMessage'), this.callback(this, 'onCreateAnswerFailure'), mediaConstraints);
    } else {
      logger.log("createAnswer - Promise version");
      this.pc.createAnswer(mediaConstraints).then(this.callback(this, 'setLocalAndSendMessage'))["catch"](this.callback(this, 'onCreateAnswerFailure'));
    }
  };

  this.doUpdateAnswer = function () {
    logger.info('doUpdateAnswer');
    var mediaConstraints = null;

    if (this.audioOnly) {
      logger.log('audioOnly call');
      mediaConstraints = this.mediaConstraintsAudioOnly;
    } else {
      mediaConstraints = this.mediaConstraints;
    }

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
      logger.log("createAnswer");
      this.pc.createAnswer(this.callback(this, 'setLocalAndSendMessageUpdate'), this.callback(this, 'onCreateAnswerFailure'), mediaConstraints);
    } else {
      logger.log("createAnswer - Promise version");
      this.pc.createAnswer(mediaConstraints).then(this.callback(this, 'setLocalAndSendMessageUpdate'))["catch"](this.callback(this, 'onCreateAnswerFailure'));
    }
  };

  this.updateMediaWithRetryManagement = function (iceRestartActivated) {
    logger.debug("updateMediaWithRetryManagement");
    var updateMediaResult = this.updateMedia(iceRestartActivated);
    logger.debug('updateMediaResult :', updateMediaResult);

    if (updateMediaResult.reason === 'Sig_state_not_stable' || updateMediaResult.reason === 'Update_already_ongoing') {
      logger.debug("updateMedia will be retried later for reason :", updateMediaResult.reason); //We will try again the updateMedia after onSetRemoteDescriptionSuccess

      this.retryUpdateMedia = true;
    }
  };

  this.updateMedia = function (iceRestartActivated) {
    logger.debug("updateMedia, callId :", this.callId);
    logger.log("iceRestartActivated :", iceRestartActivated);
    var updateMediaResult = null;

    if (this.pc === null) {
      logger.log('updateMedia, pc no more exist');
      updateMediaResult = {
        status: "Not_Done",
        reason: 'PC_Not_Exit'
      };
      return updateMediaResult;
    }

    if (this.updateMediaOngoing === true) {
      logger.log('updateMedia, already ongoing');
      updateMediaResult = {
        status: "Not_Done",
        reason: 'Update_already_ongoing'
      };
      return updateMediaResult;
    }

    this.updateMediaOngoing = true;

    if (this.pc.signalingState !== 'stable') {
      updateMediaResult = {
        status: "Not_Done",
        reason: 'Sig_state_not_stable'
      };
      return updateMediaResult;
    }

    logger.log('Sending Update offer to peer.');

    if (this.audioOnly) {
      logger.log('audioOnly call :', this.mediaConstraintsAudioOnly);

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
        logger.log("createOffer");

        if (this.mediaConstraintsAudioOnly.mandatory !== undefined) {
          this.mediaConstraintsAudioOnly.mandatory.IceRestart = true;
        } else {
          this.mediaConstraintsAudioOnly.iceRestart = true;
        }

        logger.log('this.mediaConstraints :', this.mediaConstraintsAudioOnly);
        this.pc.createOffer(this.callback(this, 'setLocalAndSendMessageonOfferUpdate'), this.callback(this, 'onCreateOfferFailure'), this.mediaConstraintsAudioOnly);
      } else {
        logger.log("createOffer - Promise version");

        if (iceRestartActivated === true) {
          this.mediaConstraintsAudioOnly.iceRestart = true;
        }

        logger.log('this.mediaConstraints :', this.mediaConstraintsAudioOnly);
        this.pc.createOffer(this.mediaConstraintsAudioOnly).then(this.callback(this, 'setLocalAndSendMessageonOfferUpdate'))["catch"](this.callback(this, 'onCreateOfferFailure'));
      }
    } else {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
        logger.log("createOffer");

        if (iceRestartActivated === true) {
          if (this.mediaConstraints.mandatory !== undefined) {
            this.mediaConstraints.mandatory.IceRestart = true;
          } else {
            this.mediaConstraints.iceRestart = true;
          }
        }

        logger.log('this.mediaConstraints :', this.mediaConstraints);
        this.pc.createOffer(this.callback(this, 'setLocalAndSendMessageonOfferUpdate'), this.callback(this, 'onCreateOfferFailure'), this.mediaConstraints);
      } else {
        logger.log("createOffer - Promise version");

        if (iceRestartActivated === true) {
          this.mediaConstraints.iceRestart = true;
        }

        logger.log('this.mediaConstraints :', this.mediaConstraints);
        this.pc.createOffer(this.mediaConstraints).then(this.callback(this, 'setLocalAndSendMessageonOfferUpdate'))["catch"](this.callback(this, 'onCreateOfferFailure'));
      }
    }

    updateMediaResult = {
      status: "OnGoing",
      reason: 'OK'
    };
    return updateMediaResult;
  };
  /*
   * @param {RTCSessionDescription} sessionDescription
   * @param {string} sdpType - Either 'OFFER' or 'ANSWER'.
   */


  this.manipulateSDP = function (sessionDescription, sdpType) {
    var guideline = null,
        guidelineChanged = false;
    logger.log("manipulateSDP with type :", sdpType); //logger.error("manipulateSDP:: modif H264 profil");
    //alert("manipulateSDP:: modif H264 profil");
    //sessionDescription.sdp = sessionDescription.sdp.replace('42001f', '42e01f');

    if (webRTCClient.receiveMediaDeactivated === true) {
      logger.log('setting receiveMediaDeactivated in SDP :' + webRTCClient.receiveMediaDeactivated);
      sessionDescription.sdp = webRTCClient.mySDPManager.setSendOnly(sessionDescription.sdp);
    }

    if (webRTCClient.RTPMedia === true) {
      //SDP Modification to activate RTP instead of SRTP
      sessionDescription.sdp = sessionDescription.sdp.replace(/RTP\/SAVPF/g, 'RTP/SF');
    }

    if (webRTCClient.audioBandwidth !== null) {
      logger.log('setting audioBandwidth in SDP :' + webRTCClient.audioBandwidth);
      sessionDescription.sdp = webRTCClient.mySDPManager.setAudioBandwidth(sessionDescription.sdp, webRTCClient.audioBandwidth);
    }

    if (webRTCClient.videoBandwidth !== null) {
      logger.log('setting videoBandwidth in SDP :' + webRTCClient.videoBandwidth);
      sessionDescription.sdp = webRTCClient.mySDPManager.setVideoBandwidth(sessionDescription.sdp, webRTCClient.videoBandwidth);
    }

    if (webRTCClient.dataBandwidth !== null) {
      logger.log('setting dataBandwidth in SDP :' + webRTCClient.dataBandwidth);
      sessionDescription.sdp = webRTCClient.mySDPManager.setDataBandwidth(sessionDescription.sdp, webRTCClient.dataBandwidth);
    }

    if (webRTCClient.preferOpusCodec === true) {
      logger.log('setting preferOpusCodec');
      sessionDescription.sdp = webRTCClient.mySDPManager.preferOpus(sessionDescription.sdp);
    }

    if (webRTCClient.preferVP9Codec === true || this.preferVP9Codec === true) {
      logger.log('Call prefer VP9 Codec');
      sessionDescription.sdp = webRTCClient.mySDPManager.maybePreferCodec(sessionDescription.sdp, 'video', 'VP9');
    }

    if (webRTCClient.preferH264Codec === true || this.preferH264Codec === true) {
      logger.log('Call prefer H264 Codec');
      sessionDescription.sdp = webRTCClient.mySDPManager.maybePreferCodec(sessionDescription.sdp, 'video', 'H264');
    }

    if (this.preferVP8Codec === true) {
      logger.log('Call prefer VP8 Codec');
      sessionDescription.sdp = webRTCClient.mySDPManager.maybePreferCodec(sessionDescription.sdp, 'video', 'VP8');
    }

    if (webRTCClient.setStereo === true) {
      logger.log('Set Stereo');
      sessionDescription.sdp = webRTCClient.mySDPManager.setCodecParam(sessionDescription.sdp, 'opus/48000', 'stereo', '1');
    } //Updating audio codecs


    sessionDescription = webRTCClient.mySDPManager.updateSDPcodecs(sessionDescription, sessionDescription.type, 'audio', webRTCClient.allowedAudioCodecs); //Updating video codecs

    sessionDescription = webRTCClient.mySDPManager.updateSDPcodecs(sessionDescription, sessionDescription.type, 'video', webRTCClient.allowedVideoCodecs);

    if (sdpType === 'OFFER') {
      if (this.settingUpType === 'publish' && this.mediaTypeForIncomingCall === 'NONE') {
        // Modifying SDP offer in order to enforce mediaTypeForOutgoingCall.
        guideline = webRTCClient.mySDPManager.createGuideline(sessionDescription.sdp);

        if (this.mediaTypeForOutgoingCall === 'VIDEO') {
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(guideline, 'audio', 'object') && guideline.audio.direction !== 'sendonly') {
            guideline.audio.direction = 'sendonly';
            guidelineChanged = true;
          }

          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(guideline, 'video', 'object') && guideline.video.direction !== 'sendonly') {
            guideline.video.direction = 'sendonly';
            guidelineChanged = true;
          }
        } else if (this.mediaTypeForOutgoingCall === 'AUDIO') {
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(guideline, 'audio', 'object') && guideline.audio.direction !== 'sendonly') {
            guideline.audio.direction = 'sendonly';
            guidelineChanged = true;
          }

          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(guideline, 'video', 'object') && guideline.video.direction !== 'inactive') {
            guideline.video.direction = 'inactive';
            guidelineChanged = true;
          }
        } else if (this.mediaTypeForOutgoingCall === 'VIDEOONLY') {
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(guideline, 'audio', 'object') && guideline.audio.direction !== 'inactive') {
            guideline.audio.direction = 'inactive';
            guidelineChanged = true;
          }

          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(guideline, 'video', 'object') && guideline.video.direction !== 'sendonly') {
            guideline.video.direction = 'sendonly';
            guidelineChanged = true;
          }
        }

        if (guidelineChanged === true) {
          sessionDescription.sdp = guideline.generate();
        }
      } else {
        //Management of MediaType for outgoing calls
        if (this.mediaTypeForOutgoingCall === "VIDEO") {
          logger.log('mediaTypeForOutgoingCall is VIDEO');
        } else if (this.mediaTypeForOutgoingCall === "AUDIO" || this.audioOnly === true) {
          logger.log('mediaTypeForOutgoingCall is AUDIO'); //Setting recvOnly for video

          sessionDescription.sdp = webRTCClient.mySDPManager.setRecvOnlyForVideo(sessionDescription.sdp);
        } else if (this.mediaTypeForOutgoingCall === "VIDEOONLY") {
          logger.log('mediaTypeForOutgoingCall is VIDEOONLY'); //Setting recvOnly for audio

          sessionDescription.sdp = webRTCClient.mySDPManager.setRecvOnlyForAudio(sessionDescription.sdp);
        } else if (this.mediaTypeForOutgoingCall === "NONE") {
          logger.log('mediaTypeForOutgoingCall is NONE'); //logger.error('av sessionDescription.sdp :', sessionDescription.sdp);

          sessionDescription.sdp = webRTCClient.mySDPManager.setRecvOnly(sessionDescription.sdp); //logger.error('ap sessionDescription.sdp :', sessionDescription.sdp);
        }
      }
    } else if (sdpType === 'ANSWER') {
      //Management of MediaType for incoming calls
      if (this.mediaTypeForIncomingCall === "VIDEO") {
        logger.log('mediaTypeForIncomingCall is VIDEO');
      } else if (this.mediaTypeForIncomingCall === "AUDIO" || this.audioOnly === true) {
        logger.log('mediaTypeForIncomingCall is AUDIO'); //Setting recvOnly for video

        sessionDescription.sdp = webRTCClient.mySDPManager.setRecvOnlyForVideo(sessionDescription.sdp);
      } else if (this.mediaTypeForIncomingCall === "VIDEOONLY") {
        logger.log('mediaTypeForIncomingCall is VIDEOONLY'); //Setting recvOnly for audio

        sessionDescription.sdp = webRTCClient.mySDPManager.setRecvOnlyForAudio(sessionDescription.sdp);
      } else if (this.mediaTypeForIncomingCall === "NONE") {
        logger.log('mediaTypeForIncomingCall is NONE'); //logger.error('av sessionDescription.sdp :', sessionDescription.sdp);

        sessionDescription.sdp = webRTCClient.mySDPManager.setRecvOnly(sessionDescription.sdp); //logger.error('ap sessionDescription.sdp :', sessionDescription.sdp);
      }
    }

    if (this.simulcast === 'SDP' && sdpType === 'OFFER' && this.settingUpType === 'publish') {
      guideline = webRTCClient.mySDPManager.createGuideline(sessionDescription.sdp);
      guideline.mungeForSimulcasting();
      sessionDescription.sdp = guideline.generate();
    }

    return sessionDescription;
  };
  /*
   * Called when this one is the caller.
   */


  this.setLocalAndSendMessageonOffer = function (sessionDescription) {
    logger.info('setLocalAndSendMessageonOffer');
    logger.log('sessionDescription = ', sessionDescription);
    logger.log('sessionDescription.sdp = ', sessionDescription.sdp);
    var audioMediaPart = null;
    sessionDescription.sdp = this.manipulateSDP(sessionDescription, 'OFFER').sdp;
    logger.log('manipulated sessionDescription.sdp = ', sessionDescription.sdp);

    if (this.stripAudioSDPActivated === true) {
      sessionDescription.sdp = webRTCClient.mySDPManager.stripAudioMediaDescriptionFromSDP(sessionDescription.sdp);
    }

    if (this.stripVideoSDPActivated === true) {
      sessionDescription.sdp = webRTCClient.mySDPManager.stripVideoMediaDescriptionFromSDP(sessionDescription.sdp);
    }

    this.setLocalCallProfile(webRTCClient.evalCallProfileWithSdp(sessionDescription.sdp, 'local', 'send'));
    this.sendedSdpOfferMessage = sessionDescription; //Modif_Fred : virer this.sendedSdpOfferMessage ??? faire test avec FX + opera
    //this.pc.setLocalDescription(this.sendedSdpOfferMessage,  this.callback(this, 'onSetLocalDescriptionSuccess'), this.callback(this, 'onSetLocalDescriptionFailure'));

    if (this.dataCall === true) {
      logger.log("setLocalAndSendMessageonOffer : data Call");
      this.callType = "data";
    }

    if (this.callCancelled === false) {
      if (webRTCClient.NtoNConf === false) {
        logger.log('Conf N to 1');

        if (this.screenSharing === true) {
          //Detecting if call has audio
          audioMediaPart = webRTCClient.mySDPManager.getAudioMediaDescriptionPart(this.sendedSdpOfferMessage.sdp);

          if (audioMediaPart !== undefined && audioMediaPart !== null) {
            this.callType = 'screenSharingWithAudio';
          } else {
            this.callType = 'screenSharing';
          } //TODO avoir un callType par dfaut pass sur les invite

        }

        if (this.trickleIce === true) {
          this.myWebRTC_Stack.sendInvite(this.callId, this.callerId, webRTCClient.nickname, this.dest_roomId, this.dest_roomId, this.callType, {
            offer: sessionDescription,
            data: this.data,
            stream: this.mcuRemoteStream,
            "volatile": !!this.restarted
          });
          this.inviteSended = true;
        } //setLocalDescription


        if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
          logger.log("setLocalAndSendMessageonOffer : before setLocalDescription");
          this.pc.setLocalDescription(this.sendedSdpOfferMessage, this.callback(this, 'onSetLocalDescriptionSuccess'), this.callback(this, 'onSetLocalDescriptionFailure'));
        } else {
          logger.log("setLocalAndSendMessageonOffer : before setLocalDescription - Promise version");
          this.pc.setLocalDescription(this.sendedSdpOfferMessage).then(this.callback(this, 'onSetLocalDescriptionSuccess'))["catch"](this.callback(this, 'onSetLocalDescriptionFailure'));
        }
      } else {
        logger.log('Conf N to N');
        this.myWebRTC_Stack.sendInviteBroadcast(this.callId, this.callerId, webRTCClient.nickname, this.dest_roomId, this.dest_roomId, sessionDescription);
        this.inviteSended = true;
      }
    } else {
      logger.warn('Invite is not sent has call has been canceled');
      webRTCClient.removeCallFromTableWithCallIdandRemoteId(this.callId, this.calleeId, 'Call_Cancelled');

      if (webRTCClient.callsTable.length === 0) {
        logger.log('No more established calls for client');
      }
    }
  };
  /*
   * Called when this one is the update initiator.
   */


  this.setLocalAndSendMessageonOfferUpdate = function (sessionDescription) {
    var guideline = null,
        dst = 0;
    logger.info('setLocalAndSendMessageonOfferUpdate, sessionDescription :' + sessionDescription);
    this.sendedSdpOfferMessage = sessionDescription;
    logger.log('sessionDescription.sdp = ', sessionDescription.sdp);

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.audioSdpDirection, 'string') || (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.videoSdpDirection, 'string')) {
      guideline = webRTCClient.mySDPManager.createGuideline(sessionDescription.sdp);

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(guideline, 'audio', 'object') && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.audioSdpDirection, 'string')) {
        guideline.audio.direction = this.audioSdpDirection;
      }

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(guideline, 'video', 'object') && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.videoSdpDirection, 'string')) {
        guideline.video.direction = this.videoSdpDirection;
      }

      sessionDescription.sdp = guideline.generate();
    }

    this.setLocalCallProfile(webRTCClient.evalCallProfileWithSdp(sessionDescription.sdp, 'local', 'send'), true);

    if (this.callee) {
      dst = this.callerId;
    } else {
      dst = this.calleeId;
    }

    if (this.trickleIce === true) {
      this.myWebRTC_Stack.sendUpdate(this.callId, this.callerId, this.calleeId, this.dest_roomId, dst, sessionDescription, this.callType, this.data); //setLocalDescription

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
        logger.log("setLocalAndSendMessageonOfferUpdate : before setLocalDescription");
        this.pc.setLocalDescription(sessionDescription, this.callback(this, 'onSetLocalDescriptionSuccess'), this.callback(this, 'onSetLocalDescriptionFailure'));
      } else {
        logger.log("setLocalAndSendMessageonOfferUpdate : before setLocalDescription - Promise version");
        this.pc.setLocalDescription(sessionDescription).then(this.callback(this, 'onSetLocalDescriptionSuccess'))["catch"](this.callback(this, 'onSetLocalDescriptionFailure'));
      }
    } else {
      //TODO Code switchScreen a vrifier
      //Trying to update with Offer / Answer with actual data
      // as Ice doesn't seems to restart and we don't get complete SDP to send update
      //This is the case on switch screen / video
      logger.log('Updating PC offer and answer after switch Stream'); //setLocalDescription

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
        logger.log("setLocalAndSendMessageonOfferUpdate : before setLocalDescription");
        this.pc.setLocalDescription(sessionDescription, this.callback(this, 'onSetLocalDescriptionSuccess'), this.callback(this, 'onSetLocalDescriptionFailure'));
      } else {
        logger.log("setLocalAndSendMessageonOfferUpdate : before setLocalDescription - Promise version");
        this.pc.setLocalDescription(sessionDescription).then(this.callback(this, 'onSetLocalDescriptionSuccess'))["catch"](this.callback(this, 'onSetLocalDescriptionFailure'));
      } //setRemoteDescription


      if (webRTCClient.preferSendingH264Codec) {
        logger.log("Modification of SDP to set H264 as prefered sending codec");
        this.pc.remoteDescription.sdp = webRTCClient.mySDPManager.maybePreferCodec(this.pc.remoteDescription.sdp, 'video', 'H264');
      }

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
        logger.log("setLocalAndSendMessageonOfferUpdate : before setRemoteDescription");
        this.pc.setRemoteDescription(this.pc.remoteDescription, this.callback(this, 'onSetRemoteDescriptionSuccess'), this.callback(this, 'onSetRemoteDescriptionFailure'));
      } else {
        logger.log("setLocalAndSendMessageonOfferUpdate : before setRemoteDescription - Promise version");
        this.pc.setRemoteDescription(this.pc.remoteDescription).then(this.callback(this, 'onSetRemoteDescriptionSuccess'))["catch"](this.callback(this, 'onSetRemoteDescriptionFailure'));
      }
    }
  };

  this.onCreateOfferFailure = function (e) {
    logger.info('onCreateOfferFailure' + e);
    e = null;
  };

  this.onCreateAnswerFailure = function (e) {
    logger.info('onCreateAnswerFailure' + e);
    e = null;
  };
  /*
   * Called when this one is the callee.
   */


  this.setLocalAndSendMessage = function (sessionDescription) {
    var guideline;
    logger.info('setLocalAndSendMessage');
    logger.log('sessionDescription.sdp = ', sessionDescription.sdp);

    if (this.pc === null) {
      logger.log('setLocalAndSendMessage, pc no more exist');
      return;
    }

    sessionDescription = this.manipulateSDP(sessionDescription, 'ANSWER');
    guideline = webRTCClient.mySDPManager.createGuideline(sessionDescription.sdp);
    this.setLocalCallProfile(webRTCClient.evalCallProfileWithSdpGuideline(guideline, sessionDescription.sdp, 'local', 'send'));
    this.setRemoteCallProfile(webRTCClient.evalCallProfileWithSdpGuideline(guideline, sessionDescription.sdp, 'local', 'receive'));
    logger.log('manipulated sessionDescription.sdp = ', sessionDescription.sdp); //setLocalDescription

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
      logger.log("setLocalAndSendMessage : before setLocalDescription");
      this.pc.setLocalDescription(sessionDescription, this.callback(this, 'onSetLocalDescriptionSuccess'), this.callback(this, 'onSetLocalDescriptionFailure'));
    } else {
      logger.log("setLocalAndSendMessage : before setLocalDescription - Promise version");
      this.pc.setLocalDescription(sessionDescription).then(this.callback(this, 'onSetLocalDescriptionSuccess'))["catch"](this.callback(this, 'onSetLocalDescriptionFailure'));
    }

    this.sendedSdpOfferMessage = sessionDescription;

    if (this.trickleIce === true) {
      this.myWebRTC_Stack.send200OK(this.callId, this.callerId, this.calleeId, webRTCClient.nickname, this.dest_roomId, sessionDescription, this.data);
    }
  };
  /*
   * Called when this one is the update recipient.
   */


  this.setLocalAndSendMessageUpdate = function (sessionDescription) {
    var guideline;

    if (this.pc === null) {
      logger.log('setLocalAndSendMessageUpdate, pc no more exist');
      return;
    }

    if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'safari') {
      // On safari, SDP must be modified to count the mediaTypeForOutgoingCall.
      sessionDescription.sdp = this.manipulateSDP(sessionDescription, 'OFFER').sdp;
    }

    guideline = webRTCClient.mySDPManager.createGuideline(sessionDescription.sdp);

    if (this.mediaType === 'AUDIOONLY') {
      // Case of a subscribe call and only audio was requested.
      // Making sure no video is added in the update.
      if (guideline.hasOwnProperty('video') && guideline.video.direction !== 'inactive') {
        logger.debug('Only audio was requested at call setup: deactivating video');
        guideline.video.direction = 'inactive';
        sessionDescription.sdp = guideline.generate();
      }
    } else if (this.mediaType === 'VIDEOONLY') {
      // Case of a subscribe call and only video was requested.
      // Making sure no audio is added in the update.
      if (guideline.hasOwnProperty('audio') && guideline.audio.direction !== 'inactive') {
        logger.debug('Only video was requested at call setup: deactivating audio');
        guideline.audio.direction = 'inactive';
        sessionDescription.sdp = guideline.generate();
      }
    }

    this.setLocalCallProfile(webRTCClient.evalCallProfileWithSdpGuideline(guideline, sessionDescription.sdp, 'local', 'send'), true);
    this.setRemoteCallProfile(webRTCClient.evalCallProfileWithSdpGuideline(guideline, sessionDescription.sdp, 'local', 'receive'), true); // CallType has been updated at this point.

    if (this.updateOngoingTimeoutId) {
      clearTimeout(this.updateOngoingTimeoutId);
      delete this.updateOngoingTimeoutId;
    } //setLocalDescription


    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
      logger.log("setLocalAndSendMessageUpdate : before setLocalDescription");
      this.pc.setLocalDescription(sessionDescription, this.callback(this, 'onSetLocalDescriptionSuccess'), this.callback(this, 'onSetLocalDescriptionFailure'));
    } else {
      logger.log("setLocalAndSendMessageUpdate : before setLocalDescription - Promise version");
      this.pc.setLocalDescription(sessionDescription).then(this.callback(this, 'onSetLocalDescriptionSuccess'))["catch"](this.callback(this, 'onSetLocalDescriptionFailure'));
    }

    var dst = 0;

    if (this.callee) {
      dst = this.callerId;
    } else {
      dst = this.calleeId;
    }

    this.myWebRTC_Stack.send200Update(this.callId, this.callerId, this.calleeId, this.dest_roomId, dst, sessionDescription, this.data);

    if (this.asyncCallbacks && this.asyncCallbacks.type === 'updateMediaType') {
      // Preceding updateMediaTypeOnCall requires a promise to be resolved.
      logger.debug('asyncCallbacks resolve');
      this.asyncCallbacks.resolve();

      if (this.asyncCallbacks.timeoutId) {
        clearTimeout(this.asyncCallbacks.timeoutId);
        delete this.asyncCallbacks.timeoutId;
      }

      delete this.asyncCallbacks;
    }
  };

  this.onIceCandidate = function (event) {
    try {
      logger.debug('onIceCandidate :', JSON.stringify(event.candidate));
    } catch (e) {
      logger.error(e); // you can get error here
    }

    var dst = 0,
        n = 0,
        m = 0;

    if (this.callee) {
      dst = this.callerId;
    } else {
      dst = this.calleeId;
    }

    if (this.pc !== null) {
      logger.debug('Ice Connection State is now : ' + this.pc.iceConnectionState); //logger.log('Ice  State is now : ' + this.pc.iceState);

      logger.debug('Ice Gathering State is now : ' + this.pc.iceGatheringState);
    }

    if (event.candidate) {
      this.candidateNb += 1;

      if (this.trickleIce === true) {
        if (this.mediaRoutingMode === webRTCClient.mediaRoutingModeEnum.hostOnly) {
          //Only host candidates are considered : this will forced direct RTP routing for media routing
          n = event.candidate.candidate.search('host');

          if (n !== -1) {
            this.myWebRTC_Stack.sendCandidate(this.callId, this.callerId, this.calleeId, this.dest_roomId, dst, event.candidate.sdpMLineIndex, event.candidate.sdpMid, event.candidate.candidate, this.data, event.candidate, {
              "volatile": !!this.restarted
            });
          } else {
            logger.log('Media routing mode is hostOnly and not a HOST Candidate : ignoring message');
          }
        } else if (this.mediaRoutingMode === webRTCClient.mediaRoutingModeEnum.stun) {
          //Only HOST an SRFLX candidates are considered and routed
          n = event.candidate.candidate.search('host');
          m = event.candidate.candidate.search('srflx');

          if (n !== -1 || m !== -1) {
            this.myWebRTC_Stack.sendCandidate(this.callId, this.callerId, this.calleeId, this.dest_roomId, dst, event.candidate.sdpMLineIndex, event.candidate.sdpMid, event.candidate.candidate, this.data, event.candidate, {
              "volatile": !!this.restarted
            });
          } else {
            logger.log('Media routing mode is stun and not a HOST or SRFLX Candidate : ignoring message');
          }
        } else if (this.mediaRoutingMode === webRTCClient.mediaRoutingModeEnum.stunOnly) {
          //Only SRFLX candidates are considered and routed
          n = event.candidate.candidate.search('srflx');

          if (n !== -1) {
            this.myWebRTC_Stack.sendCandidate(this.callId, this.callerId, this.calleeId, this.dest_roomId, dst, event.candidate.sdpMLineIndex, event.candidate.sdpMid, event.candidate.candidate, this.data, event.candidate, {
              "volatile": !!this.restarted
            });
          } else {
            logger.log('Media routing mode is stunOnly and not a SRFLX Candidate : ignoring message');
          }
        } else if (this.mediaRoutingMode === webRTCClient.mediaRoutingModeEnum.turn) {
          //all candidates are considered and routed
          logger.log('Media routing mode is turn : all candidates are considered');
          this.myWebRTC_Stack.sendCandidate(this.callId, this.callerId, this.calleeId, this.dest_roomId, dst, event.candidate.sdpMLineIndex, event.candidate.sdpMid, event.candidate.candidate, this.data, event.candidate, {
            "volatile": !!this.restarted
          });
        } else if (this.mediaRoutingMode === webRTCClient.mediaRoutingModeEnum.turnOnly) {
          //Only TURN candidates are considered : this will forced the usage of TURN server for media routing
          n = event.candidate.candidate.search('relay');

          if (n !== -1) {
            this.myWebRTC_Stack.sendCandidate(this.callId, this.callerId, this.calleeId, this.dest_roomId, dst, event.candidate.sdpMLineIndex, event.candidate.sdpMid, event.candidate.candidate, this.data, event.candidate, {
              "volatile": !!this.restarted
            });
          } else {
            logger.log('Media routing mode is TurnOnly and not a RELAY Candidate : ignoring message');
          }
        }
      } else {
        logger.log("trickleIce is deactivated : candidates are not sended");
      }
    } else {
      logger.info('End of candidates.');

      if (this.trickleIce === false) {
        //TriclkeIce is desactivated sending Invite or 200OK when all candidates are received
        logger.log('trickleIce === false');

        if (this.callee === true) {
          if (this.send200OKTrickleIceFalseTimeOutId !== 0) {
            clearTimeout(this.send200OKTrickleIceFalseTimeOutId);
            this.send200OKTrickleIceFalseTimeOutId = 0;
          }

          if (this.message200OKSended === false) {
            this.myWebRTC_Stack.send200OK(this.callId, this.callerId, this.calleeId, webRTCClient.nickname, this.dest_roomId, this.pc.localDescription, this.data);
          } else {
            logger.log('200OK already sended');
          }
        } else {
          if (this.pc !== null) {
            if (this.sendInviteTrickleIceFalseTimeOutId !== 0) {
              clearTimeout(this.sendInviteTrickleIceFalseTimeOutId);
              this.sendInviteTrickleIceFalseTimeOutId = 0;
            }

            if (this.inviteSended === false) {
              logger.log('sendInvite on end of candidate');
              this.myWebRTC_Stack.sendInvite(this.callId, this.callerId, webRTCClient.nickname, this.dest_roomId, this.dest_roomId, this.callType, {
                offer: this.pc.localDescription,
                data: this.data,
                stream: this.mcuRemoteStream,
                "volatile": !!this.restarted
              });
              this.inviteSended = true;
            } else {
              logger.log('Invite already sended');
            }
          }
        }
      }
      /*
      //NEED To be more tested as it seems to create issue on automatic testing on sendFile : contact.spec : removing this for now
      
      Doc de l'event :
      <li>iceConnection not established : ICE_CONNECTION_STATE_NOT_ESTABLISHED</li>
      
                  if ((this.pc.iceConnectionState === "new" || this.pc.iceConnectionState === "disconnected") && this.pc.iceGatheringState === "complete") {
                      logger.warn('ConnectionState is new or disconnected and iceGathering is completed, need to stop call');
      
                      // IceDisconnectionState went straight to failed, no restart.
                      logger.warn('Removing call with callId: ' + this.callId);
                      webRTCClient.removeCallFromTableWithCallIdAndSendBye(this.callId, 'Not_Established_Ice_Connection');
      
                      myWebRTC_Event.createErrorEvent('iceConnection not established', 'ICE_CONNECTION_STATE_NOT_ESTABLISHED', this.callId, this.dest_roomId, this.settingUpType, this.data);
      
                  }
      */

    }
  };
  /*
   * Combines two given remote streams.
   * @ignore
   * @param {MediaStream} stream1
   * @param {string} src1 - Either 'event' or 'internal'.
   * @param {MediaStream} stream2
   * @param {string} src2 - Either 'event' or 'internal'.
   * @return {boolean} True on success, false otherwise.
   */


  this.combineRemoteStreams = function (stream1, src1, stream2, src2) {
    var tracks1 = stream1.getTracks();
    var tracks2 = stream2.getTracks();

    if (tracks1.length === 1 && tracks2.length === 1 && (tracks1[0].kind === 'audio' && tracks2[0].kind === 'video' || tracks1[0].kind === 'video' && tracks2[0].kind === 'audio')) {
      // Merge two media streams so the application sees only one.
      logger.debug('combineRemoteStreams');
      var newStream = new MediaStream();
      newStream.addTrack(tracks1[0]);
      newStream.addTrack(tracks2[0]);

      if (src2 === 'internal') {
        stream2.removeTrack(tracks2[0]);
        this.onRemoteStreamRemoved({
          stream: stream2
        });
      }

      if (src1 === 'internal') {
        stream1.removeTrack(tracks1[0]);
        this.onRemoteStreamRemoved({
          stream: stream1
        });
      }

      this.onRemoteStreamAdded({
        stream: newStream
      });
      return true;
    }

    return false;
  };
  /*
   * Checks whether given stream ID and/or given track IDs exists.
   * @param {string} streamId
   * @param {array<string>} trackIds
   * @return {boolean}
   */


  this.checkRemoteStreamExists = function (streamId, trackIds) {
    var found = false,
        idx = null,
        tracks = null,
        ti = null,
        foundTracks = null,
        res = null;

    if (trackIds && Array.isArray(trackIds)) {
      foundTracks = trackIds.slice(0);
    }

    for (idx = this.remoteMediaStreams.length; --idx >= 0;) {
      if (this.remoteMediaStreams[idx].id === streamId) {
        found = true;
        break;
      }

      if (foundTracks) {
        tracks = this.remoteMediaStreams[idx].getTracks();

        for (ti = tracks.length; --ti >= 0;) {
          res = trackIds.indexOf(tracks[ti].id);

          if (res >= 0) {
            foundTracks[res] = true;
          }
        }
      }
    }

    if (!found && foundTracks) {
      res = 0;

      for (ti = foundTracks.length; --ti >= 0;) {
        if (foundTracks[ti] === true) {
          res += 1;
        }
      }

      if (res === foundTracks.length) {
        found = true;
      }
    }

    return found;
  };

  this.onRemoteStreamAdded = function (event) {
    var _this8 = this;

    var audio = null,
        video = null;
    logger.info('onRemoteStreamAdded', event); // Searching for entry in remote media stream table.

    if (this.checkRemoteStreamExists(event.stream.id, event.stream.getTracks().map(function (e) {
      return e.id;
    }))) {
      // Track already known.
      logger.debug('onRemoteStreamAdded: ignoring event; stream/track already known');
      return;
    }

    if (this.remoteMediaStreams.length === 1) {
      if (this.combineRemoteStreams(this.remoteMediaStreams[0], 'internal', event.stream, 'event')) {
        // Two streams have been merged.
        return;
      }
    } // Registering new remote media stream.


    logger.debug('onRemoteStreamAdded adding', event.stream.id);
    this.remoteMediaStreams.push(event.stream);
    logger.log('CallId is :' + this.callId);
    logger.log('ClientId is :' + webRTCClient.clientId);

    if (this.sessionMCU && this.sessionMCU.modeChangeKind === 'new') {
      // room mode transition
      webRTCClient.processRemoteStreamAdded(this, event.stream);
    }

    if (this.screenSharing === true) {
      this.callType = "screenSharing";
    } else if (this.audioOnly === true) {
      this.callType = "audio";
    }

    var registerMuteEvents = function registerMuteEvents(track) {
      var audiotrackMutedTimeoutId = null;
      var videotrackMutedTimeoutId = null;

      track.onmute = function (e) {
        logger.debug(track.kind + ' mute event');
        var change = "";

        if (track.kind === "audio" && audiotrackMutedTimeoutId === null) {
          audiotrackMutedTimeoutId = setTimeout(function () {
            _this8.isRemoteAudioSilent = true;
            change = 'audioIsSilentLocally';
            var audio = {};
            var video = {};
            var changes = [];
            var cause = 'browserAction';
            changes.push(change);
            audio.available = _this8.remoteCallProfile.audio;
            audio.active = _this8.remoteCallProfile.audioActive;
            audio.muted = _this8.isRemoteAudioMuted;
            audio.silent = _this8.isRemoteAudioSilent;
            video.available = _this8.remoteCallProfile.video;
            video.active = _this8.remoteCallProfile.videoActive;
            video.muted = _this8.isRemoteVideoMuted;
            video.silent = _this8.isRemoteVideoSilent;

            _this8.myWebRTC_Event.createRemoteStreamUpdatedEvent(changes, audio, video, _this8.destCallType, _this8.callId, cause);

            audiotrackMutedTimeoutId = null; // Chrome seems to raise mute events only at multiples of 834ms; 
            // we set the timeout to three times this value (rounded to 840ms) 
          }, 3 * 840);
        } else if (track.kind === "video" && videotrackMutedTimeoutId === null) {
          videotrackMutedTimeoutId = setTimeout(function () {
            _this8.isRemoteVideoSilent = true;
            change = 'videoIsSilentLocally';
            var audio = {};
            var video = {};
            var changes = [];
            var cause = 'browserAction';
            changes.push(change);
            audio.available = _this8.remoteCallProfile.audio;
            audio.active = _this8.remoteCallProfile.audioActive;
            audio.muted = _this8.isRemoteAudioMuted;
            audio.silent = _this8.isRemoteAudioSilent;
            video.available = _this8.remoteCallProfile.video;
            video.active = _this8.remoteCallProfile.videoActive;
            video.muted = _this8.isRemoteVideoMuted;
            video.silent = _this8.isRemoteVideoSilent;

            _this8.myWebRTC_Event.createRemoteStreamUpdatedEvent(changes, audio, video, _this8.destCallType, _this8.callId, cause);

            videotrackMutedTimeoutId = null; // Chrome seems to raise mute events only at multiples of 834ms; 
            // we set the timeout to three times this value (rounded to 840ms) 
          }, 3 * 840);
        }
      };

      track.onunmute = function (e) {
        logger.debug(track.kind + ' unmute event');

        if (track.kind === "audio" && audiotrackMutedTimeoutId !== null) {
          clearTimeout(audiotrackMutedTimeoutId);
          audiotrackMutedTimeoutId = null;
        } else if (track.kind === "video" && videotrackMutedTimeoutId !== null) {
          clearTimeout(videotrackMutedTimeoutId);
          videotrackMutedTimeoutId = null;
        } else {
          var change = "";

          if (track.kind === "audio") {
            _this8.isRemoteAudioSilent = false;
            change = 'audioIsSilentLocally';
          } else if (track.kind === "video") {
            _this8.isRemoteVideoSilent = false;
            change = 'videoIsSilentLocally';
          }

          var _audio = {};
          var _video = {};
          var changes = [];
          var cause = 'browserAction';
          changes.push(change);
          _audio.available = _this8.remoteCallProfile.audio;
          _audio.active = _this8.remoteCallProfile.audioActive;
          _audio.muted = _this8.isRemoteAudioMuted;
          _audio.silent = _this8.isRemoteAudioSilent;
          _video.available = _this8.remoteCallProfile.video;
          _video.active = _this8.remoteCallProfile.videoActive;
          _video.muted = _this8.isRemoteVideoMuted;
          _video.silent = _this8.isRemoteVideoSilent;

          _this8.myWebRTC_Event.createRemoteStreamUpdatedEvent(changes, _audio, _video, _this8.destCallType, _this8.callId, cause);
        }
      };

      track.onended = function (e) {
        logger.debug(track.kind + ' ended event');

        if (track.kind === "audio" && audiotrackMutedTimeoutId !== null) {
          clearTimeout(audiotrackMutedTimeoutId);
          audiotrackMutedTimeoutId = null;
        } else if (track.kind === "video" && videotrackMutedTimeoutId !== null) {
          clearTimeout(videotrackMutedTimeoutId);
          videotrackMutedTimeoutId = null;
        }
      };
    };

    var _iterator = _createForOfIteratorHelper(event.stream.getVideoTracks()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var videoTrack = _step.value;
        registerMuteEvents(videoTrack);
        this.isRemoteVideoSilent = videoTrack.muted;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var _iterator2 = _createForOfIteratorHelper(event.stream.getAudioTracks()),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var audioTrack = _step2.value;
        registerMuteEvents(audioTrack);
        this.isRemoteAudioSilent = audioTrack.muted;
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    audio = {
      available: this.remoteCallProfile.audio,
      active: this.remoteCallProfile.audioActive,
      muted: this.isRemoteAudioMuted,
      silent: this.isRemoteAudioSilent
    };
    video = {
      available: this.remoteCallProfile.video,
      active: this.remoteCallProfile.videoActive,
      muted: this.isRemoteVideoMuted,
      silent: this.isRemoteVideoSilent
    };

    if (this.data !== null) {
      if (this.data.mesh !== undefined) {
        webRTCClient.myWebRTC_Event.createRemoteStreamAddedEvent(this.callType, this.callId, event.stream, this.remoteId, this.destCallType, audio, video);
      } else if (this.data.type === 'publish' && this.data.mode !== "passive") {
        //Don't send createRemoteStreamAddedEvent
        logger.warn('Filtering Remote stream added event (behavior on Chrome 44), no remote stream on publish calls');
      } else {
        if (this.data.subscribeOrder === true && this.data.pubCallId !== undefined) {
          // In case of subscribe order, we must substitute the callId
          logger.debug('substitute callId: ' + this.callId + ' -> ' + this.data.pubCallId);
          webRTCClient.myWebRTC_Event.createRemoteStreamAddedEvent(this.callType, this.data.pubCallId, event.stream, this.remoteId, this.destCallType, audio, video);
        } else {
          webRTCClient.myWebRTC_Event.createRemoteStreamAddedEvent(this.callType, this.callId, event.stream, this.remoteId, this.destCallType, audio, video);
        }
      }
    } else {
      webRTCClient.myWebRTC_Event.createRemoteStreamAddedEvent(this.callType, this.callId, event.stream, this.remoteId, this.destCallType, audio, video);
    }
  };

  this.onRemoteTrackAdded = function (event) {
    logger.info('onRemoteTrackAdded', event);
    var audio = null,
        video = null;

    if (event.streams[0] === undefined || event.track === undefined) {
      logger.debug('onRemoteTrackAdded: ignoring event; event data are not correct');
      return;
    } // Searching for entry in remote media stream table.


    if (this.checkRemoteStreamExists(event.streams[0].id, [event.track.id])) {
      // Track already known.
      logger.debug('onRemoteTrackAdded: ignoring event; stream/track already known');
      return;
    }

    if (this.remoteMediaStreams.length === 1) {
      if (this.combineRemoteStreams(this.remoteMediaStreams[0], 'internal', event.streams[0], 'event')) {
        // Two streams have been merged.
        return;
      }
    } // Whether the kind of track matches the call type.


    if (this.belongsToRoom()) {
      if (this.callType === "audio" && event.track.kind !== "audio" || this.callType === "videoOnly" && event.track.kind !== "video" || this.callType === "media" && event.track.kind !== "video" || this.callType === "screenSharing" && event.track.kind !== "video" || this.callType === "screenSharingWithAudio" && event.track.kind !== "video") {
        // Kind of track does not match call type.
        logger.debug('onRemoteTrackAdded: ignoring event; callType: ' + this.callType + ', event.track.kind: ' + event.track.kind);
        return;
      }
    } else {
      if (this.destCallType === "audio" && event.track.kind !== "audio" || this.destCallType === "videoOnly" && event.track.kind !== "video" || this.destCallType === "media" && event.track.kind !== "video" || this.destCallType === "screenSharing" && event.track.kind !== "video" || this.destCallType === "screenSharingWithAudio" && event.track.kind !== "video") {
        // Kind of track does not match call type.
        logger.debug('onRemoteTrackAdded: ignoring event; destCallType: ' + this.destCallType + ', event.track.kind: ' + event.track.kind);

        if (this.remoteMediaStreams.length === 2) {
          this.combineRemoveStreams(this.remoteMediaStreams[0], 'internal', this.remoteMediaStreams[1], 'internal');
        }

        return;
      }
    } // Registering new remote media stream.


    logger.debug('onRemoteTrackAdded adding; stream.id: ' + event.streams[0].id);
    this.remoteMediaStreams.push(event.streams[0]);
    logger.log('CallId is :' + this.callId);
    logger.log('ClientId is :' + webRTCClient.clientId);
    logger.log('this.callType :' + this.callType);

    if (this.screenSharing === true) {
      this.callType = "screenSharing";
    } else if (this.audioOnly === true) {
      this.callType = "audio";
    }

    if (this.sessionMCU && this.sessionMCU.modeChangeKind === 'new') {
      // room mode transition
      webRTCClient.processRemoteStreamAdded(this, event.streams[0]);
    } // Triggered when a track is added to the stream.


    event.streams[0].onaddtrack = function (e) {
      logger.debug('onRemoteTrackAdded ontrack.onaddtrack', e);
    }; // Triggered when a track is removed from the stream.


    event.streams[0].onremovetrack = function (e) {
      var idx = null;
      logger.debug('onRemoteTrackAdded ontrack.onremovetrack', e); // Update ongoing

      if (this.updateOngoingTimeoutId) {
        logger.debug('onRemoteTrackAdded onremovetrack: update ongoing');
        logger.debug('onRemoteTrackAdded onremovetrack: ignoring event', e.track.kind);
        return;
      } // Whether the kind of track matches the call type.


      if (this.callType === "audio" && e.track.kind !== "audio" || this.callType === "videoOnly" && e.track.kind !== "video" || this.callType === "media" && e.track.kind !== "video" || this.callType === "screenSharing" && e.track.kind !== "video" || this.callType === "screenSharingWithAudio" && e.track.kind !== "video") {
        // Kind of track does match call type.
        logger.debug('onRemoteTrackAdded onremovetrack: ignoring event', e.track.kind);
        return;
      }

      if (!(e.target instanceof MediaStream)) {
        logger.debug('onRemoteTrackAdded onremovetrack: ignoring event target not MediaStream');
        return;
      } // Searching for entry in remote media stream table.


      for (idx = this.remoteMediaStreams.length; --idx >= 0;) {
        if (this.remoteMediaStreams[idx].id === e.target.id) {
          // Removing remote media stream already from table.
          logger.debug('onRemoteTrackAdded onremovetrack removing', e.target.id);
          this.remoteMediaStreams.splice(idx, 1);
          break;
        }
      }

      webRTCClient.myWebRTC_Event.createRemoteStreamRemovedEvent(this.callType, this.callId, e.target, this.remoteId, this.destCallType);
    }.bind(this);

    audio = {
      available: this.remoteCallProfile.audio,
      active: this.remoteCallProfile.audioActive,
      muted: this.isRemoteAudioMuted,
      silent: this.isRemoteAudioSilent
    };
    video = {
      available: this.remoteCallProfile.video,
      active: this.remoteCallProfile.videoActive,
      muted: this.isRemoteVideoMuted,
      silent: this.isRemoteVideoSilent
    };

    if (this.data !== null) {
      if (this.data.mesh !== undefined) {
        // Room in mesh mode.
        if (this.callType === "audio" && event.track.kind === "audio" || this.callType === "videoOnly" && event.track.kind === "video" || this.callType === "media" && event.track.kind === "video" || this.callType === "screenSharing" && event.track.kind === "video" || this.callType === "screenSharingWithAudio" && event.track.kind === "video") {
          webRTCClient.myWebRTC_Event.createRemoteStreamAddedEvent(this.callType, this.callId, event.streams[0], this.remoteId, this.destCallType, audio, video);
        }
      } else if (this.data.type === 'publish' && this.data.mode !== "passive") {
        //Don't send createRemoteStreamAddedEvent
        logger.warn('Filtering Remote stream added event (behavior on Chrome 44), no remote stream on publish calls');
      } else if (this.belongsToRoom()) {
        // Room.
        if (this.callType === "audio" && event.track.kind === "audio" || this.callType === "videoOnly" && event.track.kind === "video" || this.callType === "media" && event.track.kind === "video" || this.callType === "screenSharing" && event.track.kind === "video" || this.callType === "screenSharingWithAudio" && event.track.kind === "video") {
          if (this.data.subscribeOrder === true && this.data.pubCallId !== undefined) {
            // In case of subscribe order, we must substitute the callId
            logger.debug('substitute callId: ' + this.callId + ' -> ' + this.data.pubCallId);
            webRTCClient.myWebRTC_Event.createRemoteStreamAddedEvent(this.callType, this.data.pubCallId, event.streams[0], this.remoteId, this.destCallType, audio, video);
          } else {
            webRTCClient.myWebRTC_Event.createRemoteStreamAddedEvent(this.callType, this.callId, event.streams[0], this.remoteId, this.destCallType, audio, video);
          }
        }
      } else {
        // Regular call.
        if (this.destCallType === "audio" && event.track.kind === "audio" || this.destCallType === "videoOnly" && event.track.kind === "video" || this.destCallType === "media" && event.track.kind === "video" || this.destCallType === "screenSharing" && event.track.kind === "video" || this.destCallType === "screenSharingWithAudio" && event.track.kind === "video") {
          webRTCClient.myWebRTC_Event.createRemoteStreamAddedEvent(this.callType, this.callId, event.streams[0], this.remoteId, this.destCallType, audio, video);
        }
      }
    } else {
      // No data.
      if (this.belongsToRoom()) {
        // Room.
        if (this.callType === "audio" && event.track.kind === "audio" || this.callType === "videoOnly" && event.track.kind === "video" || this.callType === "media" && event.track.kind === "video" || this.callType === "screenSharing" && event.track.kind === "video" || this.callType === "screenSharingWithAudio" && event.track.kind === "video") {
          webRTCClient.myWebRTC_Event.createRemoteStreamAddedEvent(this.callType, this.callId, event.streams[0], this.remoteId, this.destCallType, audio, video);
        }
      } else {
        // Regular call.
        if (this.destCallType === "audio" && event.track.kind === "audio" || this.destCallType === "videoOnly" && event.track.kind === "video" || this.destCallType === "media" && event.track.kind === "video" || this.destCallType === "screenSharing" && event.track.kind === "video" || this.destCallType === "screenSharingWithAudio" && event.track.kind === "video") {
          webRTCClient.myWebRTC_Event.createRemoteStreamAddedEvent(this.callType, this.callId, event.streams[0], this.remoteId, this.destCallType, audio, video);
        }
      }
    }
  };

  this.onRemoteStreamRemoved = function (event) {
    var idx = null;
    logger.info('onRemoteStreamRemoved', event); // Searching for entry in remote media stream table.

    for (idx = this.remoteMediaStreams.length; --idx >= 0;) {
      if (this.remoteMediaStreams[idx].id === event.stream.id) {
        // Removing remote media stream already from table.
        logger.debug('onRemoteStreamRemoved removing', event.stream.id);
        this.remoteMediaStreams.splice(idx, 1);
        break;
      }
    }

    webRTCClient.myWebRTC_Event.createRemoteStreamRemovedEvent(this.callType, this.callId, event.stream, this.remoteId, this.destCallType);
    event = null;
  };

  this.onNegotiationNeeded = function (event) {
    logger.debug('onNegotiationNeeded', event);
    event = null; //TODO voir si OK quand caller et callee sur 1er call

    if (this.addingDataChannelOnCallOngoing) {
      this.updateMediaWithRetryManagement(false);
      this.addingDataChannelOnCallOngoing = false;
    }
  };

  this.onSignalingStateChange = function (event) {
    logger.debug('onSignalingStateChange', event);
    event = null;
  };

  this.onCallDisconnection = function () {
    logger.info('onCallDisconnection; callId: ' + this.callId);
    var date = new Date();
    logger.debug('date:', date); //Avoid unnecessary disconnection warnings as call has now ended

    if (this.disconnectionWarningInterval !== 0) {
      logger.debug('date:', date);
      logger.debug('clearing disconnectionWarningInterval');
      clearInterval(this.disconnectionWarningInterval);
      this.disconnectionWarningInterval = 0;
    }

    if (this.disconnectionWarningTimeout !== 0) {
      logger.debug('date:', date);
      logger.debug('clearing disconnectionWarningTimeout');
      clearTimeout(this.disconnectionWarningTimeout);
      this.disconnectionWarningTimeout = 0;
    }

    if (this.belongsToRoom()) {
      // Restart call with disconnected reason.
      webRTCClient.onHangup(this.callId, 'disconnected');
    } else {
      webRTCClient.onHangup(this.callId, 'Ice_disconnected');
    }
  };

  this.sendDisconnectionWarning = function () {
    logger.log("sendDisconnectionWarning()");
    var roomName = null,
        settingUpType = null;

    if (this.callControl) {
      roomName = this.callControl.roomName;
      settingUpType = this.callControl.type;
    }

    this.disconnectionWarningCount++;
    myWebRTC_Event.createEvent({
      "eventType": "disconnectionWarning",
      "callId": this.callId,
      "remoteId": this.remoteId,
      "tries": this.disconnectionWarningCount,
      "roomName": roomName,
      "settingUpType": settingUpType
    });

    if ((this.disconnectionWarningCount - 1) * this.disconnectionWarningDelay >= this.disconnectionTimer && this.disconnectionWarningInterval !== 0) {
      //Avoid unnecessary disconnection warnings as call will soon end
      var date = Date();
      logger.debug('date :' + date);
      logger.debug('clearing disconnectionWarningInterval : no more warnings');
      clearInterval(this.disconnectionWarningInterval);
      this.disconnectionWarningInterval = 0;
    }
  };
  /*
   * Creates ICE error descriptor for notifications.
   * @param {string} state - Either 'disconnected' or 'failed'.
   * @param {boolean} disconnected - Whether state routed through disconnected before ended in failed.
   * @return {object} Descriptor.
   * @return {string} .iceState - Either 'disconnected' or 'failed'.
   * @return {string} .previousIceState - Either 'disconnected' or undefined.
   * @return {string} .callType
   * @return {string} .context - Either 'conf' or 'call'.
   * @return {string} .mode - Either 'mesh', 'sfu' or 'p2p'.
   * @return {string} .type - Either 'publish' or 'subscribe'.
   * @return {string} .clientId
   * @return {string} .remoteId
   * @return {object} .stream - Stream descriptor for subscribe.
   */


  this.createIceErrorDescriptor = function (state, previouslyDisconnected) {
    var data = {};

    if (state === 'disconnected') {
      data.iceState = 'disconnected';
    } else if (state === 'failed') {
      data.iceState = 'failed';

      if (previouslyDisconnected === true) {
        data.previousIceState = 'disconnected';
      }
    } else {
      data.iceState = 'unknown';
    }

    data.callType = this.callType;

    if (this.belongsToRoom()) {
      // This one has been established in a conference context.
      data.context = 'conf';

      if (this.data.mesh) {
        // This one is not using any sfu.
        data.mode = 'mesh';

        if (this.data.mesh.callerCompositeUserId ? this.data.mesh.callerCompositeUserId === webRTCClient.compositeClientId : this.data.mesh.callerId === webRTCClient.clientId) {
          // Subscriber.
          data.type = 'subscribe';
          data.clientId = this.data.mesh.callerId;
          data.remoteId = this.data.mesh.calleeId;
        } else if (this.data.mesh.calleeCompositeUserId ? this.data.mesh.calleeCompositeUserId === webRTCClient.compositeClientId : this.data.mesh.calleeId === webRTCClient.clientId) {
          // Publisher.
          data.type = 'publish';
          data.clientId = this.data.mesh.calleeId;
          data.remoteId = this.data.mesh.callerId;
        } else {
          data.type = 'unknown';
        }

        data.mesh = this.data.mesh;
      } else {
        // This one is using a sfu.
        data.mode = 'sfu';

        if (this.settingUpType === 'publish' || this.settingUpType === 'shareScreen') {
          data.type = 'publish';
        } else if (this.settingUpType === 'subscribe') {
          data.type = 'subscribe';
        } else {
          data.type = 'unknown';
        }

        if (this.callee) {
          data.clientId = this.calleeId;
          data.remoteId = this.callerId;
        } else {
          data.clientId = this.callerId;
          data.remoteId = this.calleeId;
        }
      }

      if (this.mcuRemoteStream) {
        data.stream = this.mcuRemoteStream;
      }
    } else {
      // This one has been established outside a conference context.
      data.context = 'call';
      data.mode = 'p2p';

      if (this.callerId === webRTCClient.clientId) {
        data.clientId = this.callerId;
        data.remoteId = this.calleeId;
      } else if (this.calleeId === webRTCClient.clientId) {
        data.clientId = this.calleeId;
        data.remoteId = this.callerId;
      }
    }

    return data;
  };

  this.onIceConnectionStateChange = function (event) {
    logger.debug('onIceConnectionStateChange: ', event);
    event = null;
    var date = 0,
        roomName = null,
        settingUpType = null,
        data = null;

    if (this.pc !== null) {
      logger.info('Ice Connection State is now : ' + this.pc.iceConnectionState);
      this.iceState = this.pc.iceConnectionState;

      if (this.pc.iceConnectionState === 'connected' || this.pc.iceConnectionState === 'completed' || this.pc.iceConnectionState === 'checking') {
        logger.debug('iceConnectionState === connected or completed or checking');
        logger.debug('this.disconnectionTimeoutId :' + this.disconnectionTimeoutId);

        if (this.disconnectionTimeoutId !== 0) {
          //Removing disconnectionTimeout as iceConnection is now connected
          date = Date();
          logger.debug('date:', date);
          logger.debug('clearing disconnectionTimeout');
          clearTimeout(this.disconnectionTimeoutId);
          this.disconnectionTimeoutId = 0;
        }

        if (this.disconnectionWarningInterval !== 0) {
          //Removing disconnectionWarningInterval as iceConnection is now connected
          date = Date();
          logger.debug('date:', date);
          logger.debug('clearing disconnectionWarningInterval');
          clearInterval(this.disconnectionWarningInterval);
          this.disconnectionWarningInterval = 0;
        }

        if (this.pc.iceConnectionState !== 'checking') {
          this.checkCandidateTypesTimeoutId = setTimeout(this.callback(this, 'checkCandidateTypes'), this.checkCandidateTypesTimer);
          this.checkCandidateTypesTimeoutTable.push(this.checkCandidateTypesTimeoutId);
        }
      } else if (this.pc.iceConnectionState === 'disconnected') {
        if (this.callControl) {
          roomName = this.callControl.roomName;
          settingUpType = this.callControl.type;
        }

        data = this.createIceErrorDescriptor('disconnected');

        if (data.context === 'conf') {
          // Sending info to conf connector.
          this.myWebRTC_Stack.sendInfo('iceError', {
            clientId: webRTCClient.clientId,
            callId: this.callId,
            roomId: this.sessionMCU.roomName,
            pubSub: webRTCClient.MCUClient.pubConnector,
            descriptor: data
          });
        }

        logger.warn('disconnection detected');
        myWebRTC_Event.createErrorEvent('iceDisconnection detected', 'ICE_CONNECTION_STATE_DISCONNECTED', this.callId, roomName, settingUpType, data);
        /*
        //Testing connection to determine if connection issue is on client or remote side
                        apiCC.testUserUpload(20, function (err, res, call) {
                            if (!err) {
                                logger.log('testUserUpload OK :', res);
                                logger.log('User is still connected to internet');
                                call.internetConnectionLost = false;
                            } else {
                                logger.log('testUserUpload Error :', err);
                                if (err.msg === 0) {
                                    //ERROR correspond to ERR_INTERNET_DISCONNECTED
                                    logger.log('User is no more connected to internet');
                                    call.internetConnectionLost = true;
                                }
                            }
        
        //TODO si internet lost, on retry pour dtecter retour ????
        
                        }, this);
        */

        date = new Date();
        logger.debug('date:', date);
        this.disconnectionTimeoutId = setTimeout(this.callback(this, 'onCallDisconnection'), this.disconnectionTimer);
        this.disconnectionWarningCount = 0;
        this.disconnectionWarningTimeout = setTimeout(this.callback(this, 'sendDisconnectionWarning'), 2000); //avoid cases where Ice disconnection is fired before call end

        this.disconnectionWarningInterval = setInterval(this.callback(this, 'sendDisconnectionWarning'), this.disconnectionWarningDelay);
        /*
                        var stun_config = 'stun:' + 'stun.l.google.com:19302',
                            turn_config = 'turn:' + 'anonymous@46.105.45.162:443',
                            servers = [{'url': stun_config}];
        
                        if (webRTCClient.myWebRTC_Adapter.webrtcDetectedBrowser === 'firefox') {
                            logger.log('createPeerConnection FIREFOX');
                            //servers = [{'url': 'stun:23.21.150.121'}];
                            servers = [{'url': 'stun:46.105.45.162:443'}];
                        } else {
                            logger.log('createPeerConnection CHROME');
                            servers = [{'url': turn_config, 'credential': 'password'}];      //Activation TURN
                        }
                        this.pc.updateIce({iceServers: servers});
        */
      } else if (this.pc.iceConnectionState === 'failed') {
        if (this.callControl) {
          roomName = this.callControl.roomName;
          settingUpType = this.callControl.type;
        }

        data = this.createIceErrorDescriptor('failed', this.disconnectionTimeoutId !== 0);

        if (data.context === 'conf') {
          // Sending info to conf connector.
          this.myWebRTC_Stack.sendInfo('iceError', {
            clientId: webRTCClient.clientId,
            callId: this.callId,
            roomId: this.sessionMCU.roomName,
            pubSub: webRTCClient.MCUClient.pubConnector,
            descriptor: data
          });
        }

        logger.warn('iceConnection failed detected');
        myWebRTC_Event.createErrorEvent('iceConnection failed detected', 'ICE_CONNECTION_STATE_FAILED', this.callId, roomName, settingUpType, data);

        if (this.disconnectionTimeoutId !== 0) {
          if (this.belongsToRoom()) {
            // IceDisconnectionState was disconnected before, restart the call right away.
            clearTimeout(this.disconnectionTimeoutId);
            this.disconnectionTimeoutId = 0;
            webRTCClient.onHangup(this.callId, 'disconnected');
          }
        } else {
          if (this.belongsToRoom() && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.callControl, ['autoRestart', 'counter'], 'number') && this.callControl.autoRestart.counter > 0) {
            // IceDisconnectionState went straight to failed, but the call was already restarted so keep doing it.
            webRTCClient.onHangup(this.callId, 'disconnected');
          } else {
            // IceDisconnectionState went straight to failed, no restart.
            logger.warn('Removing call with callId: ' + this.callId);
            webRTCClient.removeCallFromTableWithCallIdAndSendBye(this.callId, 'Ice_failed');
          }
        }
      }
    } else {
      logger.log('Ice Connection State change with pc is null');
    }
  };

  this.callback = function (that, fnct) {
    this.closureHandler = function (e, f) {
      return that[fnct](e, f);
    };

    return this.closureHandler;
  };

  this.onSelectedCandidate = function (candidates) {
    if (this.selectedCandidate !== undefined && this.selectedCandidate !== null) {
      /* Checking whether it is the same candidate than before */
      if (this.selectedCandidate.LocalCandidateType === candidates.LocalCandidateType && this.selectedCandidate.RemoteCandidateType === candidates.RemoteCandidateType && this.selectedCandidate.LocalAddress === candidates.LocalAddress && this.selectedCandidate.RemoteAddress === candidates.RemoteAddress && this.selectedCandidate.TransportType === candidates.TransportType && this.selectedCandidate.LocalTransportType === candidates.LocalTransportType) {
        logger.debug('filtering duplicate candidate');
        return;
      }
    }

    logger.debug("WebRTC_Call::onSelectedCandidate() :", candidates);
    this.selectedCandidate = candidates;

    if (this.callControl && this.callControl.autoRestart) {
      logger.debug('selectedCandidate, this.callControl.autoRestart.counter:', this.callControl.autoRestart.counter);
      logger.debug('selectedCandidate, this.callControl.autoRestart.callIdWhenStartingTimer:', this.callControl.autoRestart.callIdWhenStartingTimer);

      if (this.callControl.autoRestart.counter) {
        logger.debug('Reinit of autoRestart.counter'); //Reinit autoRestart.counter : counter is used to defined delay before doing restartProcess
        //If call is established next restartProcess will need a short delay to begin

        this.callControl.autoRestart.counter = 0; //Stopping maxCallsRetriesDuration timer

        if (this.callControl.autoRestart.callIdWhenStartingTimer !== undefined) {
          webRTCClient.stopMaxCallRetriesTimer(this.callControl.autoRestart.callIdWhenStartingTimer);
        }
      }
    } //Create event


    this.myWebRTC_Event.createSelectedICECandidateEvent(this.callId, candidates.LocalCandidateType, candidates.RemoteCandidateType, candidates.LocalAddress, candidates.RemoteAddress, candidates.TransportType, candidates.LocalTransportType);
    var messageToSend = candidates;
    messageToSend.callId = this.callId;
    messageToSend.clientId = webRTCClient.clientId;
    messageToSend.roomId = this.dest_roomId;

    if (this.data.pubSub !== undefined) {
      messageToSend.pubSub = this.data.pubSub;
    }

    if (this.data.confId !== undefined) {
      messageToSend.confId = this.data.confId;
    }

    if (this.data.mesh !== undefined) {
      messageToSend.mesh = this.data.mesh;
    }

    if (this.data.instanceId !== undefined) {
      messageToSend.instanceId = this.data.instanceId;
    } //Send Info message to CCS


    this.myWebRTC_Stack.sendInfo('callSelectedCandidate', messageToSend);
  }; //check candidate types for call both for local and remote peer and sends  an ICECandidateTypeUpdate event


  this.checkCandidateTypes = function () {
    logger.debug("WebRTC_Call::checkCandidatesTypes()");
    var self = this,
        candidates = {
      'LocalCandidateType': 'unknow',
      'RemoteCandidateType': 'unknow',
      'LocalAddress': 'unknow',
      'RemoteAddress': 'unknow',
      'TransportType': 'unknow',
      'LocalTransportType': 'unknow'
    },
        reqFields = ['googLocalAddress', 'googLocalCandidateType', 'googRemoteAddress', 'googRemoteCandidateType', 'googTransportType'];

    if (this.pc === null) {
      logger.warn("Peer connection is null : no candidates");
      self.myWebRTC_Event.createICECandidateTypeUpdateEvent(self.callId, candidates.LocalCandidateType, candidates.RemoteCandidateType);
      self.onSelectedCandidate(candidates);
    } else if (typeof apiRTC_React !== 'undefined') {
      logger.warn("apiRTC_React : no info on candidates"); //TODO

      self.myWebRTC_Event.createICECandidateTypeUpdateEvent(self.callId, candidates.LocalCandidateType, candidates.RemoteCandidateType);
      self.onSelectedCandidate(candidates);
    } else {
      if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome') {
        logger.debug("WebRTC_Call::checkCandidatesTypes() chrome");
        this.pc.getStats(function (stats) {
          var filtered = stats.result().filter(function (e) {
            return e.id.indexOf('Conn-') === 0 && e.stat('googActiveConnection') === 'true';
          })[0];

          if (!filtered) {
            self.myWebRTC_Event.createICECandidateTypeUpdateEvent(self.callId, candidates.LocalCandidateType, candidates.RemoteCandidateType);
            self.onSelectedCandidate(candidates);
          } else {
            reqFields.forEach(function (e) {
              candidates[e.replace('goog', '')] = filtered.stat(e);
            });
            self.myWebRTC_Event.createICECandidateTypeUpdateEvent(self.callId, candidates.LocalCandidateType, candidates.RemoteCandidateType);
            self.onSelectedCandidate(candidates);
          }
        });
      } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
        logger.debug("WebRTC_Call::checkCandidatesTypes() firefox");
        this.pc.getStats(null).then(function (stats) {
          var selectedCandidatePair = null;
          stats.forEach(function (section) {
            // Assuming type is candidate-pair
            if (section.selected === true) {
              if (selectedCandidatePair !== null) {
                logger.warn('multiple selected candidate-pairs');
              }

              selectedCandidatePair = section;
            }
          });

          if (selectedCandidatePair !== null) {
            var localICE = stats.get(selectedCandidatePair.localCandidateId),
                remoteICE = stats.get(selectedCandidatePair.remoteCandidateId);
            candidates.LocalCandidateType = localICE.candidateType;
            candidates.RemoteCandidateType = remoteICE.candidateType;

            if (localICE.address && localICE.port) {
              candidates.LocalAddress = localICE.address + ':' + localICE.port;
            } else {
              candidates.LocalAddress = localICE.ipAddress + ':' + localICE.portNumber;
            }

            if (remoteICE.address && remoteICE.port) {
              candidates.RemoteAddress = remoteICE.address + ':' + remoteICE.port;
            } else {
              candidates.RemoteAddress = remoteICE.ipAddress + ':' + remoteICE.portNumber;
            }

            candidates.TransportType = localICE.transport;
            candidates.LocalTransportType = localICE.mozLocalTransport;
            self.myWebRTC_Event.createICECandidateTypeUpdateEvent(self.callId, candidates.LocalCandidateType, candidates.RemoteCandidateType);
            self.onSelectedCandidate(candidates);
          }
        })["catch"](function (err) {
          logger.warn('failed to get stats', err);
        });
      } else {
        logger.debug('checkCandidateTypes not Chrome or Firefox');
        self.myWebRTC_Event.createICECandidateTypeUpdateEvent(self.callId, candidates.LocalCandidateType, candidates.RemoteCandidateType);
        self.onSelectedCandidate(candidates);
      }
    }
  };
  /*
   * Tests whether this one if linked to a conference room.
   *
   * @method belongsToRoom
   *
   * @return {boolean} true if this one is linked to a conference room, false otherwise.
   */


  this.belongsToRoom = function () {
    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.sessionMCU, 'roomName', 'string')) {
      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.data, 'MCUType', 'string') && (this.data.MCUType === 'MCU-Caller' || this.data.MCUType === 'MCU-Callee') && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.data, 'confId', 'string')) {
        // recorded call.
        return this.data.confId === this.sessionMCU.roomName;
      }

      return this.dest_roomId === this.sessionMCU.roomName;
    }

    return false;
  };
  /*
   * Sets a new local call profile and sends the appropriate events.
   *
   * The localCallProfile represents local stream sent to remote.
   *
   * @method setLocalCallProfile
   *
   * @param {object} newLocalCallProfile - New local call profile.
   * @param {boolean} fireEvents - Whether to fire events. Default is false.
   */


  this.setLocalCallProfile = function (newLocalCallProfile) {
    var fireEvents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var changes = [];
    var audio = {};
    var video = {};
    var userMediaStreamId = null;
    var userMediaStream = null;
    var cause = 'adaptation';

    if (this.dataCall !== true && this.settingUpType !== 'subscribe') {
      // There is no sent stream changes for subscribe calls.
      if (this.localCallProfile.audioActive !== newLocalCallProfile.audioActive) {
        changes.push('audioIsActive');
      }

      if (this.localCallProfile.videoActive !== newLocalCallProfile.videoActive) {
        changes.push('videoIsActive');
      }

      this.localCallProfile = newLocalCallProfile; // Updating callType.

      if (this.screenSharing === true) {
        if (this.localCallProfile.audioActive === true && this.localCallProfile.videoActive === true) {
          if (this.callType !== 'screenSharingWithAudio') {
            this.callType = 'screenSharingWithAudio';
            changes.push('callType');
          }
        } else if (this.localCallProfile.audioActive === true) {
          if (this.callType !== 'audio') {
            this.callType = 'audio';
            changes.push('callType');
          }
        } else if (this.localCallProfile.videoActive === true) {
          if (this.callType !== 'screenSharing') {
            this.callType = 'screenSharing';
            changes.push('callType');
          }
        } else {
          if (this.callType !== 'inactive') {
            this.callType = 'inactive';
            changes.push('callType');
          }
        }
      } else {
        if (this.localCallProfile.audioActive === true && this.localCallProfile.videoActive === true) {
          if (this.callType !== 'media') {
            this.callType = 'media';
            changes.push('callType');
          }
        } else if (this.localCallProfile.audioActive === true) {
          if (this.callType !== 'audio') {
            this.callType = 'audio';
            changes.push('callType');
          }
        } else if (this.localCallProfile.videoActive === true) {
          if (this.callType !== 'videoOnly') {
            this.callType = 'videoOnly';
            changes.push('callType');
          }
        } else {
          if (this.callType !== 'inactive') {
            this.callType = 'inactive';
            changes.push('callType');
          }
        }
      }

      if (fireEvents === true && changes.length > 0) {
        audio.available = this.localCallProfile.audio;
        audio.active = this.localCallProfile.audioActive;
        audio.muted = this.isLocalAudioMuted;
        audio.silent = this.isRemoteAudioSilent;
        video.available = this.localCallProfile.video;
        video.active = this.localCallProfile.videoActive;
        video.muted = this.isLocalVideoMuted;
        video.silent = this.isRemoteVideoSilent;

        if (this.callConfiguration && this.callConfiguration.userMediaStreamId) {
          userMediaStreamId = this.callConfiguration.userMediaStreamId;
          userMediaStream = apiCC.getUserMediaStream(userMediaStreamId);

          if (userMediaStream) {
            audio.deviceLabel = userMediaStream.audioDeviceLabel;
            video.deviceLabel = userMediaStream.videoDeviceLabel;
          }
        }

        if (this.updateCause) {
          cause = this.updateCause;
        }

        this.myWebRTC_Event.createLocalStreamUpdatedEvent(changes, audio, video, true, this.callType, this.callId, this.callLocalStream, userMediaStreamId, cause);
      }
    }
  };
  /*
   * Sets a new remote call profile and sends the appropriate events.
   *
   * The remoteCallProfile represents remote stream received from remote.
   *
   * @method setRemoteCallProfile
   *
   * @param {object} newRemoteCallProfile - New remote call profile.
   * @param {boolean} fireEvents - Whether to fire events. Default is false.
   */


  this.setRemoteCallProfile = function (newRemoteCallProfile) {
    var fireEvents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var changes = [];
    var audio = {};
    var video = {};
    var cause = 'adaptation';

    if (this.dataCall !== true) {
      if (this.remoteCallProfile.audioActive !== newRemoteCallProfile.audioActive) {
        changes.push('audioIsActive');
      }

      if (this.remoteCallProfile.videoActive !== newRemoteCallProfile.videoActive) {
        changes.push('videoIsActive');
      }

      this.remoteCallProfile = newRemoteCallProfile; // Updating callType.

      if (this.settingUpType === 'subscribe') {
        // In the case of subscribe, callType defines the received stream.
        if (this.screenSharing === true) {
          if (this.remoteCallProfile.audioActive === true && this.remoteCallProfile.videoActive === true) {
            if (this.callType !== 'screenSharingWithAudio') {
              this.callType = 'screenSharingWithAudio';
              changes.push('callType');
            }
          } else if (this.remoteCallProfile.audioActive === true) {
            if (this.callType !== 'audio') {
              this.callType = 'audio';
              changes.push('callType');
            }
          } else if (this.remoteCallProfile.videoActive === true) {
            if (this.callType !== 'screenSharing') {
              this.callType = 'screenSharing';
              changes.push('callType');
            }
          } else {
            if (this.callType !== 'inactive') {
              this.callType = 'inactive';
              changes.push('callType');
            }
          }
        } else {
          if (this.remoteCallProfile.audioActive === true && this.remoteCallProfile.videoActive === true) {
            if (this.callType !== 'media') {
              this.callType = 'media';
              changes.push('callType');
            }
          } else if (this.remoteCallProfile.audioActive === true) {
            if (this.callType !== 'audio') {
              this.callType = 'audio';
              changes.push('callType');
            }
          } else if (this.remoteCallProfile.videoActive === true) {
            if (this.callType !== 'videoOnly') {
              this.callType = 'videoOnly';
              changes.push('callType');
            }
          } else {
            if (this.callType !== 'inactive') {
              this.callType = 'inactive';
              changes.push('callType');
            }
          }
        }

        if (fireEvents === true && changes.length > 0) {
          audio.available = this.remoteCallProfile.audio;
          audio.active = this.remoteCallProfile.audioActive;
          audio.muted = this.isRemoteAudioMuted;
          audio.silent = this.isRemoteAudioSilent;
          video.available = this.remoteCallProfile.video;
          video.active = this.remoteCallProfile.videoActive;
          video.muted = this.isRemoteVideoMuted;
          video.silent = this.isRemoteVideoSilent;

          if (this.updateCause) {
            cause = this.updateCause;
          }

          this.myWebRTC_Event.createRemoteStreamUpdatedEvent(changes, audio, video, this.callType, this.callId, cause);
        }
      } else {
        // In every other case, destCallType defines the received stream.
        if (this.screenSharing === true) {
          if (this.remoteCallProfile.audioActive === true && this.remoteCallProfile.videoActive === true) {
            if (this.destCallType !== 'screenSharingWithAudio') {
              this.destCallType = 'screenSharingWithAudio';
              changes.push('callType');
            }
          } else if (this.remoteCallProfile.audioActive === true) {
            if (this.destCallType !== 'audio') {
              this.destCallType = 'audio';
              changes.push('callType');
            }
          } else if (this.remoteCallProfile.videoActive === true) {
            if (this.destCallType !== 'screenSharing') {
              this.destCallType = 'screenSharing';
              changes.push('callType');
            }
          } else {
            if (this.destCallType !== 'inactive') {
              this.destCallType = 'inactive';
              changes.push('callType');
            }
          }
        } else if (this.settingUpType === 'publish' || this.settingUpType === 'shareScreen') {
          if (this.remoteCallProfile.audioActive === true && this.remoteCallProfile.videoActive === true) {
            if (this.destCallType !== 'media') {
              this.destCallType = 'media';
              changes.push('callType');
            }
          } else if (this.remoteCallProfile.audioActive === true) {
            if (this.destCallType !== 'audio') {
              this.destCallType = 'audio';
              changes.push('callType');
            }
          } else if (this.remoteCallProfile.videoActive === true) {
            if (this.destCallType !== 'videoOnly') {
              this.destCallType = 'videoOnly';
              changes.push('callType');
            }
          } else {
            if (this.destCallType !== 'inactive') {
              this.destCallType = 'inactive';
              changes.push('callType');
            }
          }
        }

        if (fireEvents === true && changes.length > 0) {
          audio.available = this.remoteCallProfile.audio;
          audio.active = this.remoteCallProfile.audioActive;
          audio.muted = this.isRemoteAudioMuted;
          audio.silent = this.isRemoteAudioSilent;
          video.available = this.remoteCallProfile.video;
          video.active = this.remoteCallProfile.videoActive;
          video.muted = this.isRemoteVideoMuted;
          video.silent = this.isRemoteVideoSilent;

          if (this.updateCause) {
            cause = this.updateCause;
          }

          this.myWebRTC_Event.createRemoteStreamUpdatedEvent(changes, audio, video, this.destCallType, this.callId, cause);
        }
      }
    }
  };

  this.setMediaConstraintsToSendOnlyOffer = function () {
    // Set mediaConstraints to have a sendOnly offer.
    if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version > 43) {
        this.mediaConstraints = {
          'offerToReceiveAudio': false,
          'offerToReceiveVideo': false
        };
      } else {
        this.mediaConstraints = {
          'mandatory': {
            'OfferToReceiveAudio': false,
            'OfferToReceiveVideo': false
          }
        };
      }
    } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'edge') {
      this.mediaConstraints = {
        'offerToReceiveAudio': 0,
        'offerToReceiveVideo': 0
      };
    } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version < 55) {
      this.mediaConstraints = {
        // For createOffer(successCallback, failureCallback, mediaConstraints):
        'mandatory': {
          'OfferToReceiveAudio': false,
          'OfferToReceiveVideo': false
        }
      };
    } else {
      this.mediaConstraints = {
        // For createOffer(mediaConstraints)->Promise:
        'offerToReceiveAudio': false,
        'offerToReceiveVideo': false,
        // For createOffer(successCallback, failureCallback, mediaConstraints):
        'mandatory': {
          'OfferToReceiveAudio': false,
          'OfferToReceiveVideo': false
        }
      };
    } // Same media constraints for audio-only calls.


    this.mediaConstraintsAudioOnly = this.mediaConstraints;
  };
  /*
   * Sets the maximum bitrate to video encoder.
   * @ignore
   * @method applyOutgoingBitrate
   * @param {number|null} bitrate - The maximum bitrate in kbps.
   */


  this.applyOutgoingBitrate = function (bitrate) {
    var _this9 = this;

    logger.debug('applyOutgoingBitrate', this.callId, bitrate);
    var rtpSender = null;

    for (var si = 0; si < this.rtpSenders.video.length; si += 1) {
      if (this.rtpSenders.video[si].track) {
        rtpSender = this.rtpSenders.video[si];
        break;
      }
    } // for


    if (!rtpSender) {
      logger.warn('no such video rtpSender', this.callId);
      return;
    }

    if (typeof rtpSender.getParameters !== 'function' || typeof rtpSender.setParameters !== 'function') {
      logger.warn('no such functions: getParameters/setParameters', this.callId);
      return;
    }

    var params = rtpSender.getParameters();

    if (!Object.prototype.hasOwnProperty.call(params, 'encodings')) {
      params.encodings = [{}];
    } else if (params.encodings.length !== 1) {
      // For simulcast (.i.e. 3 encodings) this is normal.
      // We are waiting for a configureEncodings request.
      logger.debug('encodings cannot be changed', this.callId, params.encodings.length);
      return;
    }

    if (bitrate !== null && typeof bitrate === 'number') {
      if (bitrate < 50) {
        bitrate = 50;
      }

      var bitsPerSeconds = bitrate * 1000;

      if (params.encodings[0].maxBitrate === bitsPerSeconds) {
        // Already applied.
        return;
      }

      params.encodings[0].maxBitrate = bitsPerSeconds;
    } else {
      if (!Object.prototype.hasOwnProperty.call(params.encodings[0], 'maxBitrate')) {
        // Already applied.
        return;
      }

      delete params.encodings[0].maxBitrate;
    }

    rtpSender.setParameters(params)["catch"](function (err) {
      logger.error('applyOutgoingBitrate - setParameters', _this9.callId, err);
    });
  };
  /*
   * Configures simulcast encodings. Handles command from janusConnector.
   * Command 'changeMaxBitrate' means the maxBitrate changed and encodings
   * need to be activated or deactivated, depending on the case.
   * Command 'disableEncoding' means the highest active encoding need to be
   * deactivated.
   * Note that the lowest encoding (low) must always be active, meaning
   * that only the high encoding and the medium encoding can be deactivated.
   * @ignore
   * @method configureSimulcastEncodings
   * @param {string} command - Either 'changeMaxBitrate' or 'disableEncoding',
   * @param {object} options
   * @param {number} options.maxBitrate - In kbps.
   */


  this.configureSimulcastEncodings = function (command) {
    var _this10 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    logger.debug('configureSimulcastEncodings', this.callId, command, options.maxBitrate);

    if (this.simulcast !== 'RID') {
      // Current simulcast mode cannot be configured.
      return;
    } // Look for the video RTP sender.


    var rtpSender = null;

    for (var si = 0; si < this.rtpSenders.video.length; si += 1) {
      if (this.rtpSenders.video[si].track) {
        rtpSender = this.rtpSenders.video[si];
        break;
      }
    } // for


    if (!rtpSender) {
      logger.warn('no such video rtpSender', this.callId);
      return;
    }

    if (typeof rtpSender.getParameters !== 'function' || typeof rtpSender.setParameters !== 'function') {
      logger.warn('no such functions: getParameters/setParameters', this.callId);
      return;
    } // Simulcasting means exactly 3 encodings, already configured.


    var params = rtpSender.getParameters();

    if (!Object.prototype.hasOwnProperty.call(params, 'encodings')) {
      logger.warn('no encodings configured', this.callId);
      return;
    }

    if (params.encodings.length !== 3) {
      logger.warn('wrong encodings', this.callId, params.encodings.length);
      return;
    } // Match encodings.


    var highEnc = null;
    var mediumEnc = null;
    var lowEnc = null;

    for (var idx = params.encodings.length; --idx >= 0;) {
      var enc = params.encodings[idx];

      if (!highEnc && enc.rid === 'h') {
        highEnc = enc;
      } else if (!mediumEnc && enc.rid === 'm') {
        mediumEnc = enc;
      } else if (!lowEnc && enc.rid === 'l') {
        lowEnc = enc;
      }
    } // for


    if (!highEnc || !Object.prototype.hasOwnProperty.call(highEnc, 'maxBitrate') || !mediumEnc || !Object.prototype.hasOwnProperty.call(mediumEnc, 'maxBitrate') || !lowEnc || !Object.prototype.hasOwnProperty.call(lowEnc, 'maxBitrate')) {
      logger.warn('cannot find h/m/l encodings', this.callId);
      return;
    } // Evaluate current bitrate.
    // Test whether the high encoding and the medium encoding are active.


    var applyChanges = false;
    var currBitrate = Math.floor(lowEnc.maxBitrate / 1000);
    var highActive = false;
    var mediumActive = false;

    if (highEnc.active && highEnc.maxBitrate > 1) {
      currBitrate += Math.floor(highEnc.maxBitrate / 1000);
      highActive = true;
    }

    if (mediumEnc.active && mediumEnc.maxBitrate > 1) {
      currBitrate += Math.floor(mediumEnc.maxBitrate / 1000);
      mediumActive = true;
    }

    logger.debug('currentStatus', currBitrate, highActive, mediumActive);

    if (command === 'changeMaxBitrate') {
      if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(options, 'maxBitrate', 'number')) {
        return;
      }

      var maxBitrate = options.maxBitrate;

      if (currBitrate <= maxBitrate) {
        // Check whether we can activate medium and/or high encodings.
        if (!mediumActive) {
          if (currBitrate + this.callConfiguration.simulcast.encodings.medium.maxBitrate <= maxBitrate) {
            // Activate medium encoding.
            if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome') {
              mediumEnc.active = true;
            } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
              mediumEnc.maxBitrate = this.callConfiguration.simulcast.encodings.medium.maxBitrate * 1000;
            }

            this.callConfiguration.simulcast.encodings.medium.active = true;
            mediumActive = true;
            currBitrate += this.callConfiguration.simulcast.encodings.medium.maxBitrate;
            applyChanges = true;
          }
        }

        if (!highActive) {
          if (currBitrate + this.callConfiguration.simulcast.encodings.high.maxBitrate <= maxBitrate) {
            // Activate high encoding.
            if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome') {
              highEnc.active = true;
            } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
              highEnc.maxBitrate = this.callConfiguration.simulcast.encodings.high.maxBitrate * 1000;
            }

            this.callConfiguration.simulcast.encodings.high.active = true;
            highActive = true;
            currBitrate += this.callConfiguration.simulcast.encodings.high.maxBitrate;
            applyChanges = true;
          }
        }
      } else {
        // Check whether we can deactivate high and/or medium encodings.
        if (highActive) {
          // Deactivate high encoding.
          highActive = false;
          this.callConfiguration.simulcast.encodings.high.active = false;
          currBitrate -= Math.floor(highEnc.maxBitrate / 1000);

          if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome') {
            highEnc.active = false;
          } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
            highEnc.maxBitrate = 1;
          }

          applyChanges = true;
        }

        if (currBitrate > maxBitrate && mediumActive) {
          // Deactivate medium encoding.
          mediumActive = false;
          this.callConfiguration.simulcast.encodings.medium.active = false;
          currBitrate -= Math.floor(mediumEnc.maxBitrate / 1000);

          if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome') {
            mediumEnc.active = false;
          } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
            mediumEnc.maxBitrate = 1;
          }

          applyChanges = true;
        }
      }
    } else if (command === 'disableEncoding') {
      if (highActive) {
        // Deactivate high encoding.
        highActive = false;
        this.callConfiguration.simulcast.encodings.high.active = false;
        currBitrate -= Math.floor(highEnc.maxBitrate / 1000);

        if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome') {
          highEnc.active = false;
        } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
          highEnc.maxBitrate = 1;
        }

        applyChanges = true;
      } else if (mediumActive) {
        // Deactivate medium encoding.
        mediumActive = false;
        this.callConfiguration.simulcast.encodings.medium.active = false;
        currBitrate -= Math.floor(mediumEnc.maxBitrate / 1000);

        if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome') {
          mediumEnc.active = false;
        } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox') {
          mediumEnc.maxBitrate = 1;
        }

        applyChanges = true;
      }
    }

    logger.debug('applyChanges', currBitrate, highActive, mediumActive, applyChanges);

    if (!applyChanges) {
      // Nothing to do.
      return;
    }

    rtpSender.setParameters(params)["catch"](function (err) {
      logger.error('configureEncodings - setParameters', _this10.callId, err);
    }); // Notify janusConnector about the encodings changes.

    this.myWebRTC_Stack.sendInfo('configureEncodings', {
      pubSub: webRTCClient.MCUClient.pubConnector,
      clientId: webRTCClient.clientId,
      roomId: this.sessionMCU.roomName,
      callId: this.callId,
      instanceId: this.instanceId,
      hint: 'simulcast',
      encodings: this.callConfiguration.simulcast.encodings
    });
  };
};



/***/ }),

/***/ "./src/Core/WebRTC_Client.js":
/*!***********************************!*\
  !*** ./src/Core/WebRTC_Client.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebRTC_Client": () => (/* binding */ WebRTC_Client)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
/* harmony import */ var _WebRTC_Stack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WebRTC_Stack */ "./src/Core/WebRTC_Stack.js");
/* harmony import */ var _SDPManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SDPManager */ "./src/Core/SDPManager.js");
/* harmony import */ var _ApiCCMCUClient__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ApiCCMCUClient */ "./src/Core/ApiCCMCUClient.js");
/* harmony import */ var _CallControl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./CallControl */ "./src/Core/CallControl.js");
/* harmony import */ var _WebRTC_Call__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WebRTC_Call */ "./src/Core/WebRTC_Call.js");
/* harmony import */ var _Checksum64__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Checksum64 */ "./src/Core/Checksum64.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/* globals apiCC, webkitMediaStream, alert*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('WebRTC_Client');

 //TEMP_APIRTCV4 a voir
//Voir doublon this.myWebRTC_Event et myWebRTC_Event

var myWebRTC_Event = apiCC.myWebRTC_Event;






var ADDING_USER_MEDIA_TIMEOUT = 40000;
var UPDATE_MEDIA_TYPE_TIMEOUT = 20000;
var DATA_TRANSFER_BEGIN_TIMEOUT = 20000;
var EARLY_DISTANT_CALL_DESCRIPTOR_DELAY = 30000;
/*
 * This is the description for my class WebRTC_Client.
 *
 * @module webRTC_Client
 */

var WebRTC_Client = function WebRTC_Client(session) {
  this.localStream = null;
  this.remoteStream = null;
  this.channelReady = false;
  this.socket = session.channel.socket;
  this.clientId = session.apiCCId;
  this.compositeClientId = session.apiCCId + '@' + session.apiCCSessionId; // the format is defined in janusConnector

  this.apiKey = session.apiKey;
  this.isVideoMuted = false;
  this.isAudioMuted = false;
  this.receiptHooks = {};
  this.callControlTable = []; // holds requests from the application, like what should be published and/or subscribed to.

  this.userMediaTable = [];
  this.callsTable = [];
  this.callsRetriesTable = {}; //This table is used to manage calls restries datas
  //Parameters are :
  //- maxCallsRetriesDurationTimeOutId
  //- allowedStatus
  //- restartCallTimeOutId

  this.restartCallDelay = 1000; //in ms - internal delay - initial delay - This delay is doubled on each retry

  this.maxCallsRetriesDuration = 150000; //in ms - internal delay

  this.accessToLocalMedia = false;
  this.unidirectionelCallOnly = false;
  this.NtoNConf = false;
  this.autoAnswer = false;
  this.RTPMedia = false;
  this.logoAdded = false;
  this.preferOpusCodec = false;
  this.preferVP9Codec = false;

  if (typeof apiRTC_React !== 'undefined' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.osName === "iOS") {
    logger.log("React and iOS : Setting H264 as preferred codec");
    this.preferH264Codec = true;
  } else {
    this.preferH264Codec = false;
  }

  this.preferSendingH264Codec = false; //Modif to validate

  this.setStereo = false;
  this.allowedAudioCodecs = '';
  this.allowedVideoCodecs = '';
  this.mediaRoutingModeEnum = {
    hostOnly: 1,
    stun: 2,
    stunOnly: 3,
    turn: 4,
    turnOnly: 5
  };
  this.mediaRoutingMode = this.mediaRoutingModeEnum.turn; //this.myWebRTC_Event = new WebRTC_Event();
  //TEMP_APIRTCV4 a voir
  //Voir doublon this.myWebRTC_Event et myWebRTC_Event

  this.myWebRTC_Event = apiCC.myWebRTC_Event;
  this.getUserMediaOnGoing = false;
  this.userAcceptOnIncomingCall = false;
  this.userAcceptOnIncomingCallBeforeGetUserMedia = false;
  this.userAcceptOnIncomingDataCall = false;
  this.userAcceptOnIncomingScreenSharingCall = false;
  this.maxWidthRemoteVideo = 0;
  this.maxHeightRemoteVideo = 0;
  this.nickname = session.nickname;
  this.allowMultipleCalls = false;
  this.mySDPManager = new _SDPManager__WEBPACK_IMPORTED_MODULE_4__.SDPManager();
  this.MCUClient = new _ApiCCMCUClient__WEBPACK_IMPORTED_MODULE_5__.ApiCCMCUClient(this, this.clientId); //Client MCU

  this.audioSourceId = null;
  this.audioOutputId = null;
  this.videoSourceId = null;
  this.facingMode = null;
  this.apiRTCExtensionInstalled = false; //extension Chrome screenSharing

  this.trickleIce = true;
  this.waitingShareScreenCallId = 0; //used to keep screenSharing callId during extension installation

  this.waitingShareScreenDestNumber = 0; //used to keep screenSharing dest number during extension installation

  this.waitingCaptureSourceType = null; //used to keep screenSharing CaptureSourceType during extension installation

  this.qosEnable = false;
  this.qosInterval = 5000;
  this.csmEnable = false;
  this.qualityScoreEnable = false;
  this.qualityScoreIntervalMs = 5000;
  this.csmIntervalMs = 5000;
  this.recordedCall = false; //used to force call recording through Kurento

  this.audioBandwidth = null;
  this.videoBandwidth = null;
  this.videoRemoteBandwidth = null;
  this.videoBandwidthSettings = {
    /* overallIncoming, overallOutgoing, perCallIncoming, perCallOutgoing */
  };
  this.dataBandwidth = null;
  this.pc_config = '';
  this.clientIncomingCandidatesQueue = []; //Candidate Storage when call doesn't exist yet // candidates are stored with callId

  this.cleanStoredCallCandidateTimer = 60000; //Timer to keep candidate for a call

  this.initializeGumConfig = function () {
    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Edge" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 15) {
      this.gum_config = {
        'audio': true,
        'video': true
      };
    } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 49 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50) {
      this.gum_config = {
        'audio': {
          'mandatory': {},
          'optional': []
        },
        'video': {
          'mandatory': {},
          'optional': []
        }
      };
    } else {
      this.gum_config = {
        'audio': {},
        'video': {}
      };
    }
  };

  this.initializeGumConfig();

  this.setGumConfigWithDevicePresent = function () {
    if (apiCC.mediaDeviceMgr.audioDevicePresent === false) {
      this.gum_config.audio = false;
    }

    if (apiCC.mediaDeviceMgr.videoDevicePresent === false) {
      this.gum_config.video = false;
    }

    if (apiCC.mediaDeviceMgr.audioDevicePresent === false && apiCC.mediaDeviceMgr.videoDevicePresent === false) {
      this.unidirectionelCallOnly = true;
    }

    logger.log("this.gum_config:", this.gum_config);
  };

  this.userMediaErrorDetected = false;
  this.lastUsedUserMediaConstraint = null;
  this.mediaTypeForIncomingCall = "VIDEO"; //value can be : VIDEO, AUDIO, VIDEOONLY, NONE

  this.mediaTypeForOutgoingCall = "VIDEO"; //value can be : VIDEO, AUDIO, VIDEOONLY, NONE

  this.allowAsymetricMediaCalls = false;
  this.receiveMediaDeactivated = false; //if set client will never receive any media (setSendOnly on SDP)

  this.configTurnServer = null; //Turn server setted by API
  //Redefining WebRTC fct for iOS/Cordova

  apiCC.myWebRTC_Adapter.adaptForIoSCordova(); //default this.pc_config configuration

  this.pc_config = {
    "iceServers": [{
      'urls': ['turns:mp1.apizee.com:443?transport=udp', 'turns:mp1.apizee.com:443?transport=tcp', 'turn:mp1.apizee.com:443?transport=udp', 'turn:mp1.apizee.com:443?transport=tcp', 'turns:mp2.apizee.com:443?transport=udp', 'turns:mp2.apizee.com:443?transport=tcp', 'turn:mp2.apizee.com:443?transport=udp', 'turn:mp2.apizee.com:443?transport=tcp'],
      'credential': 'password',
      'username': 'anonymous'
    }]
  };

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 53) {
    logger.log('createPeerConnection FIREFOX');
    logger.log('webrtcDetectedVersion : ' + apiCC.myWebRTC_Adapter.webrtcDetectedVersion);

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 38) {
      // .urls is not supported in FF < 38.
      // create RTCIceServers with a single url.
      this.pc_config = {
        "iceServers": [{
          "url": "stun:mp1.apizee.com:443",
          "credential": "password",
          'username': 'anonymous'
        }, {
          "url": "turn:mp1.apizee.com:443",
          "credential": "password",
          'username': 'anonymous'
        }]
      };
    } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version >= 42) {
      this.pc_config = {
        "iceServers": [{
          'urls': ['turn:mp1.apizee.com:443?transport=udp', 'turn:mp1.apizee.com:443?transport=tcp'],
          'credential': 'password',
          'username': 'anonymous'
        }]
      };
    } else {
      this.pc_config = {
        "iceServers": [{
          'urls': 'turn:mp1.apizee.com:443?transport=tcp',
          'credential': 'password',
          'username': 'anonymous'
        }, {
          'url': 'turn:mp1.apizee.com:443?transport=tcp',
          'credential': 'password',
          'username': 'anonymous'
        }]
      };
    }
  } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 11) {
    logger.log("Browser is :" + _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser + " - using Plugin");
    this.pc_config = {
      "iceServers": [{
        "url": "stun:mp1.apizee.com:443",
        "credential": "password",
        'username': 'anonymous'
      }, {
        "url": "turn:mp1.apizee.com:443",
        "credential": "password",
        'username': 'anonymous'
      }]
    };
  } else if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Edge' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 45) {
    logger.log('Browser is Edge - removing Turns config');
    this.pc_config = {
      "iceServers": [{
        'urls': ['turn:mp1.apizee.com:443?transport=udp', 'turn:mp1.apizee.com:443?transport=tcp', 'turn:mp2.apizee.com:443?transport=udp', 'turn:mp2.apizee.com:443?transport=tcp'],
        'credential': 'password',
        'username': 'anonymous'
      }]
    };
  } else {
    logger.log('default this.pc_config configuration');
  }

  this.pc_constraints = {
    "optional": []
  }; //this.pc_constraints = {"optional": [{"DtlsSrtpKeyAgreement": false}]};

  if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'edge') {
    logger.debug('not data channel capable');
  } else if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'safari') {
    if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 11) {
      this.dataChannelCapable = true;
    } else {
      logger.debug('not data channel capable');
    }
  } else {
    this.dataChannelCapable = true;
  } // Whether RTCRtpSender#setParameters is available for outgoing bitrate control.


  if (_Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'chrome' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 68 || _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'firefox' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 64 || _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.type === 'safari' && _Utils__WEBPACK_IMPORTED_MODULE_2__.browserDetails.version >= 12) {
    // RTCRtpSender#setParameters is available.
    logger.debug('RTCRtpSender#setParameters is available');
    this.rtpSenderSetParamatersCapable = true;
  } else {
    // RTCRtpSender#setParameters is not available.
    // As a fallback, SDP update with modified AS/TIAS will be used.
    logger.debug('RTCRtpSender#setParameters is NOT available');
    this.rtpSenderSetParamatersCapable = false;
  }

  this.setClientTurnServer = function (turnServerAddress) {
    logger.info("setClientTurnServer :", turnServerAddress);
    var stringified_pc_config = JSON.stringify(this.pc_config);
    stringified_pc_config = stringified_pc_config.replace(/mp1.apizee.com/g, turnServerAddress);
    this.pc_config = JSON.parse(stringified_pc_config);
  };

  this.activateScreenSharing = function (extensionId) {
    apiCC.activateScreenSharing(extensionId);
  };

  this.setGetUserMediaConfig = function (conf) {
    logger.log('setGetUserMediaConfig :', conf);

    if (navigator.mediaDevices !== null && navigator.mediaDevices !== undefined) {
      if (navigator.mediaDevices.getSupportedConstraints !== null && navigator.mediaDevices.getSupportedConstraints !== undefined) {
        var supports = navigator.mediaDevices.getSupportedConstraints();
        logger.log('Supported Constraints :', supports);
      }
    }

    if (conf.video !== undefined) {
      if (conf.video.height !== undefined || conf.video.width !== undefined) {
        if (conf.optional !== undefined) {
          //Modification of constraints to support new format and avoid this issue :
          //Malformed constraints: Cannot use both optional/mandatory and specific or advanced constraints
          logger.warn('contraints with both optional/mandatory and specific or advanced constraints usage : this may failed depending of browsers');
          logger.log('setGetUserMediaConfig : contraints modification to avoid both optional/mandatory and specific or advanced constraints usage');

          if (conf.optional.sourceId !== undefined) {
            logger.log('sourceId contraints modification to deviceId');

            if (conf.video.deviceId === undefined) {
              conf.video.deviceId = {};
            }

            conf.video.deviceId.ideal = conf.optional.sourceId;
          }

          delete conf.optional;
        }
      }
    }

    logger.log('this.gum_config :', this.gum_config);
    this.gum_config = conf;
  };

  this.getUserMedia = function () {
    try {
      this.gum_config = apiCC.setAudioSourceIdInConstraint(this.audioSourceId, this.gum_config);
      this.gum_config = apiCC.setVideoSourceIdInConstraint(this.videoSourceId, this.gum_config);
      this.lastUsedUserMediaConstraint = this.gum_config;

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version > 8.0) {
        apiCC.getUserMediaWithCB(this.gum_config, this.callback(this, 'onUserMediaSuccess'), this.callback(this, 'onUserMediaError'));
      } else {
        apiCC.getUserMedia(this.gum_config).then(this.callback(this, 'onUserMediaSuccess'))["catch"](this.callback(this, 'onUserMediaError'));
      }
    } catch (e) {
      logger.error('getUserMedia() failed. Is this a WebRTC capable browser?');
      logger.log('getUserMedia failed with exception: ' + e.message);
    }
  };

  this.onUserMediaSuccess = function (stream) {
    logger.info('onUserMediaSuccess : User has granted access to local media.');
    this.accessToLocalMedia = true;
    var audioIsAvailable = false,
        audioDeviceLabel = "Unknown",
        videoIsAvailable = false,
        videoDeviceLabel = "Unknown";
    this.localStream = stream;

    if (stream.getAudioTracks().length > 0) {
      audioIsAvailable = true;

      if (stream.getAudioTracks()[0].label) {
        audioDeviceLabel = stream.getAudioTracks()[0].label;
      }

      logger.log('Using audio device: ' + audioDeviceLabel);
    }

    if (stream.getVideoTracks().length > 0) {
      videoIsAvailable = true;

      if (stream.getVideoTracks()[0].label) {
        videoDeviceLabel = stream.getVideoTracks()[0].label;
      }

      logger.log('Using video device: ' + videoDeviceLabel);
    }

    this.myWebRTC_Event.createUserMediaSuccessEvent(false, audioIsAvailable, audioDeviceLabel, videoIsAvailable, videoDeviceLabel, 'media', null, stream, null, false);
  };

  this.onUserMediaError = function (error) {
    logger.info('onUserMediaError : Failed to get access to local media. Error : ', error);
    logger.error(error);
    this.accessToLocalMedia = false;

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.applicationType !== 'electron' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version > 47) {
      logger.log("browser_version > 47");

      if (window.location.protocol !== "https:") {
        logger.error("HTTPS is now mandatory to use getUserMedia()");
      }
    }

    this.myWebRTC_Event.createUserMediaErrorEvent(false, 'media', error, null, null, null, this.gum_config);
    error = null;

    if (apiCC.session.tryAudioCallAfterUserMediaError === true) {
      logger.log("this.lastUsedUserMediaConstraint :", this.lastUsedUserMediaConstraint);
      logger.log("this.lastUsedUserMediaConstraint.video :", this.lastUsedUserMediaConstraint.video);

      if (this.lastUsedUserMediaConstraint.video !== false) {
        logger.log("this.lastUsedUserMediaConstraint.audio :", this.lastUsedUserMediaConstraint.audio);
        logger.log("UserMediaError, Trying to getUserMedia with audioOnly");
        this.videoSourceId = null;
        this.gum_config.video = false;
        this.getUserMedia();
      } else {
        logger.log("onUserMediaError without video");
      }
    } else {
      logger.log("try AudioCall after UserMediaError is not activated");
    }
  };
  /*
   * Evaluates call profile from SDP offer/answer.
   *
   * @method evalCallProfileWithSdp
   *
   * @param {string} sdp - SDP.
   * @param {string} type - Type of SDP description. Either local or remote.
   * @param {string} angle - Either send (for sending local stream) or receive (for receiving remote stream).
   *
   * @return {object} call profile.
   */


  this.evalCallProfileWithSdp = function (sdp, type, angle) {
    return this.evalCallProfileWithSdpGuideline(this.mySDPManager.createGuideline(sdp), sdp, type, angle);
  };
  /*
   * Evaluates call profile from SDP offer/answer guideline.
   *
   * @method evalCallProfileWithSdpGuideline
   *
   * @param {object} guideline - SDP guideline.
   * @param {string} sdp - SDP.
   * @param {string} type - Type of SDP description. Either 'local' or 'remote'.
   * @param {string} angle - Either 'send' (for sending local stream) or 'receive' (for receiving remote stream).
   *
   * @return {object} Call profile.
   *         {boolean} .audio - Whether an audio mline exists.
   *         {boolean} .audioActive - Whether an audio mline exists and its direction is not inactive.
   *         {boolean} .video - Whether a video mline exists.
   *         {boolean} .videoActive - Whether a video mline exists and its direction is not inactive.
   */


  this.evalCallProfileWithSdpGuideline = function (guideline, sdp, type, angle) {
    var ret = {};

    if (guideline.hasOwnProperty('audio')) {
      ret.audio = true;

      if (type === 'local' && angle === 'send') {
        ret.audioActive = guideline.audio.direction === 'sendrecv' || guideline.audio.direction === 'sendonly';
      } else if (type === 'local' && angle === 'receive') {
        ret.audioActive = guideline.audio.direction === 'sendrecv' || guideline.audio.direction === 'recvonly';
      } else if (type === 'remote' && angle === 'send') {
        ret.audioActive = guideline.audio.direction === 'sendrecv' || guideline.audio.direction === 'recvonly';
      } else if (type === 'remote' && angle === 'receive') {
        ret.audioActive = guideline.audio.direction === 'sendrecv' || guideline.audio.direction === 'sendonly';
      } else {
        ret.audioActive = false;
      }
    } else {
      ret.audio = false;
      ret.audioActive = false;
    }

    if (guideline.hasOwnProperty('video')) {
      ret.video = true;

      if (type === 'local' && angle === 'send') {
        ret.videoActive = guideline.video.direction === 'sendrecv' || guideline.video.direction === 'sendonly';
      } else if (type === 'local' && angle === 'receive') {
        ret.videoActive = guideline.video.direction === 'sendrecv' || guideline.video.direction === 'recvonly';
      } else if (type === 'remote' && angle === 'send') {
        ret.videoActive = guideline.video.direction === 'sendrecv' || guideline.video.direction === 'recvonly';
      } else if (type === 'remote' && angle === 'receive') {
        ret.videoActive = guideline.video.direction === 'sendrecv' || guideline.video.direction === 'sendonly';
      } else {
        ret.videoActive = false;
      }
    } else {
      ret.video = false;
      ret.videoActive = false;
    }

    return ret;
  };

  this.checkDestCallTypeWithSDP = function (sdp, call) {
    logger.debug('checkDestCallTypeWithSDP');
    var guideline = this.mySDPManager.createGuideline(sdp),
        remoteSendAudio = false,
        remoteSendVideo = false;

    if (guideline.audio && (guideline.audio.direction === 'sendrecv' || guideline.audio.direction === 'sendonly')) {
      remoteSendAudio = true;
    }

    if (guideline.video && (guideline.video.direction === 'sendrecv' || guideline.video.direction === 'sendonly')) {
      remoteSendVideo = true;
    }

    if (remoteSendAudio === true) {
      if (remoteSendVideo === true) {
        call.destCallType = "media";
      } else {
        call.destCallType = "audio";
      }
    } else {
      if (remoteSendVideo === true) {
        call.destCallType = "videoOnly";
      } else {
        call.destCallType = "inactive";
      }
    }

    logger.debug('call.destCallType: ' + call.destCallType); // When we are processing an unidirectional incoming call.

    if (call.callee === true && (!guideline.audio || guideline.audio.direction === 'sendonly') && (!guideline.video || guideline.video.direction === 'sendonly')) {
      call.userMediaAccessRequired = false;
      call.mediaTypeForOutgoingCall = "NONE";
      logger.debug('access to user media not required');
    }
  };
  /*
   * Evaluates video cap during call establishment.
   * @ignore
   * @method evaluateVideoCap
   * @param {WebRTC_Call} call
   * @see {@link WebRTC_Client#processInvite}
   * @see {@link WebRTC_Client#process200OK}
   * @see {@link WebRTC_Client#process200Update}
   * @see {@link WebRTC_Call#onSetLocalDescriptionSuccess}
   */


  this.evaluateVideoCap = function (call) {
    // Evaluate video bandwidth cap.
    delete call.videoCap;

    if (call.belongsToRoom()) {
      // Room call.
      if (call.settingUpType === 'publish' || call.settingUpType === 'shareScreen') {
        if (call.localCallProfile && call.localCallProfile.video && call.localCallProfile.videoActive) {
          this.evalOutgoingVideoBandwithCap(call);
        }
      }
    } else {
      // 1-to-1 call.
      if ((this.rtpSenderSetParamatersCapable || !call.callee) && call.localCallProfile && call.localCallProfile.video && call.localCallProfile.videoActive) {
        this.evalOutgoingVideoBandwithCap(call);
      }
    }
  };

  this.processInvite = function (msg) {
    logger.info('processInvite() - invite received from :' + msg.callerId);
    var callNumber = 0,
        call = null,
        userMedia = null,
        userMediaStream = null,
        localUserMediaStreamId = null,
        //videoPresent = true,
    //videoMediaPart = null,
    i,
        callAlreadyExist = false,
        destUserInfo = null,
        destUserInfoJson = null,
        key = null,
        data = {}; // Selecting action according to message data.

    if (msg.data !== undefined && msg.data.type === 'publish' && msg.data.mesh !== undefined) {
      // Received invite publish mesh: this means we subscribed to remote stream and
      // the remote stream comes from publisher directly.
      logger.info('received invite publish mesh; mesh: ' + JSON.stringify(msg.data.mesh));
      call = this.findCallWithCallIdAndInstanceId(msg.data.mesh.callerCallId, msg.data.instanceId);

      if (call === undefined || call === null) {
        logger.error('cannot find call; callId: ' + msg.data.mesh.callerCallId);
        return;
      } // Forcing no userMediaAccess as it correspond to a "subscribe" call.


      call.userMediaAccessRequired = false;
      call.data.mesh = msg.data.mesh; // Clear setup timeout.

      if (call.setupTimeoutId) {
        clearTimeout(call.setupTimeoutId);
        delete call.setupTimeoutId;
      }

      callAlreadyExist = true;
    } else if (msg.data !== undefined && msg.data.type === 'subscribe' && msg.data.mesh !== undefined) {
      // Received invite subscribe mesh: this means we must publish local stream
      // to subscriber directly.
      logger.debug('received invite subscribe mesh; mesh: ', msg.data.mesh);
      userMedia = this.findUserMediaById(msg.data.mesh.calleeCallId);

      if (userMedia !== null) {
        // Add early distant call descriptor. That because the distantCallEstablished
        // message are triggered by the late call selected candidate.
        this.MCUClient.distantCalls.push({
          early: true,
          roomId: msg.roomId,
          clientId: msg.data.mesh.callerId,
          callId: msg.data.mesh.callerCallId,
          callMode: 'mesh',
          callDirection: 'recvonly',
          callFeed: {
            clientId: msg.data.mesh.calleeId,
            callId: msg.data.mesh.calleeCallId
          }
        });
        setTimeout(function (roomId, clientId, callId) {
          logger.debug('early distant call descriptor timeout');

          for (var idx = this.MCUClient.distantCalls.length; --idx >= 0;) {
            if (this.MCUClient.distantCalls[idx].early && this.MCUClient.distantCalls[idx].roomId === roomId && this.MCUClient.distantCalls[idx].clientId === clientId && this.MCUClient.distantCalls[idx].callId === callId) {
              logger.debug('remove early distant call descriptor: timeout');
              this.MCUClient.distantCalls.splice(idx, 1);
              break;
            }
          }
        }.bind(this, msg.roomId, msg.data.callerId, msg.data.callerCallId), EARLY_DISTANT_CALL_DESCRIPTOR_DELAY);

        if (userMedia.callType === 'screenSharing' || userMedia.callType === 'screenSharingWithAudio') {
          data.type = 'publish';
          data.mesh = msg.data.mesh;
          data.instanceId = msg.data.instanceId;
          this.MCUClient.publishScreen(msg.roomId, data, null, userMedia.captureSourceType);
        } else {
          var callConfiguration = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.assignObject)({}, userMedia.callConfiguration);

          if (msg.data.mediaType === 'AUDIOONLY') {
            callConfiguration.audioOnly = true;
          } else if (msg.data.mediaType === 'VIDEOONLY') {
            callConfiguration.videoOnly = true;
          } // Update callConfiguration.muted to match userMediaStream audio/video mute states.


          userMediaStream = apiCC.getUserMediaStream(callConfiguration.userMediaStreamId);

          if (userMediaStream) {
            if (userMediaStream.audioMuted && userMediaStream.videoMuted) {
              callConfiguration.muted = 'VIDEO';
            } else if (userMediaStream.audioMuted) {
              callConfiguration.muted = 'AUDIOONLY';
            } else if (userMediaStream.videoMuted) {
              callConfiguration.muted = 'VIDEOONLY';
            } else {
              delete callConfiguration.muted;
            }
          }

          delete callConfiguration.distributedBroadcastEnabled;
          delete callConfiguration.simulcast;
          data.type = 'publish';
          data.mesh = msg.data.mesh;
          data.instanceId = msg.data.instanceId;
          this.MCUClient.publish(msg.roomId, null, null, callConfiguration, data, null);
        }
      } else {
        // media not found: sending bye.
        logger.debug('media not found: sending bye : Call_not_found');
        var myWebRTC_Stack = new _WebRTC_Stack__WEBPACK_IMPORTED_MODULE_3__.WebRTC_Stack(apiCC.session.channel.socket);
        myWebRTC_Stack.sendBye(msg.callId, msg.calleeId, msg.roomId, msg.callerId, 'Call_not_found', msg.data);
      }

      return;
    } else if (msg.data !== undefined && msg.data.type === 'publish' && msg.data.mode === 'passive') {
      // Received invite publish passive: this means we subscribed to remote stream and
      // the remote stream comes from SFU/MCU.
      // When dealing with passive publish, the call already exists.
      call = this.findCallWithCallIdAndRemoteIdAndInstanceId(msg.callId, msg.callerId, msg.data.instanceId);

      if (call === undefined || call === null) {
        logger.debug('cannot find call; callId: ' + msg.callId + ', callerId: ' + msg.callerId + ', instanceId: ' + msg.data.instanceId);
        return;
      } // Forcing no userMediaAccess as it correspond to a "subscribe" call.


      call.userMediaAccessRequired = false; // Clear setup timeout.

      if (call.setupTimeoutId) {
        clearTimeout(call.setupTimeoutId);
        delete call.setupTimeoutId;
      }

      callAlreadyExist = true;
    } else {
      // Creating the call.
      call = new _WebRTC_Call__WEBPACK_IMPORTED_MODULE_7__.WebRTC_Call(this);
      call.callId = msg.callId; // CallId is generated by caller

      call.instanceId = msg.data.instanceId; //InstanceId is generated by caller

      call.callerId = msg.callerId;
      call.calleeId = this.clientId;
      call.callee = true;
      call.remoteId = msg.callerId;
    }

    call.dest_roomId = msg.roomId;

    if (call.data !== undefined && callAlreadyExist === true) {
      // In order to keep original call data
      for (key in msg.data) {
        if (msg.data.hasOwnProperty(key)) {
          call.data[key] = msg.data[key];
        }
      }
    } else {
      call.data = msg.data;
    }

    call.data.instanceId = call.instanceId;

    if (msg.data !== undefined) {
      if (msg.data.pubSub === 'sipConnector') {
        //this a call from SIP, deactivating trickleIce
        call.trickleIce = false;
        call.remoteType = 'sip';
      }
    } //Modif TODO Optimisation : rcupration userData en double : dans checkDTLSCompliancy et en dessous


    call.checkDTLSCompliancy();

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Edge') {
      //Checking if remote is on Android & Chrome : in this case set VP8 as prefered codec to answer call
      destUserInfo = apiCC.session.getConnectedUserInfo(msg.callerId, 'userData');
      logger.log("destUserInfo :", destUserInfo);

      if (destUserInfo !== 'User_Not_Found' && destUserInfo !== undefined) {
        destUserInfoJson = JSON.parse(destUserInfo);

        if (destUserInfoJson.browser === 'Chrome' && destUserInfoJson.osName === "Android") {
          logger.log("Browser is Edge and caller is Chrome on Android, setting VP8 as prefered codec for the call");
          call.preferVP8Codec = true;
        }
      }
    }
    /* Retrieving stream id in case for passive publish. */


    if (msg.data !== undefined && msg.data.type === "publish" && msg.data.mode === "passive" && msg.stream !== undefined && msg.stream.id !== undefined) {
      call.streamId = msg.stream.id;
      logger.log('call.streamId: ' + call.streamId);
    }

    callNumber = this.callsTable.length;
    logger.log('processInvite() - Actual call Number is :' + callNumber);

    if (msg.callType === "screenSharing" || msg.callType === "screenSharingWithAudio") {
      //All screenSharing calls are allowed
      call.screenSharing = true;
      call.callType = msg.callType;
    } else if (msg.callType === "data") {//call.establishCall();
    } else {
      if (this.allowMultipleCalls === false) {
        logger.log('processInvite() - Refusing double call checking ...');

        for (i = 0; i < callNumber; i += 1) {
          if (this.callsTable[i].callType !== "screenSharing" && this.callsTable[i].callType !== "screenSharingWithAudio" && this.callsTable[i].callType !== "data") {
            //Refusing double call if first call is not screenSharing or data
            logger.log('processInvite() - Refusing double call');

            if (callAlreadyExist === false) {
              //callNumber = this.callsTable.push(call);
              this.callsTable.push(call);
            } else {
              logger.log('callAlreadyExist in table');
            }

            this.myWebRTC_Event.createCallAttemptEvent(this.clientId, msg.callerId, msg.callerNickname, call.callId);
            this.refuseCall(call.callId, 'User_Busy');
            return;
          }
        }

        logger.log('NOT Refusing double call');
      }
    }

    if (callAlreadyExist === false) {
      callNumber = this.callsTable.push(call);
      logger.log('processInvite() - New call Number is :' + callNumber);
    } else {
      logger.log('callAlreadyExist in table');
      logger.log('processInvite() - call Number is :' + callNumber);
    }

    this.checkDestCallTypeWithSDP(msg.sdpoffer.sdp, call);
    var guideline = this.mySDPManager.createGuideline(msg.sdpoffer.sdp);
    call.setLocalCallProfile(this.evalCallProfileWithSdpGuideline(guideline, msg.sdpoffer.sdp, 'remote', 'send'));
    call.setRemoteCallProfile(this.evalCallProfileWithSdpGuideline(guideline, msg.sdpoffer.sdp, 'remote', 'receive'));

    if (!this.rtpSenderSetParamatersCapable) {
      this.evaluateVideoCap(call);

      if (call.videoCap) {
        guideline.video.bandwidth = call.videoCap;
        msg.sdpoffer.sdp = guideline.generate();
      }
    }

    call.receivedSdpOfferMessage = msg.sdpoffer;

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(msg, 'stream', 'object')) {
      if (msg.stream.audioMuted === true) {
        call.isRemoteAudioMuted = true;
      }

      if (msg.stream.videoMuted === true) {
        call.isRemoteVideoMuted = true;
      }
    }

    if (msg.callType === "data") {
      logger.log("Receiving DATA call");
      call.callType = "data";
      call.dataCall = true;

      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Edge' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 79) {
        logger.warn('Cannot create DataChannel as it is not supported on Edge');
        this.refuseCall(call.callId, 'DataChannel_Not_Supported');
        return;
      } // this sends a 200OK (doAnswer) without requesting the media


      if (!this.userAcceptOnIncomingDataCall) {
        call.onUserMediaSuccessTestUni();
      }

      this.myWebRTC_Event.createIncomingCallEvent(this.clientId, msg.callerId, msg.callerNickname, call.callId, false, callNumber, false, msg.callType, false, call.remoteType, call.destCallType);
    } else if (call.userMediaAccessRequired === false || this.unidirectionelCallOnly || call.screenSharing === true) {
      //Media Stream from caller to callee
      logger.log('call.userMediaAccessRequired :', call.userMediaAccessRequired);
      logger.log('this.unidirectionelCallOnly :', this.unidirectionelCallOnly);
      logger.log('call.screenSharing :', call.screenSharing);

      if (call.screenSharing === true) {
        if (this.userAcceptOnIncomingScreenSharingCall === false) {
          call.onUserMediaSuccessTestUni();
        } else {
          logger.debug('userAcceptOnIncomingScreenSharingCall is activated : need user accept');
        }
      } else {
        if (callAlreadyExist === true) {
          logger.log('processInvite() - callAlreadyExist');
          call.onUserMediaSuccessTestUni();
        } else if (this.userAcceptOnIncomingCall === true || this.userAcceptOnIncomingCallBeforeGetUserMedia === true) {
          //User has already granted access to his media but have to accept or refuse call
          logger.log('processInvite() - Waiting for call accept or refuse from user - 1');
        } else {
          logger.log('processInvite() - userAcceptOnIncomingCall is not activated');
          call.onUserMediaSuccessTestUni();
        }
      } // When subscribeOrder is true, the call must be hidden from upper levels


      if ((msg.data === undefined || msg.data.subscribeOrder !== true) && callAlreadyExist === false) {
        //TODO voir callOnly pass a false dans event
        this.myWebRTC_Event.createIncomingCallEvent(this.clientId, msg.callerId, msg.callerNickname, call.callId, false, callNumber, false, msg.callType, false, call.remoteType, call.destCallType);
      }
    } else {
      if (apiCC.userMediaStreamTable.length > 0) {
        localUserMediaStreamId = apiCC.userMediaStreamTable[0].userMediaStreamId;
      }

      if ((this.accessToLocalMedia === true || localUserMediaStreamId) && this.autoAnswer === true) {
        logger.log('processInvite() :: User has already granted access to local media and AutoAnswer activated : establishing call'); //TODO voir callOnly pass a false dans event

        if (this.userAcceptOnIncomingCall === true || this.userAcceptOnIncomingCallBeforeGetUserMedia === true) {
          //User has already granted access to his media but have to accept or refuse call
          logger.log('processInvite() - Waiting for call accept or refuse from user - 2');
        } else {
          if (localUserMediaStreamId) {
            logger.log('using First available stream on apiRTC');
            userMediaStream = apiCC.getUserMediaStream(localUserMediaStreamId);
            userMediaStream.addCallInfo(call.callId);

            if (call.callConfiguration === undefined || call.callConfiguration === null) {
              call.callConfiguration = {};
            }

            call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
            call.onUserMediaSuccessOnCall(userMediaStream.stream);
          } else {
            call.establishCall();
          }
        }

        if (callAlreadyExist === false) {
          this.myWebRTC_Event.createIncomingCallEvent(this.clientId, msg.callerId, msg.callerNickname, call.callId, true, callNumber, call.audioOnly, msg.callType, false, call.remoteType, call.destCallType);
        }
      } else {
        if (call.audioOnly === true && apiCC.mediaDeviceMgr.audioDevicePresent === false) {
          //incoming audio call but no micro present
          //establising unidirectional call
          logger.log('processInvite() - audio and video media are not transmitted');
          call.onUserMediaSuccessTestUni();
        } else {
          if (this.userAcceptOnIncomingCallBeforeGetUserMedia === true) {
            logger.log('Stand-by :: wait for getUserMediaOnCall && establishCall');
          } else {
            logger.debug("processInvite() - call.getUserMediaOnCall()");
            logger.log('processInvite() - this.autoAnswer :' + this.autoAnswer);
            call.getUserMediaOnCall();
          }
        }

        if (callAlreadyExist === false) {
          this.myWebRTC_Event.createIncomingCallEvent(this.clientId, msg.callerId, msg.callerNickname, call.callId, false, callNumber, call.audioOnly, msg.callType, false, call.remoteType, call.destCallType);
        }
      }
    }
  };

  this.setRemoteDescriptionProcess = function (call, remoteDesc) {
    if (this.preferSendingH264Codec) {
      logger.log("Modification of SDP to set H264 as prefered sending codec");
      remoteDesc.sdp = this.mySDPManager.maybePreferCodec(remoteDesc.sdp, 'video', 'H264');
    }

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 55 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 50 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE' || typeof apiRTC_React !== 'undefined') {
      if (call.pc !== null) {
        call.pc.setRemoteDescription(remoteDesc, call.callback(call, 'onSetRemoteDescriptionSuccess'), call.callback(call, 'onSetRemoteDescriptionFailure'));
      } else {
        logger.debug("setRemoteDescriptionProcess - pc is null");
      }
    } else {
      logger.log("before setRemoteDescription - Promise version");

      if (call.pc !== null) {
        call.pc.setRemoteDescription(remoteDesc).then(call.callback(call, 'onSetRemoteDescriptionSuccess'))["catch"](call.callback(call, 'onSetRemoteDescriptionFailure'));
      } else {
        logger.debug("setRemoteDescriptionProcess - pc is null");
      }
    }
  };

  this.process200OK = function (msg) {
    var call = null,
        guideline,
        remoteDesc = null;

    if (msg.data !== undefined && msg.data.instanceId !== undefined) {
      logger.info('200OK received from callId :' + msg.calleeId + ", intanceId is :" + msg.data.instanceId); //Searching call corresponding to 200OK

      call = this.findCallWithCallIdAndRemoteIdAndInstanceId(msg.callId, msg.calleeId, msg.data.instanceId);
    } else {
      logger.info('200OK received from callId :' + msg.calleeId); //Searching call corresponding to 200OK

      call = this.findCallWithCallIdAndRemoteId(msg.callId, msg.calleeId);
    }

    if (call === null) {
      logger.warn('200OK received but callId and instanceId are not matching, no process');
      this.myWebRTC_Event.createErrorEvent('200OK received but callId is not matching, no process', 'NOT_MATCHING_CALLID_ON_200OK');
      return;
    } else {
      call.calleeId = msg.calleeId;

      if (!msg.sdpanswer || msg.sdpanswer.type === 'no-answer') {
        // Case of recorded 1-to-1 call initially established without sharing media.
        myWebRTC_Event.createCallEstablishedEvent(call.calleeId, call.callType, call.callId, call.destCallType);
        return;
      } //Checking call state to avoid forking issue when 2 device answer to the call


      if (call.message200OKReceived === false) {
        logger.debug('first 200OK for the call');
        call.message200OKReceived = true;
      } else {
        logger.debug('200OK has already been received for this call, leaving process200OK');
        return;
      }

      if (call.data.type !== 'subscribe') {
        this.checkDestCallTypeWithSDP(msg.sdpanswer.sdp, call);
      } //else {
      //DestCallType already set in subscribeToStreams
      //}


      guideline = this.mySDPManager.createGuideline(msg.sdpanswer.sdp);
      call.setLocalCallProfile(this.evalCallProfileWithSdpGuideline(guideline, msg.sdpanswer.sdp, 'remote', 'send'));
      call.setRemoteCallProfile(this.evalCallProfileWithSdpGuideline(guideline, msg.sdpanswer.sdp, 'remote', 'receive'));
      this.evaluateVideoCap(call); // Apply video bandwith cap (if any).

      if (!this.rtpSenderSetParamatersCapable && call.videoCap) {
        guideline.video.bandwidth = call.videoCap;
        msg.sdpanswer.sdp = guideline.generate();
      }

      call.receivedSdpOfferMessage = msg.sdpanswer;
      logger.log("process200OK : before setRemoteDescription");
      remoteDesc = new apiCC.myWebRTC_Adapter.RTCSessionDescription(msg.sdpanswer); //setRemoteDescription

      if (this.videoRemoteBandwidth) {
        logger.log("Modification of SDP to set remote video bandwidth");
        remoteDesc.sdp = this.mySDPManager.setVideoBandwidth(remoteDesc.sdp, this.videoRemoteBandwidth);
      }

      this.setRemoteDescriptionProcess(call, remoteDesc); //            if (call.screenSharing === true) {
      //                call.callType = "screenSharing";
      //            }

      if (msg.data !== null && msg.data !== undefined) {
        if (call.data !== null && call.data !== undefined) {
          call.data = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.mergeJSON)(call.data, msg.data);
        } else {
          call.data = msg.data;
        }
      }
    }
  };

  this.cleanStoredCallCandidate = function (callId, instanceId) {
    logger.debug('cleanStoredCallCandidate from callId :' + callId + ", instanceId is :" + instanceId);

    if (this.clientIncomingCandidatesQueue[callId + '-' + instanceId] !== undefined && this.clientIncomingCandidatesQueue[callId + '-' + instanceId].length !== 0) {
      this.clientIncomingCandidatesQueue[callId + '-' + instanceId].splice(0, this.clientIncomingCandidatesQueue[callId + '-' + instanceId].length);
      delete this.clientIncomingCandidatesQueue[callId + '-' + instanceId];
    } //logger.debug('this.clientIncomingCandidatesQueue :', this.clientIncomingCandidatesQueue);

  };

  this.processCandidate = function (msg) {
    var call = null;
    var instanceId = msg.data && msg.data.instanceId ? msg.data.instanceId : null;
    logger.debug('Candidate received from callId :' + msg.callId + ", instanceId is :" + instanceId);

    if (msg.callerId === this.clientId) {
      //Client is the caller
      if (instanceId) {
        call = this.findCallWithCallIdAndRemoteIdAndInstanceId(msg.callId, msg.calleeId, instanceId);
      } else {
        call = this.findCallWithCallIdAndRemoteId(msg.callId, msg.calleeId);
      }
    } else {
      //Client is the callee
      if (instanceId) {
        call = this.findCallWithCallIdAndRemoteIdAndInstanceId(msg.callId, msg.callerId, instanceId);
      } else {
        call = this.findCallWithCallIdAndRemoteId(msg.callId, msg.callerId);
      }
    }

    logger.trace("msg.label :" + msg.label);
    logger.log("msg.candidate :" + msg.candidate);

    if (call !== null) {
      if (call.started && call.remoteDescriptionSetted) {
        call.processCandidateMsg(msg);
      } else {
        logger.log('Call not started or remoteDescription is not yet setted'); //Call is not ready yet : bufferize candidate

        call.incomingcandidatesQueue.push(msg);
      }
    } else if (instanceId) {
      logger.debug('Call not found, Candidate message is not handled, storing candidate message in client');

      if (this.clientIncomingCandidatesQueue[msg.callId + '-' + instanceId] === null || this.clientIncomingCandidatesQueue[msg.callId + '-' + instanceId] === undefined) {
        this.clientIncomingCandidatesQueue[msg.callId + '-' + instanceId] = [];
        logger.debug('First candidate for this call, starting a timeout before candidate storage cleaning');
        setTimeout(this.cleanStoredCallCandidate.bind(this), this.cleanStoredCallCandidateTimer, msg.callId, instanceId);
      }

      this.clientIncomingCandidatesQueue[msg.callId + '-' + instanceId].push(msg); //logger.debug('this.clientIncomingCandidatesQueue :', this.clientIncomingCandidatesQueue);
    }
  };

  this.processUpdate = function (msg) {
    logger.info('Update message on:' + msg.roomId);
    var call = null,
        remoteDesc = null;

    if (msg.callerId === this.clientId) {
      //Client is the caller
      call = this.findCallWithCallIdAndRemoteIdAndInstanceId(msg.callId, msg.calleeId, msg.data.instanceId);
    } else {
      //Client is the callee
      call = this.findCallWithCallIdAndRemoteIdAndInstanceId(msg.callId, msg.callerId, msg.data.instanceId);
    }

    if (call === null) {
      this.myWebRTC_Event.createErrorEvent('Cannot find call to process Update', 'CALL_NOT_FOUND_ON_UPDATE');
      return;
    }

    if (!msg.hasOwnProperty('sdpoffer') || !msg.sdpoffer.hasOwnProperty('sdp')) {
      // Update without any SDP offer.
      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(msg.data, 'mesh', 'object') && (msg.data.mesh.calleeCompositeUserId ? msg.data.mesh.calleeCompositeUserId === this.compositeClientId : msg.data.mesh.calleeId === this.clientId)) {
        // Mesh update from subscriber.
        logger.debug('mesh update from subscriber');
        var callConfiguration = {};

        if (msg.data.mediaType === 'AUDIOONLY') {
          callConfiguration.audioOnly = true;
        } else if (msg.data.mediaType === 'VIDEOONLY') {
          callConfiguration.videoOnly = true;
        }

        this.updateCallConfigurationOnCall(msg.callId, callConfiguration).then(function () {
          logger.debug('updateCallConfigurationOnCall OK');
        })["catch"](function (err) {
          logger.error('updateCallConfigurationOnCall failed', err);
        });
      } else {
        // Error.
        logger.error('update without SDP offer');
      }

      return;
    } // Updating remoteCallProfile and callType/destCallType.


    call.setRemoteCallProfile(this.evalCallProfileWithSdp(msg.sdpoffer.sdp, 'remote', 'receive'), true); // The updateOngoing timeout prevents from firing remoteStreamRemoved events.

    call.updateOngoingTimeoutId = setTimeout(function () {
      delete call.updateOngoingTimeoutId;
    }, ADDING_USER_MEDIA_TIMEOUT); //Checking destCallType on update message

    this.checkDestCallTypeWithSDP(msg.sdpoffer.sdp, call);
    logger.log("processUpdate : before setRemoteDescription");
    remoteDesc = new apiCC.myWebRTC_Adapter.RTCSessionDescription(msg.sdpoffer);
    this.setRemoteDescriptionProcess(call, remoteDesc);
    call.doUpdateAnswer();
  };

  this.process200Update = function (msg) {
    logger.info('200 Update received from :' + msg.calleeId);
    var call = null,
        guideline,
        remoteDesc = null;

    if (msg.callerId === this.clientId) {
      //Client is the caller
      //Find call with roomId & calleeId
      call = this.findCallWithCallIdAndRemoteIdAndInstanceId(msg.callId, msg.calleeId, msg.data.instanceId);
    } else {
      //Client is the callee
      //Find call with roomId & callerId
      call = this.findCallWithCallIdAndRemoteIdAndInstanceId(msg.callId, msg.callerId, msg.data.instanceId);
    }

    if (call === null) {
      logger.info('Call not found on 200 Update');
      this.myWebRTC_Event.createErrorEvent('Cannot find call to process 200 Update', 'CALL_NOT_FOUND_ON_200UPDATE');
      return;
    }

    call.calleeId = msg.calleeId; //Set calleeId

    /*
            //setLocalDescription
            if ((browser === 'Chrome' && browser_major_version < 55) || (browser === 'Firefox' && browser_major_version < 50) || browser === 'IE') {
                logger.log("process200Update : before setLocalDescription");
                call.pc.setLocalDescription(call.sendedSdpOfferMessage,  call.callback(call, 'onSetLocalDescriptionSuccess'), call.callback(call, 'onSetLocalDescriptionFailure'));
            } else {
                logger.log("process200Update : before setLocalDescription - Promise version");
                call.pc.setLocalDescription(call.sendedSdpOfferMessage)
                .then(call.callback(call, 'onSetLocalDescriptionSuccess'))
                .catch(call.callback(call, 'onSetLocalDescriptionFailure'));
            }
    */

    guideline = this.mySDPManager.createGuideline(msg.sdpanswer.sdp);
    call.setLocalCallProfile(this.evalCallProfileWithSdpGuideline(guideline, msg.sdpanswer.sdp, 'remote', 'send'), true);
    call.setRemoteCallProfile(this.evalCallProfileWithSdpGuideline(guideline, msg.sdpanswer.sdp, 'remote', 'receive'), true);
    this.evaluateVideoCap(call); // Apply video bandwith cap (if any).

    if (!this.rtpSenderSetParamatersCapable && call.videoCap) {
      guideline.video.bandwidth = call.videoCap;
      msg.sdpanswer.sdp = guideline.generate();
    }

    logger.log("process200Update : before setRemoteDescription");
    remoteDesc = new apiCC.myWebRTC_Adapter.RTCSessionDescription(msg.sdpanswer); //setRemoteDescription

    if (this.videoBandwidth) {
      logger.log("Modification of SDP to set remote video bandwidth");
      remoteDesc.sdp = this.mySDPManager.setVideoBandwidth(remoteDesc.sdp, this.videoBandwidth);
    }

    this.setRemoteDescriptionProcess(call, remoteDesc);
    logger.log("msg.sdpanswer.sdp :", msg.sdpanswer.sdp);

    if (call.addingUserMedia === true) {
      call.addingUserMedia = false;
    }

    if (call.updateUserMedia === true) {
      call.updateUserMedia = false;
    }

    if (call.updateCause) {
      call.updateCause = null;
    }
  };
  /*
   * @method processSlowLink
   * @param {string} callId
   * @param {object} options
   * @param {string} options.advice
   */


  this.processSlowLink = function (callId, options) {
    var idx = this.callsTable.length,
        call = null;

    while (--idx >= 0) {
      if (this.callsTable[idx].callId === callId) {
        call = this.callsTable[idx];
        break;
      }
    }

    if (call !== null) {
      var advice = null;

      if (options && options.advice) {
        advice = options.advice;
      }

      this.myWebRTC_Event.createSlowLinkEvent(call.callId, advice);
    }
  };

  this.processAudioAmplitude = function (data, speaking) {
    myWebRTC_Event.createAudioAmplitudeEvent(data.descriptor.audioAmplitude, speaking, data.callId, data.descriptor.streamID);
  };
  /*
   * @method processDistantIceError
   * @ignore
   * @param {object} data
   * @param {object} data.descriptor
   * @param {string} data.descriptor.iceState - Either "failed" or "disconnected".
   */


  this.processDistantIceError = function (data) {
    if (data.descriptor.iceState === 'disconnected') {
      this.myWebRTC_Event.createErrorEvent('distant iceDisconnection detected', 'DISTANT_ICE_CONNECTION_STATE_DISCONNECTED', null, data.roomId, null, data.descriptor);
    } else if (data.descriptor.iceState === 'failed') {
      myWebRTC_Event.createErrorEvent('distant iceConnection failed detected', 'DISTANT_ICE_CONNECTION_STATE_FAILED', null, data.roomId, null, data.descriptor);
    }
  };
  /*
   * @method processStreamTrackMuteChanged
   *
   * @param callId {string}
   * @param mline {string} audio/video.
   * @param muted {boolean}
   */


  this.processStreamTrackMuteChanged = function (callId, mline, muted) {
    var idx = this.callsTable.length,
        call = null,
        changes = [],
        audio = {},
        video = {};

    while (--idx >= 0) {
      if (this.callsTable[idx].callId === callId) {
        call = this.callsTable[idx];
        break;
      }
    }

    if (call !== null) {
      if (mline === 'audio') {
        call.isRemoteAudioMuted = muted;
        changes.push('audioIsMuted');
        audio.available = call.remoteCallProfile.audio;
        audio.active = call.remoteCallProfile.audioActive;
        audio.muted = call.isRemoteAudioMuted;
        audio.silent = call.isRemoteAudioSilent;
        video.available = call.remoteCallProfile.video;
        video.active = call.remoteCallProfile.videoActive;
        video.muted = call.isRemoteVideoMuted;
        video.silent = call.isRemoteVideoSilent;
      } else if (mline === 'video') {
        call.isRemoteVideoMuted = muted;
        changes.push('videoIsMuted');
        audio.available = call.remoteCallProfile.audio;
        audio.active = call.remoteCallProfile.audioActive;
        audio.muted = call.isRemoteAudioMuted;
        audio.silent = call.isRemoteAudioSilent;
        video.available = call.remoteCallProfile.video;
        video.active = call.remoteCallProfile.videoActive;
        video.muted = call.isRemoteVideoMuted;
        video.silent = call.isRemoteVideoSilent;
      }

      if (changes.length > 0) {
        this.myWebRTC_Event.createRemoteStreamUpdatedEvent(changes, audio, video, call.destCallType, call.callId, 'userAction');
      }
    }
  };
  /*
   * @method processStreamTrackStatusChanged
   *
   * @param callId {string}
   * @param mline {string} audio/video.
   * @param muted {boolean}
   */


  this.processStreamTrackStatusChanged = function (callId, mline, muted) {
    var idx = this.callsTable.length,
        call = null,
        changes = [],
        audio = {},
        video = {};

    while (--idx >= 0) {
      if (this.callsTable[idx].callId === callId) {
        call = this.callsTable[idx];
        break;
      }
    }

    if (call !== null) {
      if (mline === 'audio') {
        call.isRemoteAudioSilent = muted;
        changes.push('audioIsSilent');
        audio.available = call.remoteCallProfile.audio;
        audio.active = call.remoteCallProfile.audioActive;
        audio.muted = call.isRemoteAudioMuted;
        audio.silent = call.isRemoteAudioSilent;
        video.available = call.remoteCallProfile.video;
        video.active = call.remoteCallProfile.videoActive;
        video.muted = call.isRemoteVideoMuted;
        video.silent = call.isRemoteVideoSilent;
      } else if (mline === 'video') {
        call.isRemoteVideoSilent = muted;
        changes.push('videoIsSilent');
        audio.available = call.remoteCallProfile.audio;
        audio.active = call.remoteCallProfile.audioActive;
        audio.muted = call.isRemoteAudioMuted;
        audio.silent = call.isRemoteAudioSilent;
        video.available = call.remoteCallProfile.video;
        video.active = call.remoteCallProfile.videoActive;
        video.muted = call.isRemoteVideoMuted;
        video.silent = call.isRemoteVideoSilent;
      }

      if (changes.length > 0) {
        this.myWebRTC_Event.createRemoteStreamUpdatedEvent(changes, audio, video, call.destCallType, call.callId, 'userAction');
      }
    }
  };
  /*
   * Treats an incoming updateStream message.
   * @param {string} callId
   * @param {string} mline - Either 'audio' or 'video'.
   * @param {string} direction - Either 'inactive' or else.
   * @return {boolean} true on success, false otherwise.
   */


  this.processUpdateStream = function (callId, mline, direction) {
    // Find the call.
    var idx = this.callsTable.length;
    var call = null;

    while (--idx >= 0) {
      //Mesh or Janus
      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.callsTable[idx].data, 'mesh', 'object') && this.callsTable[idx].data.mesh.calleeCallId === callId || this.callsTable[idx].callId === callId) {
        call = this.callsTable[idx];
        break;
      }
    } // while


    if (!call) {
      return false;
    } // Trigger update.


    var done = false;

    if (mline === 'audio') {
      if (direction === 'inactive') {
        // deactivating audio.
        if (call.callType === 'media') {
          call.callType = 'videoOnly';
          call.updateUserMedia = true;
          call.updateCause = 'adaptation';
          call.audioSdpDirection = 'inactive';
          call.establishCall();
          done = true;
        }
      } else {
        // activating audio.
        if (call.callType === 'videoOnly') {
          call.callType = 'media';
          call.updateUserMedia = true;
          call.updateCause = 'adaptation';
          call.audioSdpDirection = null;
          call.establishCall();
          done = true;
        }
      }
    } else if (mline === 'video') {
      if (direction === 'inactive') {
        // deactivating video.
        if (call.callType === 'media') {
          this.evalOutgoingVideoBandwithCap(call);
          call.callType = 'audio';
          call.updateUserMedia = true;
          call.updateCause = 'adaptation';
          call.videoSdpDirection = 'inactive';
          call.establishCall();
          done = true;
        }
      } else {
        // activating video.
        if (call.callType === 'audio') {
          this.evalOutgoingVideoBandwithCap(call);
          call.callType = 'media';
          call.updateUserMedia = true;
          call.updateCause = 'adaptation';
          call.videoSdpDirection = null;
          call.establishCall();
          done = true;
        }
      }
    }

    return done;
  };
  /*
   * Treats 'updateVideoQuality' directive,
   * @param {string} callId
   * @param {object} profile
   * @param {number} profile.width
   * @param {number} profile.height
   * @param {number} profile.frameRate
   */


  this.processUpdateVideoQuality = function (callId, profile) {
    logger.debug('processUpdateVideoQuality', callId, profile);
    var call = this.findCallWithCallId(callId);

    if (!call) {
      logger.warn('processUpdateVideoQuality - no such call; callId:', callId);
      return;
    }

    if (!call.sessionMCU || call.sessionMCU.roomMode === 'mesh') {
      logger.warn('processUpdateVideoQuality - wrong roomMode; callId:', callId);
      return;
    }

    var userMediaStream = apiCC.getUserMediaStream(call.callConfiguration.userMediaStreamId);

    if (!userMediaStream) {
      logger.warn('processUpdateVideoQuality - no such userMediaStream; callId:', callId);
      return;
    }

    var videoTrack = userMediaStream.getVideoTrack();

    if (!videoTrack) {
      logger.warn('processUpdateVideoQuality - no such video track; callId:', callId);
      return;
    }

    var newConstraints = {};

    if (profile.width && profile.height) {
      newConstraints.width = profile.width;
      newConstraints.height = profile.height;
    }

    if (profile.frameRate) {
      newConstraints.frameRate = profile.frameRate;
    }

    videoTrack.applyConstraints(newConstraints).then(function (res) {
      logger.debug('processUpdateVideoQuality - applyConstraints; OK');
    })["catch"](function (err) {
      logger.error('processUpdateVideoQuality - applyConstraints', err);
    });
  };

  this.removeAllCallsFromRoom = function (roomId, reason) {
    logger.info('removeAllCallsFromRoom :' + roomId + " with reason :" + reason);
    var i,
        callsNumber = this.callsTable.length,
        callIdTable = [],
        j,
        callIdEntry = {};

    for (i = 0; i < callsNumber; i += 1) {
      if (this.callsTable[i].dest_roomId == roomId) {
        logger.log('Call is attached to the room, removing ...');
        callIdEntry = {
          callId: this.callsTable[i].callId
        };
        callIdTable.push(callIdEntry);
      }
    }

    for (j = 0; j < callIdTable.length; j += 1) {
      this.removeCallFromTableWithCallIdAndSendBye(callIdTable[j].callId, reason);
    } //Removing callIdTable Entries


    callIdTable.splice(0, callIdTable.length);
  };

  this.onHangup = function (callId, reason) {
    var call = null,
        userMedia = null,
        userMediaStream = null,
        idx = null,
        foundCallIds = [],
        restart = false,
        meshRestart = false,
        restartStream = null,
        callInfo = null;

    if (callId) {
      if (typeof callId !== 'string') {
        callId = String(callId);
      }
    } else {
      callId = null;
    }

    if (reason) {
      if (typeof reason !== 'string') {
        reason = null;
      }
    } else {
      reason = null;
    }

    logger.info('Hanging up.'); //this.myWebRTC_Event.createHangupEvent('local', this.clientId, 0, true, 'Hangup');

    if (callId === null) {
      logger.log('Leaving all calls that are established');

      if (this.MCUClient) {
        // Releasing user media in mesh mode.
        this.MCUClient.meshOnHangup();
      }

      this.removeAllCalls();
      this.callControlTable.splice(0, this.callControlTable.length);
    } else {
      // callId is given.
      if ((userMedia = this.findUserMediaById(callId)) !== null) {
        // mesh publish call.
        if (this.MCUClient.pubConnector === 'janusConnector' && (reason === 'RTC_Setup_Timeout' || reason === 'disconnected')) {
          userMediaStream = userMedia.getUserMediaStream();

          if (userMediaStream && userMediaStream.stream) {
            restart = true;
            restartStream = userMediaStream.stream;
            userMedia.streamStolen = true;

            if (userMedia.sessionMCU.roomMode === 'mesh') {
              meshRestart = true;
            } else {
              callInfo = userMediaStream.getCallInfo(userMedia.userMediaId);

              if (callInfo) {
                // Changing the flavor of the attached call/userMedia.
                callInfo.flavor = 'call';
              }
            }
          }
        } // Closing every call related to this one.
        // Gathering every callId matching the given stream.


        for (idx = this.callsTable.length; --idx >= 0;) {
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.callsTable[idx].data, 'object') && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(this.callsTable[idx].data.mesh, 'object') && this.callsTable[idx].data.mesh.calleeCallId === callId) {
            foundCallIds.push(this.callsTable[idx].callId);
          }
        } // for
        // Removing each gathered call one by one.


        for (idx = foundCallIds.length; --idx >= 0;) {
          this.removeCallFromTableWithCallIdAndSendBye(foundCallIds[idx], reason);
        } // for
        // Finally, removing the given stream.


        this.MCUClient.meshOnHangup(callId, null, {
          restart: restart
        });
      } else if ((call = this.findCallWithCallId(callId)) !== null) {
        // call.
        if (this.MCUClient.pubConnector === 'janusConnector' && (reason === 'RTC_Setup_Timeout' || reason === 'disconnected')) {
          if (call.settingUpType === 'publish' || call.settingUpType === 'shareScreen') {
            if (!call.data || !call.data.mesh) {
              restart = true;
              call.streamStolen = true;
            }
          } else if (call.settingUpType === 'subscribe') {
            restart = true;
          }
        }

        logger.log('Leaving call with callId :' + callId);
        this.removeCallFromTableWithCallIdAndSendBye(callId, reason);
      }
    }

    if (restart === true) {
      // Auto restart.
      if (call !== null) {
        // Restarting call.
        this.restartCall(call);
      } else if (userMedia) {
        if (meshRestart === true) {
          // Restarting mesh call in mesh mode.
          this.restartCall(userMedia, {
            userMedia: true,
            mesh: true
          });
        } else {
          // Restarting mesh call via MCU.
          this.restartCall(userMedia, {
            userMedia: true,
            stream: restartStream
          });
        }
      }
    } else {
      if (call && call.callControl) {
        this.destroyCallControl(call.callControl);
      }

      this.stopMaxCallRetriesTimer(callId); //clean maxCallsRetriesDuration timer

      this.stopRestartCallTimer(callId); //clean restartCall timer

      delete this.callsRetriesTable[callId];
    }
  };

  this.stopStream = function (stream) {
    logger.info("stopStream in client");
    var i,
        tracks = null;

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 45 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Firefox" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 44 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Opera" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 34 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chromium" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 44 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === "Chrome WebView" && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 45) {
      stream.onended = null;
      stream.stop();
    } else {
      stream.onended = null;
      logger.log("MediaStream.stop is now deprecated, using MediaStreamTrack.stop");
      tracks = stream.getTracks();

      for (i = 0; i < tracks.length; i += 1) {
        tracks[i].onended = null;
        tracks[i].stop();
      }

      logger.log('... tracks stopped');
    }

    stream = null;
  };

  this.clearCallTimeouts = function (call) {
    logger.debug('clearCallTimeouts');
    var i;

    if (call.send200OKTrickleIceFalseTimeOutId !== 0) {
      logger.debug('clearing send200OKTrickleIceFalseTimeOutId');
      clearTimeout(call.send200OKTrickleIceFalseTimeOutId);
      call.send200OKTrickleIceFalseTimeOutId = 0;
    }

    if (call.sendInviteTrickleIceFalseTimeOutId !== 0) {
      logger.debug('clearing sendInviteTrickleIceFalseTimeOutId');
      clearTimeout(call.sendInviteTrickleIceFalseTimeOutId);
      call.sendInviteTrickleIceFalseTimeOutId = 0;
    }

    if (call.disconnectionTimeoutId !== 0) {
      logger.debug('clearing disconnectionTimeout');
      clearTimeout(call.disconnectionTimeoutId);
      call.disconnectionTimeoutId = 0;
    }

    if (call.disconnectionWarningInterval !== 0) {
      logger.debug('clearing disconnectionWarningInterval');
      clearInterval(call.disconnectionWarningInterval);
      call.disconnectionWarningInterval = 0;
    }

    for (i = 0; i < call.checkCandidateTypesTimeoutTable.length; i += 1) {
      logger.debug('clearing checkCandidateTypesTimeout :', call.checkCandidateTypesTimeoutTable[i]);
      clearTimeout(call.checkCandidateTypesTimeoutTable[i]);
    }

    call.checkCandidateTypesTimeoutTable.splice(0, call.checkCandidateTypesTimeoutTable.length);
  };

  this.removeAllCalls = function () {
    logger.info('removeAllCalls');
    var callsNumber = this.callsTable.length,
        iBoucle,
        dst = 0,
        reason = null,
        nbRemovedEntry = 0,
        userMediaStream = null;
    logger.log('callsNumber = ' + callsNumber); //Sending 1 bye par call

    for (iBoucle = 0; iBoucle < callsNumber; iBoucle += 1) {
      if (this.callsTable[iBoucle - nbRemovedEntry].callee) {
        dst = this.callsTable[iBoucle - nbRemovedEntry].callerId;
      } else {
        dst = this.callsTable[iBoucle - nbRemovedEntry].calleeId;
      } //logger.log('dst = ' + dst);


      if (this.callsTable[iBoucle - nbRemovedEntry].callee === true) {
        reason = 'Hangup_From_Callee';
        this.callsTable[iBoucle - nbRemovedEntry].myWebRTC_Stack.sendBye(this.callsTable[iBoucle - nbRemovedEntry].callId, this.clientId, this.callsTable[iBoucle - nbRemovedEntry].dest_roomId, dst, reason, this.callsTable[iBoucle - nbRemovedEntry].data);
      } else {
        reason = 'Hangup_From_Caller'; //Checking if invite has been sended, cancel may happen before invite has been send

        if (this.callsTable[iBoucle - nbRemovedEntry].inviteSended === true) {
          //Sending Bye message
          this.callsTable[iBoucle - nbRemovedEntry].myWebRTC_Stack.sendBye(this.callsTable[iBoucle - nbRemovedEntry].callId, this.clientId, this.callsTable[iBoucle - nbRemovedEntry].dest_roomId, dst, reason, this.callsTable[iBoucle - nbRemovedEntry].data);
        } else {
          this.callsTable[iBoucle - nbRemovedEntry].callCancelled = true;
          logger.warn('Leaving call iteration on removeAllCalls');
          continue; //leaving the for iteration, call will be removed when callCanced is detected before sending invite
        }
      }

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.callsTable[iBoucle - nbRemovedEntry].sessionMCU, 'roomName', 'string') && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.callsTable[iBoucle - nbRemovedEntry].data, 'MCUType', 'string') && (this.callsTable[iBoucle - nbRemovedEntry].data.MCUType === 'MCU-Caller' || this.callsTable[iBoucle - nbRemovedEntry].data.MCUType === 'MCU-Callee')) {
        this.MCUClient.leaveSession(this.callsTable[iBoucle - nbRemovedEntry].sessionMCU.roomName, {
          noHangup: true
        });
      }

      if (this.callsTable[iBoucle - nbRemovedEntry].callConfiguration && this.callsTable[iBoucle - nbRemovedEntry].callConfiguration.userMediaStreamId) {
        userMediaStream = apiCC.getUserMediaStream(this.callsTable[iBoucle - nbRemovedEntry].callConfiguration.userMediaStreamId);

        if (userMediaStream) {
          apiCC.releaseUserMediaStream(userMediaStream.userMediaStreamId, this.callsTable[iBoucle - nbRemovedEntry].callId);
        }
      }

      if (this.callsTable[iBoucle - nbRemovedEntry].screenStream !== null) {
        logger.log('stopping screenStream');
        this.stopStream(this.callsTable[iBoucle - nbRemovedEntry].screenStream);
        myWebRTC_Event.createUserMediaStopEvent(this.callsTable[iBoucle - nbRemovedEntry].callId, 'screen'); //this.callsTable[iBoucle - nbRemovedEntry].screenStream.stop();
        //this.callsTable[iBoucle - nbRemovedEntry].screenStream = null;
      }

      if (this.callsTable[iBoucle - nbRemovedEntry].pc !== null) {
        logger.log('Closing PC'); //stats
        // at end of call, sends stored stats to ccs server for storage on mongodb.

        if (this.qosEnable) {
          if (typeof this.callsTable[iBoucle - nbRemovedEntry].qm !== 'undefined' && this.callsTable[iBoucle - nbRemovedEntry].qm !== null && typeof this.callsTable[iBoucle - nbRemovedEntry].qm.saveStatsToDb === 'function') {
            this.callsTable[iBoucle - nbRemovedEntry].qm.saveStatsToDb(true);
            clearInterval(this.callsTable[iBoucle - nbRemovedEntry].statisticId); // stop getting stats each interval
          }
        }

        if (this.callsTable[iBoucle - nbRemovedEntry].csmIntervalId) {
          clearInterval(this.callsTable[iBoucle - nbRemovedEntry].csmIntervalId);
        }

        this.callsTable[iBoucle - nbRemovedEntry].pc.close();
        this.callsTable[iBoucle - nbRemovedEntry].pc = null;
      }

      this.myWebRTC_Event.createHangupEvent('local', this.clientId, this.callsTable[iBoucle - nbRemovedEntry].remoteId, true, reason, this.callsTable[iBoucle - nbRemovedEntry].callId, this.callsTable[iBoucle - nbRemovedEntry].callType);

      if (this.callsTable[iBoucle - nbRemovedEntry].data !== undefined && this.callsTable[iBoucle - nbRemovedEntry].data !== null) {
        if (this.callsTable[iBoucle - nbRemovedEntry].data.pubSub !== 'janusConnector' && (this.callsTable[iBoucle - nbRemovedEntry].data.MCUType === 'MCU-Caller' || this.callsTable[iBoucle - nbRemovedEntry].data.MCUType === 'MCU-Callee')) {
          //Recorded Call : firing an event
          this.myWebRTC_Event.createRecordedStreamsAvailableEvent(this.callsTable[iBoucle - nbRemovedEntry].data.confId, this.callsTable[iBoucle - nbRemovedEntry].callerId, this.callsTable[iBoucle - nbRemovedEntry].calleeId, this.callsTable[iBoucle - nbRemovedEntry].callId);
        }
      }

      this.clearCallTimeouts(this.callsTable[iBoucle - nbRemovedEntry]);

      if (this.callsTable[iBoucle - nbRemovedEntry].incomingcandidatesQueue.length !== 0) {
        this.callsTable[iBoucle - nbRemovedEntry].incomingcandidatesQueue.splice(0, this.callsTable[iBoucle - nbRemovedEntry].incomingcandidatesQueue.length);
      }

      if (this.clientIncomingCandidatesQueue[this.callsTable[iBoucle - nbRemovedEntry].callId + '-' + this.callsTable[iBoucle - nbRemovedEntry].instanceId] !== undefined) {
        if (this.clientIncomingCandidatesQueue[this.callsTable[iBoucle - nbRemovedEntry].callId + '-' + this.callsTable[iBoucle - nbRemovedEntry].instanceId].length !== 0) {
          this.clientIncomingCandidatesQueue[this.callsTable[iBoucle - nbRemovedEntry].callId + '-' + this.callsTable[iBoucle - nbRemovedEntry].instanceId].splice(0, this.clientIncomingCandidatesQueue[this.callsTable[iBoucle - nbRemovedEntry].callId + '-' + this.callsTable[iBoucle - nbRemovedEntry].instanceId].length);
        }
      }

      logger.log('Removing call from table');
      this.callsTable.splice(iBoucle - nbRemovedEntry, 1);
      nbRemovedEntry += 1;
    }
  };

  this.onRemoteHangup = function (callId, from, roomId, reason, confId, data) {
    var _this = this;

    logger.debug('onRemoteHangup');
    var callType = null,
        call = null,
        userMedia = null,
        // when call is in mesh mode.
    userMediaStream = null,
        // associated userMediaStream.
    restart = false,
        // whether to restart the broken call.
    meshRestart = false,
        // whether the restart must be done in mesh mode.
    mesh2janus = false,
        // mesh to janus mode transition ongoing.
    restartStream = null,
        // mediaStream used for restart.
    callInfo = null;
    logger.log("callId :" + callId);
    logger.log("confId :" + confId);

    if (this.MCUClient.pubConnector === 'janusConnector') {
      if (reason === 'RTC_Setup_Timeout' || reason === 'Broken_by_MCU' || reason === 'disconnected') {
        if (data === null || data === undefined) {
          call = this.findCallWithCallId(callId);
        } else {
          call = this.findCallWithCallIdAndInstanceId(callId, data.instanceId);
        }

        if (call !== undefined && call !== null) {
          // real call.
          // Clear setup timeout.
          if (call.setupTimeoutId) {
            clearTimeout(call.setupTimeoutId);
            delete call.setupTimeoutId;
          }

          if (call.restarting === true) {
            // Ignoring bye message during call restart.
            logger.debug('call restarting');
            return;
          }

          if (call.settingUpType === 'publish' || call.settingUpType === 'shareScreen') {
            if (!call.data || !call.data.mesh) {
              restart = true;
              call.streamStolen = true;
            }
          } else if (call.settingUpType === 'subscribe') {
            restart = true;
          }

          if (call.sessionMCU !== null && call.sessionMCU.modeChangeKind === 'old') {
            logger.debug('onRemoteHangup ignore');
            return;
          }
        } else if ((userMedia = this.findUserMediaById(callId)) !== null) {
          userMedia.close(); // mesh publish call.

          userMediaStream = userMedia.getUserMediaStream();

          if (userMediaStream && userMediaStream.stream) {
            if (userMedia.sessionMCU !== null && userMedia.sessionMCU.modeChangeKind === 'old') {
              restart = true;
              restartStream = userMediaStream.stream;
              userMedia.streamStolen = true;

              if (userMedia.distantCalls.length > 0) {
                mesh2janus = true;
              }

              callInfo = userMediaStream.getCallInfo(userMedia.userMediaId);

              if (callInfo) {
                // Changing the flavor of the attached call/userMedia.
                callInfo.flavor = 'call';
              }
            } else if (userMedia.sessionMCU !== null && userMedia.sessionMCU.roomMode === 'mesh') {
              restart = true;
              meshRestart = true;
              restartStream = userMediaStream.stream;
              userMedia.streamStolen = true;
            } else {
              restart = true;
              restartStream = userMediaStream.stream;
              userMedia.streamStolen = true;
              callInfo = userMediaStream.getCallInfo(userMedia.userMediaId);

              if (callInfo) {
                // Changing the flavor of the attached call/userMedia.
                callInfo.flavor = 'call';
              }
            }
          }
        } else {
          logger.debug("No call and no userMedia found");
        }
      } else {
        if (data === null || data === undefined) {
          call = this.findCallWithCallId(callId);
        } else {
          call = this.findCallWithCallIdAndInstanceId(callId, data.instanceId);
        }

        if (call) {
          // Clear setup timeout.
          if (call.setupTimeoutId) {
            clearTimeout(call.setupTimeoutId);
            delete call.setupTimeoutId;
          }

          if (call.settingUpType === 'subscribe') {
            restart = true;
          }
        } else {
          userMedia = this.findUserMediaById(callId);

          if (userMedia) {
            userMedia.close();
          }
        }
      }
    }

    if (!mesh2janus) {
      // close call (or calls for a user media).
      if (userMedia !== null) {
        // Mesh publish call.
        // Closing every call related to this one.
        // Gathering every callId matching the given stream.
        var idx = null,
            foundCallIds = [];

        for (idx = this.callsTable.length; --idx >= 0;) {
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.callsTable[idx].data, 'mesh', 'object') && this.callsTable[idx].data.mesh.calleeCallId === callId && this.callsTable[idx].settingUpType !== 'subscribe') {
            foundCallIds.push(this.callsTable[idx].callId);
          }
        } // for
        // Removing each gathered call one by one.


        for (idx = foundCallIds.length; --idx >= 0;) {
          this.removeCallFromTableWithCallIdAndSendBye(foundCallIds[idx], reason);
        } // for
        // Finally, removing the given stream.


        this.MCUClient.meshOnHangup(callId);

        if (userMedia.sessionMCU.modeChangeKind === 'old') {
          // case of userMedia without any distant call.
          // transition clean up is possible.
          var newSessionMCU = this.MCUClient.getSessionMCU(null, {
            callback: function callback(entry) {
              return entry.roomName === userMedia.sessionMCU.roomName && entry.modeChangeKind === 'new';
            }
          });

          if (newSessionMCU) {
            this.finalizeMeshToJanusTransition(userMedia.sessionMCU, newSessionMCU);
          }
        }
      } else if (callId !== undefined) {
        if (data === null || data === undefined) {
          callType = this.removeCallFromTableWithCallIdandRemoteId(callId, from, reason);
        } else {
          callType = this.removeCallFromTableWithCallIdandInstanceId(callId, data.instanceId, reason);
        }
      } else if (confId !== undefined) {
        callType = this.removeCallFromTableWithConfIdandRemoteId(confId, from, reason);
      }
    }

    logger.log('Reason : ' + reason);

    if (call && restart !== true) {
      // Hung up call is restarted.
      if (this.callsTable.length === 0 && this.userMediaTable.length === 0) {
        logger.log('No more established calls for client');
        this.myWebRTC_Event.createRemoteHangupEvent(this.clientId, from, true, reason); //Deprecated

        this.myWebRTC_Event.createHangupEvent('remote', this.clientId, from, true, reason, callId, callType);

        if (this.getUserMediaOnGoing === true && session.deactivateReloadOnCancel !== true) {
          //this.callsTable.length !== 1 : already an established call : no reload
          logger.log('Cancel from Remote');

          if (typeof apiRTC_React === 'undefined') {
            location.reload();
          }

          this.getUserMediaOnGoing = false;
        }
      } else {
        logger.log('Other calls are still established');
        this.myWebRTC_Event.createRemoteHangupEvent(this.clientId, from, false, reason); //Deprecated

        this.myWebRTC_Event.createHangupEvent('remote', this.clientId, from, false, reason, callId, callType);
      }
    } else if (call && call.settingUpType === 'subscribe') {
      // Firing events for clean up.
      this.myWebRTC_Event.createRemoteHangupEvent(this.clientId, from, false, 'restarted'); //Deprecated

      this.myWebRTC_Event.createHangupEvent('remote', this.clientId, from, false, 'restarted', callId, callType);
    }

    if (data !== undefined && data !== null) {
      if (this.MCUClient.pubConnector !== 'janusConnector' && (data.MCUType === 'MCU-Caller' || data.MCUType === 'MCU-Callee')) {
        //Recorded Call : firing an event
        this.myWebRTC_Event.createRecordedStreamsAvailableEvent(confId, this.clientId, from, callId);
      }
    }

    if (restart === true) {
      // Auto restart.
      if (call !== null) {
        // Restarting call.
        this.restartCall(call);
      } else if (userMedia) {
        if (meshRestart === true) {
          // Restarting mesh call in mesh mode.
          this.restartCall(userMedia, {
            userMedia: true,
            mesh: true
          });
        } else {
          // Restarting mesh call via MCU.
          if (this.randomDelayOnRestart) {
            logger.debug('onRemoteHangup - randomDelayOnRestart');
            setTimeout(function () {
              _this.restartCall(userMedia, {
                userMedia: true,
                stream: restartStream
              });
            }, Math.random() * 5000);
          } else {
            this.restartCall(userMedia, {
              userMedia: true,
              stream: restartStream
            });
          }
        }
      }
    } else {
      if (call && call.callControl) {
        this.destroyCallControl(call.callControl);
      }

      if (call || userMedia) {
        this.stopMaxCallRetriesTimer(callId); // Cleaning maxCallsRetriesDuration timer

        this.stopRestartCallTimer(callId); //clean restartCall timer

        delete this.callsRetriesTable[callId];
      }
    }
  };
  /*
   * startMaxCallRetriesTimer.
   * used to start maxCallsRetriesDuration timer for calls restart process
   * @ignore
   * @param {string} callId
   */


  this.startMaxCallRetriesTimer = function (callId) {
    var _this2 = this;

    logger.debug('startMaxCallRetriesTimer for callIdWhenStartingTimer :', callId);
    var timeOutId = setTimeout(function () {
      logger.debug('[restartCall] MaxCallRetriesTimer reached for callIdWhenStartingTimer :', callId);
      _this2.callsRetriesTable[callId].allowedStatus = false;
      delete _this2.callsRetriesTable[callId].maxCallsRetriesDurationTimeOutId;
    }, this.maxCallsRetriesDuration);
    this.callsRetriesTable[callId] = {};
    this.callsRetriesTable[callId].maxCallsRetriesDurationTimeOutId = timeOutId; //CallId is CallIdWhenStartingTimer
  };
  /*
   * stopMaxCallRetriesTimer.
   * used to stop maxCallsRetriesDuration timer for calls restart process
   * @ignore
   * @param {string} callId
   */


  this.stopMaxCallRetriesTimer = function (callId) {
    logger.debug('stopMaxCallRetriesTimer for callId :', callId);

    if (this.callsRetriesTable[callId] !== undefined) {
      if (this.callsRetriesTable[callId].maxCallsRetriesDurationTimeOutId !== undefined) {
        clearTimeout(this.callsRetriesTable[callId].maxCallsRetriesDurationTimeOutId);
        logger.debug('[restartCall] MaxCallRetriesTimer cleared for callId :', callId);
        delete this.callsRetriesTable[callId]; //Delete of the complete call entry
      }
    }
  };
  /*
   * stopRestartCallTimer.
   * used to stop restartCall timer for calls restart process
   * @ignore
   * @param {string} callId
   */


  this.stopRestartCallTimer = function (callId) {
    logger.debug('stopRestartCallTimer for callId :', callId);

    if (this.callsRetriesTable[callId] !== undefined) {
      if (this.callsRetriesTable[callId].restartCallTimeOutId !== undefined) {
        clearTimeout(this.callsRetriesTable[callId].restartCallTimeOutId);
        logger.error('[restartCall] RestartCallTimer cleared for callId :', callId);
        delete this.callsRetriesTable[callId].restartCallTimeOutId;
      }
    }
  };
  /* Restarts a given call/userMedia with retries delay and limitation management
   * @param {WebRTC_Call|WebRTC_UserMedia} call - Either a call or a userMedia.
   * @param {object} options
   * @param {boolean} options.userMedia - Whether call argument is a userMedia. Default is false.
   * @param {boolean} options.mesh - Whether userMedia shall be restarted in mesh mode. Default is false.
   * @param {MediaStream} options.stream - The media stream to use.
   */


  this.restartCall = function (call) {
    var _this3 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    logger.debug('[restartCall] restartCall for callId :', call.callId);
    var autoRestartCounter = -1;

    if (options.userMedia !== true) {
      if (call.callControl && call.callControl.autoRestart) {
        autoRestartCounter = call.callControl.autoRestart.counter;

        if (autoRestartCounter === 0) {
          //start duration Timer for calls retries
          //set callIdWhenStartingTimer on callsTable
          call.callControl.autoRestart.callIdWhenStartingTimer = call.callId; //callIdWhenStartingTimer used to find the restarted call and manage the timeout

          this.startMaxCallRetriesTimer(call.callId);
        }

        if (this.callsRetriesTable[call.callControl.autoRestart.callIdWhenStartingTimer] !== undefined && this.callsRetriesTable[call.callControl.autoRestart.callIdWhenStartingTimer].allowedStatus === undefined) {
          //restart is allowed
          logger.debug('[restartCall] ... for callIdWhenStartingTimer :', call.callControl.autoRestart.callIdWhenStartingTimer);
          logger.debug('AutoRestartCounter :', autoRestartCounter);
          logger.debug('Calling restartCallProcess in :', this.restartCallDelay * Math.pow(2, autoRestartCounter));
          var timeOutId = setTimeout(function () {
            logger.debug('Timer reached for restartCall');
            delete call.callControl.autoRestart.pending;

            _this3.restartCallProcess(call, options);

            if (_this3.callsRetriesTable[call.callControl.autoRestart.callIdWhenStartingTimer] !== undefined && _this3.callsRetriesTable[call.callControl.autoRestart.callIdWhenStartingTimer].restartCallTimeOutId !== undefined) {
              delete _this3.callsRetriesTable[call.callControl.autoRestart.callIdWhenStartingTimer].restartCallTimeOutId;
            }
          }, this.restartCallDelay * Math.pow(2, autoRestartCounter));
          call.callControl.autoRestart.pending = true;
          this.callsRetriesTable[call.callControl.autoRestart.callIdWhenStartingTimer].restartCallTimeOutId = timeOutId; //CallId is CallIdWhenStartingTimer
        } else {
          logger.warn('CALL_ABORTED, retries not allowed (maxCallsRetriesDuration reached) for callIdWhenStartingTimer :', call.callControl.autoRestart.callIdWhenStartingTimer); // We need to clean the associated callControl now since the call does not exist anymore.

          this.destroyCallControl(call.callControl);
          myWebRTC_Event.createErrorEvent('call aborted after calls retries (maxCallsRetriesDuration reached)', 'CALL_ABORTED', call.callId, call.callControl.roomName);

          if (this.callsRetriesTable[call.callControl.autoRestart.callIdWhenStartingTimer] !== undefined) {
            delete this.callsRetriesTable[call.callControl.autoRestart.callIdWhenStartingTimer];
          }
        }
      } else {
        logger.debug('[restartCall] autoRestart options not defined');
      }
    } else {
      this.restartCallProcess(call, options);
    }
  };
  /* Restarts a given call/userMedia.
   * @param {WebRTC_Call|WebRTC_UserMedia} call - Either a call or a userMedia.
   * @param {object} options
   * @param {boolean} options.userMedia - Whether call argument is a userMedia. Default is false.
   * @param {boolean} options.mesh - Whether userMedia shall be restarted in mesh mode. Default is false.
   * @param {MediaStream} options.stream - The media stream to use.
   */


  this.restartCallProcess = function (call) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    logger.debug('restartCallProcess ');
    var userMedia = false,
        mesh = false,
        stream = null;

    if (call.restarting === true) {
      logger.debug('[restartCall] call already restarting');
      return;
    }

    call.restarting = true;

    if (options.userMedia === true) {
      userMedia = true;
    }

    if (options.mesh === true) {
      mesh = true;
    }

    if (userMedia === true) {
      // userMedia
      if (mesh === true) {
        // Restarting mesh call in mesh mode.
        if (call.callType === 'screenSharing' || call.callType === 'screenSharingWithAudio') {
          call.restarting = false;
          this.userMediaTable.push(call);
          this.MCUClient.meshOnScreenMediaSuccess(call);
        } else {
          call.restarting = false;
          this.userMediaTable.push(call);
          this.MCUClient.meshOnUserMediaSuccess(call);
        }
      } else {
        // Restarting mesh call in sfu mode.
        if (call.callType === 'screenSharing' || call.callType === 'screenSharingWithAudio') {
          // shareScreen
          delete call.data.meshPublish;
          call.data.type = 'publish';
          var callControl = this.createCallControl({
            type: 'shareScreen',
            callId: call.userMediaId,
            roomName: call.roomId,
            callConfiguration: call.callConfiguration,
            data: call.data
          });
          callControl.captureSourceType = call.captureSourceType;
          callControl.autoRestart.counter = 0;
          callControl.autoRestart.stream = options.stream;
          this.shareScreen(call.roomId, call.data, call.captureSourceType, call.callConfiguration, {
            callControl: callControl
          });
          this.myWebRTC_Event.createCallRestartingEvent(call.callType, call.audioOnly, call.userMediaId, call.userMediaId, 'publish', this.clientId, call.roomId, call.roomId, null);
        } else {
          // publish
          delete call.data.meshPublish;

          var _callControl = this.createCallControl({
            type: 'publish',
            callId: call.userMediaId,
            callType: call.callType,
            roomName: call.roomId,
            callConfiguration: call.callConfiguration,
            data: call.data
          });

          _callControl.audioOnly = call.callType === 'audio';
          _callControl.sessionId = call.sessionId;
          _callControl.token = call.token;
          _callControl.autoRestart.counter = 0;
          _callControl.autoRestart.stream = options.stream;
          this.MCUClient.publish(call.roomId, call.sessionId, call.token, call.callConfiguration, call.data, {
            callControl: _callControl
          });
          this.myWebRTC_Event.createCallRestartingEvent(call.callType, call.callType === 'audio', call.userMediaId, call.userMediaId, 'publish', this.clientId, call.roomId, call.roomId, null);
        }
      }
    } else {
      // call
      if (call.settingUpType === 'publish') {
        // publish call in sfu mode.
        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(call.callControl, 'object')) {
          logger.debug('[restartCall] restarting call publish');
          this.MCUClient.publish(call.callControl.roomName, call.callControl.sessionId, call.callControl.token, call.callControl.callConfiguration, call.callControl.data, {
            callControl: call.callControl
          });
          this.myWebRTC_Event.createCallRestartingEvent(call.callType, call.audioOnly, call.callId, call.callId, 'publish', this.clientId, call.callControl.roomName, call.callControl.roomName, null);
        } else {
          logger.warn('[restartCall] cannot auto restart; missing info');
        }
      } else if (call.settingUpType === 'shareScreen') {
        // shareScreen call in sfu mode.
        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(call.callControl, 'object')) {
          logger.debug('[restartCall] restarting call shareScreen');
          this.shareScreen(call.callControl.roomName, call.callControl.data, call.callControl.captureSourceType, call.callControl.callConfiguration, {
            callControl: call.callControl
          });
          this.myWebRTC_Event.createCallRestartingEvent(call.callType, call.audioOnly, call.callId, call.callId, 'publish', this.clientId, call.callControl.roomName, call.callControl.roomName, null);
        } else {
          logger.warn('[restartCall] cannot auto restart; missing info');
        }
      } else if (call.settingUpType === 'subscribe') {
        // subscribe call in sfu mode.
        logger.debug('[restartCall] restarting call subscribe');

        if (call.mcuRemoteStream.replay === true) {
          stream = this.MCUClient.getStreamOfUserCall(call.mcuRemoteStream.attributes.callerId, call.mcuRemoteStream.attributes.callId, {
            replay: true
          });
        } else {
          stream = this.MCUClient.getStreamOfUserCall(call.mcuRemoteStream.attributes.callerId, call.mcuRemoteStream.attributes.callId);
        }

        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(call.callControl, 'object') && stream) {
          // stream exists, subscribing to it.
          logger.debug('[restartCall] stream exists, subscribing to it');
          var force = !!call.callControl.autoRestart.force;
          delete call.callControl.autoRestart.force;
          var oldCallId = call.callControl.callId;
          var newCallIds = this.MCUClient.subscribeToStreams([stream], call.callControl.mediaType, call.callControl.data, call.callControl.callConfiguration, {
            noStreamCheck: true,
            autoSub: true,
            force: force
          });

          if (oldCallId && newCallIds[0]) {
            this.myWebRTC_Event.createCallRestartingEvent(call.callType, call.audioOnly, oldCallId, newCallIds[0], 'subscribe', this.clientId, call.callControl.roomName, call.callControl.roomName, stream.id);
          }
        }
      }
    }
  };

  this.closingCallProcess = function (index, reason) {
    logger.log('Session terminated.');
    var userMediaStream = null;

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.callsTable[index].sessionMCU, 'roomName', 'string') && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.callsTable[index].data, 'MCUType', 'string') && (this.callsTable[index].data.MCUType === 'MCU-Caller' || this.callsTable[index].data.MCUType === 'MCU-Callee')) {
      this.MCUClient.leaveSession(this.callsTable[index].sessionMCU.roomName);
    }

    if (this.callsTable[index].callConfiguration && this.callsTable[index].callConfiguration.userMediaStreamId) {
      if (this.callsTable[index].streamStolen !== true) {
        userMediaStream = apiCC.getUserMediaStream(this.callsTable[index].callConfiguration.userMediaStreamId);

        if (userMediaStream) {
          apiCC.releaseUserMediaStream(userMediaStream.userMediaStreamId, this.callsTable[index].callId);
        }
      }
    }

    if (this.callsTable[index].screenStream !== null) {
      logger.log('stopping screenStream');
      this.stopStream(this.callsTable[index].screenStream);
      myWebRTC_Event.createUserMediaStopEvent(this.callsTable[index].callId, 'screen');
    }

    if (this.callsTable[index].pc !== null) {
      logger.log('Closing PC');

      if (this.qosEnable) {
        //stats
        // at end of call, sends stored stats to ccs server for storage on mongodb.
        if (typeof this.callsTable[index].qm !== 'undefined' && this.callsTable[index].qm !== null && typeof this.callsTable[index].qm.saveStatsToDb === 'function') {
          this.callsTable[index].qm.saveStatsToDb(true);
          clearInterval(this.callsTable[index].statisticId); // stop getting stats every interval
        }
      }

      if (this.callsTable[index].csmIntervalId) {
        clearInterval(this.callsTable[index].csmIntervalId);
      }

      if (this.callsTable[index].beginTimeoutId) {
        clearTimeout(this.callsTable[index].beginTimeoutId);
        delete this.callsTable[index].beginTimeoutId;
      }

      if (this.callsTable[index].dcfs) {
        if (reason === 'Ice_failed') {
          this.callsTable[index].dcfs.failure = 'iceFailed';
        } else {
          this.callsTable[index].dcfs.canceled = true;
        }
      } else if (this.callsTable[index].callType === 'data' && this.callsTable[index].calleeId === 'dataChannelConnector') {
        if (!this.callsTable[index].failure && !this.callsTable[index].success) {
          // dcfs does not exist, because data channel was never open.
          setTimeout(function (call, err) {
            myWebRTC_Event.createEvent({
              'eventType': 'onFileSended',
              'callId': call.callId,
              'remoteId': call.remoteId,
              'name': call.data.filename,
              'error': err
            });

            if (call.callbacks && call.callbacks.failure) {
              call.callbacks.failure(err);
            }
          }, 0, this.callsTable[index], reason === 'Ice_failed' ? 'iceFailed' : 'canceled');
        }
      }

      this.callsTable[index].pc.close();
      this.callsTable[index].pc = null;
    }
  };

  this.removeCallProcess = function (index) {
    var _this4 = this;

    var call = this.callsTable[index];
    this.clearCallTimeouts(call);

    if (call.incomingcandidatesQueue.length !== 0) {
      call.incomingcandidatesQueue.splice(0, call.incomingcandidatesQueue.length);
    }

    if (this.clientIncomingCandidatesQueue[call.callId + '-' + call.instanceId] !== undefined) {
      if (this.clientIncomingCandidatesQueue[call.callId + '-' + call.instanceId].length !== 0) {
        this.clientIncomingCandidatesQueue[call.callId + '-' + call.instanceId].splice(0, this.clientIncomingCandidatesQueue[call.callId + '-' + call.instanceId].length);
      }
    }

    logger.log('Removing call from table');
    this.callsTable.splice(index, 1);
    logger.log('this.callsTable.length :', this.callsTable.length);
    logger.log('Call is terminated'); // For 'push data'
    // Let this call stops before starting the next one

    setTimeout(function () {
      _this4.startNextPushData();
    }); // Update video cap for remaining calls.

    this.evalOutgoingVideoBandwithCap();
  };

  this.removeCallFromTableWithCallIdAndSendBye = function (callId, reason) {
    //TODO : Check if callId is a unique ID
    // In 1 vers N call : it may be possibleto have 2 calls with the same callId and different remote ID
    // Use removeCallFromTableWithCallIdandRemoteId
    //This case will not happen when we use MCU
    logger.debug('removeCallFromTableWithCallIdAndSendBye()', callId);
    var index = 0,
        videoId = null,
        dst = null;
    index = this.findCallIndexWithCallId(callId);

    if (index !== -1) {
      this.closingCallProcess(index, reason);
      videoId = this.callsTable[index].callId + '-' + this.callsTable[index].calleeId; //Sending Bye to the remote user

      if (this.callsTable[index].callee) {
        dst = this.callsTable[index].callerId;

        if (reason === null) {
          reason = 'Hangup_From_Callee';
        }
      } else {
        dst = this.callsTable[index].calleeId;

        if (reason === null) {
          reason = 'Hangup_From_Caller';
        }
      }

      logger.log("reason is :" + reason); //TODO Fred ongoing voir si invite a t envoy avant sendBye

      if (this.callsTable[index].calleeId !== 'LOCAL') {
        var userInfo = apiCC.session.getConnectedUserInfo(this.callsTable[index].calleeId, 'userData');
        var userInfoJson = null;

        if (userInfo !== 'User_Not_Found') {
          try {
            userInfoJson = JSON.parse(userInfo);
          } catch (e) {
            logger.error("userInfo parse fail", userInfo);
          }
        }

        if (userInfoJson !== undefined && userInfoJson !== null && userInfoJson.isSimulated === "true") {
          apiCC.session.channel.socket.emit('simulatedAgentCancelCallRequest', {
            number: this.callsTable[index].calleeId,
            callId: callId
          });
        } else {
          this.callsTable[index].myWebRTC_Stack.sendBye(this.callsTable[index].callId, this.clientId, this.callsTable[index].dest_roomId, dst, reason, this.callsTable[index].data);
        }
      }

      if (reason !== 'Broken_by_MCU') {
        this.myWebRTC_Event.createHangupEvent('local', this.clientId, this.callsTable[index].remoteId, true, reason, this.callsTable[index].callId, this.callsTable[index].callType);
      }

      if (this.callsTable[index].data !== undefined && this.callsTable[index].data !== null) {
        if (this.callsTable[index].data.pubSub !== 'janusConnector' && (this.callsTable[index].data.MCUType === 'MCU-Caller' || this.callsTable[index].data.MCUType === 'MCU-Callee')) {
          //Recorded Call : firing an event
          this.myWebRTC_Event.createRecordedStreamsAvailableEvent(this.callsTable[index].data.confId, this.callsTable[index].callerId, this.callsTable[index].calleeId, this.callsTable[index].callId);
        }
      }

      this.removeCallProcess(index);
    } else {
      logger.log('No call removed');
    }

    if (this.MCUClient.publishCallId === callId) {
      this.publishCallId = null;
    }
  };

  this.removeCall = function (index) {
    logger.info('removeCall');
    var callType = null,
        reason = null;

    if (index !== -1) {
      this.closingCallProcess(index, reason); //avoid unnecessary disconnection warning events

      if (this.callsTable[index].disconnectionWarningTimeout !== 0) {
        logger.debug('clearing disconnectionWarningTimeout');
        clearTimeout(this.callsTable[index].disconnectionWarningTimeout);
        this.callsTable[index].disconnectionWarningTimeout = 0;
      }

      callType = this.callsTable[index].callType;
      this.removeCallProcess(index);
    } else {
      logger.debug('No call removed');
    }

    return callType;
  };

  this.removeCallFromTableWithConfIdandRemoteId = function (confId, remoteId, reason) {
    logger.debug('removeCallFromTableWithConfIdandRemoteId() with reason :' + reason);
    reason = null;
    var index = null,
        callType = null;
    index = this.findCallIndexWithConfIdAndRemoteId(confId, remoteId);
    callType = this.removeCall(index);
    return callType;
  };

  this.removeCallFromTableWithCallIdandRemoteId = function (callId, remoteId, reason) {
    logger.debug('removeCallFromTableWithCallIdandRemoteId() with reason :' + reason);
    logger.log('callId :' + callId);
    logger.log('remoteId :' + remoteId);
    reason = null;
    var index = 0,
        callType = null;
    index = this.findCallIndexWithCallIdAndRemoteId(callId, remoteId);
    callType = this.removeCall(index);
    return callType;
  };

  this.removeCallFromTableWithCallIdandInstanceId = function (callId, instanceId, reason) {
    logger.debug('removeCallFromTableWithCallIdandInstanceId() with reason :' + reason);
    logger.log('callId :' + callId);
    logger.log('instanceId :' + instanceId);
    reason = null;
    var index = 0,
        callType = null;
    index = this.findCallIndexWithCallIdAndInstanceId(callId, instanceId);
    callType = this.removeCall(index);
    return callType;
  };

  this.toggleVideoMute = function (callId) {
    logger.debug('toggleVideoMute');
    var i,
        callsNumber = this.callsTable.length,
        index = 0,
        userMedia = null,
        userMediaStream = null;

    if (callId === undefined || callId === null) {
      logger.debug('no callId defined, toggleVideoMute all local video');

      if (this.isVideoMuted) {
        if (this.localStream !== null) {
          logger.debug('localStream unMuteTracks');
          this.unMuteTracks(this.localStream.getVideoTracks());
        }
      } else {
        if (this.localStream !== null) {
          logger.debug('localStream muteTracks');
          this.muteTracks(this.localStream.getVideoTracks());
        }
      }

      this.isVideoMuted = !this.isVideoMuted; // Handling calls (not mesh).

      for (i = 0; i < callsNumber; i += 1) {
        if (this.callsTable[i].data && this.callsTable[i].data.mesh) {
          // Mesh calls will be handled in the next loop.
          continue;
        }

        userMediaStream = null;

        if (this.callsTable[i].callConfiguration) {
          userMediaStream = apiCC.getUserMediaStream(this.callsTable[i].callConfiguration.userMediaStreamId);
        }

        if (userMediaStream) {
          if (userMediaStream.videoMuted) {
            userMediaStream.unMuteVideoOnStreams("enabled");
          } else {
            userMediaStream.muteVideoOnStreams("enabled");
          }
        } else if (this.callsTable[i].callLocalStream !== null) {
          if (this.callsTable[i].isLocalVideoMuted) {
            logger.debug('unmuting call :', this.callsTable[i].callId);
            this.unMuteTracks(this.callsTable[i].callLocalStream.getVideoTracks());
          } else {
            logger.debug('muting call :', this.callsTable[i].callId);
            this.muteTracks(this.callsTable[i].callLocalStream.getVideoTracks());
          }

          this.callsTable[i].isLocalVideoMuted = !this.callsTable[i].isLocalVideoMuted;
        }
      } // for
      // Handling mesh calls.


      callsNumber = this.userMediaTable.length;

      for (i = 0; i < callsNumber; i += 1) {
        userMediaStream = null;

        if (this.userMediaTable[i].callConfiguration) {
          userMediaStream = apiCC.getUserMediaStream(this.userMediaTable[i].callConfiguration.userMediaStreamId);
        }

        if (userMediaStream) {
          if (userMediaStream.videoMuted) {
            userMediaStream.unMuteVideoOnStreams("enabled");
          } else {
            userMediaStream.muteVideoOnStreams("enabled");
          }
        }
      } // for


      return {
        muteState: this.isVideoMuted,
        callId: "ALL"
      };
    } else {
      logger.debug('callId is defined :', callId);
      index = this.findCallIndexWithCallId(callId);

      if (index >= 0) {
        if (this.callsTable[index].callConfiguration) {
          userMediaStream = apiCC.getUserMediaStream(this.callsTable[index].callConfiguration.userMediaStreamId);
        }

        if (userMediaStream) {
          if (userMediaStream.videoMuted) {
            userMediaStream.unMuteVideoOnStreams("enabled");
          } else {
            userMediaStream.muteVideoOnStreams("enabled");
          }

          return {
            muteState: userMediaStream.videoMuted,
            callId: callId
          };
        } else if (this.callsTable[index].callLocalStream !== null) {
          if (this.callsTable[index].isLocalVideoMuted) {
            logger.debug('unmuting call :', this.callsTable[index].callId);
            this.unMuteTracks(this.callsTable[index].callLocalStream.getVideoTracks());
          } else {
            logger.debug('muting call :', this.callsTable[index].callId);
            this.muteTracks(this.callsTable[index].callLocalStream.getVideoTracks());
          }

          this.callsTable[index].isLocalVideoMuted = !this.callsTable[index].isLocalVideoMuted;
          return {
            muteState: this.callsTable[index].isLocalVideoMuted,
            callId: callId
          };
        }

        return {
          muteState: 'STREAM_NOT_FOUND',
          callId: callId
        };
      } else {
        // Not found in regular calls. Trying user media (mesh publish).
        userMedia = this.findUserMediaById(callId);

        if (userMedia) {
          if (userMedia.callConfiguration) {
            userMediaStream = apiCC.getUserMediaStream(userMedia.callConfiguration.userMediaStreamId);
          }

          if (userMediaStream) {
            if (userMediaStream.videoMuted) {
              userMediaStream.unMuteVideoOnStreams("enabled");
            } else {
              userMediaStream.muteVideoOnStreams("enabled");
            }

            return {
              muteState: userMediaStream.videoMuted,
              callId: callId
            };
          }
        }
      }

      return {
        muteState: 'CALL_NOT_FOUND',
        callId: callId
      };
    }
  };

  this.unMuteTracks = function (tracks) {
    var i;

    if (tracks.length === 0) {
      logger.log('No tracks available.');
      return;
    }

    for (i = 0; i < tracks.length; i += 1) {
      tracks[i].enabled = true;
    }

    logger.log('tracks unMuted.');
  };

  this.muteTracks = function (tracks) {
    var i;

    if (tracks.length === 0) {
      logger.log('No tracks available.');
      return;
    }

    for (i = 0; i < tracks.length; i += 1) {
      tracks[i].enabled = false;
    }

    logger.log('tracks muted.');
  };

  this.toggleAudioMute = function (callId) {
    logger.debug('toggleAudioMute');
    var i,
        callsNumber = this.callsTable.length,
        index = 0,
        userMedia = null,
        userMediaStream = null;

    if (callId === undefined || callId === null) {
      logger.debug('no callId defined, toggleAudioMute all local audio');

      if (this.isAudioMuted) {
        if (this.localStream !== null) {
          logger.debug('localStream unMuteTracks');
          this.unMuteTracks(this.localStream.getAudioTracks());
        }
      } else {
        if (this.localStream !== null) {
          logger.debug('localStream muteTracks');
          this.muteTracks(this.localStream.getAudioTracks());
        }
      }

      this.isAudioMuted = !this.isAudioMuted; // Handling calls (not mesh).

      for (i = 0; i < callsNumber; i += 1) {
        if (this.callsTable[i].data && this.callsTable[i].data.mesh) {
          // Mesh calls will be handled in the next loop.
          continue;
        }

        userMediaStream = null;

        if (this.callsTable[i].callConfiguration) {
          userMediaStream = apiCC.getUserMediaStream(this.callsTable[i].callConfiguration.userMediaStreamId);
        }

        if (userMediaStream) {
          if (userMediaStream.audioMuted) {
            userMediaStream.unMuteAudioOnStreams("enabled");
          } else {
            userMediaStream.muteAudioOnStreams("enabled");
          }
        } else if (this.callsTable[i].callLocalStream !== null) {
          if (this.callsTable[i].isLocalAudioMuted) {
            logger.debug('unmuting call :', this.callsTable[i].callId);
            this.unMuteTracks(this.callsTable[i].callLocalStream.getAudioTracks());
          } else {
            logger.debug('muting call :', this.callsTable[i].callId);
            this.muteTracks(this.callsTable[i].callLocalStream.getAudioTracks());
          }

          this.callsTable[i].isLocalAudioMuted = !this.callsTable[i].isLocalAudioMuted;
        }
      } // for
      // Handling mesh calls.


      callsNumber = this.userMediaTable.length;

      for (i = 0; i < callsNumber; i += 1) {
        userMediaStream = null;

        if (this.userMediaTable[i].callConfiguration) {
          userMediaStream = apiCC.getUserMediaStream(this.userMediaTable[i].callConfiguration.userMediaStreamId);
        }

        if (userMediaStream) {
          if (userMediaStream.audioMuted) {
            userMediaStream.unMuteAudioOnStreams("enabled");
          } else {
            userMediaStream.muteAudioOnStreams("enabled");
          }
        }
      } // for


      return {
        muteState: this.isAudioMuted,
        callId: "ALL"
      };
    } else {
      logger.debug('callId is defined :', callId);
      index = this.findCallIndexWithCallId(callId);

      if (index >= 0) {
        if (this.callsTable[index].callConfiguration) {
          userMediaStream = apiCC.getUserMediaStream(this.callsTable[index].callConfiguration.userMediaStreamId);
        }

        if (userMediaStream) {
          if (userMediaStream.audioMuted) {
            userMediaStream.unMuteAudioOnStreams("enabled");
          } else {
            userMediaStream.muteAudioOnStreams("enabled");
          }

          return {
            muteState: userMediaStream.audioMuted,
            callId: callId
          };
        } else if (this.callsTable[index].callLocalStream !== null) {
          if (this.callsTable[index].isLocalAudioMuted) {
            logger.debug('unmuting call :', this.callsTable[index].callId);
            this.unMuteTracks(this.callsTable[index].callLocalStream.getAudioTracks());
          } else {
            logger.debug('muting call :', this.callsTable[index].callId);
            this.muteTracks(this.callsTable[index].callLocalStream.getAudioTracks());
          }

          this.callsTable[index].isLocalAudioMuted = !this.callsTable[index].isLocalAudioMuted;
          return {
            muteState: this.callsTable[index].isLocalAudioMuted,
            callId: callId
          };
        }

        return {
          muteState: 'STREAM_NOT_FOUND',
          callId: callId
        };
      } else {
        // Not found in regular calls. Trying user media (mesh publish).
        userMedia = this.findUserMediaById(callId);

        if (userMedia) {
          if (userMedia.callConfiguration) {
            userMediaStream = apiCC.getUserMediaStream(userMedia.callConfiguration.userMediaStreamId);
          }

          if (userMediaStream) {
            if (userMediaStream.audioMuted) {
              userMediaStream.unMuteAudioOnStreams("enabled");
            } else {
              userMediaStream.muteAudioOnStreams("enabled");
            }

            return {
              muteState: userMediaStream.audioMuted,
              callId: callId
            };
          }
        }
      }

      return {
        muteState: 'CALL_NOT_FOUND',
        callId: callId
      };
    }
  };

  this.sendDTMF = function (callId, tones, duration, gap) {
    logger.debug('sendDTMF');
    var index = 0;

    if (callId === undefined || callId === null) {
      logger.debug('no callId defined, leaving sendDTMF');
      return;
    } else {
      logger.debug('callId is defined :', callId);
      index = this.findCallIndexWithCallId(callId);
      logger.debug('index :', index);

      if (index >= 0) {
        logger.debug('index :', index);
        this.callsTable[index].sendTones(tones, duration, gap);
      }
    }
  };

  function gaussianBlur(img, pixels, amount) {
    var width = img.width,
        width4 = width << 2,
        height = img.height,
        data = null,
        q = 0,
        qq = 0,
        qqq = 0,
        b0 = 0,
        b1 = 0,
        b2 = 0,
        b3 = 0,
        bigB = 0,
        c,
        y = 0,
        index = 0,
        indexLast = 0,
        pixel = 0,
        ppixel = 0,
        pppixel = 0,
        ppppixel = 0,
        x = 0;

    if (pixels) {
      data = pixels.data; // compute coefficients as a function of amount

      if (amount < 0.0) {
        amount = 0.0;
      }

      if (amount >= 2.5) {
        q = 0.98711 * amount - 0.96330;
      } else if (amount >= 0.5) {
        q = 3.97156 - 4.14554 * Math.sqrt(1.0 - 0.26891 * amount);
      } else {
        q = 2 * amount * (3.97156 - 4.14554 * Math.sqrt(1.0 - 0.26891 * 0.5));
      } //compute b0, b1, b2, and b3


      qq = q * q;
      qqq = qq * q;
      b0 = 1.57825 + 2.44413 * q + 1.4281 * qq + 0.422205 * qqq;
      b1 = (2.44413 * q + 2.85619 * qq + 1.26661 * qqq) / b0;
      b2 = -(1.4281 * qq + 1.26661 * qqq) / b0;
      b3 = 0.422205 * qqq / b0;
      bigB = 1.0 - (b1 + b2 + b3); // horizontal

      for (c = 0; c < 3; c++) {
        for (y = 0; y < height; y++) {
          // forward
          index = y * width4 + c;
          indexLast = y * width4 + (width - 1 << 2) + c;
          pixel = data[index];
          ppixel = pixel;
          pppixel = ppixel;
          ppppixel = pppixel;

          for (index = y * width4 + c; index <= indexLast; index += 4) {
            pixel = bigB * data[index] + b1 * ppixel + b2 * pppixel + b3 * ppppixel;
            data[index] = pixel;
            ppppixel = pppixel;
            pppixel = ppixel;
            ppixel = pixel;
          } // backward


          index = y * width4 + (width - 1 << 2) + c;
          indexLast = y * width4 + c;
          pixel = data[index];
          ppixel = pixel;
          pppixel = ppixel;
          ppppixel = pppixel;

          for (index = y * width4 + (width - 1 << 2) + c; index >= indexLast; index -= 4) {
            pixel = bigB * data[index] + b1 * ppixel + b2 * pppixel + b3 * ppppixel;
            data[index] = pixel;
            ppppixel = pppixel;
            pppixel = ppixel;
            ppixel = pixel;
          }
        }
      } // vertical


      for (c = 0; c < 3; c++) {
        for (x = 0; x < width; x++) {
          // forward
          index = (x << 2) + c;
          indexLast = (height - 1) * width4 + (x << 2) + c;
          pixel = data[index];
          ppixel = pixel;
          pppixel = ppixel;
          ppppixel = pppixel;

          for (index = (x << 2) + c; index <= indexLast; index += width4) {
            pixel = bigB * data[index] + b1 * ppixel + b2 * pppixel + b3 * ppppixel;
            data[index] = pixel;
            ppppixel = pppixel;
            pppixel = ppixel;
            ppixel = pixel;
          } // backward


          index = (height - 1) * width4 + (x << 2) + c;
          indexLast = (x << 2) + c;
          pixel = data[index];
          ppixel = pixel;
          pppixel = ppixel;
          ppppixel = pppixel;

          for (index = (height - 1) * width4 + (x << 2) + c; index >= indexLast; index -= width4) {
            pixel = bigB * data[index] + b1 * ppixel + b2 * pppixel + b3 * ppppixel;
            data[index] = pixel;
            ppppixel = pppixel;
            pppixel = ppixel;
            ppixel = pixel;
          }
        }
      }

      return pixels;
    }
  }

  this.xhr = function (url, data, callback, progressCallback) {
    var request = new XMLHttpRequest();

    request.onreadystatechange = function () {
      if (request.readyState === 4 && request.status === 200) {
        callback(request.responseText);
      }
    };

    if (typeof progressCallback !== 'undefined') {
      request.upload.onprogress = progressCallback;
    }

    request.open('POST', url);
    request.send(data);
  };

  this.takeSnapshot = function (postUrl, localPhotoIdOrDiv, apiKey, blurLevel, sessionId, progressCallback, videoForSnapShotId) {
    var options = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
    logger.info('takeSnapshot');
    var c = null,
        img = null,
        snapshot = document.createElement('canvas'),
        numBlurLevel,
        pixels = null,
        formData = null,
        time = new Date(),
        timetemp = time.toJSON(),
        timeInJSON = timetemp.replace(new RegExp(':', 'g'), '-'),
        videoForSnapShot = null;

    switch (blurLevel) {
      case 'Desactivated':
        numBlurLevel = 0;
        break;

      case 'Low':
        numBlurLevel = 2;
        break;

      case 'Medium':
        numBlurLevel = 4;
        break;

      case 'High':
        numBlurLevel = 6;
        break;

      default:
        logger.log('blurLevel not defined switch case : ' + blurLevel);
        numBlurLevel = 0;
        break;
    } //Modif to improve


    if (videoForSnapShotId !== undefined) {
      logger.log("takeSnapshot of defined video Id :" + videoForSnapShotId);
      videoForSnapShot = document.getElementById(videoForSnapShotId);

      if (videoForSnapShot === null) {
        logger.log("Cannot find video with Id :" + videoForSnapShotId);
        logger.log("Leaving takeSnapshot");
        this.myWebRTC_Event.createErrorEvent('localVideo Div Name is not correct for takeSnapshot', 'INCORRECT_VIDEOID_FOR_SNAPSHOT');
        return; //Leaving takeSnapshot
      }
    } else {
      //Modif TEMP to keep compatibility with apiRTC <= 2.7
      logger.warn("ApiRTC DEPRECATED : Please add videoId for TakeSnapshot");
      logger.log("Leaving takeSnapshot");
      this.myWebRTC_Event.createErrorEvent('Deprecated - localVideo Div Name is not correct for takeSnapshot', 'INCORRECT_VIDEOID_FOR_SNAPSHOT');
      return; //Leaving takeSnapshot
    } // Make the canvas the same size as the live video


    snapshot.width = videoForSnapShot.videoWidth;
    snapshot.height = videoForSnapShot.videoHeight;

    if (options.hasOwnProperty('width')) {
      logger.debug('options.width is set :' + options.width);
      snapshot.width = options.width;
    }

    if (options.hasOwnProperty('height')) {
      logger.debug('options.height is set :' + options.height);
      snapshot.height = options.height;
    }

    logger.log('snapshot.width : ' + snapshot.width);
    logger.log('snapshot.height :' + snapshot.height); // Draw a frame of the live video onto the canvas

    c = snapshot.getContext('2d');
    c.drawImage(videoForSnapShot, 0, 0, snapshot.width, snapshot.height); // Create an image element with the canvas image data

    img = document.createElement('img');
    img.src = snapshot.toDataURL('image/png');
    img.style.padding = 5; //img.width = snapshot.width / 2;
    //img.height = snapshot.height / 2;

    img.width = snapshot.width;
    img.height = snapshot.height;

    if (numBlurLevel !== 0) {
      //Adding Blur on Photo
      logger.log('Adding Blur on Photo');
      pixels = c.getImageData(0, 0, snapshot.width, snapshot.height);
      logger.log('av pixels data : ' + pixels.data);
      pixels = gaussianBlur(img, pixels, numBlurLevel);
      logger.log('ap pixels data : ' + pixels.data); // redraw the pixel data back to the working buffer

      c.putImageData(pixels, 0, 0);
      img.src = snapshot.toDataURL('image/png');
    } else {
      logger.log('blur on photo is desactivated');
    } //Affichage photo cot client


    if (_typeof(localPhotoIdOrDiv) === "object") {
      //logger.log('Object');
      if (localPhotoIdOrDiv !== null) {
        localPhotoIdOrDiv.src = img.src;
      } else {
        logger.log('localPhotoIdOrDiv is null');
      }
    } else {
      //logger.log('Div name');
      if (document.getElementById(localPhotoIdOrDiv) !== null) {
        document.getElementById(localPhotoIdOrDiv).src = img.src;
      } else {
        logger.log('localPhotoId is not defined');
      }
    } //Sending Photo on server

    /*
            //Mthode jQuery : OK mais a ne pas utiliser
            $.post(postUrl, {photo: snapshot.toDataURL('image/png'), clientId : this.clientId}, function (data) {
                //$('.result').html(data);
                //logger.log('result data =' + data);
            });
    */
    //logger.log('posting new photo to server');


    formData = new FormData();

    if (sessionId !== undefined) {
      //Code pour upload sur cloud.apizee.com
      logger.log("sessionId !== undefined :" + sessionId);
      formData.append('destFileName', this.clientId + '-' + timeInJSON + '.png');
      formData.append('data', snapshot.toDataURL('image/png'));
      formData.append('sessionId', sessionId);
    } else {
      //Code pour upload sur data1.apizee.com
      logger.log("Upload on data1");
      formData.append('photo', snapshot.toDataURL('image/png'));
      formData.append('clientId', this.clientId);
      formData.append('apiKey', apiCC.session.apiKey);
    }

    this.xhr(postUrl, formData, function (fileName) {
      logger.log("fileName :", fileName); //Loading on cloud.apizee.com

      if (fileName !== null) {
        try {
          var filePath = JSON.parse(fileName);

          if (filePath.resultCode === "OK") {
            logger.log("files loaded, filename :" + filePath.fileUrl);
            myWebRTC_Event.createSnapShotPhotoUploaded(filePath.fileUrl);
          }
        } catch (e) {
          logger.log("Parsing error:", e);
        }
      }

      if (fileName === 'Photo received' || fileName === 'An error occurred.' || fileName.substring(0, 6) === "Photo-") {
        //Photo received
        myWebRTC_Event.createSnapShotPhotoUploaded(fileName);
      }
    }, progressCallback);
    /*
            xhreq = new XMLHttpRequest();
            sVar1 = encodeURIComponent(snapshot.toDataURL('image/png'));
            sVar2 = encodeURIComponent(this.clientId);
            sVar3 = encodeURIComponent(apiKey);
            params = "photo=" + sVar1 + "&clientId=" + sVar2 + "&apiKey=" + sVar3;
    
            xhreq.open("POST", postUrl, true);
            xhreq.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            //xhreq.setRequestHeader("Content-length", params.length);
            //xhreq.setRequestHeader("Connection", "close");
    
            xhreq.onreadystatechange = function () {
                logger.log('onreadystatechange');
    
                logger.log('xhreq.status' + xhreq.status);
    
                var serverresponse = xhreq.responsetext;
    
                logger.log('serverresponse 1 :' + serverresponse);
    
                if (xhreq.readystate != 4) {
                    logger.log('xhreq.readystate != 4');
                    return;
                }
                var serverresponse = xhreq.responsetext;
    
                logger.log('serverresponse :' + serverresponse);
            };
            logger.log('before send');
            xhreq.send(params);
            logger.log('after send');
    */
  };

  this.takeSnapshotAndSendOnDataChannel = function (localPhotoIdOrDiv, videoForSnapShotId, callId, onProgress) {
    logger.info('takeSnapshotAndSendOnDataChannel');
    var c = null,
        img = null,
        snapshot = document.createElement('canvas'),
        videoForSnapShot = null,
        data = null;

    if (videoForSnapShotId !== undefined) {
      logger.log("takeSnapshot of defined video Id :" + videoForSnapShotId);
      videoForSnapShot = document.getElementById(videoForSnapShotId);

      if (videoForSnapShot === null) {
        logger.log("Cannot find video with Id :" + videoForSnapShotId);
        logger.log("Leaving takeSnapshot");
        this.myWebRTC_Event.createErrorEvent('localVideo Div Name is not correct for takeSnapshot', 'INCORRECT_VIDEOID_FOR_SNAPSHOT');
        return; //Leaving takeSnapshot
      }
    } else {
      logger.warn("ApiRTC DEPRECATED : Please add videoId for TakeSnapshot");
    }

    if (videoForSnapShot !== undefined && videoForSnapShot !== null) {
      // Make the canvas the same size as the live video
      snapshot.width = videoForSnapShot.clientWidth;
      snapshot.height = videoForSnapShot.clientHeight;
    }

    logger.log('snapshot.width : ' + snapshot.width);
    logger.log('snapshot.height :' + snapshot.height); // Draw a frame of the live video onto the canvas

    c = snapshot.getContext('2d');
    c.drawImage(videoForSnapShot, 0, 0, snapshot.width, snapshot.height); // Create an image element with the canvas image data

    img = document.createElement('img');
    img.src = snapshot.toDataURL('image/png');
    img.style.padding = 5; //img.width = snapshot.width / 2;
    //img.height = snapshot.height / 2;

    img.width = snapshot.width;
    img.height = snapshot.height; //Affichage photo cot client

    if (_typeof(localPhotoIdOrDiv) === "object") {
      //logger.log('Object');
      if (localPhotoIdOrDiv !== null) {
        localPhotoIdOrDiv.src = img.src;
      } else {
        logger.log('localPhotoIdOrDiv is null');
      }
    } else {
      //logger.log('Div name');
      if (document.getElementById(localPhotoIdOrDiv) !== null) {
        document.getElementById(localPhotoIdOrDiv).src = img.src;
      } else {
        logger.log('localPhotoId is not defined');
      }
    } //Sending snapshot on DataChannel


    data = snapshot.toDataURL("image/png");
    this.sendDataWithCallId(callId, {
      "file": data,
      "name": 'nomFichier',
      "type": 'image/png-dataUrl'
    }, onProgress);
  }; //TODO setTimeout(this.initialize, 1); //TODO Voir ou mettre : a remonter


  this.callWithNumber = function (number, videoActivated, data, callConfiguration) {
    logger.info('Click on Call Button, video activated : ' + videoActivated);
    logger.log('callConfiguration : ', callConfiguration);
    var call = null,
        callNumber = 0,
        callId = null,
        userInfo = null,
        userInfoJson = null,
        startWithSipPrefix = false,
        userMediaStream = null,
        localUserMediaStreamId = null;

    if (typeof number === "number") {
      logger.log('called number type is number, converting to string');
      number = number.toString();
    }

    if (number !== '' && number !== this.clientId) {
      call = new _WebRTC_Call__WEBPACK_IMPORTED_MODULE_7__.WebRTC_Call(this);
      call.instanceId = apiCC.generateInstanceId();
      logger.log('Calling destination number :' + number);

      if (callConfiguration === undefined || callConfiguration === null) {
        call.generateCallId();
      } else {
        if (callConfiguration.apzcallId === undefined || callConfiguration.apzcallId === null) {
          call.generateCallId(); //Client is caller : generation of CallId
        } else {
          //getting callId in callconfiguration
          call.callId = callConfiguration.apzcallId; //case with WebRTC plugin
        }
      }

      if (apiCC.isSIPNumber(number) === true) {
        logger.log("Prefix 0 , + , or 'sip:' detected, calling a SIP device");
        startWithSipPrefix = number.toString().startsWith('sip:');

        if (startWithSipPrefix === true) {
          number = number.toString().replace('sip:', '');
          logger.log("called SIP number is :", number);
        }

        if (data !== undefined && data !== null) {
          data.pubSub = 'sipConnector';
        } else {
          data = {};
          data.pubSub = 'sipConnector';
        } //this a call from SIP, deactivating trickleIce


        call.trickleIce = false;
      } else {
        logger.log("Establishing Web call");
      }

      call.callerId = this.clientId;
      call.calleeId = number;
      call.dest_roomId = number;
      call.audioOnly = !videoActivated;
      call.remoteId = number;
      call.callConfiguration = callConfiguration;

      if (callConfiguration !== undefined && callConfiguration !== null) {
        if (callConfiguration.mediaTypeForOutgoingCall === 'VIDEO' || callConfiguration.mediaTypeForOutgoingCall === 'AUDIO' || callConfiguration.mediaTypeForOutgoingCall === 'VIDEOONLY' || callConfiguration.mediaTypeForOutgoingCall === 'NONE') {
          logger.log('Setting mediaTypeForOutgoingCall :' + callConfiguration.mediaTypeForOutgoingCall);
          call.mediaTypeForOutgoingCall = callConfiguration.mediaTypeForOutgoingCall;
        } else {
          logger.log('mediaTypeForOutgoingCall is not set');

          if (videoActivated === false) {
            logger.log('videoActivated is false, setting mediaTypeForOutgoingCall to AUDIO');
            call.mediaTypeForOutgoingCall = 'AUDIO';
          }
        }

        if (callConfiguration.mediaRoutingMode !== undefined && callConfiguration.mediaRoutingMode !== null) {
          call.setCallMediaRoutingMode(callConfiguration.mediaRoutingMode);
        }

        if (callConfiguration.turnServerAddress !== undefined && callConfiguration.turnServerAddress !== null) {
          call.setCallTurnServer(callConfiguration.turnServerAddress);
        }

        if (callConfiguration.preferVP9Codec === true || callConfiguration.preferVP9Codec === false) {
          call.preferVP9Codec = callConfiguration.preferVP9Codec;
        }

        if (callConfiguration.hasOwnProperty('forceCallType')) {
          call.callType = callConfiguration.forceCallType;

          if (call.callType === "screenSharing" || call.callType === "screenSharingWithAudio") {
            call.screenSharing = true;
          }
        }
      } else {
        logger.log('callConfiguration is not set');
      } // Setting the pubSub when the call requires an MCU


      if (data !== undefined && data.MCUType !== undefined) {
        if (data.MCUType === 'MCU-Caller' || data.MCUType === 'MCU-Callee') {
          if (this.MCUClient.pubConnector === 'janusConnector') {
            if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Firefox') {
              if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version > 43) {
                call.mediaConstraints = {
                  "offerToReceiveAudio": false,
                  "offerToReceiveVideo": false
                };
              } else {
                call.mediaConstraints = {
                  'mandatory': {
                    'OfferToReceiveAudio': false,
                    'OfferToReceiveVideo': false
                  }
                };
              }
            }
          }

          data.pubSub = this.MCUClient.pubConnector;
          data.videoBandwidthSettings = this.videoBandwidthSettings; //logger.debug('data.pubSub :', data.pubSub);

          if (data.pubSub === "groupKurentoConnector") {
            //Record 1-1 : need to use kurentoConnector instead of groupKurentoConnector
            data.pubSub = "kurentoConnector";
          }
        }
      }

      call.checkDTLSCompliancy();
      callId = call.callId;
      userInfo = apiCC.session.getConnectedUserInfo(number, 'userData');
      logger.log("userInfo :", userInfo);

      if (userInfo !== 'User_Not_Found' && userInfo !== undefined) {
        userInfoJson = JSON.parse(userInfo);

        if (userInfoJson !== undefined && userInfoJson.react === "true") {
          logger.log("userInfoJson.react :", JSON.stringify(userInfoJson.react));
          logger.log("userInfoJson.osName :", JSON.stringify(userInfoJson.osName));

          if (userInfoJson.osName === "iOS") {
            logger.log("Callee : React and iOS detected, setting H264 as preferred codec for the call");
            call.preferH264Codec = true;
          }
        }
      }

      if (call.audioOnly === true) {
        call.callType = "audio";
      }

      if (data !== undefined) {
        call.data = data;
      } else {
        data = {};
      } // Fix legacy cloudConvId.


      if (data.convId) {
        if (!data.cloudConvId) {
          data.cloudConvId = data.convId;
        }

        delete data.convId;
      }

      if (data.dataCall === true) {
        call.dataCall = true;
      }

      call.data.instanceId = call.instanceId;
      callNumber = this.callsTable.push(call);
      logger.log('Call Number is :' + callNumber);

      if (call.data && call.data.MCUType === 'MCU-Caller' && call.mediaTypeForOutgoingCall === 'NONE') {
        // Recorded 1-to-1 call initially established without sharing any media.
        call.inviteSended = true;
        call.myWebRTC_Stack.sendInvite(call.callId, call.callerId, this.nickname, call.dest_roomId, call.dest_roomId, 'none', {
          offer: {
            type: 'no-offer'
          },
          data: call.data
        });
        return call.callId;
      }

      if (call.data && call.data.MCUType === 'MCU-Caller') {
        // Auto restart context.
        call.settingUpType = 'publish';
        call.callControl = this.createCallControl({
          type: 'publish',
          callId: call.callId,
          roomName: call.data.confId,
          callConfiguration: call.callConfiguration,
          data: call.data
        });
        call.callControl.sessionId = call.data.confId;
        call.callControl.token = call.data.confId;
        call.callControl.autoRestart.counter = 0; // Set mediaConstraints to have a sendOnly offer.

        call.setMediaConstraintsToSendOnlyOffer();
      }

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(callConfiguration, 'userMediaStreamId', 'string')) {
        localUserMediaStreamId = callConfiguration.userMediaStreamId;
      }

      if (userInfoJson !== undefined && userInfoJson !== null && userInfoJson.isSimulated === "true") {
        apiCC.session.channel.socket.emit('simulatedAgentCallRequest', {
          number: number,
          call: call,
          videoActivated: videoActivated,
          data: data,
          callConfiguration: {
            apzcallId: call.callId
          }
        });
      } else {
        if (this.accessToLocalMedia === true && this.autoAnswer === true || call.dataCall || localUserMediaStreamId) {
          if (call.dataCall) {
            logger.log('Datachannel call');
            call.establishCall();
          } else {
            logger.log('callWithNumber :: User has already granted access to local media and AutoAnswer activated : establishing call');

            if (localUserMediaStreamId) {
              userMediaStream = apiCC.getUserMediaStream(localUserMediaStreamId);
              userMediaStream.addCallInfo(call.callId);

              if (call.callConfiguration === undefined || call.callConfiguration === null) {
                call.callConfiguration = {};
              }

              call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
              call.onUserMediaSuccessOnCall(userMediaStream.stream);
            } else {
              call.establishCall();
            }
          }
        } else {
          if (data.MCUType === 'MCU-Callee' && this.userAcceptOnIncomingCallBeforeGetUserMedia === true) {
            logger.log('Stand-by :: wait for AcceptCall on recorded 1to1 call');
          } else {
            call.getUserMediaOnCall();
          }
        }
      }
    } else {
      logger.log('Call Number is incorrect');
    }

    return callId;
  };

  this.startTestCall = function (videoActivated, callConfiguration) {
    logger.info('startTestCall : video activated : ' + videoActivated);
    var call = null,
        callNumber = 0,
        callId = null,
        userMediaStream = null,
        data = {};
    call = new _WebRTC_Call__WEBPACK_IMPORTED_MODULE_7__.WebRTC_Call(this);
    call.generateCallId(); //Client is caller : generation of CallId

    call.instanceId = apiCC.generateInstanceId();
    call.callerId = this.clientId;
    call.calleeId = 12345;
    call.dest_roomId = 12345;
    call.audioOnly = !videoActivated;
    call.remoteId = 12345;
    call.callConfiguration = callConfiguration;

    if (callConfiguration !== undefined && callConfiguration !== null) {
      if (callConfiguration.mediaTypeForOutgoingCall === 'VIDEO' || callConfiguration.mediaTypeForOutgoingCall === 'AUDIO' || callConfiguration.mediaTypeForOutgoingCall === 'VIDEOONLY' || callConfiguration.mediaTypeForOutgoingCall === 'NONE') {
        logger.log('Setting mediaTypeForOutgoingCall :' + callConfiguration.mediaTypeForOutgoingCall);
        call.mediaTypeForOutgoingCall = callConfiguration.mediaTypeForOutgoingCall;
      } else {
        logger.log('mediaTypeForOutgoingCall is not set');
      }

      if (callConfiguration.mediaRoutingMode !== undefined && callConfiguration.mediaRoutingMode !== null) {
        call.setCallMediaRoutingMode(callConfiguration.mediaRoutingMode);
      }

      if (callConfiguration.turnServerAddress !== undefined && callConfiguration.turnServerAddress !== null) {
        call.setCallTurnServer(callConfiguration.turnServerAddress);
      }

      if (callConfiguration.preferVP9Codec === true || callConfiguration.preferVP9Codec === false) {
        call.preferVP9Codec = callConfiguration.preferVP9Codec;
      }
    } else {
      logger.log('callConfiguration is not set');
      callConfiguration = {};
    }

    call.checkDTLSCompliancy();
    callId = call.callId;
    data.pubSub = 'testCallKurentoConnector';
    call.data = data;
    call.data.instanceId = call.instanceId;

    if (call.audioOnly === true) {
      call.callType = "audio";
    }

    callNumber = this.callsTable.push(call);
    logger.log('Call Number is :' + callNumber);

    if (this.accessToLocalMedia === true && this.autoAnswer === true || call.dataCall || callConfiguration.userMediaStreamId || apiCC.userMediaStreamTable.length > 0) {
      if (call.dataCall) {
        logger.log('Datachannel call');
        call.establishCall();
      } else {
        logger.log('startTestCall :: User has already granted access to local media and AutoAnswer activated : establishing call');

        if (callConfiguration.userMediaStreamId) {
          userMediaStream = apiCC.getUserMediaStream(callConfiguration.userMediaStreamId);
          userMediaStream.addCallInfo(call.callId);

          if (call.callConfiguration === undefined || call.callConfiguration === null) {
            call.callConfiguration = {};
          }

          call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
          call.callLocalStream = userMediaStream.stream;
          call.establishCall();
        } else if (apiCC.userMediaStreamTable.length > 0) {
          userMediaStream = apiCC.userMediaStreamTable[0];
          userMediaStream.addCallInfo(call.callId);

          if (call.callConfiguration === undefined || call.callConfiguration === null) {
            call.callConfiguration = {};
          }

          call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
          call.callLocalStream = userMediaStream.stream;
          call.establishCall();
        } else {
          call.establishCall();
        }
      }
    } else {
      call.getUserMediaOnCall();
    }

    return callId;
  };

  this.extensionInstallationSuccessCallback = function () {
    logger.debug("extensionInstallationSuccessCallback");
    apiCC.session.apiCCWebRTCClient.webRTCClient.apiRTCExtensionInstalled = true;
    /*
            logger.log('this.waitingShareScreenCallId :' + this.waitingShareScreenCallId);
    
            if (this.waitingShareScreenCallId !== 0) {
    
                window.postMessage({command: "getDesktopId",
                                    callNumber: this.waitingShareScreenCallId,
                                    remoteId: this.waitingShareScreenDestNumber}, '*');
    
                this.waitingShareScreenCallId = 0;
                this.waitingShareScreenDestNumber = 0;
            }
    */
  };
  /*
      this.extensionInstallationFailureCallback = function () {
          logger.log("extensionInstallationFailureCallback");
          myWebRTC_Event.createDesktopCaptureEvent("Extension_installation_Error");
      };
  */


  this.extensionInstallationFailureCallback = function (error, errorCode) {
    logger.debug("extensionInstallationFailureCallback : Error :" + error + ', ' + errorCode);
    error = null;
    errorCode = null;
    myWebRTC_Event.createDesktopCaptureEvent("Extension_installation_Error", this.waitingShareScreenCallId, this.waitingShareScreenDestNumber, this.waitingCaptureSourceType);
  };

  this.manageNotInstalledExtension = function (callId, remoteId, captureSourceType) {
    logger.debug('manageNotInstalledExtension');
    logger.warn('apiRTC extension not installed');
    myWebRTC_Event.createDesktopCaptureEvent("Extension_not_installed", callId, remoteId);
    logger.warn('Starting apiRTC extension installation');
    this.waitingShareScreenDestNumber = remoteId;
    this.waitingShareScreenCallId = callId;
    this.waitingCaptureSourceType = captureSourceType;
    chrome.webstore.install("https://chrome.google.com/webstore/detail/mjjnofoemoepfididplbfimokpnpcoeg", this.callback(this, 'extensionInstallationSuccessCallback'), this.callback(this, 'extensionInstallationFailureCallback'));
  };

  this.shareScreen = function (number, data, captureSourceType, callConfiguration, options) {
    logger.info('shareScreen');
    var callId = null,
        call = null,
        userMedia = null,
        userMediaStream = null;

    if (apiCC.isScreenSharingCompliant() === true) {
      if (number !== '' && number !== this.clientId) {
        if (data === null || _typeof(data) !== 'object') {
          data = {};
        }

        if (this.MCUClient.pubConnector === 'janusConnector' && !data.mesh && options && options.callControl && options.callControl.callId) {
          if (this.findCallWithCallId(options.callControl.callId)) {
            // call already exists
            logger.debug('call already exists', options.callControl.callId);
            return options.callControl.callId;
          }
        }

        if (callConfiguration === null || _typeof(callConfiguration) !== 'object') {
          callConfiguration = {};
        }

        if (callConfiguration.qos !== null && _typeof(callConfiguration.qos) === 'object') {
          // QoS preferences is given.
          data.qos = {};

          if (callConfiguration.qos.videoMinQuality === 'excellent') {
            data.qos.videoMinQuality = 'excellent';
          } else if (callConfiguration.qos.videoMinQuality === 'good') {
            data.qos.videoMinQuality = 'good';
          } else if (callConfiguration.qos.videoMinQuality === 'medium') {
            data.qos.videoMinQuality = 'medium';
          } else if (callConfiguration.qos.videoMinQuality === 'bad') {
            data.qos.videoMinQuality = 'bad';
          } else {
            data.qos.videoMinQuality = 'bad';
          }

          if (callConfiguration.qos.videoForbidInactive === true) {
            data.qos.videoForbidInactive = true;
          }
        } else {
          // Default QoS preferences.
          data.qos = {
            'videoMinQuality': 'bad'
          };
        } // audioLabels and videoLabels.


        ['audioLabels', 'videoLabels'].forEach(function (item) {
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration[item], 'array')) {
            data[item] = [];
            callConfiguration[item].forEach(function (l) {
              if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(l, 'string')) {
                data[item].push(l);
              }
            });
          }
        }); // User defined context.

        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'context', 'object')) {
          try {
            JSON.stringify(callConfiguration.context);
            data.context = callConfiguration.context;
          } catch (e) {}
        }

        logger.log('shareScreen; callConfiguration: ' + JSON.stringify(callConfiguration));
        call = new _WebRTC_Call__WEBPACK_IMPORTED_MODULE_7__.WebRTC_Call(apiCC.session.apiCCWebRTCClient.webRTCClient); //If mesh data we re-use same instanceId

        if (data.mesh !== undefined && data.instanceId !== undefined) {
          logger.debug("keeping instanceId ");
          call.instanceId = data.instanceId;
        } else {
          call.instanceId = apiCC.generateInstanceId();
        }

        logger.log('Calling destination number :' + number);
        var sessionMCU = this.MCUClient.getSessionMCU(number);

        if (sessionMCU) {
          call.sessionMCU = sessionMCU;
        } // Support for auto restart. This block will set the callId; either generated or
        // inferred from previous call.


        if (call.sessionMCU && this.MCUClient.pubConnector === 'janusConnector' && !data.mesh) {
          call.settingUpType = 'shareScreen';

          if (options && options.callControl) {
            // call restart
            call.callControl = options.callControl;
            call.callControl.autoRestart.counter += 1;
            call.callId = call.callControl.callId;
            call.restarted = true;
          } else {
            // initial call
            call.callControl = this.createCallControl({
              type: 'shareScreen',
              roomName: number,
              callConfiguration: callConfiguration,
              data: data
            });
            call.callControl.captureSourceType = captureSourceType;
            call.callControl.autoRestart.counter = 0;
            call.generateCallId();
            call.callControl.callId = call.callId;
          }
        } else {
          call.settingUpType = 'shareScreen';
          call.generateCallId();
        }

        callId = call.callId;
        call.callerId = this.clientId;
        call.calleeId = number;
        call.dest_roomId = number;
        call.audioOnly = false;
        call.screenSharing = true;
        call.remoteId = number;
        call.callType = "screenSharing";
        call.captureSourceType = captureSourceType;
        call.callConfiguration = callConfiguration;
        call.data = data;
        call.data.instanceId = call.instanceId;

        if (callConfiguration !== null && callConfiguration !== undefined) {
          if (callConfiguration.turnServerAddress !== undefined && callConfiguration.turnServerAddress !== null) {
            call.setCallTurnServer(callConfiguration.turnServerAddress);
          }
        }

        call.checkDTLSCompliancy();
        apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable.push(call);

        if (call.sessionMCU && this.MCUClient.pubConnector === 'janusConnector' && call.callControl && call.callControl.autoRestart.stream) {
          logger.debug('shareScreen; autoRestart'); // Setting stream for call.

          apiCC.session.apiCCWebRTCClient.webRTCClient.accessToLocalMedia = true;
          call.callLocalStream = call.callControl.autoRestart.stream;
          call.establishCall();
          return call.callId;
        } // Testing whether the desired published stream is given.


        if (data !== undefined && data.mesh !== undefined && (userMedia = apiCC.session.apiCCWebRTCClient.webRTCClient.findUserMediaById(data.mesh.calleeCallId)) !== null && userMedia.callConfiguration && userMedia.callConfiguration.userMediaStreamId) {
          userMediaStream = apiCC.getUserMediaStream(userMedia.callConfiguration.userMediaStreamId);
          userMediaStream.addCallInfo(call.callId);
          apiCC.session.apiCCWebRTCClient.webRTCClient.accessToLocalMedia = true;

          if (call.sessionMCU && apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.pubConnector === 'janusConnector' && call.callControl) {
            // Setting stream for auto restart.
            call.callControl.autoRestart.stream = userMediaStream.stream;
          }

          call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
          call.callLocalStream = userMediaStream.stream;
          call.establishCall();
          return call.callId;
        } // no stream, getting one!


        apiCC.createUserMediaStream({
          'callId': call.callId,
          // Linking getUserMedia to this call.
          'type': call.callType,
          'captureSourceType': captureSourceType,
          'success': function success(userMediaStream) {
            logger.debug('[shareScreen] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
            apiCC.session.apiCCWebRTCClient.webRTCClient.accessToLocalMedia = true;

            if (call.sessionMCU && apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.pubConnector === 'janusConnector' && call.callControl) {
              // Setting stream for auto restart.
              call.callControl.autoRestart.stream = userMediaStream.stream;
            }

            call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
            call.callLocalStream = userMediaStream.stream;
            call.establishCall();
          }
        });
      } else {
        logger.log('Call Number is incorrect');
      }
    } else {
      logger.log('shareScreen is not supported on this browser');
      myWebRTC_Event.createDesktopCaptureEvent("Browser_Not_Compatible", callId, number);
    }

    logger.info('shareScreen, callId :', callId);
    return callId;
  };

  this.startScreenSharingOnCall = function (callId, captureSourceType) {
    logger.info('getScreenMedia for callId :' + callId);
    var call = null;

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Chrome') {
      call = this.findCallWithCallId(callId);

      if (call !== null) {
        if (this.apiRTCExtensionInstalled === false) {
          this.manageNotInstalledExtension(call.callId, call.remoteId, captureSourceType);
          return;
        }

        if (captureSourceType === undefined || captureSourceType === null) {
          captureSourceType = ["screen", "window", "tab"];
        }

        window.postMessage({
          // NOSONAR
          command: "getDesktopId",
          callNumber: call.callId,
          remoteId: call.remoteId,
          captureSourceType: captureSourceType,
          browser_major_version: _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version
        }, '*'); //Check in initialize() for message coming from extension handler
      } else {
        logger.log("call not found");
      }
    } else {
      logger.log('shareScreen is only available for chrome Browser');
      myWebRTC_Event.createDesktopCaptureEvent("Browser_Not_Compatible", callId, null);
    }
  };

  this.toggleVideoScreen = function (callId) {
    logger.info('toggleVideoScreen for callId :' + callId);
    var call = this.findCallWithCallId(callId);

    if (call !== null) {
      call.toggleVideoScreen();
    } else {
      logger.log("call not found");
    }
  };

  this.addVideoMedia = function (callId) {
    logger.info('webRTCClient::addVideoMedia for callId :' + callId);
    var call = this.findCallWithCallId(callId);

    if (call !== null) {
      call.addVideoMedia();
    } else {
      logger.log("call not found");
    }
  };

  function checkMail(mailToTest) {
    var reg = new RegExp('^[0-9a-z._-]+@{1}[0-9a-z.-]{2,}[.]{1}[a-z]{2,5}$', 'i');
    return reg.test(mailToTest);
  }

  this.callbymail = function (dest_mailaddress) {
    logger.info('Click on Call per mail Button');

    if (checkMail(dest_mailaddress)) {
      logger.log('Calling Destination mail :' + dest_mailaddress);
      this.socket.emit('webrtc_invite_permail', dest_mailaddress);
      session.channel.socket.emit('webrtc_invite_permail', dest_mailaddress);
    } else {
      logger.log('Mail address is not correct :' + dest_mailaddress);
    }
  };

  this.callperURL = function (destRoom) {
    logger.info('Call per URL');
    var call = null,
        callNumber = 0;
    call = new _WebRTC_Call__WEBPACK_IMPORTED_MODULE_7__.WebRTC_Call(this);
    call.instanceId = apiCC.generateInstanceId();
    logger.log('Calling Destination number :' + destRoom);
    call.generateCallId(); //Client is caller : generation of CallId

    call.callerId = this.clientId;
    call.calleeId = destRoom;
    call.dest_roomId = destRoom;
    call.audioOnly = false;
    call.getUserMediaOnCall();
    call.remoteId = destRoom;
    call.checkDTLSCompliancy();
    callNumber = this.callsTable.push(call);
    logger.log('Call Number is :' + callNumber);
  };

  this.acceptCall = function (callId, callConfiguration) {
    logger.info('acceptCall for callId :' + callId);
    logger.log('acceptCall() - callConfiguration : ', callConfiguration);
    var call = null,
        userMediaStream = null;
    call = this.findCallWithCallId(callId);

    if (call !== null) {
      logger.log("acceptCall() - Call found");
      call.isAccepted = true;

      if (callConfiguration !== null && callConfiguration !== undefined) {
        if (callConfiguration.mediaTypeForIncomingCall === 'VIDEO' || callConfiguration.mediaTypeForIncomingCall === 'AUDIO' || callConfiguration.mediaTypeForIncomingCall === 'VIDEOONLY' || callConfiguration.mediaTypeForIncomingCall === 'NONE' || callConfiguration.mediaTypeForIncomingCall === 'DATA') {
          logger.log('acceptCall() - Setting mediaTypeForIncomingCall :' + callConfiguration.mediaTypeForIncomingCall);
          call.mediaTypeForIncomingCall = callConfiguration.mediaTypeForIncomingCall;
        } else {
          logger.log('acceptCall() - mediaTypeForIncomingCall is not set');
        }

        if (callConfiguration.mediaRoutingMode !== undefined && callConfiguration.mediaRoutingMode !== null) {
          call.setCallMediaRoutingMode(callConfiguration.mediaRoutingMode);
        }

        if (callConfiguration.turnServerAddress !== undefined && callConfiguration.turnServerAddress !== null) {
          call.setCallTurnServer(callConfiguration.turnServerAddress);
        }

        if (callConfiguration.preferVP9Codec === true || callConfiguration.preferVP9Codec === false) {
          call.preferVP9Codec = callConfiguration.preferVP9Codec;
        }
      } else {
        logger.log('acceptCall() - callConfiguration is not set');
        callConfiguration = {};
      }

      if (call.screenSharing === true) {
        logger.log('acceptCall() for screenSharing : forcing mediaTypeForIncomingCall to NONE');
        callConfiguration.mediaTypeForIncomingCall = 'NONE';
        call.mediaTypeForIncomingCall = 'NONE';
      }

      call.callConfiguration = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.mergeJSON)(call.callConfiguration, callConfiguration); // Set localCallProfile and callType now because Firefox triggers the remoteStreamAdded
      // event before we set the local description (SDP answer).

      if (call.mediaTypeForIncomingCall === 'VIDEO') {
        call.setLocalCallProfile({
          audio: true,
          audioActive: true,
          video: true,
          videoActive: true
        });
      } else if (call.mediaTypeForIncomingCall === 'AUDIO') {
        call.setLocalCallProfile({
          audio: true,
          audioActive: true,
          video: false,
          videoActive: false
        });
      } else if (call.mediaTypeForIncomingCall === 'VIDEOONLY') {
        call.setLocalCallProfile({
          audio: false,
          audioActive: false,
          video: true,
          videoActive: true
        });
      } else if (call.mediaTypeForIncomingCall === 'NONE') {
        call.setLocalCallProfile({
          audio: false,
          audioActive: false,
          video: false,
          videoActive: false
        });
      }

      if (call.data && call.data.MCUType === 'MCU-Callee' && call.mediaTypeForIncomingCall === 'NONE') {
        // Recorded 1-to-1 call initially established without sharing any media.
        call.myWebRTC_Stack.sendInvite(call.callId, call.callerId, this.nickname, call.dest_roomId, call.dest_roomId, 'none', {
          offer: {
            type: 'no-offer'
          },
          data: call.data
        });
        return;
      }

      if (call.data && call.data.MCUType === 'MCU-Callee') {
        // In case of recording call, the callee is actually calling the SFU.
        call.mediaTypeForOutgoingCall = call.mediaTypeForIncomingCall; // Auto restart context.

        call.settingUpType = 'publish';
        call.callControl = this.createCallControl({
          type: 'publish',
          callId: call.callId,
          roomName: call.data.confId,
          callConfiguration: call.callConfiguration,
          data: call.data
        });
        call.callControl.sessionId = call.data.confId;
        call.callControl.token = call.data.confId;
        call.callControl.autoRestart.counter = 0; // Set mediaConstraints to have a sendOnly offer.

        call.setMediaConstraintsToSendOnlyOffer();
      }

      if (this.unidirectionelCallOnly) {
        logger.log('acceptCall() - unidirectional call');
        call.onUserMediaSuccessTestUni();
      } else {
        if (this.userAcceptOnIncomingCallBeforeGetUserMedia === true) {
          logger.log('acceptCall with userAcceptOnIncomingCallBeforeGetUserMedia');

          if (callConfiguration.userMediaStreamId) {
            userMediaStream = apiCC.getUserMediaStream(callConfiguration.userMediaStreamId);
            userMediaStream.addCallInfo(call.callId);

            if (call.callConfiguration === undefined || call.callConfiguration === null) {
              call.callConfiguration = {};
            }

            call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
            call.onUserMediaSuccessOnCall(userMediaStream.stream);
          } else {
            call.getUserMediaOnCall();
          }
        } else {
          if (call.accessToMedia === true || callConfiguration.userMediaStreamId || call.dataCall) {
            logger.log('acceptCall() :: User has already granted access to local media and AutoAnswer activated : establishing call');

            if (call.dataCall) {
              call.establishCall();
            } else {
              if (callConfiguration.userMediaStreamId) {
                userMediaStream = apiCC.getUserMediaStream(callConfiguration.userMediaStreamId);
                userMediaStream.addCallInfo(call.callId);

                if (call.callConfiguration === undefined || call.callConfiguration === null) {
                  call.callConfiguration = {};
                }

                call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
                call.callLocalStream = userMediaStream.stream;
                call.establishCall();
              } else {
                call.establishCall();
              }
            }
          } else {
            logger.log('acceptCall() - call will be established when user accept his media');
          }
        }
      }
    } else {
      logger.log("Call not found");
    }
  };

  this.refuseCall = function (callId, reason) {
    logger.info('refuseCall for callId :' + callId);
    var call = null,
        refuseReason = null;

    if (reason !== undefined) {
      refuseReason = reason;
    } else {
      refuseReason = 'User_Refused_Call';
    }

    call = this.findCallWithCallId(callId);

    if (call !== null) {
      logger.log("Call found"); //Send Bye message

      if (call.data.MCUType === 'MCU-Callee') {
        call.myWebRTC_Stack.sendBye(call.callId, call.callerId, call.dest_roomId, call.calleeId, 'User_Media_Error', call.data);
        this.removeCallFromTableWithCallIdandRemoteId(call.callId, call.calleeId, refuseReason);
      } else {
        call.myWebRTC_Stack.sendBye(call.callId, call.calleeId, call.dest_roomId, call.callerId, refuseReason, call.data);
        this.removeCallFromTableWithCallIdandRemoteId(call.callId, call.callerId, refuseReason);
      }

      if (this.callsTable.length === 0) {
        logger.log('No more established calls for client');
      }
    } else {
      logger.log("Call not found");
    }
  };
  /*
   * Removes the media media from the peer connection of a given call.
   * @method stopMedia
   * @param {string} callId - callId.
   * @return {Promise} when it is done.
   */


  this.stopMedia = function (callId) {
    var _this5 = this;

    return new Promise(function (resolve, reject) {
      var call = null,
          userMedia = null;
      call = _this5.findCallWithCallId(callId);

      if (call) {
        if (call.callLocalStream) {
          call.removeStream(call.callLocalStream).then(function () {
            call.callLocalStream = null;

            if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(call.callConfiguration, 'userMediaStreamId', 'string')) {
              apiCC.releaseUserMediaStream(call.callConfiguration.userMediaStreamId, call.callId);
              delete call.callConfiguration.userMediaStreamId;
            }

            return resolve();
          })["catch"](reject);
        } else {
          return resolve();
        }
      } else {
        userMedia = _this5.findUserMediaById(callId);

        if (userMedia) {
          userMedia.releaseUserMediaStream();
        }

        return resolve();
      }
    });
  };
  /*
   * Updates media stream for a given call.
   *
   * @method addMedia
   * @param {string} callId - callId.
   * @param {boolean} stopCurrentMedia - whether current media stream of call shall be stopped.
   * @param {(MediaStream|string)} stream - Either media stream (deprecated) or userMediaStreamId.
   * @param {object} callbacks - Callbacks.
   * @param {function} callbacks.getUserMediaStreamId - function returning a Promise<string>.
   *
   * @return {Promise<string>} Promise of userMediaStreamId.
   */


  this.addMedia = function (callId, stopCurrentMedia, stream, callbacks) {
    var _this6 = this;

    logger.info('addMedia for callId :' + callId);

    var call = null,
        userMedia = null,
        userMediaStream = null,
        removeMediaStream = function removeMediaStream() {
      return Promise.resolve();
    },
        addMediaStream = function addMediaStream() {
      return Promise.resolve();
    };

    if (stopCurrentMedia === true) {
      removeMediaStream = function removeMediaStream() {
        return _this6.stopMedia(callId);
      };
    } // Handling new version of function signature.


    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(stream, 'string')) {
      // stream parameter is might be a userMediaStreamId.
      userMediaStream = apiCC.getUserMediaStream(stream);
      stream = null;
    }

    var addMediaSuccess = function addMediaSuccess() {
      logger.error('[addMedia] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);

      if (userMedia.callConfiguration === undefined || userMedia.callConfiguration === null) {
        userMedia.callConfiguration = {};
      }

      userMedia.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
      userMedia.callType = userMediaStream.callType;
      userMedia.audio = userMediaStream.audio;
      userMedia.video = userMediaStream.video;
      userMedia.audioMuted = userMediaStream.audioMuted;
      userMedia.videoMuted = userMediaStream.videoMuted;
      apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.meshOnUserMediaSuccess(userMedia, true);
    };

    var setCallConfigurationMuted = function setCallConfigurationMuted(call) {
      if (call.callConfiguration === undefined || call.callConfiguration === null) {
        call.callConfiguration = {};
      }

      if (call.isLocalAudioMuted && call.isLocalVideoMuted) {
        call.callConfiguration.muted = 'VIDEO';
      } else if (call.isLocalAudioMuted) {
        call.callConfiguration.muted = 'AUDIOONLY';
      } else if (call.isLocalVideoMuted) {
        call.callConfiguration.muted = 'VIDEOONLY';
      }
    };

    var setCallMLineDirection = function setCallMLineDirection(call, mline, active) {
      if (mline === 'audio') {
        if (active) {
          // send audio to remote.
          call.audioSdpDirection = null;
        } else {
          // do not send any audio to remote.
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(call.remoteCallProfile, 'audio', 'boolean') && call.remoteCallProfile.audio === true && call.remoteCallProfile.audioActive === true) {
            // receive audio from remote.
            call.audioSdpDirection = 'recvonly';
          } else {
            // do not receive any audio from remote.
            call.audioSdpDirection = 'inactive';
          }
        }
      } else if (mline === 'video') {
        if (active) {
          // send video to remote.
          call.videoSdpDirection = null;
        } else {
          // do not send any video to remote.
          if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(call.remoteCallProfile, 'video', 'boolean') && call.remoteCallProfile.video === true && call.remoteCallProfile.videoActive === true) {
            // receive video from remote.
            call.videoSdpDirection = 'recvonly';
          } else {
            // do not receive any video from remote.
            call.videoSdpDirection = 'inactive';
          }
        }
      }
    };

    var setCallProperties = function setCallProperties(call, audioEnabled, videoEnabled) {
      // Update call properties based audio/video activation.
      // The callType and destCallType are updated after renegotiation.
      // audioOnly must be false to allow future video addition.
      if (audioEnabled && videoEnabled) {
        // Send audio and video.
        call.audioOnly = false;
        call.mediaTypeForIncomingCall = 'VIDEO';
        call.mediaTypeForOutgoingCall = 'VIDEO';
      } else if (audioEnabled) {
        // Send only audio.
        call.audioOnly = false;
        call.mediaTypeForIncomingCall = 'AUDIO';
        call.mediaTypeForOutgoingCall = 'AUDIO';
      } else if (videoEnabled) {
        // Send only video.
        call.audioOnly = false;
        call.mediaTypeForIncomingCall = 'VIDEOONLY';
        call.mediaTypeForOutgoingCall = 'VIDEOONLY';
      } else {
        // Send nothing.
        call.audioOnly = false;
        call.mediaTypeForIncomingCall = 'NONE';
        call.mediaTypeForOutgoingCall = 'NONE';
      }
    };

    var establishCallWithUserMedia = function establishCallWithUserMedia(call, userMediaStream, resolve, reject) {
      if (call.callConfiguration === undefined || call.callConfiguration === null) {
        call.callConfiguration = {};
      }

      call.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
      setCallMLineDirection(call, 'audio', userMediaStream.audio);
      setCallMLineDirection(call, 'video', userMediaStream.video);
      setCallConfigurationMuted(call);
      setCallProperties(call, userMediaStream.audio, userMediaStream.video);
      call.callLocalStream = userMediaStream.stream;

      if (call.started) {
        // Normal case.
        call.addingUserMedia = true;
      } else {
        // Recorded 1-to1 call initially established without sharing any media.
        // User granted access to local media.
        _this6.accessToLocalMedia = true;
      }

      call.asyncCallbacks = {};
      call.asyncCallbacks.type = 'addingUserMedia';
      call.asyncCallbacks.resolve = resolve;
      call.asyncCallbacks.reject = reject;
      call.asyncCallbacks.timeoutId = setTimeout(function () {
        if (call.asyncCallbacks && typeof call.asyncCallbacks.reject === 'function') {
          call.asyncCallbacks.reject('addMedia timeout');
          delete call.asyncCallbacks;
        }
      }, ADDING_USER_MEDIA_TIMEOUT);
      call.establishCall();
    }; // Assigning functions removeMediaStream and addMediaStream.


    call = this.findCallWithCallId(callId);

    if (call !== null) {
      if (call.asyncCallbacks) {
        return Promise.reject('job already ongoing');
      }

      addMediaStream = function addMediaStream() {
        return new Promise(function (resolve, reject) {
          if (userMediaStream) {
            userMediaStream.addCallInfo(call.callId);
            establishCallWithUserMedia(call, userMediaStream, resolve, reject);
          } else if (stream) {
            // Wrapping MediaStream around a UserMediaStream.
            apiCC.createUserMediaStream({
              'type': 'media',
              'callId': call.callId,
              'stream': stream,
              'sync': true,
              'success': function success(userMediaStream) {
                logger.debug('[addMedia] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
                establishCallWithUserMedia(call, userMediaStream, resolve, reject);
              },
              'failure': function failure(userMediaStream, err) {
                return reject(err);
              }
            });
          } else if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(callbacks, 'getUserMediaStreamId', 'function')) {
            callbacks.getUserMediaStreamId().then(function (userMediaStreamId) {
              userMediaStream = apiCC.getUserMediaStream(userMediaStreamId);

              if (userMediaStream) {
                userMediaStream.addCallInfo(call.callId);
                establishCallWithUserMedia(call, userMediaStream, resolve, reject);
              } else {
                return reject('wrong userMediaStreamId');
              }
            })["catch"](reject);
          } else if (apiCC.userMediaStreamTable.length > 0) {
            userMediaStream = apiCC.userMediaStreamTable[0];
            userMediaStream.addCallInfo(call.callId);
            establishCallWithUserMedia(call, userMediaStream, resolve, reject);
          } else {
            setCallConfigurationMuted(call);
            call.addingUserMedia = true;
            call.asyncCallbacks = {};
            call.asyncCallbacks.type = 'addingUserMedia';
            call.asyncCallbacks.resolve = resolve;
            call.asyncCallbacks.reject = reject;
            call.asyncCallbacks.timeoutId = setTimeout(function () {
              if (call.asyncCallbacks && typeof call.asyncCallbacks.reject === 'function') {
                call.asyncCallbacks.reject('addMedia timeout');
                delete call.asyncCallbacks;
              }
            }, ADDING_USER_MEDIA_TIMEOUT);
            call.getUserMediaOnCall();
          }
        });
      };
    } else {
      userMedia = this.findUserMediaById(callId);

      if (userMedia) {
        if (userMedia.addingUserMedia === true) {
          return Promise.reject('addMedia already ongoing');
        }

        var prerequisite = function prerequisite() {
          return new Promise(function (resolve, reject) {
            if (userMediaStream) {
              userMediaStream.addCallInfo(userMedia.userMediaId, 'userMedia');

              if (userMedia.callConfiguration === undefined || userMedia.callConfiguration === null) {
                userMedia.callConfiguration = {};
              }

              userMedia.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
              userMedia.callType = userMediaStream.callType;
              userMedia.audio = userMediaStream.audio;
              userMedia.video = userMediaStream.video;
              userMedia.audioMuted = userMediaStream.audioMuted;
              userMedia.videoMuted = userMediaStream.videoMuted;
              apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.meshOnUserMediaSuccess(userMedia, true);
              return resolve(userMediaStream.userMediaStreamId);
            } else if (stream) {
              // Wrapping MediaStream around a UserMediaStream.
              apiCC.createUserMediaStream({
                'callId': userMedia.userMediaId,
                'callFlavor': 'userMedia',
                'type': userMedia.callType,
                'stream': stream,
                'sync': true,
                'success': function success() {
                  addMediaSuccess();
                  return resolve(userMediaStream.userMediaStreamId);
                },
                'failure': function failure(userMediaStream, err) {
                  return reject(err);
                }
              });
            } else if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(callbacks, 'getUserMediaStreamId', 'function')) {
              callbacks.getUserMediaStreamId().then(function (userMediaStreamId) {
                userMediaStream = apiCC.getUserMediaStream(userMediaStreamId);

                if (userMediaStream) {
                  userMediaStream.addCallInfo(userMedia.userMediaId, 'userMedia');

                  if (userMedia.callConfiguration === undefined || userMedia.callConfiguration === null) {
                    userMedia.callConfiguration = {};
                  }

                  userMedia.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
                  userMedia.callType = userMediaStream.callType;
                  userMedia.audio = userMediaStream.audio;
                  userMedia.video = userMediaStream.video;
                  userMedia.audioMuted = userMediaStream.audioMuted;
                  userMedia.videoMuted = userMediaStream.videoMuted;
                  apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.meshOnUserMediaSuccess(userMedia, true);
                  return resolve(userMediaStream.userMediaStreamId);
                } else {
                  return reject('wrong userMediaStreamId');
                }
              })["catch"](reject);
            } else if (apiCC.userMediaStreamTable.length > 0) {
              userMediaStream = apiCC.userMediaStreamTable[0];
              userMediaStream.addCallInfo(userMedia.userMediaId, 'userMedia');

              if (userMedia.callConfiguration === undefined || userMedia.callConfiguration === null) {
                userMedia.callConfiguration = {};
              }

              userMedia.callConfiguration.userMediaStreamId = userMediaStream.userMediaStreamId;
              userMedia.callType = userMediaStream.callType;
              userMedia.audio = userMediaStream.audio;
              userMedia.video = userMediaStream.video;
              userMedia.audioMuted = userMediaStream.audioMuted;
              userMedia.videoMuted = userMediaStream.videoMuted;
              apiCC.session.apiCCWebRTCClient.webRTCClient.MCUClient.meshOnUserMediaSuccess(userMedia, true);
              return resolve(userMediaStream.userMediaStreamId);
            } else {
              apiCC.createUserMediaStream({
                'callId': userMedia.userMediaId,
                'callFlavor': 'userMedia',
                'type': userMedia.callType,
                'audioSourceId': apiCC.session.apiCCWebRTCClient.webRTCClient.audioSourceId,
                'videoSourceId': apiCC.session.apiCCWebRTCClient.webRTCClient.videoSourceId,
                'success': function success() {
                  addMediaSuccess();
                  return resolve(userMediaStream.userMediaStreamId);
                },
                'failure': function failure(userMediaStream, err) {
                  return reject(err);
                }
              });
            }
          });
        };

        var dispatch = function dispatch(userMediaStreamId) {
          return new Promise(function (resolve, reject) {
            // Updating every call associated to the given UserMedia.
            var promises = [];

            for (var idx = 0; idx < apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable.length; idx += 1) {
              var _call = apiCC.session.apiCCWebRTCClient.webRTCClient.callsTable[idx];

              if (_call.data !== undefined && _call.data.mesh !== undefined && _call.data.mesh.calleeCallId === callId) {
                promises.push(apiCC.session.apiCCWebRTCClient.webRTCClient.addMedia(_call.callId, true, userMediaStreamId));
              }
            } // for


            Promise.all(promises).then(function () {
              return resolve(userMediaStreamId);
            })["catch"](reject);
          });
        };

        addMediaStream = function addMediaStream() {
          return new Promise(function (resolve, reject) {
            userMedia.addingUserMedia = true;
            prerequisite().then(function (userMediaStreamId) {
              return dispatch(userMediaStreamId);
            }).then(function (userMediaStreamId) {
              delete userMedia.addingUserMedia;
              return resolve(userMediaStreamId);
            })["catch"](function (err) {
              delete userMedia.addingUserMedia;
              return reject(err);
            });
          });
        };
      } else {
        addMediaStream = function addMediaStream() {
          return Promise.reject('no suitable replacement');
        };
      }
    }

    return new Promise(function (resolve, reject) {
      removeMediaStream().then(function () {
        return addMediaStream();
      }).then(function (userMediaStreamId) {
        logger.info('addMedia success; userMediaStreamId: ' + userMediaStreamId);
        return resolve(userMediaStreamId);
      })["catch"](function (err) {
        logger.error('addMedia failure: ' + err);
        var roomName = null,
            settingUpType = null;

        if (call) {
          if (call.callControl) {
            roomName = call.callControl.roomName;
            settingUpType = call.callControl.type;
          }

          myWebRTC_Event.createErrorEvent('Failed to addMedia', 'MEDIA_UPDATE_ERROR', call.callId, roomName, settingUpType);
        } else if (userMedia) {
          myWebRTC_Event.createErrorEvent('Failed to addMedia', 'MEDIA_UPDATE_ERROR', userMedia.userMediaId, null, 'publish');
        }

        return reject(err);
      });
    });
  };

  this.updateMediaDeviceOnCall = function (callId, stream) {
    logger.info('updateMediaDeviceOnCall for callId :' + callId);
    this.addMedia(callId, true, stream);
    return callId;
  };
  /*
   * Updates the media type during a call. Only for subscribe calls.
   *
   * @method updateMediaTypeOnCall
   * @param {String} callId - Call identifier.
   * @param {String} mediaType - New media type. One of VIDEO, AUDIOONLY and VIDEOONLY.
   * @return {Promise} - Resolved when it is done.
   */


  this.updateMediaTypeOnCall = function (callId, mediaType) {
    var update = function update(call, stream, mediaType) {
      return new Promise(function (resolve, reject) {
        var messageToSend = {},
            msgString = null;
        call.callControl.mediaType = mediaType;
        call.mediaType = mediaType;
        call.data.mediaType = mediaType;
        call.updateCause = 'userAction'; // Sending message to janusConnector.

        messageToSend.type = 'update';
        messageToSend.mode = 'passive';
        messageToSend.callId = call.callId;
        messageToSend.callerId = apiCC.session.apiCCWebRTCClient.webRTCClient.clientId;
        messageToSend.callerNickname = apiCC.session.apiCCWebRTCClient.webRTCClient.clientId;
        messageToSend.calleeId = call.sessionMCU.roomName;
        messageToSend.roomId = call.sessionMCU.roomName;
        messageToSend.callType = stream.attributes.callType;
        messageToSend.data = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.mergeJSON)(call.data);
        messageToSend.data.type = 'subscribe'; // routing value for janusConnector

        messageToSend.stream = stream;
        msgString = JSON.stringify(messageToSend);
        logger.log('C->S: ' + msgString);
        apiCC.session.apiCCWebRTCClient.webRTCClient.socket.emit('update', msgString); // The returned promise will be resolved later.

        call.asyncCallbacks = {};
        call.asyncCallbacks.type = 'updateMediaType';
        call.asyncCallbacks.resolve = resolve;
        call.asyncCallbacks.reject = reject;
        call.asyncCallbacks.timeoutId = setTimeout(function () {
          if (call.asyncCallbacks && typeof call.asyncCallbacks.reject === 'function') {
            call.asyncCallbacks.reject('timeout');
            delete call.asyncCallbacks;
          }
        }, UPDATE_MEDIA_TYPE_TIMEOUT);
      });
    };

    var call = this.findCallWithCallId(callId);

    if (!call) {
      return Promise.reject('call not found');
    }

    if (call.settingUpType !== 'subscribe') {
      return Promise.reject('wrong call type');
    }

    if (call.asyncCallbacks) {
      return Promise.reject('job already ongoing');
    }

    var streamInfo = this.MCUClient.getStreamFromList(call.streamId);

    if (!streamInfo) {
      return Promise.reject('wrong streamId');
    }

    if (call.callControl.mediaType === 'VIDEO') {
      // Currently we subscribed to audio and video.
      if (mediaType === 'AUDIOONLY' && streamInfo.audio) {
        return update(call, streamInfo, mediaType);
      } else if (mediaType === 'VIDEOONLY' && streamInfo.video) {
        return update(call, streamInfo, mediaType);
      }
    } else if (call.callControl.mediaType === 'AUDIOONLY') {
      // Currently we subscribed to audio only.
      if (mediaType === 'VIDEO' && streamInfo.video) {
        return update(call, streamInfo, mediaType);
      } else if (mediaType === 'VIDEOONLY' && streamInfo.video) {
        return update(call, streamInfo, mediaType);
      }
    } else if (call.callControl.mediaType === 'VIDEOONLY') {
      // Currently we subscribed to video only.
      if (mediaType === 'VIDEO' && streamInfo.video) {
        return update(call, streamInfo, mediaType);
      } else if (mediaType === 'AUDIOONLY' && streamInfo.audio) {
        return update(call, streamInfo, mediaType);
      }
    }

    return Promise.reject('wrong mediaType');
  };
  /*
   * Updates the simulcast parameters during a call. Only for subscribe calls.
   * @ignore
   * @method updateSimulcastFeedOnCall
   * @param {string} callId - Call identifier.
   * @param {object} simulcast
   * @param {number} simulcast.streamQuality - Substream selection. Either 'high', 'medium' or 'low'.
   * @param {number} simulcast.streamFrameRate - Temporal layer selection. Either 'high', 'medium' or 'low'.
   * @return {Promise} - Resolved when it is done.
   */


  this.updateSimulcastFeedOnCall = function (callId, simulcast) {
    var call = this.findCallWithCallId(callId);

    if (!call) {
      return Promise.reject('call not found');
    }

    if (call.settingUpType !== 'subscribe') {
      return Promise.reject('wrong call type');
    }

    if (call.asyncCallbacks) {
      return Promise.reject('job already ongoing');
    }

    var streamInfo = this.MCUClient.getStreamFromList(call.streamId);

    if (!streamInfo) {
      return Promise.reject('wrong streamId');
    }

    if (!simulcast) {
      return Promise.reject('wrong simulcast');
    }

    if (!call.callControl.callConfiguration.simulcast) {
      call.callControl.callConfiguration.simulcast = {};
    }

    if (!call.data.simulcast) {
      call.data.simulcast = {};
    }

    if (simulcast.streamQuality) {
      if (simulcast.streamQuality === 'high') {
        call.callControl.callConfiguration.simulcast.substream = 2;
        call.data.simulcast.substream = 2;
      } else if (simulcast.streamQuality === 'medium') {
        call.callControl.callConfiguration.simulcast.substream = 1;
        call.data.simulcast.substream = 1;
      } else if (simulcast.streamQuality === 'low') {
        call.callControl.callConfiguration.simulcast.substream = 0;
        call.data.simulcast.substream = 0;
      } else {
        call.callControl.callConfiguration.simulcast.substream = -1;
        call.data.simulcast.substream = -1;
      }
    }

    if (simulcast.streamFrameRate) {
      if (simulcast.streamFrameRate === 'high') {
        call.callControl.callConfiguration.simulcast.temporal = 2;
        call.data.simulcast.temporal = 2;
      } else if (simulcast.streamFrameRate === 'medium') {
        call.callControl.callConfiguration.simulcast.temporal = 1;
        call.data.simulcast.temporal = 1;
      } else if (simulcast.streamFrameRate === 'low') {
        call.callControl.callConfiguration.simulcast.temporal = 0;
        call.data.simulcast.temporal = 0;
      } else {
        call.callControl.callConfiguration.simulcast.temporal = -1;
        call.data.simulcast.temporal = -1;
      }
    } // Sending message to janusConnector.


    var messageToSend = {};
    messageToSend.type = 'updateSimulcastFeed';
    messageToSend.callId = call.callId;
    messageToSend.callerId = apiCC.session.apiCCWebRTCClient.webRTCClient.clientId;
    messageToSend.callerNickname = apiCC.session.apiCCWebRTCClient.webRTCClient.clientId;
    messageToSend.calleeId = call.sessionMCU.roomName;
    messageToSend.roomId = call.sessionMCU.roomName;
    messageToSend.callType = streamInfo.attributes.callType;
    messageToSend.data = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.mergeJSON)(call.data);
    messageToSend.stream = streamInfo;
    var msgString = JSON.stringify(messageToSend);
    logger.log('C->S: ' + msgString);
    apiCC.session.apiCCWebRTCClient.webRTCClient.socket.emit('updateSimulcastFeed', msgString);
    return Promise.resolve();
  };
  /*
   * Updates the call configuration during a call. Only for publisher.
   *
   * @method updateCallConfigurationOnCall
   * @param {string} callId - Call identified.
   * @param {object} callConfiguration - New call configuration.
   * @param {boolean} callConfiguration.audioOnly - Whether only audio track must be present.
   * @param {boolean} callConfiguration.videoOnly - Whether only video track must be present.
   * @return {Promise} When it is done.
   */


  this.updateCallConfigurationOnCall = function (callId, callConfiguration) {
    var setCallMLineDirection = function setCallMLineDirection(call, mline, active) {
      if (mline === 'audio') {
        if (active) {
          call.audioSdpDirection = null;
        } else {
          call.audioSdpDirection = 'inactive';
        }
      } else if (mline === 'video') {
        if (active) {
          call.videoSdpDirection = null;
        } else {
          call.videoSdpDirection = 'inactive';
        }
      }
    };

    var update = function update(call, callConfiguration) {
      return new Promise(function (resolve, reject) {
        call.mediaTypeForIncomingCall = 'NONE';

        if (callConfiguration.audioOnly === true) {
          logger.log('Setting call as audioOnly');
          call.audioOnly = true;
          call.callType = 'audio';
          call.mediaTypeForOutgoingCall = 'AUDIO';
          setCallMLineDirection(call, 'audio', true);
          setCallMLineDirection(call, 'video', false);
        } else if (callConfiguration.videoOnly === true) {
          logger.log('Setting call as videoOnly');
          call.audioOnly = false;
          call.callType = 'videoOnly';
          call.mediaTypeForOutgoingCall = 'VIDEOONLY';
          setCallMLineDirection(call, 'audio', false);
          setCallMLineDirection(call, 'video', true);
        } else {
          logger.log('Setting call as media');
          call.audioOnly = false;
          call.callType = 'media';
          call.mediaTypeForOutgoingCall = 'VIDEO';
          setCallMLineDirection(call, 'audio', true);
          setCallMLineDirection(call, 'video', true);
        }

        call.updateUserMedia = true;
        call.updateCause = 'userAction';
        call.establishCall(); // The returned promise will be resolved later.

        call.asyncCallbacks = {};
        call.asyncCallbacks.type = 'updateCallConfiguration';
        call.asyncCallbacks.resolve = resolve;
        call.asyncCallbacks.reject = reject;
        call.asyncCallbacks.timeoutId = setTimeout(function () {
          if (call.asyncCallbacks && typeof call.asyncCallbacks.reject === 'function') {
            call.asyncCallbacks.reject('timeout');
            delete call.asyncCallbacks;
          }
        }, UPDATE_MEDIA_TYPE_TIMEOUT);
      });
    };

    var call = this.findCallWithCallId(callId);

    if (!call) {
      return Promise.reject('call not found');
    }

    if (call.settingUpType !== 'publish') {
      return Promise.reject('wrong call type');
    }

    if (call.asyncCallbacks) {
      return Promise.reject('job already ongoing');
    }

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callConfiguration, 'object')) {
      callConfiguration = {};
    }

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(callConfiguration, 'audioOnly', 'boolean')) {
      callConfiguration.audioOnly = false;
    }

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(callConfiguration, 'videoOnly', 'boolean')) {
      callConfiguration.videoOnly = false;
    }

    return update(call, callConfiguration);
  };

  this.findUserMediaById = function (userMediaId) {
    var idx = this.userMediaTable.length;

    while (--idx >= 0) {
      if (this.userMediaTable[idx].userMediaId === userMediaId) {
        return this.userMediaTable[idx];
      }
    }

    return null;
  };

  this.findCallIndexWithCallIdAndRemoteId = function (callId, remoteId) {
    logger.debug("findCallIndexWithCallIdAndRemoteId");
    var i,
        callsNumber = this.callsTable.length;
    logger.trace("callsNumber : " + callsNumber);

    for (i = 0; i < callsNumber; i += 1) {
      if (this.callsTable[i].callId === callId) {
        logger.log("callId found");
        logger.log("this.callsTable[i].callee :" + this.callsTable[i].callee);
        logger.log("this.callsTable[i].calleeId :" + this.callsTable[i].calleeId);

        if (this.callsTable[i].callee === true && this.callsTable[i].callerId === remoteId || this.callsTable[i].callee === false && this.callsTable[i].calleeId === remoteId) {
          //logger.log('Call found with callId and remoteId');
          return i;
        }
      }
    }

    logger.log('Call not found');
    return -1;
  };

  this.findCallIndexWithConfIdAndRemoteId = function (confId, remoteId) {
    logger.debug("findCallIndexWithConfIdAndRemoteId");
    logger.log("confId :" + confId);
    logger.log("remoteId :" + remoteId);
    var i,
        callsNumber = this.callsTable.length;

    for (i = 0; i < callsNumber; i += 1) {
      logger.log("this.callsTable[i].data.confId :" + this.callsTable[i].data.confId);

      if (this.callsTable[i].data.confId === confId) {
        if (this.callsTable[i].callee === true && this.callsTable[i].callerId === remoteId || this.callsTable[i].callee === false && this.callsTable[i].calleeId === remoteId) {
          //logger.debug('Call found with confId and remoteId');
          return i;
        }
      } else {
        logger.debug('ConfId is different');
      }
    }

    logger.debug('Call not found - findCallIndexWithConfIdAndRemoteId');
    return -1;
  };

  this.findCallIndexWithCallId = function (callId) {
    logger.debug("findCallIndexWithCallId");
    var i,
        callsNumber = this.callsTable.length;

    for (i = 0; i < callsNumber; i += 1) {
      if (this.callsTable[i].callId === callId) {
        logger.log('Call found with callId');
        return i;
      }
    }

    logger.debug('Call not found - findCallIndexWithCallId');
    return -1;
  };

  this.findCallWithCallIdAndInstanceId = function (callId, instanceId) {
    logger.debug("findCallWithCallIdAndInstanceId :" + callId + " ,instanceId : " + instanceId);

    if (instanceId === undefined) {
      logger.debug("instanceId is undefined : must be a mesh publish call, id must be a streamId");
    }

    var i,
        callsNumber = this.callsTable.length;
    logger.trace('callsNumber :' + callsNumber);

    for (i = 0; i < callsNumber; i += 1) {
      //logger.log('this.callsTable[i].callId :' + this.callsTable[i].callId);
      if (this.callsTable[i].callId === callId && this.callsTable[i].instanceId === instanceId) {
        //logger.debug('Call found with instanceId');
        return this.callsTable[i];
      }
    }

    logger.debug('Call not found, findCallWithCallIdAndInstanceId');
    return null;
  };

  this.findCallIndexWithCallIdAndInstanceId = function (callId, instanceId) {
    logger.debug("findCallIndexWithCallIdAndInstanceId :" + callId + " ,instanceId : " + instanceId);

    if (instanceId === undefined) {
      logger.debug("instanceId is undefined : must be a mesh publish call, id must be a streamId");
    }

    var i,
        callsNumber = this.callsTable.length;
    logger.trace('callsNumber :' + callsNumber);

    for (i = 0; i < callsNumber; i += 1) {
      //logger.log('this.callsTable[i].callId :' + this.callsTable[i].callId);
      if (this.callsTable[i].callId === callId && this.callsTable[i].instanceId === instanceId) {
        //logger.debug('Call found with instanceId');
        return i;
      }
    }

    logger.debug('Call not found, findCallIndexWithCallIdAndInstanceId');
    return -1;
  };

  this.findCallWithCallId = function (callId) {
    logger.trace("findCallWithCallId :" + callId);
    var i,
        callsNumber = this.callsTable.length;
    logger.trace('callsNumber :' + callsNumber);

    for (i = 0; i < callsNumber; i += 1) {
      logger.trace('this.callsTable[i].callId :' + this.callsTable[i].callId);

      if (this.callsTable[i].callId === callId) {
        return this.callsTable[i];
      }
    }

    logger.debug('Call not found');
    return null;
  };
  /*
   * Searches for a (subscribe) call for a stream ID.
   * @param {string} streamId
   * @param {object} options
   * @param {boolean} options.ignoreModeChangeKindOld - Whether to ignore calls from old session during a session mode transition.
   */


  this.findCallWithStreamId = function (streamId, options) {
    logger.debug("findCallWithStreamId :" + streamId);
    var ignoreModeChangeKindOld = !!(options && options.ignoreModeChangeKindOld),
        i,
        callsNumber = this.callsTable.length;
    logger.trace('callsNumber :' + callsNumber);

    for (i = 0; i < callsNumber; i += 1) {
      logger.log('this.callsTable[i].streamId :' + this.callsTable[i].streamId); //TODO voir pourquoi === ne marche pas

      if (this.callsTable[i].streamId == streamId && (!ignoreModeChangeKindOld || !this.callsTable[i].sessionMCU || this.callsTable[i].sessionMCU.modeChangeKind !== 'old')) {
        logger.log('Call found');
        return this.callsTable[i];
      }
    }

    logger.log('Call not found');
    return null;
  };

  this.findCallWithCallIdAndRemoteIdAndInstanceId = function (callId, remoteId, instanceId) {
    logger.debug("findCallWithCallIdAndRemoteIdAndInstanceId callId : " + callId + ' ,instanceId : ' + instanceId);
    var i,
        callsNumber = this.callsTable.length;
    logger.trace('callsNumber :' + callsNumber);

    for (i = 0; i < callsNumber; i += 1) {
      if (this.callsTable[i].callId === callId && this.callsTable[i].instanceId === instanceId) {
        if (this.callsTable[i].callee === true && this.callsTable[i].callerId === remoteId || this.callsTable[i].callee === false && this.callsTable[i].calleeId === remoteId) {
          //logger.log("Call found with callId and remoteId");
          return this.callsTable[i];
        }
      }
    }

    logger.debug('Call not found');
    return null;
  };

  this.findCallWithCallIdAndRemoteId = function (callId, remoteId) {
    logger.log("findCallWithCallIdAndRemoteId");
    var i,
        callsNumber = this.callsTable.length;
    logger.trace('callsNumber :' + callsNumber);

    for (i = 0; i < callsNumber; i += 1) {
      if (this.callsTable[i].callId === callId) {
        //== au lieu de === pour plus de souplesse sur format Id
        if (this.callsTable[i].callee === true && this.callsTable[i].callerId === remoteId || this.callsTable[i].callee === false && this.callsTable[i].calleeId === remoteId) {
          //logger.log("Call found with callId and remoteId");
          return this.callsTable[i];
        }
      }
    }

    logger.log('Call not found');
    return null;
  };

  this.releaseUserMedia = function () {
    logger.info('releaseUserMedia');

    if (this.localStream !== null) {
      logger.log('stopping localStream');
      this.stopStream(this.localStream);
      myWebRTC_Event.createUserMediaStopEvent(null, 'media'); //this.localStream.stop();
      //this.localStream = null;

      this.accessToLocalMedia = false;
      this.autoAnswer = false;
      logger.log('this.autoAnswer :' + this.autoAnswer);
    }

    if (this.screenStream !== null && this.screenStream !== undefined) {
      logger.log('stopping screenStream');
      this.stopStream(this.screenStream);
      myWebRTC_Event.createUserMediaStopEvent(null, 'screen'); //this.screenStream.stop();
      //this.screenStream = null;
    }
  };

  this.startDataChannelOnCall = function (callId) {
    logger.info('startDataChannelOnCall with callId :' + callId);
    var call = this.findCallWithCallId(callId);

    if (!call) {
      logger.log("Call not found");
      return;
    }

    logger.log("Call found", call);
    call.addingDataChannelOnCallOngoing = true;
    call.createDataChannel(); // datachannel creation on existing call
  };

  this.sendDataWithCallId = function (callId, data, onProgress) {
    logger.info('sendDataWithCallId :' + callId);
    var call = this.findCallWithCallId(callId);

    if (!call) {
      logger.log("Call not found");
      return;
    }

    logger.log("Call found", call);
    call.sendData(data, onProgress); // datachannel
  };

  this.processDataAck = function (msg) {
    logger.debug('processDataAck', msg);
    var call = this.findCallWithCallId(msg.callId);

    if (!call) {
      logger.debug('no such call', msg.callId);
      return;
    }

    if (msg.result === 'ok') {
      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(msg, 'capabilities', 'object')) {
        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(msg.capabilities, 'dataEndAckEnabled', 'boolean')) {
          // The dataEndAck message will tell us when to close the data channel
          // at the end of the transfer.
          call.dataEndAckEnabled = msg.capabilities.dataEndAckEnabled;
          logger.debug('dataEndAckEnabled', call.dataEndAckEnabled);
        }
      }

      if (msg.state === 'complete') {
        // File already exists on server side.
        if (call.beginTimeoutId) {
          clearTimeout(call.beginTimeoutId);
          delete call.beginTimeoutId;
        }

        call.callbacks.success({
          'state': 'complete',
          'filename': call.data.filename,
          'size': call.data.size,
          'mediaURL': msg.mediaURL,
          'mediaId': msg.mediaId
        });
        apiCC.session.apiCCWebRTCClient.webRTCClient.onHangup(call.callId);
      } else if (msg.state === 'incomplete') {
        // Part of file exists on server side.
        var blockLength = 1 << 17;
        var checksums = [];
        var fullBlockCount = Math.floor(call.data.size / blockLength);
        var remByteCount = call.data.size % blockLength;
        var i, checksum;

        for (i = 0; i < fullBlockCount; i += 1) {
          checksum = (0,_Checksum64__WEBPACK_IMPORTED_MODULE_8__.createChecksum)("checksum64");
          checksum.update(call.fileContent, i * blockLength, blockLength);
          checksums.push(checksum.digest('hex'));
        }

        if (remByteCount > 0) {
          checksum = (0,_Checksum64__WEBPACK_IMPORTED_MODULE_8__.createChecksum)("checksum64");
          checksum.update(call.fileContent, fullBlockCount * blockLength, remByteCount);
          checksums.push(checksum.digest('hex'));
        }

        logger.debug(JSON.stringify(checksums));

        if (msg.checksums.length === checksums.length) {
          for (i = 0; i < checksums.length; i += 1) {
            if (msg.checksums[i] !== checksums[i]) {
              break;
            }
          }

          call.data.offset = blockLength * i;
        }

        call.mediaURL = msg.mediaURL;
        call.mediaId = msg.mediaId;
        call.establishCall();
      } else if (msg.state === 'missing') {
        // File does not exist on server side.
        call.mediaURL = msg.mediaURL;
        call.mediaId = msg.mediaId;
        call.establishCall();
      } else if (msg.state === 'ready') {
        // Server is ready for transfer (plugin).
        call.establishCall();
      } else {
        logger.debug('wrong state ' + msg.state);

        if (call.beginTimeoutId) {
          clearTimeout(call.beginTimeoutId);
          delete call.beginTimeoutId;
        }

        call.callbacks.failure('serverError');
        apiCC.session.apiCCWebRTCClient.webRTCClient.onHangup(call.callId);
      }
    } else {
      logger.debug('wrong result ' + msg.result);

      if (call.beginTimeoutId) {
        clearTimeout(call.beginTimeoutId);
        delete call.beginTimeoutId;
      }

      call.callbacks.failure('serverError');
      apiCC.session.apiCCWebRTCClient.webRTCClient.onHangup(call.callId);
    }
  };
  /*
   * Processes a 'dataEndAck' message, describing the successful (or not) transfer of data.
   * @ignore
   * @method processDataEndAck
   * @param {object} msg
   */


  this.processDataEndAck = function (msg) {
    logger.debug('processDataEndAck', msg);
    var call = this.findCallWithCallId(msg.callId);

    if (!call) {
      logger.debug('no such call', msg.callId);
      return;
    }

    var pipelineCall = null;

    if (!call.dcfs) {
      // Received dataEndAck on pipeline call.
      if (!call.data || call.data.transferType !== 'pipeline') {
        logger.debug('not pipeline');
        return;
      }

      logger.debug('pipeline');
      pipelineCall = call;

      if (call.clientCall) {
        // Resolve actual call.
        logger.debug('resolve client call');
        call = call.clientCall;
      } else {
        logger.debug('no client call');
        call = null;
      }
    }

    if (call) {
      if (call.success && msg.data) {
        call.success.data = msg.data;
      }

      if (msg.result === 'ok') {
        if (msg.complete === true) {
          call.dcfs.terminateTransfer();
        } else {
          delete call.success;
          call.failure = 'transferIncomplete';
          call.dcfs.terminateTransfer();
        }
      } else if (msg.result === 'error') {
        delete call.success;
        call.failure = msg.errorInfo;
        call.dcfs.terminateTransfer();
      }
    }

    if (pipelineCall) {
      if (msg.result === 'error') {
        logger.debug('error on pipeline');
        pipelineCall.failure = msg.errorInfo; // Notify error.

        myWebRTC_Event.createEvent({
          eventType: 'onFileSended',
          callId: pipelineCall.callId,
          remoteId: pipelineCall.remoteId,
          name: pipelineCall.filename,
          error: pipelineCall.failure
        });
        pipelineCall.callbacks.failure(pipelineCall.failure); // Close pipeline.

        this.onHangup(pipelineCall.callId);
      }
    }
  };
  /*
   * @ignore
   * @method pushData
   * @param {string} convId - Conversation ID.
   * @param {object} data
   * @param {object} data.file
   * @param {boolean} data.asFile - Force the use of file.
   * @param {object} data.buffer
   * @param {boolean} data.asBuffer - Force the user of buffer.
   * @param {string} data.filename - Force the filename. Mandatory for buffer.
   * @param {string} data.filetype - Force the file type. Mandatory for buffer.
   * @param {string} data.sourceType - An optional source type.
   * @param {boolean} data.overwrite - Enable the overwriting the existing data.
   * @param {number} data.ttl - Set a time to live (in seconds) for the data once pushed.
   * @param {boolean} data.checksumEnabled - Whether checksum validation is enabled. Enabled by default.
   * @param {string} data.transferType - Either 'file' or 'plugin'.
   * @param {object} data.plugin
   * @param {string} data.plugin.name
   * @param {object} data.metadata
   * @param {object} callConfiguration
   * @param {string} callConfiguration.turnServerAddress
   * @param {function} callbacks.progress
   * @param {function} callbacks.success
   * @param {function} callbacks.failure
   * @return {string} call id on success, null otherwise.
   */


  this.pushData = function (convId, data, callConfiguration, callbacks) {
    var _this7 = this;

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'object')) {
      return null;
    }

    data = Object.assign({}, data);

    if (!data.transferType) {
      // Default transfer type.
      data.transferType = 'file';
    }

    if (data.transferType === 'file') {
      // For file (to Cloud NFS).
      if (!convId) {
        return null;
      }
    }

    if (data.transferType !== 'file' && data.transferType !== 'pipeline' && data.transferType !== 'plugin') {
      return null;
    }

    if (data.transferType === 'plugin' && (!data.pluginName || !data.pluginData)) {
      return null;
    }

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(callbacks, 'object')) {
      callbacks = {};
    }

    if (typeof callbacks.pending !== 'function') {
      callbacks.pending = function () {};
    }

    if (typeof callbacks.progress !== 'function') {
      callbacks.progress = function () {};
    }

    if (typeof callbacks.success !== 'function') {
      callbacks.success = function () {};
    }

    if (typeof callbacks.failure !== 'function') {
      callbacks.failure = function () {};
    }

    var call = new _WebRTC_Call__WEBPACK_IMPORTED_MODULE_7__.WebRTC_Call(apiCC.session.apiCCWebRTCClient.webRTCClient);
    call.generateCallId();
    call.instanceId = apiCC.generateInstanceId();
    call.callerId = apiCC.session.apiCCWebRTCClient.webRTCClient.clientId;
    call.calleeId = 'dataChannelConnector';
    call.dest_roomId = 'dataChannelConnector';
    call.callType = 'data';
    call.dataCall = true;
    call.remoteId = 'dataChannelConnector';

    if (data.pipelineCallId) {
      call.pipelineCallId = data.pipelineCallId;
    }

    call.data = {};
    call.data.pubSub = 'dataChannelConnector';
    call.data.transferType = data.transferType;

    if (data.transferType === 'pipeline') {
      // Pipeline.
      data.checksumEnabled = false;
      call.transferCount = 0;
    } else if (data.transferType === 'plugin') {
      // Plugin.
      data.checksumEnabled = false;
      call.data.pluginName = data.pluginName;
      call.data.pluginData = Object.assign({}, data.pluginData);

      if (call.data.pluginData.headers) {
        // For httpPost plugin.
        call.data.pluginData.headers = Object.assign({}, call.data.pluginData.headers);
      }

      if (call.data.pluginData.data) {
        // For httpPost plugin.
        call.data.pluginData.data = Object.assign({}, call.data.pluginData.data);
      }

      if (call.data.pluginData.formData) {
        // For httpPost plugin.
        call.data.pluginData.formData = Object.assign({}, call.data.pluginData.formData);
      }
    } // User defined context.


    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(data, 'context', 'object')) {
      try {
        JSON.stringify(data.context);
        call.data.context = Object.assign({}, data.context);
      } catch (e) {}
    }

    if (data.overwrite === true) {
      call.data.overwrite = true;
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'ttl', 'number') && data.ttl > 0) {
      call.data.ttl = data.ttl;
    }

    call.data.instanceId = call.instanceId;

    if (convId) {
      call.data.cloudConvId = convId;
    }

    call.callbacks = callbacks;

    if (callConfiguration !== null && callConfiguration !== undefined) {
      if (callConfiguration.turnServerAddress !== undefined && callConfiguration.turnServerAddress !== null) {
        call.setCallTurnServer(callConfiguration.turnServerAddress);
      }
    }

    if (call.data.transferType === 'pipeline') {
      // Not really a transfer, just open a datachannel for future transfers.
      call.data.size = 0;
      call.pushDataStatus = {
        type: 'pipeline',
        state: 'pending',
        data: data
      };
      this.callsTable.push(call); // This function must return first so the event sent by startNextPushData will be treated in Conversation

      setTimeout(function () {
        _this7.startNextPushData();
      });
    } else if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'file', 'object') && (data.file instanceof File || data.file.constructor === File || data.asFile === true)) {
      // Normal transfer, with file.
      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'filename', 'string')) {
        call.data.filename = data.filename;
      } else {
        call.data.filename = data.file.name;
      }

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'filetype', 'string')) {
        call.data.contentType = data.filetype;
      } else {
        call.data.contentType = data.file.type;
      }

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'sourceType', 'string') && data.sourceType.length > 0) {
        call.data.sourceType = data.sourceType;
      }

      call.data.size = data.file.size;
      call.data.metadata = data.metadata;
      call.pushDataStatus = {
        type: 'file',
        state: 'pending',
        convId: String(convId),
        data: data
      };
      this.callsTable.push(call); // This function must return first so the event sent by startNextPushData will be treated in Conversation

      setTimeout(function () {
        _this7.startNextPushData();
      });
    } else if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'buffer', 'object') && (data.buffer instanceof ArrayBuffer || data.buffer.constructor === ArrayBuffer || data.asBuffer === true)) {
      // Normal transfer, with buffer.
      if (!((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'filename', 'string') && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'filetype', 'string'))) {
        return null;
      }

      call.data.filename = data.filename;
      call.data.contentType = data.filetype;

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'sourceType', 'string') && data.sourceType.length > 0) {
        call.data.sourceType = data.sourceType;
      }

      call.data.size = data.buffer.byteLength;
      call.data.metadata = data.metadata;
      call.pushDataStatus = {
        type: 'buffer',
        state: 'pending',
        convId: String(convId),
        data: data
      };
      this.callsTable.push(call); // This function must return first so the event sent by startNextPushData will be treated in Conversation

      setTimeout(function () {
        _this7.startNextPushData();
      });
    } else {
      return null;
    }

    return call.callId;
  };
  /*
   * Looks the next pushdata and starts it.
   * @ignore
   * @method startNextPushData
   * @return {boolean} true on success, false otherwise.
   */


  this.startNextPushData = function () {
    var _this8 = this;

    // Look for 'push data' calls
    var calls = [];

    for (var idx = 0; idx < this.callsTable.length; idx += 1) {
      var c = this.callsTable[idx];

      if (c.callType === 'data' && c.dataCall && c.remoteId === 'dataChannelConnector' && c.pushDataStatus) {
        if (c.pushDataStatus.state === 'ready') {
          // Pipeline is ready to be used.
          continue;
        }

        calls.push(c);
      }
    } // for


    if (calls.length === 0) {
      // no call to start
      return false;
    }

    var call = null;

    if (calls[0].pushDataStatus.state === 'active') {
      // First 'push data' already active
      calls.splice(0, 1);
    } else if (calls[0].pushDataStatus.state === 'pending') {
      // First 'push data' call can be started
      call = calls[0];
      calls.splice(0, 1);
    } // Notify other calls are (still) pending


    for (var _idx = 0; _idx < calls.length; _idx += 1) {
      var _c = calls[_idx];

      if (_c.pushDataStatus.rank !== _idx) {
        _c.pushDataStatus.rank = _idx;
        myWebRTC_Event.createEvent({
          eventType: 'onFilePending',
          callId: _c.callId,
          remoteId: _c.remoteId,
          name: _c.data.filename,
          rank: _idx
        });

        _c.callbacks.pending({
          state: 'pending',
          callId: _c.callId,
          rank: _idx
        });
      }
    } // for


    if (!call) {
      // no call to start
      return false;
    }

    logger.debug('startNextPushData', call.callId);
    var data = call.pushDataStatus.data;
    delete call.pushDataStatus.data;

    if (call.pushDataStatus.type === 'pipeline') {
      call.pushDataStatus.state = 'active';
      var messageToSend = {
        type: 'pushData',
        callerId: apiCC.session.apiCCId,
        callId: call.callId,
        data: call.data
      };
      var msgString = JSON.stringify(messageToSend);
      logger.debug('C->S: ' + msgString);
      apiCC.session.channel.socket.emit('pushData', msgString); // Do not set any begin timeout.

      return true;
    } else if (call.pushDataStatus.type === 'file') {
      call.pushDataStatus.state = 'active';
      var fileReader = new FileReader();

      fileReader.onload = function (e) {
        apiCC.session.apiCCWebRTCClient.webRTCClient.startPushData(call, data, e.target.result);
      };

      fileReader.readAsArrayBuffer(data.file);
    } else if (call.pushDataStatus.type === 'buffer') {
      call.pushDataStatus.state = 'active';
      this.startPushData(call, data, data.buffer);
    } else {
      // should not happen as we set type ourselves
      logger.error('startNextPushData - wrong type');
      call.callbacks.failure('start', call.callId);
      this.onHangup(call.callId);
      return false;
    } // Set a timeout for the transfer to start.


    call.beginTimeoutId = setTimeout(function () {
      delete call.beginTimeoutId;
      call.callbacks.failure('timeout', call.callId);

      _this8.onHangup(call.callId);
    }, DATA_TRANSFER_BEGIN_TIMEOUT);
    return true;
  };
  /*
   * Starts given pushData.
   * @ignore
   * @method startPushData
   * @param {WebRTC_Call} call
   * @param {object} data
   * @param {object} buffer
   */


  this.startPushData = function (call, data, buffer) {
    call.fileContent = new Uint8Array(buffer);

    if (call.pipelineCallId) {
      // Pipeline transfer.
      var pipelineCall = this.findCallWithCallId(call.pipelineCallId);

      if (!pipelineCall) {
        logger.error('no such pipeline call');
        this.onHangup(call.callId);
        return;
      } // Set the relationship.


      call.pipelineCall = pipelineCall;
      pipelineCall.clientCall = call; // Lend the dataChannel.

      call.sendDataChannel = pipelineCall.sendDataChannel; // Start transfer immediately.

      var delay = pipelineCall.transferCount === 0 ? 100 : 0;
      call.startTransfer({
        delay: delay
      }); // Increase counter of transfers.

      pipelineCall.transferCount += 1;
    } else {
      if (!Object.prototype.hasOwnProperty.call(data, 'checksumEnabled') || data.checksumEnabled) {
        var checksum = (0,_Checksum64__WEBPACK_IMPORTED_MODULE_8__.createChecksum)('checksum64');
        checksum.update(call.fileContent);
        call.data.checksum = checksum.digest('hex');
      } else {
        call.data.checksumEnabled = false;
      }

      var messageToSend = {
        type: 'pushData',
        callerId: apiCC.session.apiCCId,
        convId: call.pushDataStatus.convId,
        callId: call.callId,
        data: call.data
      };
      var msgString = JSON.stringify(messageToSend);
      logger.debug('C->S: ' + msgString);
      apiCC.session.channel.socket.emit('pushData', msgString);
    }
  };
  /*
   * Closes a 'push data' call.
   * @ignore
   * @param {string} callId
   * @return {string|null} null on success, a message (String) otherwise.
   */


  this.cancelPushData = function (callId) {
    var call = null;

    for (var idx = this.callsTable.length; --idx >= 0;) {
      var c = this.callsTable[idx];

      if (c.callId === callId && c.callType === 'data' && c.dataCall && c.remoteId === 'dataChannelConnector' && c.pushDataStatus) {
        call = c;
        break;
      }
    } // for


    if (!call) {
      logger.error('cancelPushData - no such call', callId);
      return 'no such call';
    }

    if (call.pushDataStatus.state === 'pending') {
      // Call not up.
      // Send event and call failure callback.
      myWebRTC_Event.createEvent({
        eventType: 'onFileSended',
        callId: call.callId,
        remoteId: call.remoteId,
        name: call.data.filename,
        error: 'canceled'
      });
      call.callbacks.failure('canceled');
      this.onHangup(call.callId);
    } else if (call.pushDataStatus.state === 'active') {
      // Call up.
      this.onHangup(call.callId);
    } else if (call.pushDataStatus.state === 'ready') {
      // Pipeline call up.
      if (call.clientCall) {
        // Transfer ongoing.
        this.cancelPushData(call.clientCall.callId);
      }

      call.success = {
        state: 'complete'
      }; // Notify success.

      myWebRTC_Event.createEvent({
        eventType: 'onFileSended',
        callId: call.callId,
        remoteId: call.remoteId
      });
      call.callbacks.success(call.success);
      this.onHangup(call.callId);
    } else {
      // should not happen as we set state ourselves
      logger.error('cancelPushData - wrong state');
      return 'wrong state';
    }

    return null;
  };
  /*
   * Sets the expected bandwidth for a given category. Negative value to unset.
   * @method setVideoBandwidth
   * @ignore
   * @param {number} bandwidth - In kbps.
   * @param {string} flavor - Either 'overall' or 'perCall'.
   * @param {string} direction - Either 'incoming' or 'outgoing'.
   */


  this.setVideoBandwidth = function (bandwidth, flavor, direction) {
    if (typeof bandwidth !== 'number') {
      logger.error('Unvalid target bandwidth usage value needs to be a number :', bandwidth);
      return;
    }

    var changed = false;
    var outgoingChanged = false;

    if (flavor === 'overall') {
      if (direction === 'incoming') {
        if (bandwidth > 0) {
          this.videoBandwidthSettings.overallIncoming = bandwidth;
          changed = true;
        } else {
          delete this.videoBandwidthSettings.overallIncoming;
          changed = true;
        }
      } else if (direction === 'outgoing') {
        if (bandwidth > 0) {
          this.videoBandwidthSettings.overallOutgoing = bandwidth;
          changed = true;
          outgoingChanged = true;
        } else {
          delete this.videoBandwidthSettings.overallOutgoing;
          changed = true;
          outgoingChanged = true;
        }
      }
    } else if (flavor === 'perCall') {
      if (direction === 'incoming') {
        if (bandwidth > 0) {
          this.videoBandwidthSettings.perCallIncoming = bandwidth;
          changed = true;
        } else {
          delete this.videoBandwidthSettings.perCallIncoming;
          changed = true;
        }
      } else if (direction === 'outgoing') {
        if (bandwidth > 0) {
          this.videoBandwidthSettings.perCallOutgoing = bandwidth;
          changed = true;
          outgoingChanged = true;
        } else {
          delete this.videoBandwidthSettings.perCallOutgoing;
          changed = true;
          outgoingChanged = true;
        }
      }
    } else if (flavor === 'remote') {
      this.videoRemoteBandwidth = bandwidth;
    }

    if (changed) {
      for (var idx = this.MCUClient.sessionMCUs.length; --idx >= 0;) {
        var messageToSend = {
          type: 'info',
          infoType: 'setVideoBandwidthSettings',
          data: {
            clientId: this.clientId,
            roomId: this.MCUClient.sessionMCUs[idx].roomName,
            pubSub: this.MCUClient.pubConnector,
            videoBandwidthSettings: this.videoBandwidthSettings
          }
        };
        var msgString = JSON.stringify(messageToSend);
        logger.log('C->S: ' + msgString);
        apiCC.session.channel.socket.emit('info', msgString);
      } // for

    }

    if (outgoingChanged) {
      // Update all calls if necessary.
      this.evalOutgoingVideoBandwithCap();
    }
  };

  this.setAudioBandwidth = function (bandwidth) {
    this.audioBandwidth = bandwidth;
  };

  this.setDataBandwidth = function (bandwidth) {
    this.dataBandwidth = bandwidth;
  };
  /*
   * Message sent by CCS to check session and call status.
   * @param {object} msg
   */


  this.processCheckCallStatus = function (msg) {
    this.MCUClient.processCheckCallStatus(msg); // gather call status

    var messageToSend = {
      type: 'updateCallStatus',
      clientId: this.clientId,
      data: {}
    };

    if (msg.data.pubSub) {
      messageToSend.data.pubSub = msg.data.pubSub;
    } // MCU sessions


    messageToSend.sessions = [];

    for (var idx = 0; idx < this.MCUClient.sessionMCUs.length; idx += 1) {
      messageToSend.sessions.push(this.MCUClient.createSessionDescriptor(this.MCUClient.sessionMCUs[idx]));
    } // for
    // calls


    messageToSend.calls = [];

    for (var _idx2 = 0; _idx2 < this.userMediaTable.length; _idx2 += 1) {
      var call = this.userMediaTable[_idx2];
      messageToSend.calls.push({
        callId: call.userMediaId,
        callType: call.callType,
        remoteId: call.remoteId,
        roomId: call.roomId,
        data: call.data,
        meshPublish: true
      });
    } // for


    for (var _idx3 = 0; _idx3 < this.callsTable.length; _idx3 += 1) {
      var _call2 = this.callsTable[_idx3];
      messageToSend.calls.push({
        callId: _call2.callId,
        callType: _call2.callType,
        remoteId: _call2.remoteId,
        roomId: _call2.roomId,
        data: _call2.data,
        remoteStream: _call2.mcuRemoteStream
      });
    } // for


    var msgString = JSON.stringify(messageToSend);
    apiCC.session.channel.socket.emit('updateCallStatus', msgString);
  };
  /*
   * Called when a remote stream is added on given call.
   * @method processRemoteStreamAdded
   * @ignore
   * @param {WebRTC_Call} call
   * @param {MediaStream} stream
   */


  this.processRemoteStreamAdded = function (call, stream) {
    if (call.sessionMCU && call.sessionMCU.modeChangeKind === 'new') {
      logger.debug('processRemoteStreamAdded', call);
      var oldSessionMCU = this.MCUClient.getSessionMCU(null, {
        callback: function callback(entry) {
          return entry.roomName === call.sessionMCU.roomName && entry.modeChangeKind === 'old';
        }
      });

      if (!oldSessionMCU) {
        logger.error('wrong roomId: no such old session');
        return;
      }

      logger.debug('oldSessionMCU', oldSessionMCU); // Close the (previous) call replaced by the given one.

      for (var cIdx = this.callsTable.length; --cIdx >= 0;) {
        if (this.callsTable[cIdx].sessionMCU === oldSessionMCU && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(this.callsTable[cIdx], ['mcuRemoteStream', 'attributes', 'callId'], 'string') && this.callsTable[cIdx].mcuRemoteStream.attributes.callId === call.mcuRemoteStream.attributes.callId) {
          logger.debug('processRemoteStreamAdded: bye', this.callsTable[cIdx]);
          this.removeCallFromTableWithCallIdAndSendBye(this.callsTable[cIdx].callId);
          break;
        }
      }
    }
  };
  /*
   * @method processDistantCallEstablished
   * @ignore
   * @param {object} data
   * @param {boolean} data.active - True when the call is established, false when the call stopped.
   * @param {object} data.descriptor
   * @param {string} data.descriptor.roomId - Room ID.
   * @param {string} data.descriptor.clientId - User ID of subscriber.
   * @param {string} data.descriptor.callId - Call ID for the subscriber.
   * @param {string} data.descriptor.callMode - Either 'mesh' or 'sfu'.
   * @param {string} data.descriptor.callDirection - Either 'recvonly' or 'sendonly'.
   * @param {string} data.descriptor.callType
   * @param {object} data.descriptor.callProfile
   * @param {boolean} data.descriptor.callProfile.audio - Whether audio has been negotiated.
   * @param {boolean} data.descriptor.callProfile.audioActive - Whether audio is active.
   * @param {boolean} data.descriptor.callProfile.video - Whether video has been negotiated.
   * @param {boolean} data.descriptor.callProfile.videoActive - Whether video is active.
   * @param {object} data.descriptor.callFeed
   * @param {string} data.descriptor.callFeed.clientId - User ID of the feed's owner.
   * @param {string} data.descriptor.callFeed.callId - Call ID of the feed for its owner.
   */


  this.processDistantCallEstablished = function (data) {
    logger.debug('processDistantCallEstablished', data);

    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(data, ['descriptor', 'callFeed', 'callId'], 'string')) {
      logger.debug('wrong format: missing callFeed');
      return;
    }

    if (data.descriptor.callFeed.clientId !== this.clientId) {
      logger.debug('wrong clientId: message not intended for self');
      return;
    }

    var sessionMCU = null;

    if (data.descriptor.callMode === 'mesh') {
      sessionMCU = this.MCUClient.getSessionMCU(null, {
        callback: function callback(entry) {
          return entry.roomName === data.descriptor.roomId && entry.roomMode === 'mesh';
        }
      });
    } else if (data.descriptor.callMode === 'sfu') {
      sessionMCU = this.MCUClient.getSessionMCU(null, {
        callback: function callback(entry) {
          return entry.roomName === data.descriptor.roomId && !entry.hasOwnProperty('roomMode');
        }
      });
    }

    if (!sessionMCU) {
      logger.debug('wrong roomId: no such session');
      return;
    }

    logger.debug('sessionMCU', sessionMCU);
    var userMedia = null;
    var call = null;

    if (data.descriptor.callMode === 'mesh') {
      userMedia = this.findUserMediaById(data.descriptor.callFeed.callId);
      logger.debug('userMedia', userMedia);
    } else {
      call = this.findCallWithCallId(data.descriptor.callFeed.callId);
      logger.debug('call', call);
    } // Add/replace/remove distant call descriptor.


    if (data.active) {
      // Call active.
      if (!userMedia && !call) {
        logger.debug('wrong callId: no such call');
        return;
      }

      var idx = this.MCUClient.distantCalls.length;

      while (--idx >= 0) {
        if (this.MCUClient.distantCalls[idx].roomId === data.descriptor.roomId && this.MCUClient.distantCalls[idx].clientId === data.descriptor.clientId && this.MCUClient.distantCalls[idx].callId === data.descriptor.callId) {
          break;
        }
      }

      if (idx >= 0) {
        if (this.MCUClient.distantCalls[idx].early) {
          logger.debug('processDistantCallEstablished: replace early descriptor', this.MCUClient.distantCalls[idx], data.descriptor);
          this.MCUClient.distantCalls[idx] = data.descriptor;
        } else {
          logger.debug('processDistantCallEstablished: descriptor already exists');
          return;
        }
      } else {
        logger.debug('processDistantCallEstablished: add descriptor', data.descriptor);
        this.MCUClient.distantCalls.push(data.descriptor);
      }
    } else {
      // Call no longer active
      if (sessionMCU.modeChangeKind === 'old') {
        // mode change ongoing: keep the entry to insure transition
        for (var _idx4 = this.MCUClient.distantCalls.length; --_idx4 >= 0;) {
          if (this.MCUClient.distantCalls[_idx4].roomId === data.descriptor.roomId && this.MCUClient.distantCalls[_idx4].clientId === data.descriptor.clientId && this.MCUClient.distantCalls[_idx4].callId === data.descriptor.callId) {
            logger.debug('processDistantCallEstablished: set descriptor to removed', this.MCUClient.distantCalls[_idx4]);
            this.MCUClient.distantCalls[_idx4].removed = true;
            break;
          }
        } // for

      } else {
        // normal
        for (var _idx5 = this.MCUClient.distantCalls.length; --_idx5 >= 0;) {
          if (this.MCUClient.distantCalls[_idx5].roomId === data.descriptor.roomId && this.MCUClient.distantCalls[_idx5].clientId === data.descriptor.clientId && this.MCUClient.distantCalls[_idx5].callId === data.descriptor.callId) {
            logger.debug('processDistantCallEstablished: remove descriptor', this.MCUClient.distantCalls[_idx5]);
            this.MCUClient.distantCalls.splice(_idx5, 1);
            break;
          }
        } // for

      }
    }

    if (sessionMCU.modeChangeKind === 'new') {
      // Mode change is ongoing.
      // Get the sessionMCU representing the previous state.
      var oldSessionMCU = this.MCUClient.getSessionMCU(null, {
        callback: function callback(entry) {
          return entry.roomName === data.descriptor.roomId && entry.modeChangeKind === 'old';
        }
      });

      if (!oldSessionMCU) {
        logger.error('wrong roomId: no such old session');
        return;
      }

      logger.debug('oldSessionMCU', oldSessionMCU); // distant call description is a replacement.

      logger.debug('processDistantCallEstablished: replacement');
      var cleanUp = false;

      for (var uIdx = this.userMediaTable.length; --uIdx >= 0;) {
        var uEntry = this.userMediaTable[uIdx];

        if (uEntry.sessionMCU !== oldSessionMCU) {
          continue;
        }

        var match = false;
        var replacedCnt = 0;
        logger.debug('processDistantCallEstablished: userMedia', uEntry);

        for (var dIdx = uEntry.distantCalls.length; --dIdx >= 0;) {
          if (uEntry.distantCalls[dIdx].replaced) {
            replacedCnt += 1;
          } else if (uEntry.distantCalls[dIdx].callFeed.callId === data.descriptor.callFeed.callId) {
            logger.debug('processDistantCallEstablished: distantCall', uEntry.distantCalls[dIdx]);
            match = true;
            uEntry.distantCalls[dIdx].replaced = true;
            replacedCnt += 1;
          }
        } // for


        if (match) {
          // Current userMedia is related to distantCall.
          if (replacedCnt === uEntry.distantCalls.length) {
            // Every call has been replaced.
            logger.debug('processDistantCallEstablished: remove replaced distant call descriptors');

            for (var _dIdx = this.MCUClient.distantCalls.length; --_dIdx >= 0;) {
              if (this.MCUClient.distantCalls[_dIdx].callMode === 'mesh' && this.MCUClient.distantCalls[_dIdx].callFeed.callId === uEntry.userMediaId && this.MCUClient.distantCalls[_dIdx].replaced) {
                logger.debug('processDistantCallEstablished: remove distantCall', this.MCUClient.distantCalls[_dIdx]);
                this.MCUClient.distantCalls.splice(_dIdx, 1);
              }
            } // for


            logger.debug('processDistantCallEstablished: close old calls');
            var table = this.callsTable.slice();

            for (var cIdx = table.length; --cIdx >= 0;) {
              if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(table[cIdx].data, 'mesh', 'object') && table[cIdx].data.mesh.calleeCallId === uEntry.userMediaId && table[cIdx].settingUpType !== 'subscribe') {
                this.removeCallFromTableWithCallIdAndSendBye(table[cIdx].callId);
              }
            } // for
            // Finally, removing the given stream.


            this.MCUClient.meshOnHangup(uEntry.userMediaId); // Mark than a clean up is possibly needed.

            cleanUp = true;
          }

          break;
        }
      } // for
      // Possible clean up.


      if (cleanUp) {
        this.finalizeMeshToJanusTransition(oldSessionMCU, sessionMCU);
      }
    }
  };
  /*
   * Tries to finalize the mesh to janus transition.
   * @method finalizeMeshToJanusTransition
   * @ignore
   * @param {object} oldSessionMCU
   * @param {object} newSessionMCU
   * @param {object} options
   * @param {boolean} options.force - Whether to force the end of the transition.
   */


  this.finalizeMeshToJanusTransition = function (oldSessionMCU, newSessionMCU) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    // Check whether every userMedia is closed.
    logger.debug('finalizeMeshToJanusTransition');
    var userMediaAllCnt = 0;
    var userMediaReplCnt = 0;

    if (options.force === true) {
      // Force end of transition.
      var calls = this.callsTable.slice();

      for (var callIdx = calls.length; --callIdx >= 0;) {
        var call = calls[callIdx];

        if (call.sessionMCU !== oldSessionMCU) {
          continue;
        }

        if ((call.settingUpType === 'publish' || call.settingUpType === 'shareScreen') && call.data && call.data.mesh) {
          // This type of call will be restarted by the subscriber.
          this.onHangup(call.callId);
        } else {
          // Restart.
          this.onHangup(call.callId, 'disconnected');
        }
      } // for


      var userMediaList = this.userMediaTable.slice();

      for (var umIdx = userMediaList.length; --umIdx >= 0;) {
        var userMedia = userMediaList[umIdx];

        if (userMedia.sessionMCU !== oldSessionMCU) {
          continue;
        } // Restart.


        this.onHangup(userMedia.userMediaId, 'disconnected');
      } // for

    } else {
      // Normal process. See if subscribe calls have been replaced.
      for (var uIdx = this.userMediaTable.length; --uIdx >= 0;) {
        var uEntry = this.userMediaTable[uIdx];

        if (uEntry.sessionMCU !== oldSessionMCU) {
          continue;
        }

        userMediaAllCnt += 1;
        var replacedCnt = 0;

        for (var dIdx = uEntry.distantCalls.length; --dIdx >= 0;) {
          logger.debug('finalizeMeshToJanusTransition: distantCall', uEntry.distantCalls[dIdx]);

          if (uEntry.distantCalls[dIdx].replaced) {
            replacedCnt += 1;
          }
        } // for


        if (replacedCnt === uEntry.distantCalls.length) {
          userMediaReplCnt += 1;
        }
      } // for

    }

    if (userMediaAllCnt === userMediaReplCnt) {
      // Every call has been replaced.
      logger.debug('finalizeMeshToJanusTransition: finalize transition');

      if (newSessionMCU.transitionTimeoutId) {
        clearTimeout(newSessionMCU.transitionTimeoutId);
        delete newSessionMCU.transitionTimeoutId;
      }

      this.MCUClient.removeSessionMCU(oldSessionMCU);
      delete newSessionMCU.modeChangeKind;
      this.MCUClient.transitionCount -= 1;

      if (this.MCUClient.transitionCount <= 0) {
        this.evalOutgoingVideoBandwithCap();
      } // Fire MCURoomModeChanged event.


      myWebRTC_Event.createMCURoomModeChangedEvent(newSessionMCU.roomName, 'mesh', 'sfu', 'complete');
    }
  };
  /*
   * @ignore
   * @param {object} data
   * @param {object} data.callId
   * @param {number} data.maxBitrate
   */


  this.processConfigureEncodings = function (data) {
    var call = this.findCallWithCallId(data.callId);

    if (!call) {
      return;
    }

    if (!Object.prototype.hasOwnProperty.call(data, 'command')) {
      return;
    }

    if (call.simulcast === 'RID') {
      var opts = {};

      if (Object.prototype.hasOwnProperty.call(data, 'maxBitrate')) {
        opts.maxBitrate = data.maxBitrate;
      }

      call.configureSimulcastEncodings(data.command, opts);
    }
  };
  /*
   * @ignore
   * @param {object} data
   * @param {object} data.callId
   * @param {number} data.substream
   * @param {number} data.temporal
   */


  this.processSimulcastFeedChanged = function (data) {
    var call = this.findCallWithCallId(data.callId);

    if (!call) {
      return;
    }

    var simulcast = {};

    if (data.substream === 2) {
      simulcast.streamQuality = 'high';
    } else if (data.substream === 1) {
      simulcast.streamQuality = 'medium';
    } else if (data.substream === 0) {
      simulcast.streamQuality = 'low';
    }

    if (data.temporal === 2) {
      simulcast.streamFrameRate = 'high';
    } else if (data.temporal === 1) {
      simulcast.streamFrameRate = 'medium';
    } else if (data.temporal === 0) {
      simulcast.streamFrameRate = 'low';
    }

    if (Object.keys(simulcast).length > 0) {
      myWebRTC_Event.createSimulcastFeedChanged(call.callId, simulcast);
    }
  };
  /**
   * Tests whether a given receipt exists.
   * @param {string} receiptId
   */


  this.hasReceiptHook = function (receiptId) {
    if (!receiptId || typeof receiptId !== 'string') {
      throw new Error('wrong receiptId');
    }

    return Object.prototype.hasOwnProperty.call(this.receiptHooks, receiptId);
  };
  /**
   * Creates a new receiptHook.
   * @param {string} receiptId
   * @param {Future} future
   */


  this.createReceiptHook = function (receiptId, future) {
    var _this9 = this;

    if (this.hasReceiptHook(receiptId)) {
      throw new Error('receiptHook already exists');
    }

    if (!future || future.fulfilled !== false) {
      throw new Error('wrong future');
    }

    future.onFulfillment(function () {
      delete _this9.receiptHooks[receiptId];
    });
    this.receiptHooks[receiptId] = future;
  };
  /**
   * Finalizes a receiptHook with failure.
   * @param {string} receiptId
   * @param {Error} err
   */


  this.finalizeReceiptHookFailure = function (receiptId, err) {
    logger.debug('finalizeReceiptHookFailure', receiptId, err);

    if (!receiptId || typeof receiptId !== 'string') {
      throw new Error('wrong receiptId');
    }

    if (!Object.prototype.hasOwnProperty.call(this.receiptHooks, receiptId)) {
      throw new Error('receiptHook does not exist');
    }

    this.receiptHooks[receiptId].fulfill(err);
  };
  /**
   * Finalizes a receiptHook with success.
   * @param {string} receiptId
   * @param {any} res
   */


  this.finalizeReceiptHookSuccess = function (receiptId, res) {
    logger.debug('finalizeReceiptHookSuccess', receiptId, res);

    if (!receiptId || typeof receiptId !== 'string') {
      throw new Error('wrong receiptId');
    }

    if (!Object.prototype.hasOwnProperty.call(this.receiptHooks, receiptId)) {
      throw new Error('receiptHook does not exist');
    }

    this.receiptHooks[receiptId].fulfill(null, res);
  };
  /**
   * Processes a 'receipt' message.
   * It represents always a success.
   * It may contain a result.
   * @param {object} msg
   */


  this.processReceipt = function (msg) {
    if (!msg || _typeof(msg) !== 'object') {
      logger.warn('processReceipt: wrong msg');
      return;
    }

    var receiptId = msg.receiptId,
        result = msg.result;

    if (!receiptId || typeof receiptId !== 'string') {
      logger.warn('processReceipt: wrong receiptId');
      return;
    }

    try {
      this.finalizeReceiptHookSuccess(receiptId, result);
    } catch (e) {
      logger.debug('processReceipt: finalizeReceiptHookSuccess', e);
    }
  };
  /**
   * Processes an 'error' message.
   * It may contain a receiptId.
   * @param {object} msg
   */


  this.processError = function (msg) {
    var receiptId = msg.receiptId,
        errorInfo = msg.errorInfo,
        errorCode = msg.errorCode,
        callId = msg.callId,
        roomId = msg.roomId,
        convId = msg.convId;

    if (receiptId && typeof receiptId === 'string') {
      try {
        this.finalizeReceiptHookFailure(receiptId, new Error(errorInfo));
      } catch (e) {
        logger.debug('processError: finalizeReceiptHookFailure', e);
      }
    }

    myWebRTC_Event.createErrorEvent(errorInfo, errorCode, callId, roomId, null, null, convId);
  };
  /*
   * Creates a new CallControl and adds it into the callControlTable.
   * @ignore
   * @param {object} context
   * @param {string} context.type - 'publish', 'shareScreen', 'subscribe'.
   * @param {string} context.callId - Initial callId.
   * @param {string} context.mediaType - Optional mediaType in case of type 'subscribe'.
   * @param {object} context.callConfiguration
   * @param {object} context.data
   * @param {object} context.stream - Optional stream descriptor in case of type 'subscribe'.
   * @return {CallControl}
   */


  this.createCallControl = function (context) {
    var newCallControl = new _CallControl__WEBPACK_IMPORTED_MODULE_6__.CallControl(context);
    this.callControlTable.push(newCallControl);
    return newCallControl;
  };
  /*
   * Removes a given CallControl from the callControlTable.
   * @ignore
   * @param {object} context
   * @return {CallControl | null} A CallControl if it exists, null otherwise.
   */


  this.destroyCallControl = function (context) {
    if (context.multi) {
      if (!context.roomName) {
        logger.warn('findCallControl: cannot destroy without roomName');
        return null;
      }

      var res = [];

      for (var idx = this.callControlTable.length; --idx >= 0;) {
        if (this.callControlTable[idx].roomName === context.roomName) {
          res.push(this.callControlTable[idx]);
          this.callControlTable.splice(idx, 1);
        }
      } // for


      return res;
    } else {
      var index = this.findCallControl(context, {
        accept: 'index'
      });

      if (index !== null && index >= 0) {
        var callControl = this.callControlTable[index];
        this.callControlTable.splice(index, 1);
        return callControl;
      }
    }

    return null;
  };
  /*
   * Searches for a CallControl (in the callControlTable) and returns it if it exists.
   * @ignore
   * @param {object} context
   * @param {string} context.type
   * @param {object}
   * @param {object} options
   * @param {string} options.accept - Optional 'index'.
   * @return {CallControl | number | null} A CallControl if it exists, null otherwise.
   */


  this.findCallControl = function (context) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var acceptIndex = options.accept === 'index';

    if (context.type === 'publish' || context.type === 'shareScreen') {
      if (!context.callId) {
        logger.warn('findCallControl: cannot search without callId');
        return null;
      }

      var callControl = null;
      var callControlIndex = null;

      for (var idx = this.callControlTable.length; --idx >= 0;) {
        if (this.callControlTable[idx].type !== 'publish' && this.callControlTable[idx].type !== 'shareScreen') {
          continue;
        }

        if (this.callControlTable[idx].callId === context.callId) {
          // match
          callControl = this.callControlTable[idx];
          callControlIndex = idx;
          break;
        }
      } // for


      if (callControl) {
        return acceptIndex ? callControlIndex : callControl;
      }

      return null;
    } else if (context.type === 'subscribe') {
      if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(context, 'stream', 'object') || !Object.prototype.hasOwnProperty.call(context.stream, 'id') || !(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isPropertyTypeof)(context.stream, 'attributes', 'object')) {
        logger.warn('findCallControl: cannot search without stream');
        return null;
      }

      var _callControl2 = null;
      var _callControlIndex = null;

      for (var _idx6 = this.callControlTable.length; --_idx6 >= 0;) {
        if (this.callControlTable[_idx6].type !== 'subscribe') {
          continue;
        }

        if (this.callControlTable[_idx6].stream.id === context.stream.id || this.callControlTable[_idx6].stream.attributes.callerId === context.stream.attributes.callerId && this.callControlTable[_idx6].stream.attributes.callId === context.stream.attributes.callId) {
          // match
          _callControl2 = this.callControlTable[_idx6];
          _callControlIndex = _idx6;
          break;
        }
      } // for


      if (_callControl2) {
        return acceptIndex ? _callControlIndex : _callControl2;
      }

      return null;
    }

    logger.warn('findCallControl: wrong type', context.type);
    return null;
  };
  /*
   * Maps the callControls with their callIds and filters them if necessary.
   * @ignore
   * @param {object} types - null (no filter) or an array of types. Values can be 'publish', 'shareScreen' and 'publish'.
   * @param {object} options
   * @param {string} options.addUserMedia
   * @return {object} An object.
   */


  this.getCallControls = function (types) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var ret = {};

    if (options.addUserMedia) {
      for (var idx = this.userMediaTable.length; --idx >= 0;) {
        var userMedia = this.userMediaTable[idx];
        ret[userMedia.userMediaId] = userMedia;
      } // for

    }

    if (types) {
      for (var _idx7 = this.callControlTable.length; --_idx7 >= 0;) {
        var callControl = this.callControlTable[_idx7];

        if (types.indexOf(callControl.type) >= 0) {
          ret[callControl.callId] = callControl;
        }
      } // for


      return ret;
    }

    for (var _idx8 = this.callControlTable.length; --_idx8 >= 0;) {
      var _callControl3 = this.callControlTable[_idx8];
      ret[_callControl3.callId] = _callControl3;
    } // for


    return ret;
  };
  /*
   * Gathers the callIds of all calls matching a given set of types.
   * @ignore
   * @param {object} types - An array of types. Values can be 'publish', 'shareScreen' and 'publish'.
   * @return {object} An array of callIds (string).
   */


  this.getCallIds = function (types) {
    var ret = [];

    for (var idx = this.callControlTable.length; --idx >= 0;) {
      var callControl = this.callControlTable[idx];

      if (types.indexOf(callControl.type) >= 0) {
        ret.push(callControl.callId);
      }
    } // for


    return ret;
  };
  /*
   * Evaluates the outgoing video bandwidth cap for a single call.
   * This method shall be used in the following cases:
   * - to get a cap value to fill the AS/TIAS field of the SDP answer before
   *   applying it (process200OK and process200update).
   * - to reevaluate cap values for ongoing calls on call hangup.
   * This method triggers update for ongoing calls if necessary and if the
   * browser does not support RTCRtpSender#setParameters.
   * If the browser supports RTCRtpSender#setParameters, then the limit is set
   * directly to the video encoder.
   * @ignore
   * @method evalOutgoingVideoBandwithCap
   * @param {WebRTC_Call) call - The call being treated (may be null).
   * @return {number|null} A number if there is a cap, null otherwise.
   */


  this.evalOutgoingVideoBandwithCap = function (call) {
    logger.debug('evalOutgoingVideoBandwithCap'); // During transition, we do not set anything, we are waiting for the end of the transition.

    if (this.MCUClient.transitionCount > 0) {
      logger.debug('evalOutgoingVideoBandwithCap - transition ongoing');
      return;
    }

    var cap = null;

    if (this.videoBandwidthSettings.perCallOutgoing) {
      cap = this.videoBandwidthSettings.perCallOutgoing;
    } // Gather all calls emitting video.


    var calls = [];

    for (var idx = this.callsTable.length; --idx >= 0;) {
      if (this.callsTable[idx].belongsToRoom()) {
        // Room call.
        if (this.callsTable[idx].settingUpType === 'publish' || this.callsTable[idx].settingUpType === 'shareScreen') {
          if (this.callsTable[idx].localCallProfile && this.callsTable[idx].localCallProfile.video && this.callsTable[idx].localCallProfile.videoActive) {
            calls.push(this.callsTable[idx]);
          }
        }
      } else {
        // 1-to-1 call.
        if (this.callsTable[idx].localCallProfile && this.callsTable[idx].localCallProfile.video && this.callsTable[idx].localCallProfile.videoActive) {
          calls.push(this.callsTable[idx]);
        }
      }
    } // for


    if (calls.length === 0) {
      return cap;
    } // Apply cap.


    if (this.videoBandwidthSettings.overallOutgoing) {
      var c = Math.floor(this.videoBandwidthSettings.overallOutgoing / calls.length);

      if (cap) {
        cap = Math.min(cap, c);
      } else {
        cap = c;
      }
    }

    for (var _idx9 = calls.length; --_idx9 >= 0;) {
      if (call && calls[_idx9] === call) {
        // Specified call.
        // Apply directly to video encoder but do not trigger any update.
        if (cap && calls[_idx9].videoCap !== cap) {
          calls[_idx9].videoCap = cap;

          if (this.rtpSenderSetParamatersCapable) {
            // Apply limit directly to video encoder.
            calls[_idx9].applyOutgoingBitrate(calls[_idx9].videoCap);
          }
        } else if (!cap && calls[_idx9].videoCap) {
          delete calls[_idx9].videoCap;

          if (this.rtpSenderSetParamatersCapable) {
            // Apply limit directly to video encoder.
            calls[_idx9].applyOutgoingBitrate(null);
          }
        }
      } else if (cap && calls[_idx9].videoCap !== cap) {
        // Cap exists and current call does not use it.
        calls[_idx9].videoCap = cap;

        if (this.rtpSenderSetParamatersCapable) {
          // Set limit to encoder.
          calls[_idx9].applyOutgoingBitrate(calls[_idx9].videoCap);
        } else {
          // Trigger update.
          setTimeout(function (call) {
            if (call.belongsToRoom() || !call.callee) {
              call.updateUserMedia = true;
              call.establishCall();
            } else {
              logger.debug('Call is not to be updated');
            }
          }, 0, calls[_idx9]);
        }
      } else if (!cap && calls[_idx9].videoCap) {
        // Cap does not exist and call is using one.
        delete calls[_idx9].videoCap;

        if (this.rtpSenderSetParamatersCapable) {
          // Delete limit from encoder.
          calls[_idx9].applyOutgoingBitrate(null);
        } else {
          // Trigger update.
          setTimeout(function (call) {
            if (call.belongsToRoom() || !call.callee) {
              call.updateUserMedia = true;
              call.establishCall();
            } else {
              logger.debug('Call is not to be updated');
            }
          }, 0, calls[_idx9]);
        }
      }
    } // for


    return cap;
  };

  this.callback = function (that, fnct) {
    this.closureHandler = function (e) {
      return that[fnct](e);
    };

    return this.closureHandler;
  };

  this.callbackWithParams = function (that, fnct) {
    this.closureHandler = function (e, f, g) {
      return that[fnct](e, f, g);
    };

    return this.closureHandler;
  };

  this.simulatedAgentLaunchWaitingCall = function () {
    var params = {
      type: "simulatedAgentLaunchWaitingCall"
    };
    this.socket.emit('simulatedAgentLaunchWaitingCall', params);
  };
}; //End WebRTC_Client class




/***/ }),

/***/ "./src/Core/WebRTC_Event.js":
/*!**********************************!*\
  !*** ./src/Core/WebRTC_Event.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebRTC_Event": () => (/* binding */ WebRTC_Event)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ "./src/Core/Utils.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/* globals $jqApz,jQuery, React, apiCC, apiRTC_React, eventManager*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('WebRTC_Event');


/*
* WebRTC_Event manage the creation and dispatch of apiRTC events .
*
* @module WebRTC_Event
*/

var WebRTC_Event = function WebRTC_Event() {
  logger.debug('WebRTC_Event');
  this.customEventIsDefined = 'notTested';

  if (this.customEventIsDefined === 'notTested') {
    try {
      //Run some code here
      //var event = new CustomEvent('test', {
      new CustomEvent('test', {
        detail: "test",
        bubbles: true,
        cancelable: true
      });
      this.customEventIsDefined = true;
    } catch (err) {
      //Handle errors here
      this.customEventIsDefined = false;
      logger.log('customEvent error :' + err);
    }
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version > 8.0 || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Netscape') {
    //Function to polyfill the CustomEvent() constructor functionality in Internet Explorer 9 and 10
    logger.log('polyfill the CustomEvent()');

    (function () {
      function CustomEvent(event, params) {
        params = params || {
          bubbles: false,
          cancelable: false,
          detail: undefined
        };
        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }

      CustomEvent.prototype = window.CustomEvent.prototype;
      window.CustomEvent = CustomEvent;
    })();

    this.customEventIsDefined = true;
  }

  if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_version > 8.0) {
    //Function to polyfill startsWith
    logger.log('polyfill startsWith()');

    if (!String.prototype.startsWith) {
      String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
      };
    }
  }

  this.eventDispatchMgr = function (type, detail) {
    if (typeof apiRTC_React !== 'undefined') {
      var eventReact = {
        type: type,
        detail: detail
      };
      eventManager.dispatchEvent(eventReact);
    } else if (this.customEventIsDefined === false) {
      if (typeof $jqApz !== 'undefined') {
        logger.log('CustomEvent not supported by Browser, using $jqApz ');
        $jqApz.event.trigger({
          type: type,
          detail: detail
        });
      } else if (typeof jQuery !== 'undefined') {
        logger.log('CustomEvent not supported by Browser, using jQuery ');
        jQuery.event.trigger({
          type: type,
          detail: detail
        });
      } else {
        logger.warn('Custom Events not supported on this browser : eventDispatchMgr()');
      }
    } else {
      var event = new CustomEvent(type, {
        detail: detail,
        bubbles: true,
        cancelable: true
      });
      document.dispatchEvent(event);
    }
  };

  this.createIncomingCallEvent = function (clientId, callerId, callerNickname, callId, autoAnswerActivated, callNumber, audioOnly, callType, recordedCall, remoteType, destCallType) {
    var type = 'incomingCall',
        detail = {
      eventType: 'incomingCall',
      time: new Date(),
      clientId: clientId,
      callerId: callerId,
      callId: callId,
      autoAnswerActivated: autoAnswerActivated,
      callNumber: callNumber,
      callerNickname: callerNickname,
      audioOnly: audioOnly,
      callType: callType,
      destCallType: destCallType,
      recordedCall: recordedCall,
      remoteType: remoteType
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createCallAttemptEvent = function (clientId, callerId, callerNickname, callId) {
    var type = 'callAttempt',
        detail = {
      eventType: 'callAttempt',
      time: new Date(),
      clientId: clientId,
      callerId: callerId,
      callId: callId,
      callerNickname: callerNickname
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createCallEstablishedEvent = function (calleeId, callType, callId, destCallType) {
    logger.debug("createCallEstablishedEvent with callType : " + callType);
    logger.debug("destCallType : " + destCallType);
    var type = 'callEstablished',
        detail = {
      eventType: 'callEstablished',
      time: new Date(),
      calleeId: calleeId,
      callType: callType,
      callId: callId,
      destCallType: destCallType
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createHangupEvent = function (hangupType, clientId, remoteId, lastEstablishedCall, reason, callId, callType) {
    var type = 'hangup',
        detail = {
      eventType: 'hangup',
      time: new Date(),
      hangupType: hangupType,
      clientId: clientId,
      remoteId: remoteId,
      lastEstablishedCall: lastEstablishedCall,
      reason: reason,
      callId: callId,
      callType: callType
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createRemoteHangupEvent = function (clientId, remoteId, lastEstablishedCall, reason) {
    var type = 'remoteHangup',
        detail = {
      eventType: 'remoteHangup',
      time: new Date(),
      clientId: clientId,
      remoteId: remoteId,
      lastEstablishedCall: lastEstablishedCall,
      reason: reason
    };
    this.eventDispatchMgr(type, detail);
  };
  /*
   * Fires a callRestarting event.
   * @ignore
   * @param {string} callType
   * @param {boolean} audioOnly
   * @param {string} oldCallId
   * @param {string} newCallId
   * @param {string} dataType - 'publish' or 'subscribe' if defined. May be null.
   * @param {string} clientId
   * @param {string} remoteId
   * @param {string} destRoom - May be null.
   * @param {string} streamId - May be null.
   */


  this.createCallRestartingEvent = function (callType, audioOnly, oldCallId, newCallId, dataType, clientId, remoteId, destRoom, streamId) {
    var type = 'callRestarting',
        detail = {
      eventType: 'callRestarting',
      time: new Date(),
      callType: callType,
      audioOnly: audioOnly,
      oldCallId: oldCallId,
      newCallId: newCallId,
      dataType: dataType,
      clientId: clientId,
      remoteId: remoteId,
      destRoom: destRoom,
      streamId: streamId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createUserMediaSuccessEvent = function (onCallEstablishment, audioIsAvailable, audioDeviceLabel, videoIsAvailable, videoDeviceLabel, callType, callId, stream, remoteId, restarted, userMediaStreamId) {
    var type = 'userMediaSuccess',
        detail = {
      eventType: 'userMediaSuccess',
      time: new Date(),
      onCallEstablishment: onCallEstablishment,
      audioIsAvailable: audioIsAvailable,
      audioDeviceLabel: audioDeviceLabel,
      videoIsAvailable: videoIsAvailable,
      videoDeviceLabel: videoDeviceLabel,
      callType: callType,
      callId: callId,
      stream: stream,
      remoteId: remoteId,
      restarted: restarted,
      userMediaStreamId: userMediaStreamId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createUserMediaErrorEvent = function (onCallEstablishment, callType, error, userMediaStreamId, callId, tryAudioCallActivated, gumConfig) {
    var type = 'userMediaError',
        detail = {
      eventType: 'userMediaError',
      time: new Date(),
      onCallEstablishment: onCallEstablishment,
      callType: callType,
      userMediaStreamId: userMediaStreamId,
      callId: callId,
      tryAudioCallActivated: tryAudioCallActivated,
      gumConfig: gumConfig
    };

    if (_typeof(error) === 'object') {
      detail.error = {};
      detail.error.message = error.message;
      detail.error.code = error.code;
      detail.error.name = error.name;
    } else {
      detail.error = error;
    }

    this.eventDispatchMgr(type, detail);
  };

  this.createUserMediaStopEvent = function (callId, mediaType, userMediaStreamId) {
    var type = 'userMediaStop',
        detail = {
      eventType: 'userMediaStop',
      time: new Date(),
      callId: callId,
      mediaType: mediaType,
      userMediaStreamId: userMediaStreamId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createICECandidateTypeUpdateEvent = function (callId, localCandidate, remoteCandidate) {
    var type = 'ICECandidateTypeUpdate',
        detail = {
      eventType: 'ICECandidateTypeUpdate',
      time: new Date(),
      callId: callId,
      localCandidate: localCandidate,
      remoteCandidate: remoteCandidate
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createSelectedICECandidateEvent = function (callId, localCandidateType, remoteCandidateType, localAddress, remoteAdress, transportType, localTransportType) {
    var type = 'selectedICECandidate',
        detail = {
      eventType: 'selectedICECandidate',
      time: new Date(),
      callId: callId,
      localCandidateType: localCandidateType,
      remoteCandidateType: remoteCandidateType,
      localAddress: localAddress,
      remoteAdress: remoteAdress,
      transportType: transportType,
      localTransportType: localTransportType
    };
    this.eventDispatchMgr(type, detail);
  };
  /**
   * @typedef {Object} IceErrorDescriptor
   * @memberof module:ApiRTC
   * @property {String} iceState - Either 'failed' or 'disconnected'.
   * @property {String} previousIceState - Either 'disconnected' or undefined.
   * @property {String} callType - Either 'media', 'audio', 'screenSharing', 'videoOnly', 'data' or 'screenSharingWithAudio'.
   * @property {String} context - Either 'conf' or 'call'.
   * @property {String} mode - Either 'mesh' (when context is 'conf'), 'sfu' (when context is 'conf') or 'p2p' (when context is 'call').
   * @property {String} type - Either 'publish' (when context is 'conf'), 'subscribe' (when context is 'conf') or undefined (when context is 'call').
   * @property {String} clientId - Local user ID from where this descriptor come from.
   * @property {String} remoteId - Distant user ID from where this descriptor come from.
   * @property {Object} mesh - Additional information when mode is 'mesh'.
   * @property {String} mesh.callerId - User ID of caller (subscriber).
   * @property {String} mesh.callerCallId - Call ID for the caller (subscriber).
   * @property {String} mesh.calleeId - User ID of the feed.
   * @property {String} mesh.calleeCallId - Call ID of the feed.
   * @property {Object} stream - Feed information when type is 'subscribe'.
   * @property {Object} stream.attributes - Feed attributes when type is 'subscribe'.
   * @property {Object} stream.attributes.callerId - User ID of the feed.
   * @property {Object} stream.attributes.callId - Call ID of the feed.
   */

  /**
   * <p>Fired on error: an error has occured.</p>
   * <p>Managed errors are the following: (errorInfo, errorCode)</p>
   * <i>Connection errors:</i>
   * <ul>
   * <li>ice disconnection detected: ICE_CONNECTION_STATE_DISCONNECTED</li>
   * <li>ice connection failed detected: ICE_CONNECTION_STATE_FAILED</li>
   * <li>distant ice disconnection detected: DISTANT_ICE_CONNECTION_STATE_DISCONNECTED</li>
   * <li>distant ice connection failed detected: DISTANT_ICE_CONNECTION_STATE_FAILED</li>
   * </ul>
   * <i>Errors on signaling processing:</i>
   * <ul>
   * <li>200OK received but callId is not matching, no process : NOT_MATCHING_CALLID_ON_200OK</li>
   * <li>Cannot find call to process Update : CALL_NOT_FOUND_ON_UPDATE</li>
   * <li>Cannot find call to process 200 Update : CALL_NOT_FOUND_ON_200UPDATE</li>
   * <li>Call aborted after calls retries (maxCallsRetriesDuration reached) : CALL_ABORTED</li>
   * </ul>
   * <i>Errors on Media establishment processing:</i>
   * <ul>
   * <li>Set local Description Failure : SET_LOCAL_DESCRIPTION_FAILURE</li>
   * <li>Set remote Description Failure : SET_REMOTE_DESCRIPTION_FAILURE</li>
   * </ul>
   * <i>Errors on calling API:</i>
   * <ul>
   * <li>parameter error when calling function: setUnidirectionalCall(): PARAMETER_ERROR_SETUNIDIRCALL</li>
   * <li>parameter error when calling function: setNtoNConf(): PARAMETER_ERROR_SETNTONCONF</li>
   * <li>parameter error when calling function: setRTPMedia(): PARAMETER_ERROR_SETRTPMEDIA</li>
   * <li>parameter error when calling function: setMediaRoutingMode(): PARAMETER_ERROR_SETMEDIAROUTINGMODE</li>
   * <li>parameter error when calling function: setUserAcceptOnIncomingCall(): PARAMETER_ERROR_SETUSERACCEPTONINCOCALL</li>
   * <li>Trying to add a listener on an unknown event: UNKNOWN_EVENT_ON_ADDLISTENER</li>
   * <li>parameter error when calling function: setAllowMultipleCalls(): PARAMETER_ERROR_SETALLOWMULTIPLECALLS</li>
   * </ul>
   * <i>Errors about recording :</i>
   * <ul>
   * <li>Room not found when starting recording: START_RECORD_ROOM_NOT_FOUND</li>
   * <li>Caller not found when starting recording: START_RECORD_CALLER_NOT_FOUND</li>
   * <li>Media not found when starting recording: START_RECORD_MEDIA_FOUND</li>
   * <li>Recording is already ongoing: START_RECORD_ALREADY_ON</li>
   * <li>Room not found when stopping recording: STOP_RECORD_ROOM_NOT_FOUND</li>
   * <li>Caller not found when stopping recording: STOP_RECORD_CALLER_NOT_FOUND</li>
   * <li>Media not found when stopping recording: STOP_RECORD_MEDIA_FOUND</li>
   * <li>Recorder not found when stopping recording: STOP_RECORD_ENDPOINT_NOT_FOUND</li>
   * <li>Recording is not started stopping recording: STOP_RECORD_NOT_STARTED</li>
   * <li>Recorder is not ready yet, record is not started: STOP_RECORD_RECORDER_NOT_READY</li>
   * </ul>
   * <i>Errors about media play:</i>
   * <ul>
   * <li>Autoplay was prevented: IOS_AUTOPLAY_PREVENTED</li>
   * </ul>
   * <i>Errors about media streams:</i>
   * <ul>
   * <li>Error during media update on call: MEDIA_UPDATE_ERROR</li>
   * </ul>
   * <i>Errors about user media:</i>
   * <ul>
   * <li>Error during media media access: USER_MEDIA_ERROR</li>
   * </ul>
   * <i>Errors about remote stream:</i>
   * <ul>
   * <li>Error during subscription: STREAM_NOT_AVAILABLE</li>
   * </ul>
   * @event error
   * @memberof module:ApiRTC
   * @param {String} type - 'error'
   * @param {Object} detail - Event detail.
   * @param {String} detail.eventType - 'error'.
   * @param {String} detail.time - Date
   * @param {String} detail.errorInfo - Description of the error
   * @param {String} detail.errorCode - Error Code.
   * @param {String} detail.callId - Call identifier (when the error is call related).
   * @param {String} detail.roomName - Room Name (when the error is room related).
   * @param {String} detail.roomCallType - roomCallType if error is linked room call
   * @param {IceErrorDescriptor|Object} detail.data - Additional information.
   * @param {String} detail.convId - Conversation ID (optional)
   */


  this.createErrorEvent = function (errorInfo, errorCode, callId, roomName, roomCallType, data, convId) {
    var type = 'error',
        detail = {
      eventType: 'error',
      time: new Date(),
      errorInfo: errorInfo,
      errorCode: errorCode,
      callId: callId,
      roomName: roomName,
      roomCallType: roomCallType
    };

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(data, 'object')) {
      detail.data = data;
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(convId, 'string')) {
      detail.convId = convId;
    }

    this.eventDispatchMgr(type, detail);
  };

  this.createReceiveIMMessageEvent = function (senderId, senderNickname, senderPhotoURL, message, UUCSeq, convId) {
    var type = 'receiveIMMessage',
        detail = {
      eventType: 'receiveIMMessage',
      time: new Date(),
      senderId: senderId,
      senderNickname: senderNickname,
      senderPhotoURL: senderPhotoURL,
      message: message,
      UUCSeq: UUCSeq,
      convId: convId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createChannelEvent = function (channelEvent, event) {
    var type = 'channelEvent',
        detail = {
      eventType: 'channelEvent',
      time: new Date(),
      channelEvent: channelEvent,
      event: event
    };
    this.eventDispatchMgr(type, detail);
  };
  /**
  * Fired when the session is ready : the connection is established with the server
  * @event sessionReady
  * @memberof module:ApiRTC
  * @param {String} eventType "sessionReady"
  * @param {String} time Date
  * @param {String} apiCCId Identifier of the session
  **/


  this.createSessionReadyEvent = function (apiCCId) {
    logger.debug('createSessionReadyEvent');
    var type = 'sessionReady',
        detail = {
      eventType: 'sessionReady',
      time: new Date(),
      apiCCId: apiCCId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createWebRTCClientCreatedEvent = function () {
    var type = 'webRTCClientCreated',
        detail = {
      eventType: 'webRTCClientCreated',
      time: new Date()
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createUpdatePresenceEvent = function (connectedUsersList, state, connectedUsersListWithStatus) {
    var type = 'updatePresence',
        detail = {
      eventType: 'updatePresence',
      time: new Date(),
      connectedUsersList: connectedUsersList,
      connectedUsersListWithStatus: connectedUsersListWithStatus,
      state: state
    };
    this.eventDispatchMgr(type, detail);
  };
  /*
   * Dispatches a cloudEventOccurred.
   * @param {string} type
   * @param {object} target
   */


  this.createCloudEventOccurredEvent = function (topic, target) {
    var type = 'cloudEventOccurred',
        detail = {
      eventType: 'cloudEventOccurred',
      time: new Date(),
      topic: topic,
      target: target
    };
    this.eventDispatchMgr(type, detail);
  }; //Doc a voir : s'il faut ajouter dans doc

  /*
  * Fired to update the status informations of other users : userStatus, user comments
  * @event updateUserStatus
  * @param {String} e.detail.eventType : "updateUserStatus"
  * @param {String} e.detail.time : Date
  * @param {String} e.detail.message : update user status message
  */


  this.createUpdateUserStatusEvent = function (message) {
    var type = 'updateUserStatus',
        detail = {
      eventType: 'updateUserStatus',
      time: new Date(),
      message: message
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createGroupChatCreationEvent = function (status, groupChatId, initialDestId, invitationSendedToInitialDestId, newContactId, invitationSendedToNewContactId) {
    var type = 'groupChatCreation',
        detail = {
      eventType: 'groupChatCreation',
      time: new Date(),
      status: status,
      groupChatId: groupChatId,
      initialDestId: initialDestId,
      invitationSendedToInitialDestId: invitationSendedToInitialDestId,
      newContactId: newContactId,
      invitationSendedToNewContactId: invitationSendedToNewContactId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createGroupChatInvitationEvent = function (groupChatId, senderId, senderNickname, senderPhotoURL, contactList) {
    var type = 'groupChatInvitation',
        detail = {
      eventType: 'groupChatInvitation',
      time: new Date(),
      groupChatId: groupChatId,
      contactList: contactList,
      senderId: senderId,
      senderNickname: senderNickname,
      senderPhotoURL: senderPhotoURL
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createGroupChatMemberUpdateEvent = function (groupChatId, contactList, status) {
    var type = 'groupChatMemberUpdate',
        detail = {
      eventType: 'groupChatMemberUpdate',
      time: new Date(),
      groupChatId: groupChatId,
      contactList: contactList,
      status: status
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createAddUserInGroupChatEvent = function (invitationSended, groupChatId, contactId) {
    var type = 'addUserInGroupChatAnswer',
        detail = {
      eventType: 'addUserInGroupChatAnswer',
      time: new Date(),
      invitationSended: invitationSended,
      groupChatId: groupChatId,
      contactId: contactId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createReceiveGroupChatMessageEvent = function (groupChatId, senderId, senderNickname, message, metadata) {
    var type = 'receiveGroupChatMessage',
        detail = {
      eventType: 'receiveGroupChatMessage',
      time: new Date(),
      groupChatId: groupChatId,
      senderId: senderId,
      senderNickname: senderNickname,
      message: message
    };

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(metadata, 'object')) {
      detail.metadata = metadata;
    }

    this.eventDispatchMgr(type, detail);
  };

  this.createReceiveConversationListAnswerEvent = function (convList) {
    var type = 'receiveConversationList',
        detail = {
      eventType: 'receiveConversationList',
      time: new Date(),
      convList: convList
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createReceiveContactOccurrencesFromConversationListAnswerEvent = function (occurrencesList) {
    var type = 'receiveContactOccurrencesFromConversationList',
        detail = {
      eventType: 'receiveContactOccurrencesFromConversationList',
      time: new Date(),
      occurrencesList: occurrencesList
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createReceiveConversationDetailReportAnswerEvent = function (CDR) {
    var type = 'receiveConversationDetailReport',
        detail = {
      eventType: 'receiveConversationDetailReport',
      time: new Date(),
      CDR: CDR
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createReceiveConversationHistoryEvent = function (convId, convHistory, status) {
    var type = 'receiveConversationHistory',
        detail = {
      eventType: 'receiveConversationHistory',
      time: new Date(),
      convId: convId,
      convHistory: convHistory,
      status: status
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createUserDataAnswerEvent = function (userFound, contactId, nickname, photoURL) {
    var type = 'userDataAnswer',
        detail = {
      eventType: 'userDataAnswer',
      time: new Date(),
      userFound: userFound,
      contactId: contactId,
      nickname: nickname,
      photoURL: photoURL
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createFetchUserDataAnswerEvent = function (msg) {
    var type = 'fetchUserDataAnswer',
        detail = {
      eventType: type,
      timeout: msg.timeout,
      userData: msg.userData,
      id: msg.id
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createReceiveDataEvent = function (senderId, dstRoomId, data) {
    var type = 'receiveData',
        detail = {
      eventType: 'receiveData',
      time: new Date(),
      senderId: senderId,
      dstRoomId: dstRoomId,
      data: data
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createReceiveAppRemoteEvent = function (senderId, dstRoomId, data) {
    var type = 'remoteAppMessage',
        detail = {
      eventType: 'remoteAppMessage',
      time: new Date(),
      senderId: senderId,
      dstRoomId: dstRoomId,
      data: data
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createMCUSessionCreationEvent = function (sessionId, token) {
    var type = 'MCUSessionCreation',
        detail = {
      eventType: 'MCUSessionCreation',
      time: new Date(),
      sessionId: sessionId,
      token: token
    };
    this.eventDispatchMgr(type, detail);
  };
  /*
   * Fires a joinMCUSessionAnswer event.
   * @ignore
   * @param {string} sessionId
   * @param {string} token
   * @param {string} groupChatId
   * @param {boolean} initiator
   * @param {object} sessionMCU
   * @param {string} sessionMCU.roomName
   * @param {(string|undefined)} sessionMCU.mode
   * @param {object} sessionMCU.joinSessionAnswer
   * @param {boolean} sessionMCU.joinSessionAnswer.failed
   */


  this.createJoinMCUSessionAnswerEvent = function (sessionId, token, groupChatId, initiator, sessionMCU) {
    var type = 'joinMCUSessionAnswer',
        detail = {
      eventType: 'joinMCUSessionAnswer',
      time: new Date(),
      sessionId: sessionId,
      token: token,
      groupChatId: groupChatId,
      initiator: initiator,
      roomId: sessionMCU.roomName
    };

    if (sessionMCU.roomMode) {
      detail.mode = sessionMCU.roomMode;
    }

    if (sessionMCU.meshOnly === true) {
      detail.meshOnly = true;
    }

    if (sessionMCU.joinSessionAnswer) {
      detail.result = Object.assign({}, sessionMCU.joinSessionAnswer);
    }

    this.eventDispatchMgr(type, detail);
  };

  this.createMCUAvailableStreamEvent = function (streams, isRemoteStream) {
    var type = 'MCUAvailableStream',
        detail = {
      eventType: 'MCUAvailableStream',
      time: new Date(),
      streams: streams,
      isRemoteStream: isRemoteStream
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createMCUAvailableReplayEvent = function (streams, isRemoteStream) {
    var type = 'MCUAvailableReplay',
        detail = {
      eventType: 'MCUAvailableReplay',
      time: new Date(),
      streams: streams,
      isRemoteStream: isRemoteStream
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createMCUAvailableCompositeEvent = function (streams, isRemoteStream) {
    var type = 'MCUAvailableComposite',
        detail = {
      eventType: 'MCUAvailableComposite',
      time: new Date(),
      streams: streams,
      isRemoteStream: isRemoteStream
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createMCURemovedStreamEvent = function (streamId) {
    var type = 'MCURemoveStream',
        detail = {
      eventType: 'MCURemoveStream',
      time: new Date(),
      streamId: streamId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createMCUAvailableStreamUpdateEvent = function (streams, isRemoteStream) {
    var type = 'MCUAvailableStreamUpdate',
        detail = {
      eventType: 'MCUAvailableStreamUpdate',
      time: new Date(),
      streams: streams,
      isRemoteStream: isRemoteStream
    };
    this.eventDispatchMgr(type, detail);
  };
  /*
   * Fires an MCUParticipantEjected event.
   * @ignore
   * @param {string} roomId
   * @param {string} clientId
   * @param {object} data
   */


  this.createMCUParticipantEjectedEvent = function (roomId, clientId, data) {
    var type = 'MCUParticipantEjected',
        detail = {
      eventType: 'MCUParticipantEjected',
      time: new Date(),
      roomId: roomId,
      clientId: clientId
    };

    if (data) {
      detail.data = data;
    }

    this.eventDispatchMgr(type, detail);
  };

  this.createReceiveMCUSessionInvitationEvent = function (sessionId, token, groupChatId, srcId) {
    if (groupChatId === undefined) {
      groupChatId = 0;
    }

    var type = 'receiveMCUSessionInvitation',
        detail = {
      eventType: 'receiveMCUSessionInvitation',
      time: new Date(),
      sessionId: sessionId,
      token: token,
      groupChatId: groupChatId,
      initiatorId: srcId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createRemoteStreamAddedEvent = function (callType, callId, stream, remoteId, destCallType, audio, video) {
    var type = 'remoteStreamAdded',
        detail = {
      eventType: 'remoteStreamAdded',
      time: new Date(),
      callId: callId,
      callType: callType,
      stream: stream,
      remoteId: remoteId,
      destCallType: destCallType,
      audioIsAvailable: audio.available,
      audioIsActive: audio.active,
      audioIsMuted: audio.muted,
      videoIsAvailable: video.available,
      videoIsActive: video.active,
      videoIsMuted: video.muted
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createRemoteStreamRemovedEvent = function (callType, callId, stream, remoteId, destCallType) {
    var type = 'remoteStreamRemoved',
        detail = {
      eventType: 'remoteStreamRemoved',
      time: new Date(),
      callId: callId,
      callType: callType,
      stream: stream,
      remoteId: remoteId,
      destCallType: destCallType
    };
    this.eventDispatchMgr(type, detail);
  };
  /*
   * @ignore
   * @param {string} callId
   * @param {object} simulcast
   * @param {string} simulcast.streamQuality - Substream selection. Either 'high', 'medium' or 'low'. Default is 'high'.
   * @param {string} simulcast.streamFrameRate - Temporal layer selection. Either 'high', 'medium' or 'low'. Default is 'high'.
   */


  this.createSimulcastFeedChanged = function (callId, simulcast) {
    var type = 'simulcastFeedChanged',
        detail = {
      eventType: 'simulcastFeedChanged',
      time: new Date(),
      callId: callId,
      simulcast: simulcast
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createLocalStreamRemovedEvent = function (callType, callId, stream, remoteId, destCallType) {
    var type = 'localStreamRemoved',
        detail = {
      eventType: 'localStreamRemoved',
      time: new Date(),
      callId: callId,
      callType: callType,
      stream: stream,
      remoteId: remoteId,
      destCallType: destCallType
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createSlowLinkEvent = function (callId, advice) {
    var type = 'slowLink',
        detail = {
      eventType: 'slowLink',
      time: new Date(),
      callId: callId
    };

    if (advice) {
      detail.advice = advice;
    }

    this.eventDispatchMgr(type, detail);
  };
  /*
   * @method createVideoQualityChangedEvent
   * @param {string} callId
   * @param {string} roomName
   * @param {string} hint - Either 'upgrade' or 'downgrade'.
   * @param {object} profile
   * @param {string} profile.name
   * @param {number} profile.bitrate
   * @param {number} profile.width
   * @param {number} profile.height
   * @param {number} profile.frameRate
   */


  this.createVideoQualityChangedEvent = function (callId, roomName, hint, profile) {
    var type = 'videoQualityChanged',
        detail = {
      eventType: 'videoQualityChanged',
      time: new Date(),
      roomname: roomName,
      callId: callId,
      hint: hint,
      profileType: profile.name
    };

    if (profile.bitrate) {
      detail.bitrate = profile.bitrate;
    }

    if (profile.width && profile.height) {
      detail.width = profile.width;
      detail.height = profile.height;
    }

    if (profile.frameRate) {
      detail.frameRate = profile.frameRate;
    }

    this.eventDispatchMgr(type, detail);
  };
  /*
   * @method createAudioAmplitudeEvent
   * @param {number} amplitude
   * @param {boolean} speaking
   * @param {string|null} callId
   * @param {string} userMediaStreamId
   */


  this.createAudioAmplitudeEvent = function (amplitude, speaking, callId, userMediaStreamId) {
    var type = 'audioAmplitude',
        detail = {
      eventType: 'audioAmplitude',
      time: new Date(),
      callId: callId,
      userMediaStreamId: userMediaStreamId,
      descriptor: {
        amplitude: amplitude,
        isSpeaking: speaking
      }
    };
    this.eventDispatchMgr(type, detail);
  };
  /*
   * Dispatches a new localStreamUpdated event.
   *
   * @method createLocalStreamUpdatedEvent
   *
   * @param changeList {object} an array of field names.
   * @param audio {object} audio properties.
   * @param audio.available {boolean} whether an audio track exists.
   * @param audio.deviceLabel {string} the label of the audio device.
   * @param audio.active {boolean} whether the audio is active in peer connection (not inactive).
   * @param audio.muted {boolean} whether the audio track is muted.
   * @param video {object} video properties.
   * @param video.available {boolean} whether an video track exists.
   * @param video.deviceLabel {string} the label of the video device.
   * @param video.active {boolean} whether the video is active in peer connection (not inactive).
   * @param video.muted {boolean} whether the video track is muted.
   * @param onCall {boolean} whether this is related to a call.
   * @param callType {string} call type.
   * @param callId {string} call id.
   * @param stream {MediaStream} media stream.
   * @param userMediaStreamId {string} user media stream id.
   * @param cause {string} either 'adaptation' or 'userAction'.
   */


  this.createLocalStreamUpdatedEvent = function (changeList, audio, video, onCall, callType, callId, stream, userMediaStreamId, cause) {
    var type = 'localStreamUpdated',
        detail = {
      eventType: 'localStreamUpdated',
      time: new Date(),
      changeList: changeList,
      audioIsAvailable: audio.available,
      audioDeviceLabel: audio.deviceLabel,
      audioIsActive: audio.active,
      audioIsMuted: audio.muted,
      audioIsSilent: audio.silent,
      videoIsAvailable: video.available,
      videoDeviceLabel: video.deviceLabel,
      videoIsActive: video.active,
      videoIsMuted: video.muted,
      videoIsSilent: video.silent,
      onCall: onCall,
      callType: callType,
      callId: callId,
      stream: stream,
      userMediaStreamId: userMediaStreamId,
      cause: cause
    };
    this.eventDispatchMgr(type, detail);
  };
  /*
   * Dispatches a new remoteStreamUpdated event.
   *
   * @method createRemoteStreamUpdatedEvent
   *
   * @param changeList {object} an array of field names.
   * @param audio {object} audio properties.
   * @param audio.available {boolean} whether an audio track exists.
   * @param audio.active {boolean} whether the audio is active in peer connection (not inactive).
   * @param audio.muted {boolean} whether the audio track is muted.
   * @param video {object} video properties.
   * @param video.available {boolean} whether an video track exists.
   * @param video.active {boolean} whether the video is active in peer connection (not inactive).
   * @param video.muted {boolean} whether the video track is muted.
   * @param callType {string} call type.
   * @param callId {string} call id.
   * @param cause {string} either 'adaptation', 'userAction' or 'browserAction'.
   */


  this.createRemoteStreamUpdatedEvent = function (changeList, audio, video, callType, callId, cause) {
    var type = 'remoteStreamUpdated',
        detail = {
      eventType: 'remoteStreamUpdated',
      time: new Date(),
      changeList: changeList,
      audioIsAvailable: audio.available,
      audioIsActive: audio.active,
      audioIsMuted: audio.muted,
      audioIsSilent: audio.silent,
      videoIsAvailable: video.available,
      videoIsActive: video.active,
      videoIsMuted: video.muted,
      videoIsSilent: video.silent,
      callType: callType,
      callId: callId,
      cause: cause
    };
    this.eventDispatchMgr(type, detail);
  }; //Doc a voir : s'il faut ajouter dans doc

  /*
  * Fired when the browser can start playing the specified remote video
  * @event canPlayRemoteVideo
  * @param {String} eventType: "canPlayRemoteVideo"
  * @param {String} time : Date
  * @param {String} videoDivId: Div Identifier of the video
  * @param {String} callType: callType value can be 'screenSharing' or 'media' in other case
  */


  this.createCanPlayRemoteVideoEvent = function (videoDivId, callType, remoteId) {
    var type = 'canPlayRemoteVideo',
        detail = {
      eventType: 'canPlayRemoteVideo',
      time: new Date(),
      videoDivId: videoDivId,
      callType: callType,
      remoteId: remoteId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createRecordedFileAvailableEvent = function (fileName) {
    var type = 'recordedFileAvailable',
        detail = {
      eventType: 'recordedFileAvailable',
      time: new Date(),
      fileName: fileName
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createRecordedStreamsAvailableEvent = function (confId, userId1, userId2, callId, convId, mediaId, mediaURL) {
    var type = 'recordedStreamsAvailable',
        detail = {
      eventType: 'recordedStreamsAvailable',
      time: new Date(),
      confId: confId,
      userId1: userId1,
      userId2: userId2,
      callId: callId,
      apiKey: apiCC.session.apiKey
    };

    if (convId) {
      detail.convId = convId;
    }

    if (mediaId) {
      detail.mediaId = mediaId;
    }

    if (mediaURL) {
      detail.mediaURL = mediaURL;
    }

    this.eventDispatchMgr(type, detail);
  };
  /*
   * Fires an MCURecordedStreamsAvailable event.
   * @param {string} roomName
   * @param {string} callId
   * @param {string} clientId
   * @param {string} recordedFileName
   * @param {string} convId - Cloud conversation ID.
   * @param {string} mediaId - Cloud media ID.
   * @param {string} mediaURL - Cloud media URL.
   * @param {string} recordType - Either 'userStream' or 'composite'.
   * @param {string} remoteId - Remote user ID (for recorded call).
   * @param {string} mediaType - Either 'AUDIO-VIDEO', 'AUDIO-ONLY' or 'VIDEO-ONLY'.
   * @param {object} descriptor - Recording descriptor.
   * @param {string} descriptor.mode - Either 'complete', 'efficient' or 'audioOnly'.
   * @param {boolean} descriptor.labelEnabled - Whether label use is enabled.
   * @param {string} descriptor.labels - User stream selection labels.
   */


  this.createMCURecordedStreamsAvailableEvent = function (roomName, callId, clientId, recordedFileName, convId, mediaId, mediaURL, recordType, remoteId, mediaType, descriptor) {
    var type = 'MCURecordedStreamsAvailable',
        detail = {
      eventType: 'MCURecordedStreamsAvailable',
      time: new Date(),
      roomName: roomName,
      callId: callId,
      clientId: clientId,
      convId: convId,
      mediaId: mediaId,
      mediaURL: mediaURL,
      recordType: recordType
    };

    if (remoteId) {
      detail.remoteId = remoteId;
    }

    if (recordedFileName) {
      detail.recordedFileName = recordedFileName;
    }

    if (mediaType) {
      detail.mediaType = mediaType;
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'object')) {
      detail.descriptor = {};

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'mode', 'string')) {
        detail.descriptor.mode = descriptor.mode;
      }

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'labelEnabled', 'boolean')) {
        detail.descriptor.labelEnabled = descriptor.labelEnabled;
      }

      if (detail.descriptor.labelEnabled === true && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'labels', 'array')) {
        detail.descriptor.labels = descriptor.labels;
      }
    } else {
      detail.descriptor = {
        mode: 'complete',
        labelEnabled: false
      };
    }

    this.eventDispatchMgr(type, detail);
  };
  /*
   * Fires an MCURecordingStarted event.
   * @param {string} roomName
   * @param {string} callId
   * @param {string} clientId
   * @param {string} recordType - Either 'userStream' or 'composite'.
   * @param {object} recordStartTime
   * @param {string} convId - Cloud conversation ID.
   * @param {string} mediaId - Cloud media ID.
   * @param {string} mediaURL - Cloud media URL.
   * @param {string} remoteId - Remote user ID (for recorded call).
   * @param {string} recordedFileName - The name of final media file.
   * @param {string} mediaType - Either 'AUDIO-VIDEO', 'AUDIO-ONLY' or 'VIDEO-ONLY'.
   * @param {object} descriptor - Recording descriptor.
   * @param {string} descriptor.mode - Either 'complete', 'efficient' or 'audioOnly'.
   * @param {boolean} descriptor.labelEnabled - Whether label use is enabled.
   * @param {string} descriptor.labels - User stream selection labels.
   */


  this.createMCURecordingStartedEvent = function (roomName, callId, clientId, recordType, recordStartTime, convId, mediaId, mediaURL, remoteId, recordedFileName, mediaType, descriptor) {
    var type = 'MCURecordingStarted',
        detail = {
      eventType: 'MCURecordingStarted',
      time: new Date(),
      roomName: roomName,
      callId: callId,
      clientId: clientId,
      recordType: recordType,
      recordStartTime: recordStartTime
    };

    if (convId) {
      detail.convId = convId;
    }

    if (mediaId) {
      detail.mediaId = mediaId;
    }

    if (mediaURL) {
      detail.mediaURL = mediaURL;
    }

    if (remoteId) {
      detail.remoteId = remoteId;
    }

    if (recordedFileName) {
      detail.recordedFileName = recordedFileName;
    }

    if (mediaType) {
      detail.mediaType = mediaType;
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'object')) {
      detail.descriptor = {};

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'mode', 'string')) {
        detail.descriptor.mode = descriptor.mode;
      }

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'labelEnabled', 'boolean')) {
        detail.descriptor.labelEnabled = descriptor.labelEnabled;
      }

      if (detail.descriptor.labelEnabled === true && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'labels', 'array')) {
        detail.descriptor.labels = descriptor.labels;
      }
    }

    this.eventDispatchMgr(type, detail);
  };
  /*
   * Fires an MCURecordingStopped event.
   * @param {string} roomName
   * @param {string} callId
   * @param {string} clientId
   * @param {string} recordType - Either 'userStream' or 'composite'.
   * @param {object} recordStartTime
   * @param {string} convId - Cloud conversation ID.
   * @param {string} mediaId - Cloud media ID.
   * @param {string} mediaURL - Cloud media URL.
   * @param {string} remoteId - Remote user ID (for recorded call).
   * @param {string} recordedFileName - The name of final media file.
   * @param {string} mediaType - Either 'AUDIO-VIDEO', 'AUDIO-ONLY' or 'VIDEO-ONLY'.
   * @param {object} descriptor - Recording descriptor.
   * @param {string} descriptor.mode - Either 'complete', 'efficient' or 'audioOnly'.
   * @param {boolean} descriptor.labelEnabled - Whether label use is enabled.
   * @param {string} descriptor.labels - User stream selection labels.
   */


  this.createMCURecordingStoppedEvent = function (roomName, callId, clientId, recordType, recordStartTime, convId, mediaId, mediaURL, remoteId, recordedFileName, mediaType, descriptor) {
    var type = 'MCURecordingStopped',
        detail = {
      eventType: 'MCURecordingStopped',
      time: new Date(),
      roomName: roomName,
      callId: callId,
      clientId: clientId,
      recordType: recordType,
      recordStartTime: recordStartTime
    };

    if (convId) {
      detail.convId = convId;
    }

    if (mediaId) {
      detail.mediaId = mediaId;
    }

    if (mediaURL) {
      detail.mediaURL = mediaURL;
    }

    if (remoteId) {
      detail.remoteId = remoteId;
    }

    if (recordedFileName) {
      detail.recordedFileName = recordedFileName;
    }

    if (mediaType) {
      detail.mediaType = mediaType;
    }

    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'object')) {
      detail.descriptor = {};

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'mode', 'string')) {
        detail.descriptor.mode = descriptor.mode;
      }

      if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'labelEnabled', 'boolean')) {
        detail.descriptor.labelEnabled = descriptor.labelEnabled;
      }

      if (detail.descriptor.labelEnabled === true && (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isTypeof)(descriptor, 'labels', 'array')) {
        detail.descriptor.labels = descriptor.labels;
      }
    }

    this.eventDispatchMgr(type, detail);
  };

  this.createStopRecordEvent = function () {
    var type = 'stopRecord',
        detail = {
      eventType: 'stopRecord',
      time: new Date()
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createMCUStreamingStartedEvent = function (roomName, callId, clientId, streamingStartTime) {
    var type = 'MCUStreamingStarted',
        detail = {
      eventType: 'MCUStreamingStarted',
      time: new Date(),
      roomName: roomName,
      callId: callId,
      clientId: clientId,
      streamingStartTime: streamingStartTime
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createMCUStreamingStoppedEvent = function (roomName, callId, clientId, streamingEndTime) {
    var type = 'MCUStreamingStopped',
        detail = {
      eventType: 'MCUStreamingStopped',
      time: new Date(),
      roomName: roomName,
      callId: callId,
      clientId: clientId,
      streamingEndTime: streamingEndTime
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createMCURoomModeChangedEvent = function (roomId, oldMode, newMode, state) {
    var type = 'MCURoomModeChanged',
        detail = {
      eventType: 'MCURoomModeChanged',
      time: new Date(),
      roomId: roomId,
      oldMode: oldMode,
      newMode: newMode,
      state: state
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createSnapShotPhotoUploaded = function (filename) {
    var type = 'snapShotPhotoUploaded',
        detail = {
      eventType: 'snapShotPhotoUploaded',
      time: new Date(),
      fileName: filename
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createRoomCreationEvent = function (status, roomId, roomType) {
    var type = 'roomCreation',
        detail = {
      eventType: 'roomCreation',
      time: new Date(),
      status: status,
      roomId: roomId,
      roomType: roomType
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createRoomJoinedEvent = function (status, roomId, roomType) {
    var type = 'roomJoined',
        detail = {
      eventType: 'roomJoined',
      time: new Date(),
      status: status,
      roomId: roomId,
      roomType: roomType
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createRoomInvitationEvent = function (roomId, senderId, senderNickname, senderPhotoURL, contactList, roomType) {
    var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
    var type = 'roomInvitation',
        detail = {
      eventType: 'roomInvitation',
      time: new Date(),
      roomId: roomId,
      contactList: contactList,
      senderId: senderId,
      senderNickname: senderNickname,
      senderPhotoURL: senderPhotoURL,
      roomType: roomType
    };

    if (options.cloudConvId) {
      detail.cloudConvId = options.cloudConvId;
    }

    if (options.webconf === true) {
      detail.webconf = true;
    }

    this.eventDispatchMgr(type, detail);
  };

  this.createRoomMemberUpdateEvent = function (roomId, contactList, status, roomType) {
    var type = 'roomMemberUpdate',
        detail = {
      eventType: 'roomMemberUpdate',
      time: new Date(),
      roomId: roomId,
      contactList: contactList,
      status: status,
      roomType: roomType
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createContactListInRoomEvent = function (roomId, contactList, roomType) {
    var type = 'contactListInRoom',
        detail = {
      eventType: 'contactListInRoom',
      time: new Date(),
      roomId: roomId,
      contactList: contactList,
      roomType: roomType
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createReceiveRoomMessageEvent = function (roomId, senderId, senderNickname, message, roomType) {
    var type = 'receiveRoomMessage',
        detail = {
      eventType: 'receiveRoomMessage',
      time: new Date(),
      roomId: roomId,
      senderId: senderId,
      senderNickname: senderNickname,
      message: message,
      roomType: roomType
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createDesktopCaptureEvent = function (event, callId, remoteId) {
    var type = 'desktopCapture',
        detail = {
      eventType: 'desktopCapture',
      time: new Date(),
      event: event,
      callId: callId,
      remoteId: remoteId
    };
    this.eventDispatchMgr(type, detail);
  };
  /**
  * Fired when the set of media devices, available to the user has changed.
  * The current list devices can be retrieved with the getMediaDevices() method.
  * @event mediaDeviceChanged
  * @memberof module:ApiRTC
  * @param {String} eventType "mediaDeviceChanged"
  * @param {String} time Date
  * @param {Array} diff Array with info about added and removed media device
  * @param {String} updateReason give context about the reason of deviceChanged, value can be :
  *  - "updatedOnDeviceChange" : a media device has been added
  *  - "updatedAfterGetUserMediaSuccess" : list has been updated after userMediaSuccess (browsers now block the media device list retrieval without a getUserMedia success)
  **/
  //@memberof apiRTC


  this.createMediaDeviceChangedEvent = function (diff, updateReason, firstMediaDeviceListInitialization) {
    var localUpdateReason = "NotDefined";

    if (updateReason !== null && updateReason !== undefined) {
      localUpdateReason = updateReason;
    }

    var type = 'mediaDeviceChanged',
        detail = {
      eventType: 'mediaDeviceChanged',
      time: new Date(),
      diff: diff,
      updateReason: localUpdateReason,
      firstMediaDeviceListInitialization: firstMediaDeviceListInitialization
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createSwitchStreamEvent = function (callId, stream) {
    var type = 'switchStream',
        detail = {
      eventType: 'switchStream',
      time: new Date(),
      callId: callId,
      stream: stream
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createConnectedUsersListUpdateEvent = function (group, connectedUsersList, status, updateReason) {
    var type = 'connectedUsersListUpdate',
        detail = {
      eventType: 'ConnectedUsersListUpdate',
      time: new Date(),
      group: group,
      usersList: connectedUsersList,
      status: status,
      updateReason: updateReason
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createClosingWhiteBoardEvent = function (roomId, reason) {
    var type = 'closingWhiteBoard',
        detail = {
      eventType: 'closingWhiteBoard',
      time: new Date(),
      roomId: roomId,
      reason: reason
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createExternalJsLoadingStatusEvent = function (extjs, status) {
    var type = 'externalJsLoadingStatus',
        detail = {
      eventType: 'externalJsLoadingStatus',
      extjs: extjs,
      status: status,
      time: new Date()
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createBackgroundSubstractionStopVisibilityChangeEvent = function (userMediaStreamId) {
    var type = 'backgroundSubstractionStopVisibilityChange';
    var detail = {
      userMediaStreamId: userMediaStreamId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createBackgroundSubstractionStopComputeTimeEvent = function (userMediaStreamId) {
    var type = 'backgroundSubstractionStopComputeTime';
    var detail = {
      userMediaStreamId: userMediaStreamId
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createAIESnapshotEvent = function (userMediaStreamId, image) {
    var type = 'AIESnapshot';
    var detail = {
      userMediaStreamId: userMediaStreamId,
      image: image
    };
    this.eventDispatchMgr(type, detail);
  };

  this.createAIELogEvent = function (userMediaStreamId, log) {
    var type = 'AIELog';
    var detail = {
      userMediaStreamId: userMediaStreamId,
      log: log
    };
    this.eventDispatchMgr(type, detail);
  };
  /*
  * Create generic event
  */


  this.createEvent = function (json) {
    if (!json.eventType) {
      throw new Error("The event json must have an eventType" + json);
    }

    json.time = new Date();
    this.eventDispatchMgr(json.eventType, json);
  };
};



/***/ }),

/***/ "./src/Core/WebRTC_Stack.js":
/*!**********************************!*\
  !*** ./src/Core/WebRTC_Stack.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebRTC_Stack": () => (/* binding */ WebRTC_Stack)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BrowserInfo */ "./src/Core/BrowserInfo.js");

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('WebRTC_Stack');

/*
* This is the description for my class webRTC_Stack.
*
* @module webRTC_Stack
*/

var WebRTC_Stack = function WebRTC_Stack(clientSocket) {
  /*
  * My method description.  Like other pieces of your comment blocks,
  * this can span multiple lines.
  *
  * @method sendInvite
  * @param {string} callId
  * @param {string} callerId
  * @param {string} callerNickname
  * @param {string} calleeId
  * @param {string} roomId
  * @param {string} callType
  * @param {object} options
  * @param {string} options.mode - 'passive'.
  * @param {object} options.offer
  * @param {string} options.offer.type
  * @param {string} options.offer.sdp
  * @param {object} options.data
  * @param {object} options.stream
  */
  this.sendInvite = function (callId, callerId, callerNickname, calleeId, roomId, callType) {
    var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};
    logger.debug('WebRTC_Stack::sendInvite()');

    if (!callType) {
      callType = 'media';
    }

    var messageToSend = {
      type: 'invite',
      callId: callId,
      callerId: callerId,
      callerNickname: callerNickname,
      calleeId: calleeId,
      roomId: roomId,
      callType: callType
    };

    if (options.mode) {
      messageToSend.mode = options.mode;
    }

    var offer = options.offer;

    if (offer) {
      if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 11) {
        var type = offer.type;
        var sdp = offer.sdp; //Modification to solve issue with Temasys object stringify

        logger.log('JSON.stringify(type):', JSON.stringify(type));
        logger.log('JSON.stringify(sdp):', JSON.stringify(sdp));
        offer = {
          type: type,
          sdp: sdp
        };
      }

      messageToSend.sdpoffer = offer;
    }

    if (options.data) {
      messageToSend.data = options.data;
    }

    if (options.stream) {
      messageToSend.stream = options.stream;
    }

    var msgString = JSON.stringify(messageToSend);
    logger.info('C->S:', msgString);
    clientSocket.emit('invite', msgString);
  };
  /*
  * My method description.  Like other pieces of your comment blocks,
  * this can span multiple lines.
  *
  * @method sendInviteBroadcast
  * @param {String} ...
  */


  this.sendInviteBroadcast = function (callId, callerId, callerNickname, calleeId, roomId, offer) {
    logger.debug('WebRTC_Stack::sendInviteBroadcast()');
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'invite',
      callId: callId,
      callerId: callerId,
      callerNickname: callerNickname,
      calleeId: calleeId,
      roomId: roomId,
      sdpoffer: offer
    };
    msgString = JSON.stringify(messageToSend);
    logger.debug('C->S: ' + msgString);
    clientSocket.emit('invite_broadcast', msgString);
  };
  /*
  * My method description.  Like other pieces of your comment blocks,
  * this can span multiple lines.
  *
  * @method send200OK
  * @param {String} ...
  */


  this.send200OK = function (callId, callerId, calleeId, calleeNickname, roomId, answer, data) {
    logger.debug('WebRTC_Stack::send200OK()');
    var messageToSend = null,
        msgString = null,
        newAnswer = null;

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE' || _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'Safari' && _BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser_major_version < 11) {
      //Modification for to solve issue with Temasys object stringify
      logger.log('JSON.stringify(offer.sdp) :' + JSON.stringify(answer.sdp));
      logger.log('JSON.stringify(offer.type) :' + JSON.stringify(answer.type));
      newAnswer = {};
      newAnswer.sdp = answer.sdp;
      newAnswer.type = answer.type;
      answer = newAnswer;
    }

    messageToSend = {
      type: '200OK',
      callId: callId,
      callerId: callerId,
      calleeId: calleeId,
      calleeNickname: calleeNickname,
      roomId: roomId,
      sdpanswer: answer,
      data: data
    };
    msgString = JSON.stringify(messageToSend);
    logger.info('C->S: ' + msgString);
    clientSocket.emit('200OK', msgString);
  };
  /*
  * My method description.  Like other pieces of your comment blocks,
  * this can span multiple lines.
  *
  * @method sendCandidate
  * @param {String} ...
  */


  this.sendCandidate = function (callId, callerId, calleeId, roomId, dst, label, id, candidate, data, completeCandidate) {
    var options = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : {};
    logger.debug('WebRTC_Stack::sendCandidate()'); //TODO sendCandidate will need to be cleaned : removing label, id and candidate

    var messageToSend = null,
        completeCandidateToSend = {};
    logger.debug("completeCandidate :", completeCandidate);

    if (_BrowserInfo__WEBPACK_IMPORTED_MODULE_1__.browser === 'IE') {
      logger.log("Browser is IE, adapting completeCandidate"); //This is an issue as Candidate is a Javascript Object when we use the plugin

      completeCandidateToSend.sdpMLineIndex = completeCandidate.sdpMLineIndex;
      completeCandidateToSend.candidate = completeCandidate.candidate;
      completeCandidateToSend.sdpMid = completeCandidate.sdpMid;
    } else {
      completeCandidateToSend = completeCandidate;
    }

    if (data !== null) {
      logger.log("call data is defined :", data);
      messageToSend = {
        type: 'candidate',
        callId: callId,
        callerId: callerId,
        calleeId: calleeId,
        roomId: roomId,
        dst: dst,
        label: label,
        id: id,
        candidate: candidate,
        data: data,
        completeCandidate: completeCandidateToSend
      };
    } else {
      logger.log("call data is undefined");
      messageToSend = {
        type: 'candidate',
        callId: callId,
        callerId: callerId,
        calleeId: calleeId,
        roomId: roomId,
        dst: dst,
        label: label,
        id: id,
        candidate: candidate,
        completeCandidate: completeCandidateToSend
      };
    }

    var msgString = JSON.stringify(messageToSend);
    logger.info('C->S:', msgString);
    clientSocket.emit('candidate', msgString);
  };
  /*
  * My method description.  Like other pieces of your comment blocks,
  * this can span multiple lines.
  *
  * @method sendBye
  * @param {String} ...
  */


  this.sendBye = function (callId, clientId, roomId, dst, reason, data) {
    logger.debug('WebRTC_Stack::sendBye()');
    var messageToSend = null,
        msgString = null;

    if (data !== null) {
      logger.log("call data is defined :" + data);
      messageToSend = {
        type: 'bye',
        callId: callId,
        clientId: clientId,
        roomId: roomId,
        dst: dst,
        reason: reason,
        data: data
      };
    } else {
      logger.log("call data is undefined");
      messageToSend = {
        type: 'bye',
        callId: callId,
        clientId: clientId,
        roomId: roomId,
        dst: dst,
        reason: reason
      };
    }

    msgString = JSON.stringify(messageToSend);
    logger.info('C->S: ' + msgString);
    clientSocket.emit('bye', msgString);
  };
  /*
  * My method description.  Like other pieces of your comment blocks,
  * this can span multiple lines.
  *
  * @method sendUpdate
  * @param {String} ...
  */


  this.sendUpdate = function (callId, callerId, calleeId, roomId, dst, offer, callType, data) {
    logger.debug('WebRTC_Stack::sendUpdate()');
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'update',
      callId: callId,
      callerId: callerId,
      calleeId: calleeId,
      roomId: roomId,
      dst: dst,
      sdpoffer: offer,
      callType: callType
    };

    if (data !== undefined && data !== null) {
      logger.log('call data is defined: ' + data);
      messageToSend.data = data;
    }

    msgString = JSON.stringify(messageToSend);
    logger.info('C->S: ' + msgString);
    clientSocket.emit('update', msgString);
  };
  /*
  * My method description.  Like other pieces of your comment blocks,
  * this can span multiple lines.
  *
  * @method send200Update
  * @param {String} ...
  */


  this.send200Update = function (callId, callerId, calleeId, roomId, dst, answer, data) {
    logger.debug('WebRTC_Stack::send200Update()');
    var messageToSend = null,
        msgString = null;

    if (data !== null) {
      logger.log("call data is defined :" + data);
      messageToSend = {
        type: '200update',
        callId: callId,
        callerId: callerId,
        calleeId: calleeId,
        roomId: roomId,
        dst: dst,
        sdpanswer: answer,
        data: data
      };
    } else {
      logger.log("call data is undefined");
      messageToSend = {
        type: '200update',
        callId: callId,
        callerId: callerId,
        calleeId: calleeId,
        roomId: roomId,
        dst: dst,
        sdpanswer: answer
      };
    }

    msgString = JSON.stringify(messageToSend);
    logger.info('C->S: ' + msgString);
    clientSocket.emit('200update', msgString);
  }; //TODO: Doc sendDisplayClientSocketInfoRequest - Documenter en interne

  /*
  * DEBUG REQUEST
  *
  * @method sendDisplayClientSocketInfoRequest
  * @param {String} command = getClientSocketsInfo
  * @param {String} apiKey = apiKey
  * @param {String} clientId = clientId
  */


  this.sendDebugCommand = function (command, apiKey, clientId) {
    logger.debug('WebRTC_Stack::sendDebugCommand :' + command);
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'debugCommand',
      command: command,
      apiKey: apiKey,
      clientId: clientId
    };
    msgString = JSON.stringify(messageToSend);
    logger.info('C->S: ' + msgString);
    clientSocket.emit('debugCommand', msgString);
  };
  /*
  *
  * @method sendAck
  */
  //Cseq must be same value as acknowledged request


  this.sendAck = function (AckMessageType, cSeq, dst) {
    logger.debug('WebRTC_Stack::sendAck()');
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'Ack',
      AckMessageType: AckMessageType,
      cSeq: cSeq,
      dst: dst
    };
    msgString = JSON.stringify(messageToSend);
    logger.info('C->S: ' + msgString);
    clientSocket.emit('Ack', msgString);
  };
  /*
  * My method description.  Like other pieces of your comment blocks,
  * this can span multiple lines.
  *
  * @method sendInfo
  *
  * @param {string} infoType - info identifier.
  * @param {object data - data.
  */


  this.sendInfo = function (infoType, data) {
    var ignore = ['activeSpeaker', 'callStats', 'stopSpeaking'];

    if (ignore.indexOf(infoType) < 0) {
      logger.debug('WebRTC_Stack::sendInfo()');
    }

    var messageToSend = null,
        msgString = null;
    messageToSend = {
      type: 'info',
      infoType: infoType,
      data: data
    };
    msgString = JSON.stringify(messageToSend);

    if (ignore.indexOf(infoType) < 0) {
      logger.info('C->S: ' + msgString);
    }

    clientSocket.emit('info', msgString);
  };
  /*
   * Sends an apiRTC data message to another apiRTC instance.
   *
   * @method sendDataMessage
   *
   * @param {string} senderId - clientId of caller.
   * @param {object} data - data.
   * @param {string} data.type - data message identifier.
   * @param {string} data.callerId - clientId of caller.
   * @param {string} data.calleeId - clientId of callee.
   */


  this.sendDataMessage = function (senderId, data) {
    logger.debug('WebRTC_Stack::sendDataMessage()');
    var messageToSend = {
      type: 'apiRTCDataMessage',
      senderId: senderId,
      data: data
    },
        msgString = JSON.stringify(messageToSend);
    logger.info('C->S: ' + msgString);
    clientSocket.emit('apiRTCDataMessage', msgString);
  };
};



/***/ }),

/***/ "./src/Core/WebRTC_UserMedia.js":
/*!**************************************!*\
  !*** ./src/Core/WebRTC_UserMedia.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebRTC_UserMedia": () => (/* binding */ WebRTC_UserMedia)
/* harmony export */ });
/* harmony import */ var _WebRTC_Stack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebRTC_Stack */ "./src/Core/WebRTC_Stack.js");
/* globals apiCC*/

/*
* Dummy publish call for mesh conference room.
* @module WebRTC_UserMedia
*/

var WebRTC_UserMedia = function WebRTC_UserMedia(webRTCClient) {
  this.disconnectionTimer = 15000;

  if (Number.MAX_SAFE_INTEGER !== undefined) {
    this.userMediaId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString();
  } else {
    this.userMediaId = Math.floor(Math.random() * 1000001).toString();
  } // callType: media, audio, screenSharing, videoOnly, data or screenSharingWithAudio.


  this.callType = 'media';
  this.audio = false;
  this.video = false;
  this.audioSdpDirection = null;
  this.videoSdpDirection = null;
  this.callConfiguration = {}; // The sessionMCU this one has been established into.

  this.sessionMCU = null;
  this.myWebRTC_Stack = new _WebRTC_Stack__WEBPACK_IMPORTED_MODULE_0__.WebRTC_Stack(webRTCClient.socket);

  this.getUserMediaStream = function () {
    if (this.callConfiguration && this.callConfiguration.userMediaStreamId) {
      return apiCC.getUserMediaStream(this.callConfiguration.userMediaStreamId);
    }

    return null;
  };

  this.releaseUserMediaStream = function () {
    if (this.callConfiguration && this.callConfiguration.userMediaStreamId) {
      var userMediaStreamId = this.callConfiguration.userMediaStreamId;
      delete this.callConfiguration.userMediaStreamId;
      return apiCC.releaseUserMediaStream(userMediaStreamId, this.userMediaId);
    }

    return false;
  };

  this.close = function () {
    if (this.addAck || this.addTimeoutId) {
      delete this.addAck;
      clearTimeout(this.addTimeoutId);
      delete this.addTimeoutId;
    }
  };
};



/***/ }),

/***/ "./src/Core/apiDB.js":
/*!***************************!*\
  !*** ./src/Core/apiDB.js ***!
  \***************************/
/***/ (() => {

/* globals $jqApz, jQuery, apiRTC_React, eventManager*/
(function (window) {
  'use strict'; //console.log('Loading APIRTC-DB MODULE');

  var apiDB = null,
      DB_Event = null,
      myDB_Event = null,
      browser = null,
      browser_version = null,
      requestCallback = []; //TODO voir pour factoriser code entre ApiRTC et apiRTC-DB pour browser versions + Events

  function get_browser() {
    if (typeof apiRTC_React !== 'undefined') {
      return 'react-native';
    }

    var N = navigator.appName,
        ua = navigator.userAgent,
        tem,
        M = ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);

    if (M && (tem = ua.match(/version\/([\.\d]+)/i)) !== null) {
      M[2] = tem[1];
    }

    M = M ? [M[1], M[2]] : [N, navigator.appVersion, '-?'];
    return M[0];
  }

  function get_browser_version() {
    if (typeof apiRTC_React !== 'undefined') {
      return 1;
    }

    var N = navigator.appName,
        ua = navigator.userAgent,
        tem,
        M = ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);

    if (M && (tem = ua.match(/version\/([\.\d]+)/i)) !== null) {
      M[2] = tem[1];
    }

    M = M ? [M[1], M[2]] : [N, navigator.appVersion, '-?'];
    return M[1];
  }

  browser = get_browser();
  browser_version = get_browser_version(); //console.log("Browser : " + browser);
  //console.log("Browser version : " + browser_version);

  function getRandomId() {
    return Math.random().toString(36).substr(2);
  }

  DB_Event = function DB_Event() {
    //console.log('WebRTC_Event');
    if (browser === 'MSIE' && browser_version > 8.0 || browser === 'Netscape') {
      //Function to polyfill the CustomEvent() constructor functionality in Internet Explorer 9 and 10
      //console.log('polyfill the CustomEvent()');
      (function () {
        function CustomEvent(event, params) {
          params = params || {
            bubbles: false,
            cancelable: false,
            detail: undefined
          };
          var evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
          return evt;
        }

        CustomEvent.prototype = window.CustomEvent.prototype;
        window.CustomEvent = CustomEvent;
      })();
    }

    this.eventDispatchMgr = function (type, detail) {
      if (typeof apiRTC_React !== 'undefined') {
        var eventReact = {
          type: type,
          detail: detail
        };
        eventManager.dispatchEvent(eventReact);
      } else if (browser === 'MSIE' && browser_version <= 8.0) {
        if (typeof $jqApz !== 'undefined') {
          //console.log('CustomEvent not supported by Browser, using $jqApz ');
          $jqApz.event.trigger({
            type: type,
            detail: detail
          });
        } else if (typeof jQuery !== 'undefined') {
          //console.log('CustomEvent not supported by Browser, using jQuery ');
          jQuery.event.trigger({
            type: type,
            detail: detail
          });
        } else {//console.warn('Custom Events not supported on this browser : eventDispatchMgr()');
        }
      } else {
        var event = new CustomEvent(type, {
          detail: detail,
          bubbles: true,
          cancelable: true
        });
        document.dispatchEvent(event);
      }
    };

    this.createGetUserFromIdAnswerEvent = function (message) {
      var type = 'getUserFromIdAnswer',
          detail = {
        eventType: 'getUserFromIdAnswer',
        time: new Date(),
        message: message
      };
      this.eventDispatchMgr(type, detail);
    };

    this.createGetAllUsersAnswerEvent = function (message) {
      var type = 'getAllUsersAnswer',
          detail = {
        eventType: 'getAllUsersAnswer',
        time: new Date(),
        message: message
      };
      this.eventDispatchMgr(type, detail);
    };

    this.createErrorEvent = function (errorInfo) {
      var type = 'error',
          detail = {
        eventType: 'error :',
        time: new Date(),
        errorInfo: errorInfo
      };
      this.eventDispatchMgr(type, detail);
    };

    this.createSearchUserAnswerEvent = function (searchStr, searchAnswerList, group) {
      var type = 'searchUserAnswer',
          detail = {
        eventType: 'searchUserAnswer :',
        time: new Date(),
        searchStr: searchStr,
        searchAnswerList: searchAnswerList,
        group: group
      };
      this.eventDispatchMgr(type, detail);
    };
  };

  myDB_Event = new DB_Event();
  apiDB = {
    /**
    Version of apiDB Connector library
    @property version
    @type String
    **/
    version: '1.0.4',

    /**
    Description of ApiCC library
    @property description
    @type String
    @default ApiRTC Cloud Communication Library
    **/
    description: 'ApiRTC DataBase Library' //,

    /**
    Session object of ApiCC library
    @property session
    @type {ApiCCSession}
    **/
    //session: null

  };
  /*
  <b>Description</b>
  <p>This method will initialize the apiCC session and establish a connection between your application and the server</p>
  <b>Associated events :</b>
  <li>sessionReady</li>
  @method init
  @param {String} initParameters.apiKey : API Key that you will receive on your ApiRTC account creation
  @param {String} initParameters.onReady : User Identifier that can be used to identify one client
  @param {Number} [initParameters.apiCCId] : Optional parameters that enable you to set your client number.
  This is useful if you have an account database on your side and want to associate an apiCC identifier to theses accounts.
  If not provided apiCC will create an ID for your client instance.
  @return {ApiCCSession} ApiCC Session object
  **/

  apiDB.init = function (socket) {
    //apiCC.session = new apiCC.ApiCCSession(initParameters);
    //return apiCC.session;
    //console.log('apiDB.init, version is :' + apiDB.version);
    this.socket = socket;
    this.socket.on('getUserFromIdAnswer', this.callback(this, 'onGetUserFromIdAnswer')).on('getAllUsersAnswer', this.callback(this, 'onGetAllUsersAnswer')).on('searchUserAnswer', this.callback(this, 'onSearchUserAnswer'));
  };

  apiDB.createUser = function (params) {
    //console.log('createUser :' + params);
    //Mandatory parameters
    //params.mail
    //params.id
    if (params !== null) {
      if (params.mail !== null && params.id !== null) {
        var msgString = JSON.stringify(params); //console.log('C->S: ' + msgString);

        this.socket.emit('createUser', msgString);
      }
    }
  };

  apiDB.searchUserInGroup = function (searchStr, presenceState, group, callback) {
    //console.log('searchUserInGroup :' + searchStr + ' ,presenceState :' + presenceState + ' ,group :' + group);
    var messageToSend = null,
        msgString = null,
        requestCallbackId = getRandomId();

    if (presenceState === undefined || presenceState !== 'all' && presenceState !== 'connected' && presenceState !== 'disconnected') {
      //console.log('Setting presenceState to all as value in not correct:' + presenceState);
      presenceState = 'all';
    }

    if (searchStr !== null) {
      messageToSend = {
        searchStr: searchStr,
        presenceState: presenceState,
        group: group
      };

      if (typeof callback !== 'undefined') {
        messageToSend.callbackId = requestCallbackId;
        requestCallback[requestCallbackId] = callback;
      }

      msgString = JSON.stringify(messageToSend); //console.log('C->S: ' + msgString);

      this.socket.emit('searchUser', msgString);
    }
  };

  apiDB.searchUser = function (searchStr, presenceState, group, callback) {
    //console.log('searchUser :' + searchStr + ' ,presenceState :' + presenceState);
    var localCallback = null;

    if (typeof group === 'function') {
      localCallback = group; //This is done for API compatibility, callback can be the 3rd parameter

      apiDB.searchUserInGroup(searchStr, presenceState, undefined, localCallback);
    } else {
      apiDB.searchUserInGroup(searchStr, presenceState, group, callback);
    }
  };

  apiDB.onSearchUserAnswer = function (message) {
    //console.log('onSearchUserAnswer' + message);
    var msg = JSON.parse(message);

    if (typeof msg.callbackId !== 'undefined' && msg.callbackId in requestCallback) {
      requestCallback[msg.callbackId](msg.searchStr, msg.searchAnswerList);
      requestCallback.splice(msg.callbackId, 1);
    } else {
      myDB_Event.createSearchUserAnswerEvent(msg.searchStr, msg.searchAnswerList, msg.group);
    }
  };

  apiDB.getUserFromId = function (id, callback) {
    //console.log('getUserFromId');
    var messageToSend = null,
        msgString = null,
        requestCallbackId = getRandomId();

    if (id !== null) {
      messageToSend = {
        id: id
      };

      if (typeof callback !== 'undefined') {
        messageToSend.callbackId = requestCallbackId;
        requestCallback[requestCallbackId] = callback;
      }

      msgString = JSON.stringify(messageToSend); //console.log('C->S: ' + msgString);

      this.socket.emit('getUserFromId', msgString);
    }
  };

  apiDB.onGetUserFromIdAnswer = function (message) {
    //console.log('onGetUserFromIdAnswer' + message);

    /*
            if (message !== null) {
                //console.dir(message);
                //console.log('message.mail : ' + message.mail);
            } else {
                //console.log('User is not created in database');
            }
    */
    if (message !== null && typeof message.callbackId !== 'undefined' && message.callbackId in requestCallback) {
      requestCallback[message.callbackId](message);
      requestCallback.splice(message.callbackId, 1);
    } else {
      myDB_Event.createGetUserFromIdAnswerEvent(message);
    }
  };

  apiDB.getAllUsers = function () {
    //console.log('getAllUsers');
    var messageToSend = null,
        msgString = null;
    messageToSend = {};
    msgString = JSON.stringify(messageToSend); //console.log('C->S: ' + msgString);

    this.socket.emit('getAllUsers', msgString);
  };

  apiDB.onGetAllUsersAnswer = function (message) {
    //console.log('onGetAllUsersAnswer' + message);
    myDB_Event.createGetAllUsersAnswerEvent(message);
  }; //TODO
  //Faire un getUserIdList
  //Faire un get Parameter fromID
  //Faire un get Paraemterssss fromID
  //Faire un getPresenceStatus


  apiDB.setPresenceStatus = function (userId, presenceStatus, commentStatus) {
    //console.log('setPresenceStatus :' + presenceStatus + ':' + commentStatus);
    //Adding presenceStatus, commentStatus in Users_Apikey
    var messageToSend = null,
        msgString = null;
    messageToSend = {
      id: userId,
      presenceStatus: presenceStatus,
      commentStatus: commentStatus
    };
    msgString = JSON.stringify(messageToSend); //console.log('C->S: ' + msgString);

    this.socket.emit('setPresenceStatus', msgString);
  };

  apiDB.setUserStatus = function (userId, statusJSONObj) {
    //console.log('setUserStatus :' + statusJSONObj);
    var msgString = null; //Adding userId in JSON status

    statusJSONObj.id = userId; //console.log('statusJSON with ID :' + statusJSONObj);

    msgString = JSON.stringify(statusJSONObj); //console.log('C->S: ' + msgString);

    this.socket.emit('setUserStatus', msgString);
  };

  apiDB.setUserInfos = function (infos) {
    //console.log('setUserInfos :' + infos);
    //Adding infos about user in Users_Apikey
    var messageToSend = null,
        msgString = null;
    messageToSend = infos;
    msgString = JSON.stringify(messageToSend); //console.log('C->S: ' + msgString);

    this.socket.emit('setUserInfos', msgString);
  };
  /*
  <b>Description</b>
  <p>addEventListener enable notifications on apiCC events. This enable you to customize the behavior of your application. </p>
  @method addEventListener
  @param {String} type A string representing the event type to listen for.
  @param {Object} listener The object that receives a notification when an event of the specified type occurs. (JavaScript function).
  */


  apiDB.addEventListener = function (type, listener) {
    if (typeof apiRTC_React !== 'undefined') {
      eventManager.addEventListener(type, listener);
    } else if (type !== "getUserFromIdAnswer" || type !== "error" || type !== "getAllUsersAnswer" || type !== "searchUserAnswer") {
      //console.log('Adding listener on type :' + type);
      document.addEventListener(type, listener, false);
    } else {
      //TODO
      myDB_Event.createErrorEvent('ERROR: Trying to add a listener on an unknow event');
    }
  };

  apiDB.callback = function (that, fnct) {
    this.closureHandler = function (e) {
      return that[fnct](e);
    };

    return this.closureHandler;
  }; // Expose apiDB to the global object


  window.apiDB = apiDB;
  return apiDB;
})(window);

/***/ }),

/***/ "./src/Core/onbeforeunload.js":
/*!************************************!*\
  !*** ./src/Core/onbeforeunload.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* globals mailClicked, apiCC*/

var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('onbeforeunload');

apiCC.beforeUnloadFct = function (eventType) {
  logger.debug('User has refreshed or left the page, eventType :', eventType); //PATCH/WORKAROUND to avoid reload of page in chrome when mailto is clicked (mailClicked variable has to be defined and set to true)

  try {
    if (typeof mailClicked !== 'undefined') {
      if (mailClicked !== null) {
        logger.log('mailClicked variable is defined');

        if (mailClicked === true) {
          logger.log('mailClicked is true : leaving onbeforeunload');
          mailClicked = false;
          return;
        }
      }
    }
  } catch (err) {
    logger.log('Catch error on PATCH/WORKAROUND to avoid reload of page in chrome when mailto :' + err);
  } //PATCH/WORKAROUND to avoid reload of page when WebRTC Plugin is being installed


  try {
    if (typeof apiCC.iePluginInstallationPreventUnload !== 'undefined') {
      if (apiCC.iePluginInstallationPreventUnload !== null) {
        //logger.log('iePluginInstallationPreventUnload variable is defined :', apiCC.iePluginInstallationPreventUnload);
        if (apiCC.iePluginInstallationPreventUnload === true) {
          logger.log('iePluginInstallationPreventUnload is true : leaving onbeforeunload');
          return;
        }
      }
    }
  } catch (err2) {
    logger.log('Catch error on PATCH/WORKAROUND to avoid reload of page in IE when installing webRTC plugin :' + err2);
  }

  if (apiCC !== null && apiCC !== undefined) {
    apiCC.storeSessionInfoInSessionStorage();
    apiCC.cleanApiRTCContext();
    apiCC.disconnect({
      invalidateApiCCId: true
    });
    apiCC.cleanAllEventListener();
    apiCC.myEventTable = [];
  }

  if (apiCC !== null && apiCC !== undefined) {
    apiCC.session = null;
    apiCC.jsLoaded = false;
  }
};

if (apiRTC.browser === 'Mobile Safari') {
  //unload event is not supported on Safari iOS
  window.addEventListener('pagehide', function () {
    apiCC.beforeUnloadFct('unload_MobileSafari');
  });
} else {
  window.onbeforeunload = function () {
    apiCC.beforeUnloadFct('unload');
  };
}

/***/ }),

/***/ "./src/Core/ua-parser.js":
/*!*******************************!*\
  !*** ./src/Core/ua-parser.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/////////////////////////////////////////////////////////////////////////////////

/* UAParser.js v1.0.32
   Copyright  2012-2021 Faisal Salman <f@faisalman.com>
   MIT License */

/*
Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
Supports browser & node.js environment. 
Demo   : https://faisalman.github.io/ua-parser-js
Source : https://github.com/faisalman/ua-parser-js */
/////////////////////////////////////////////////////////////////////////////////
//Modif_Apizee : Changed the following line
//old version : (function (window, undefined) {
(function (window) {
  //Modif_Apizee
  'use strict'; //////////////
  // Constants
  /////////////

  var LIBVERSION = '1.0.32',
      EMPTY = '',
      UNKNOWN = '?',
      FUNC_TYPE = 'function',
      UNDEF_TYPE = 'undefined',
      OBJ_TYPE = 'object',
      STR_TYPE = 'string',
      MAJOR = 'major',
      MODEL = 'model',
      NAME = 'name',
      TYPE = 'type',
      VENDOR = 'vendor',
      VERSION = 'version',
      ARCHITECTURE = 'architecture',
      CONSOLE = 'console',
      MOBILE = 'mobile',
      TABLET = 'tablet',
      SMARTTV = 'smarttv',
      WEARABLE = 'wearable',
      EMBEDDED = 'embedded',
      UA_MAX_LENGTH = 350;
  var AMAZON = 'Amazon',
      APPLE = 'Apple',
      ASUS = 'ASUS',
      BLACKBERRY = 'BlackBerry',
      BROWSER = 'Browser',
      CHROME = 'Chrome',
      EDGE = 'Edge',
      FIREFOX = 'Firefox',
      GOOGLE = 'Google',
      HUAWEI = 'Huawei',
      LG = 'LG',
      MICROSOFT = 'Microsoft',
      MOTOROLA = 'Motorola',
      OPERA = 'Opera',
      SAMSUNG = 'Samsung',
      SHARP = 'Sharp',
      SONY = 'Sony',
      XIAOMI = 'Xiaomi',
      ZEBRA = 'Zebra',
      FACEBOOK = 'Facebook'; ///////////
  // Helper
  //////////

  var extend = function extend(regexes, extensions) {
    var mergedRegexes = {};

    for (var i in regexes) {
      if (extensions[i] && extensions[i].length % 2 === 0) {
        mergedRegexes[i] = extensions[i].concat(regexes[i]);
      } else {
        mergedRegexes[i] = regexes[i];
      }
    }

    return mergedRegexes;
  },
      enumerize = function enumerize(arr) {
    var enums = {};

    for (var i = 0; i < arr.length; i++) {
      enums[arr[i].toUpperCase()] = arr[i];
    }

    return enums;
  },
      has = function has(str1, str2) {
    return _typeof(str1) === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
  },
      lowerize = function lowerize(str) {
    return str.toLowerCase();
  },
      majorize = function majorize(version) {
    return _typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split('.')[0] : undefined;
  },
      trim = function trim(str, len) {
    if (_typeof(str) === STR_TYPE) {
      str = str.replace(/^\s\s*/, EMPTY).replace(/\s\s*$/, EMPTY);
      return _typeof(len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
    }
  }; ///////////////
  // Map helper
  //////////////


  var rgxMapper = function rgxMapper(ua, arrays) {
    var i = 0,
        j,
        k,
        p,
        q,
        matches,
        match; // loop through all regexes maps

    while (i < arrays.length && !matches) {
      var regex = arrays[i],
          // even sequence (0,2,4,..)
      props = arrays[i + 1]; // odd sequence (1,3,5,..)

      j = k = 0; // try matching uastring with regexes

      while (j < regex.length && !matches) {
        matches = regex[j++].exec(ua);

        if (!!matches) {
          for (p = 0; p < props.length; p++) {
            match = matches[++k];
            q = props[p]; // check if given property is actually array

            if (_typeof(q) === OBJ_TYPE && q.length > 0) {
              if (q.length === 2) {
                if (_typeof(q[1]) == FUNC_TYPE) {
                  // assign modified match
                  this[q[0]] = q[1].call(this, match);
                } else {
                  // assign given value, ignore regex match
                  this[q[0]] = q[1];
                }
              } else if (q.length === 3) {
                // check whether function or regex
                if (_typeof(q[1]) === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                  // call function (usually string mapper)
                  this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                } else {
                  // sanitize match using given regex
                  this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                }
              } else if (q.length === 4) {
                this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
              }
            } else {
              this[q] = match ? match : undefined;
            }
          }
        }
      }

      i += 2;
    }
  },
      strMapper = function strMapper(str, map) {
    for (var i in map) {
      // check if current value is array
      if (_typeof(map[i]) === OBJ_TYPE && map[i].length > 0) {
        for (var j = 0; j < map[i].length; j++) {
          if (has(map[i][j], str)) {
            return i === UNKNOWN ? undefined : i;
          }
        }
      } else if (has(map[i], str)) {
        return i === UNKNOWN ? undefined : i;
      }
    }

    return str;
  }; ///////////////
  // String map
  //////////////
  // Safari < 3.0


  var oldSafariMap = {
    '1.0': '/8',
    '1.2': '/1',
    '1.3': '/3',
    '2.0': '/412',
    '2.0.2': '/416',
    '2.0.3': '/417',
    '2.0.4': '/419',
    '?': '/'
  },
      windowsVersionMap = {
    'ME': '4.90',
    'NT 3.11': 'NT3.51',
    'NT 4.0': 'NT4.0',
    '2000': 'NT 5.0',
    'XP': ['NT 5.1', 'NT 5.2'],
    'Vista': 'NT 6.0',
    '7': 'NT 6.1',
    '8': 'NT 6.2',
    '8.1': 'NT 6.3',
    '10': ['NT 6.4', 'NT 10.0'],
    'RT': 'ARM'
  }; //////////////
  // Regex map
  /////////////

  var regexes = {
    browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i // Chrome for Android/iOS
    ], [VERSION, [NAME, 'Chrome']], [/edg(?:e|ios|a)?\/([\w\.]+)/i // Microsoft Edge
    ], [VERSION, [NAME, 'Edge']], [// Presto based
    /(opera mini)\/([-\w\.]+)/i, // Opera Mini
    /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, // Opera Mobi/Tablet
    /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i // Opera
    ], [NAME, VERSION], [/opios[\/ ]+([\w\.]+)/i // Opera mini on iphone >= 8.0
    ], [VERSION, [NAME, OPERA + ' Mini']], [/\bopr\/([\w\.]+)/i // Opera Webkit
    ], [VERSION, [NAME, OPERA]], [// Mixed
    /(kindle)\/([\w\.]+)/i, // Kindle
    /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, // Lunascape/Maxthon/Netfront/Jasmine/Blazer
    // Trident based
    /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, // Avant/IEMobile/SlimBrowser
    /(ba?idubrowser)[\/ ]?([\w\.]+)/i, // Baidu Browser
    /(?:ms|\()(ie) ([\w\.]+)/i, // Internet Explorer
    // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
    /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
    /(weibo)__([\d\.]+)/i // Weibo
    ], [NAME, VERSION], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i // UCBrowser
    ], [VERSION, [NAME, 'UC' + BROWSER]], [/microm.+\bqbcore\/([\w\.]+)/i, // WeChat Desktop for Windows Built-in Browser
    /\bqbcore\/([\w\.]+).+microm/i], [VERSION, [NAME, 'WeChat(Win) Desktop']], [/micromessenger\/([\w\.]+)/i // WeChat
    ], [VERSION, [NAME, 'WeChat']], [/konqueror\/([\w\.]+)/i // Konqueror
    ], [VERSION, [NAME, 'Konqueror']], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i // IE11
    ], [VERSION, [NAME, 'IE']], [/yabrowser\/([\w\.]+)/i // Yandex
    ], [VERSION, [NAME, 'Yandex']], [/(avast|avg)\/([\w\.]+)/i // Avast/AVG Secure Browser
    ], [[NAME, /(.+)/, '$1 Secure ' + BROWSER], VERSION], [/\bfocus\/([\w\.]+)/i // Firefox Focus
    ], [VERSION, [NAME, FIREFOX + ' Focus']], [/\bopt\/([\w\.]+)/i // Opera Touch
    ], [VERSION, [NAME, OPERA + ' Touch']], [/coc_coc\w+\/([\w\.]+)/i // Coc Coc Browser
    ], [VERSION, [NAME, 'Coc Coc']], [/dolfin\/([\w\.]+)/i // Dolphin
    ], [VERSION, [NAME, 'Dolphin']], [/coast\/([\w\.]+)/i // Opera Coast
    ], [VERSION, [NAME, OPERA + ' Coast']], [/miuibrowser\/([\w\.]+)/i // MIUI Browser
    ], [VERSION, [NAME, 'MIUI ' + BROWSER]], [/fxios\/([-\w\.]+)/i // Firefox for iOS
    ], [VERSION, [NAME, FIREFOX]], [/\bqihu|(qi?ho?o?|360)browser/i // 360
    ], [[NAME, '360 ' + BROWSER]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[NAME, /(.+)/, '$1 ' + BROWSER], VERSION], [// Oculus/Samsung/Sailfish/Huawei Browser
    /(comodo_dragon)\/([\w\.]+)/i // Comodo Dragon
    ], [[NAME, /_/g, ' '], VERSION], [/(electron)\/([\w\.]+) safari/i, // Electron-based App
    /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, // Tesla
    /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i // QQBrowser/Baidu App/2345 Browser
    ], [NAME, VERSION], [/(metasr)[\/ ]?([\w\.]+)/i, // SouGouBrowser
    /(lbbrowser)/i, // LieBao Browser
    /\[(linkedin)app\]/i // LinkedIn App for iOS & Android
    ], [NAME], [// WebView
    /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i // Facebook App for iOS & Android
    ], [[NAME, FACEBOOK], VERSION], [/safari (line)\/([\w\.]+)/i, // Line App for iOS
    /\b(line)\/([\w\.]+)\/iab/i, // Line App for Android
    /(chromium|instagram)[\/ ]([-\w\.]+)/i // Chromium/Instagram
    ], [NAME, VERSION], [/\bgsa\/([\w\.]+) .*safari\//i // Google Search Appliance on iOS
    ], [VERSION, [NAME, 'GSA']], [/headlesschrome(?:\/([\w\.]+)| )/i // Chrome Headless
    ], [VERSION, [NAME, CHROME + ' Headless']], [/ wv\).+(chrome)\/([\w\.]+)/i // Chrome WebView
    ], [[NAME, CHROME + ' WebView'], VERSION], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i // Android Browser
    ], [VERSION, [NAME, 'Android ' + BROWSER]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i // Chrome/OmniWeb/Arora/Tizen/Nokia
    ], [NAME, VERSION], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i // Mobile Safari
    ], [VERSION, [NAME, 'Mobile Safari']], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i // Safari & Safari Mobile
    ], [VERSION, NAME], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i // Safari < 3.0
    ], [NAME, [VERSION, strMapper, oldSafariMap]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [// Gecko based
    /(navigator|netscape\d?)\/([-\w\.]+)/i // Netscape
    ], [[NAME, 'Netscape'], VERSION], [/mobile vr; rv:([\w\.]+)\).+firefox/i // Firefox Reality
    ], [VERSION, [NAME, FIREFOX + ' Reality']], [/ekiohf.+(flow)\/([\w\.]+)/i, // Flow
    /(swiftfox)/i, // Swiftfox
    /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
    /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
    /(firefox)\/([\w\.]+)/i, // Other Firefox-based
    /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, // Mozilla
    // Other
    /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
    /(links) \(([\w\.]+)/i // Links
    ], [NAME, VERSION]],
    cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i // AMD64 (x64)
    ], [[ARCHITECTURE, 'amd64']], [/(ia32(?=;))/i // IA32 (quicktime)
    ], [[ARCHITECTURE, lowerize]], [/((?:i[346]|x)86)[;\)]/i // IA32 (x86)
    ], [[ARCHITECTURE, 'ia32']], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i // ARM64
    ], [[ARCHITECTURE, 'arm64']], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i // ARMHF
    ], [[ARCHITECTURE, 'armhf']], [// PocketPC mistakenly identified as PowerPC
    /windows (ce|mobile); ppc;/i], [[ARCHITECTURE, 'arm']], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i // PowerPC
    ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [/(sun4\w)[;\)]/i // SPARC
    ], [[ARCHITECTURE, 'sparc']], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
    ], [[ARCHITECTURE, lowerize]]],
    device: [[//////////////////////////
    // MOBILES & TABLETS
    // Ordered by popularity
    /////////////////////////
    // Samsung
    /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [// Apple
    /\((ip(?:hone|od)[\w ]*);/i // iPod/iPhone
    ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [/\((ipad);[-\w\),; ]+apple/i, // iPad
    /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [// Huawei
    /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [// Xiaomi
    /\b(poco[\w ]+)(?: bui|\))/i, // Xiaomi POCO
    /\b; (\w+) build\/hm\1/i, // Xiaomi Hongmi 'numeric' models
    /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, // Xiaomi Hongmi
    /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, // Xiaomi Redmi
    /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i // Xiaomi Mi
    ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i // Mi Pad tablets
    ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [// OPPO
    /; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [// Vivo
    /vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [// Realme
    /\b(rmx[12]\d{3})(?: bui|;|\))/i], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [// Motorola
    /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [// LG
    /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [// Lenovo
    /(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [// Nokia
    /(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [// Google
    /(pixel c)\b/i // Google Pixel C
    ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i // Google Pixel
    ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [// Sony
    /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [// OnePlus
    / (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [// Amazon
    /(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, // Kindle Fire without Silk
    /(kf[a-z]+)( bui|\)).+silk\//i // Kindle Fire HD
    ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i // Fire Phone
    ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [// BlackBerry
    /(playbook);[-\w\),; ]+(rim)/i // BlackBerry PlayBook
    ], [MODEL, VENDOR, [TYPE, TABLET]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i // BlackBerry 10
    ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [// Asus
    /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [// HTC
    /(nexus 9)/i // HTC Nexus 9
    ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, // HTC
    // ZTE
    /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
    ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [// Acer
    /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [// Meizu
    /droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [// Sharp
    /\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [// MIXED
    /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
    /(hp) ([\w ]+\w)/i, // HP iPAQ
    /(asus)-?(\w+)/i, // Asus
    /(microsoft); (lumia[\w ]+)/i, // Microsoft Lumia
    /(lenovo)[-_ ]?([-\w]+)/i, // Lenovo
    /(jolla)/i, // Jolla
    /(oppo) ?([\w ]+) bui/i // OPPO
    ], [VENDOR, MODEL, [TYPE, MOBILE]], [/(archos) (gamepad2?)/i, // Archos
    /(hp).+(touchpad(?!.+tablet)|tablet)/i, // HP TouchPad
    /(kindle)\/([\w\.]+)/i, // Kindle
    /(nook)[\w ]+build\/(\w+)/i, // Nook
    /(dell) (strea[kpr\d ]*[\dko])/i, // Dell Streak
    /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, // Le Pan Tablets
    /(trinity)[- ]*(t\d{3}) bui/i, // Trinity Tablets
    /(gigaset)[- ]+(q\w{1,9}) bui/i, // Gigaset Tablets
    /(vodafone) ([\w ]+)(?:\)| bui)/i // Vodafone
    ], [VENDOR, MODEL, [TYPE, TABLET]], [/(surface duo)/i // Surface Duo
    ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i // Fairphone
    ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [/(u304aa)/i // AT&T
    ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [/\bsie-(\w*)/i // Siemens
    ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [/\b(rct\w+) b/i // RCA Tablets
    ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [/\b(venue[\d ]{2,7}) b/i // Dell Venue Tablets
    ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [/\b(q(?:mv|ta)\w+) b/i // Verizon Tablet
    ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i // Barnes & Noble Tablet
    ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [/\b(tm\d{3}\w+) b/i], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [/\b(k88) b/i // ZTE K Series Tablet
    ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [/\b(nx\d{3}j) b/i // ZTE Nubia
    ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [/\b(gen\d{3}) b.+49h/i // Swiss GEN Mobile
    ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [/\b(zur\d{3}) b/i // Swiss ZUR Tablet
    ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [/\b((zeki)?tb.*\b) b/i // Zeki Tablets
    ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i // Dragon Touch Tablet
    ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [/\b(ns-?\w{0,9}) b/i // Insignia Tablets
    ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [/\b((nxa|next)-?\w{0,9}) b/i // NextBook Tablets
    ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i // Voice Xtreme Phones
    ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [/\b(lvtel\-)?(v1[12]) b/i // LvTel Phones
    ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [/\b(ph-1) /i // Essential PH-1
    ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [/\b(v(100md|700na|7011|917g).*\b) b/i // Envizen Tablets
    ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [/\b(trio[-\w\. ]+) b/i // MachSpeed Tablets
    ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [/\btu_(1491) b/i // Rotor Tablets
    ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [/(shield[\w ]+) b/i // Nvidia Shield Tablets
    ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [/(sprint) (\w+)/i // Sprint Phones
    ], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kin\.[onetw]{3})/i // Microsoft Kin
    ], [[MODEL, /\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i // Zebra
    ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [///////////////////
    // CONSOLES
    ///////////////////
    /(ouya)/i, // Ouya
    /(nintendo) ([wids3utch]+)/i // Nintendo
    ], [VENDOR, MODEL, [TYPE, CONSOLE]], [/droid.+; (shield) bui/i // Nvidia
    ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [/(playstation [345portablevi]+)/i // Playstation
    ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i // Microsoft Xbox
    ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [///////////////////
    // SMARTTVS
    ///////////////////
    /smart-tv.+(samsung)/i // Samsung
    ], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i // LG SmartTV
    ], [[VENDOR, LG], [TYPE, SMARTTV]], [/(apple) ?tv/i // Apple TV
    ], [VENDOR, [MODEL, APPLE + ' TV'], [TYPE, SMARTTV]], [/crkey/i // Google Chromecast
    ], [[MODEL, CHROME + 'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/droid.+aft(\w)( bui|\))/i // Fire TV
    ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i // Sharp
    ], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]], [/(bravia[\w ]+)( bui|\))/i // Sony
    ], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [/(mitv-\w{5}) bui/i // Xiaomi
    ], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, // Roku
    /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i // HbbTV devices
    ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i // SmartTV from Unidentified Vendors
    ], [[TYPE, SMARTTV]], [///////////////////
    // WEARABLES
    ///////////////////
    /((pebble))app/i // Pebble
    ], [VENDOR, MODEL, [TYPE, WEARABLE]], [/droid.+; (glass) \d/i // Google Glass
    ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [/(quest( 2)?)/i // Oculus Quest
    ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [///////////////////
    // EMBEDDED
    ///////////////////
    /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i // Tesla
    ], [VENDOR, [TYPE, EMBEDDED]], [////////////////////
    // MIXED (GENERIC)
    ///////////////////
    /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i // Android Phones from Unidentified Vendors
    ], [MODEL, [TYPE, MOBILE]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i // Android Tablets from Unidentified Vendors
    ], [MODEL, [TYPE, TABLET]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i // Unidentifiable Tablet
    ], [[TYPE, TABLET]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i // Unidentifiable Mobile
    ], [[TYPE, MOBILE]], [/(android[-\w\. ]{0,9});.+buil/i // Generic Android Device
    ], [MODEL, [VENDOR, 'Generic']]],
    engine: [[/windows.+ edge\/([\w\.]+)/i // EdgeHTML
    ], [VERSION, [NAME, EDGE + 'HTML']], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i // Blink
    ], [VERSION, [NAME, 'Blink']], [/(presto)\/([\w\.]+)/i, // Presto
    /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
    /ekioh(flow)\/([\w\.]+)/i, // Flow
    /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, // KHTML/Tasman/Links
    /(icab)[\/ ]([23]\.[\d\.]+)/i // iCab
    ], [NAME, VERSION], [/rv\:([\w\.]{1,9})\b.+(gecko)/i // Gecko
    ], [VERSION, NAME]],
    os: [[// Windows
    /microsoft (windows) (vista|xp)/i // Windows (iTunes)
    ], [NAME, VERSION], [/(windows) nt 6\.2; (arm)/i, // Windows RT
    /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, // Windows Phone
    /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [NAME, [VERSION, strMapper, windowsVersionMap]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[NAME, 'Windows'], [VERSION, strMapper, windowsVersionMap]], [// iOS/macOS
    /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, // iOS
    /cfnetwork\/.+darwin/i], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i // Mac OS
    ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [// Mobile OSes
    /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i // Android-x86/HarmonyOS
    ], [VERSION, NAME], [// Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
    /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, // Blackberry
    /(tizen|kaios)[\/ ]([\w\.]+)/i, // Tizen/KaiOS
    /\((series40);/i // Series 40
    ], [NAME, VERSION], [/\(bb(10);/i // BlackBerry 10
    ], [VERSION, [NAME, BLACKBERRY]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i // Symbian
    ], [VERSION, [NAME, 'Symbian']], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
    ], [VERSION, [NAME, FIREFOX + ' OS']], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i // WebOS
    ], [VERSION, [NAME, 'webOS']], [// Google Chromecast
    /crkey\/([\d\.]+)/i // Google Chromecast
    ], [VERSION, [NAME, CHROME + 'cast']], [/(cros) [\w]+ ([\w\.]+\w)/i // Chromium OS
    ], [[NAME, 'Chromium OS'], VERSION], [// Console
    /(nintendo|playstation) ([wids345portablevuch]+)/i, // Nintendo/Playstation
    /(xbox); +xbox ([^\);]+)/i, // Microsoft Xbox (360, One, X, S, Series X, Series S)
    // Other
    /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, // Joli/Palm
    /(mint)[\/\(\) ]?(\w*)/i, // Mint
    /(mageia|vectorlinux)[; ]/i, // Mageia/VectorLinux
    /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
    /(hurd|linux) ?([\w\.]*)/i, // Hurd/Linux
    /(gnu) ?([\w\.]*)/i, // GNU
    /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
    /(haiku) (\w+)/i // Haiku
    ], [NAME, VERSION], [/(sunos) ?([\w\.\d]*)/i // Solaris
    ], [[NAME, 'Solaris'], VERSION], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, // Solaris
    /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, // AIX
    /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX
    /(unix) ?([\w\.]*)/i // UNIX
    ], [NAME, VERSION]]
  }; /////////////////
  // Constructor
  ////////////////

  var UAParser = function UAParser(ua, extensions) {
    if (_typeof(ua) === OBJ_TYPE) {
      extensions = ua;
      ua = undefined;
    }

    if (!(this instanceof UAParser)) {
      return new UAParser(ua, extensions).getResult();
    }

    var _ua = ua || (_typeof(window) !== UNDEF_TYPE && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : EMPTY);

    var _rgxmap = extensions ? extend(regexes, extensions) : regexes;

    this.getBrowser = function () {
      var _browser = {};
      _browser[NAME] = undefined;
      _browser[VERSION] = undefined;
      rgxMapper.call(_browser, _ua, _rgxmap.browser);
      _browser.major = majorize(_browser.version);
      return _browser;
    };

    this.getCPU = function () {
      var _cpu = {};
      _cpu[ARCHITECTURE] = undefined;
      rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
      return _cpu;
    };

    this.getDevice = function () {
      var _device = {};
      _device[VENDOR] = undefined;
      _device[MODEL] = undefined;
      _device[TYPE] = undefined;
      rgxMapper.call(_device, _ua, _rgxmap.device);
      return _device;
    };

    this.getEngine = function () {
      var _engine = {};
      _engine[NAME] = undefined;
      _engine[VERSION] = undefined;
      rgxMapper.call(_engine, _ua, _rgxmap.engine);
      return _engine;
    };

    this.getOS = function () {
      var _os = {};
      _os[NAME] = undefined;
      _os[VERSION] = undefined;
      rgxMapper.call(_os, _ua, _rgxmap.os);
      return _os;
    };

    this.getResult = function () {
      return {
        ua: this.getUA(),
        browser: this.getBrowser(),
        engine: this.getEngine(),
        os: this.getOS(),
        device: this.getDevice(),
        cpu: this.getCPU()
      };
    };

    this.getUA = function () {
      return _ua;
    };

    this.setUA = function (ua) {
      _ua = _typeof(ua) === STR_TYPE && ua.length > UA_MAX_LENGTH ? trim(ua, UA_MAX_LENGTH) : ua;
      return this;
    };

    this.setUA(_ua);
    return this;
  };

  UAParser.VERSION = LIBVERSION;
  UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
  UAParser.CPU = enumerize([ARCHITECTURE]);
  UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
  UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]); ///////////
  // Export
  //////////
  // check js environment

  if (( false ? 0 : _typeof(exports)) !== UNDEF_TYPE) {
    // nodejs env
    if (( false ? 0 : _typeof(module)) !== UNDEF_TYPE && module.exports) {
      exports = module.exports = UAParser;
    }

    exports.UAParser = UAParser; //Modif_Apizee : Added the following line

    window.UAParser = UAParser; //Modif_Apizee END
  } else {
    // requirejs env (optional)
    if (( false ? 0 : _typeof(__webpack_require__.amdD)) === FUNC_TYPE && __webpack_require__.amdO) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return UAParser;
      }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (_typeof(window) !== UNDEF_TYPE) {
      // browser env
      window.UAParser = UAParser;
    }
  } // jQuery/Zepto specific (optional)
  // Note:
  //   In AMD env the global scope should be kept clean, but jQuery is an exception.
  //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
  //   and we should catch that.


  var $ = _typeof(window) !== UNDEF_TYPE && (window.jQuery || window.Zepto);

  if ($ && !$.ua) {
    var parser = new UAParser();
    $.ua = parser.getResult();

    $.ua.get = function () {
      return parser.getUA();
    };

    $.ua.set = function (ua) {
      parser.setUA(ua);
      var result = parser.getResult();

      for (var prop in result) {
        $.ua[prop] = result[prop];
      }
    };
  }
})((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' ? window : this);

/***/ }),

/***/ "./src/apiRTC.js":
/*!***********************!*\
  !*** ./src/apiRTC.js ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Call": () => (/* reexport safe */ _public_Call__WEBPACK_IMPORTED_MODULE_7__.Call),
/* harmony export */   "CloudApi": () => (/* binding */ CloudApi),
/* harmony export */   "Conference": () => (/* reexport safe */ _public_Conference__WEBPACK_IMPORTED_MODULE_11__.Conference),
/* harmony export */   "Contact": () => (/* reexport safe */ _public_Contact__WEBPACK_IMPORTED_MODULE_8__.Contact),
/* harmony export */   "Conversation": () => (/* reexport safe */ _public_Conversation__WEBPACK_IMPORTED_MODULE_9__.Conversation),
/* harmony export */   "ConversationCall": () => (/* reexport safe */ _public_ConversationCall__WEBPACK_IMPORTED_MODULE_10__.ConversationCall),
/* harmony export */   "DataChannel": () => (/* reexport safe */ _public_DataChannel__WEBPACK_IMPORTED_MODULE_26__.DataChannel),
/* harmony export */   "Enterprise": () => (/* reexport safe */ _public_Enterprise__WEBPACK_IMPORTED_MODULE_12__.Enterprise),
/* harmony export */   "EventCenter": () => (/* reexport safe */ _public_EventCenter__WEBPACK_IMPORTED_MODULE_2__.EventCenter),
/* harmony export */   "EventEmitter": () => (/* reexport safe */ _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter),
/* harmony export */   "MediaDevice": () => (/* reexport safe */ _public_MediaDevice__WEBPACK_IMPORTED_MODULE_5__.MediaDevice),
/* harmony export */   "Observable": () => (/* reexport safe */ _utils_Observable__WEBPACK_IMPORTED_MODULE_27__.Observable),
/* harmony export */   "PointerSharingRoom": () => (/* reexport safe */ _public_Session__WEBPACK_IMPORTED_MODULE_22__.PointerSharingRoom),
/* harmony export */   "ReceivedCallInvitation": () => (/* reexport safe */ _public_ReceivedCallInvitation__WEBPACK_IMPORTED_MODULE_15__.ReceivedCallInvitation),
/* harmony export */   "ReceivedConversationInvitation": () => (/* reexport safe */ _public_ReceivedConversationInvitation__WEBPACK_IMPORTED_MODULE_18__.ReceivedConversationInvitation),
/* harmony export */   "ReceivedConversationJoinRequest": () => (/* reexport safe */ _public_ReceivedConversationJoinRequest__WEBPACK_IMPORTED_MODULE_17__.ReceivedConversationJoinRequest),
/* harmony export */   "ReceivedDataChannelInvitation": () => (/* reexport safe */ _public_ReceivedDataChannelInvitation__WEBPACK_IMPORTED_MODULE_16__.ReceivedDataChannelInvitation),
/* harmony export */   "ReceivedFileTransferInvitation": () => (/* reexport safe */ _public_ReceivedFileTransferInvitation__WEBPACK_IMPORTED_MODULE_19__.ReceivedFileTransferInvitation),
/* harmony export */   "ReceivedInvitation": () => (/* reexport safe */ _public_ReceivedInvitation__WEBPACK_IMPORTED_MODULE_14__.ReceivedInvitation),
/* harmony export */   "ReceivedPointerSharingInvitation": () => (/* reexport safe */ _public_ReceivedPointerSharingInvitation__WEBPACK_IMPORTED_MODULE_21__.ReceivedPointerSharingInvitation),
/* harmony export */   "ReceivedWhiteboardInvitation": () => (/* reexport safe */ _public_ReceivedWhiteboardInvitation__WEBPACK_IMPORTED_MODULE_20__.ReceivedWhiteboardInvitation),
/* harmony export */   "SentInvitation": () => (/* reexport safe */ _public_SentInvitation__WEBPACK_IMPORTED_MODULE_13__.SentInvitation),
/* harmony export */   "Session": () => (/* reexport safe */ _public_Session__WEBPACK_IMPORTED_MODULE_22__.Session),
/* harmony export */   "Stream": () => (/* reexport safe */ _public_Stream__WEBPACK_IMPORTED_MODULE_6__.Stream),
/* harmony export */   "UserAgent": () => (/* reexport safe */ _public_UserAgent__WEBPACK_IMPORTED_MODULE_23__.UserAgent),
/* harmony export */   "UserData": () => (/* reexport safe */ _public_UserData__WEBPACK_IMPORTED_MODULE_24__.UserData),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/EventEmitter */ "./src/utils/EventEmitter.js");
/* harmony import */ var _public_EventCenter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./public/EventCenter */ "./src/public/EventCenter.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Core/ApiCC.js */ "./src/Core/ApiCC.js");
/* harmony import */ var _public_MediaDevice__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./public/MediaDevice */ "./src/public/MediaDevice.js");
/* harmony import */ var _public_Stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./public/Stream */ "./src/public/Stream.js");
/* harmony import */ var _public_Call__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./public/Call */ "./src/public/Call.js");
/* harmony import */ var _public_Contact__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./public/Contact */ "./src/public/Contact.js");
/* harmony import */ var _public_Conversation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./public/Conversation */ "./src/public/Conversation.js");
/* harmony import */ var _public_ConversationCall__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./public/ConversationCall */ "./src/public/ConversationCall.js");
/* harmony import */ var _public_Conference__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./public/Conference */ "./src/public/Conference.js");
/* harmony import */ var _public_Enterprise__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./public/Enterprise */ "./src/public/Enterprise.js");
/* harmony import */ var _public_SentInvitation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./public/SentInvitation */ "./src/public/SentInvitation.js");
/* harmony import */ var _public_ReceivedInvitation__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./public/ReceivedInvitation */ "./src/public/ReceivedInvitation.js");
/* harmony import */ var _public_ReceivedCallInvitation__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./public/ReceivedCallInvitation */ "./src/public/ReceivedCallInvitation.js");
/* harmony import */ var _public_ReceivedDataChannelInvitation__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./public/ReceivedDataChannelInvitation */ "./src/public/ReceivedDataChannelInvitation.js");
/* harmony import */ var _public_ReceivedConversationJoinRequest__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./public/ReceivedConversationJoinRequest */ "./src/public/ReceivedConversationJoinRequest.js");
/* harmony import */ var _public_ReceivedConversationInvitation__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./public/ReceivedConversationInvitation */ "./src/public/ReceivedConversationInvitation.js");
/* harmony import */ var _public_ReceivedFileTransferInvitation__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./public/ReceivedFileTransferInvitation */ "./src/public/ReceivedFileTransferInvitation.js");
/* harmony import */ var _public_ReceivedWhiteboardInvitation__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./public/ReceivedWhiteboardInvitation */ "./src/public/ReceivedWhiteboardInvitation.js");
/* harmony import */ var _public_ReceivedPointerSharingInvitation__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./public/ReceivedPointerSharingInvitation */ "./src/public/ReceivedPointerSharingInvitation.js");
/* harmony import */ var _public_Session__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./public/Session */ "./src/public/Session.js");
/* harmony import */ var _public_UserAgent__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./public/UserAgent */ "./src/public/UserAgent.js");
/* harmony import */ var _public_UserData__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./public/UserData */ "./src/public/UserData.js");
/* harmony import */ var _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @apizee/cloudapi-js-sdk/CloudAPI */ "./node_modules/@apizee/cloudapi-js-sdk/CloudAPI.js");
/* harmony import */ var _public_DataChannel__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./public/DataChannel */ "./src/public/DataChannel.js");
/* harmony import */ var _utils_Observable__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./utils/Observable */ "./src/utils/Observable.js");
/* harmony import */ var _Core_ResourcesLoader__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./Core/ResourcesLoader */ "./src/Core/ResourcesLoader.js");
/* harmony import */ var _Core_Init_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./Core/Init.js */ "./src/Core/Init.js");
/* harmony import */ var _Core_MediaDeviceManager_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./Core/MediaDeviceManager.js */ "./src/Core/MediaDeviceManager.js");
/* module decorator */ module = __webpack_require__.hmd(module);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

if (console !== null && console !== undefined) {
  if (console.info) {
    console.info('Loading APIRTC_MODULE');
  }
} //Patch prototype.js for JSON issue


if (window.Prototype) {
  delete Array.prototype.toJSON;
}































var CloudApi = new _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_25__["default"]();
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.version = 'APIRTC_API_DEV_VERSION';
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.utils = {}; //populated by utils classes/functions

_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.eventCenter = new _public_EventCenter__WEBPACK_IMPORTED_MODULE_2__.EventCenter();
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.resourcesLoader = new _Core_ResourcesLoader__WEBPACK_IMPORTED_MODULE_28__["default"](); //Expose constants

for (var _i = 0, _Object$keys = Object.keys(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants); _i < _Object$keys.length; _i++) {
  var key = _Object$keys[_i];
  _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC[key] = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants[key];
} //Expose classes


_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.utils.EventEmitter = _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.utils.EventCenter = _public_EventCenter__WEBPACK_IMPORTED_MODULE_2__.EventCenter;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.MediaDevice = _public_MediaDevice__WEBPACK_IMPORTED_MODULE_5__.MediaDevice;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.Stream = _public_Stream__WEBPACK_IMPORTED_MODULE_6__.Stream;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.Call = _public_Call__WEBPACK_IMPORTED_MODULE_7__.Call;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.Conversation = _public_Conversation__WEBPACK_IMPORTED_MODULE_9__.Conversation;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.ConversationCall = _public_ConversationCall__WEBPACK_IMPORTED_MODULE_10__.ConversationCall;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.Conference = _public_Conference__WEBPACK_IMPORTED_MODULE_11__.Conference;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.Contact = _public_Contact__WEBPACK_IMPORTED_MODULE_8__.Contact;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.Enterprise = _public_Enterprise__WEBPACK_IMPORTED_MODULE_12__.Enterprise;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.SentInvitation = _public_SentInvitation__WEBPACK_IMPORTED_MODULE_13__.SentInvitation;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.ReceivedInvitation = _public_ReceivedInvitation__WEBPACK_IMPORTED_MODULE_14__.ReceivedInvitation;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.ReceivedCallInvitation = _public_ReceivedCallInvitation__WEBPACK_IMPORTED_MODULE_15__.ReceivedCallInvitation;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.ReceivedConversationJoinRequest = _public_ReceivedConversationJoinRequest__WEBPACK_IMPORTED_MODULE_17__.ReceivedConversationJoinRequest;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.ReceivedConversationInvitation = _public_ReceivedConversationInvitation__WEBPACK_IMPORTED_MODULE_18__.ReceivedConversationInvitation;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.ReceivedFileTransferInvitation = _public_ReceivedFileTransferInvitation__WEBPACK_IMPORTED_MODULE_19__.ReceivedFileTransferInvitation;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.ReceivedWhiteboardInvitation = _public_ReceivedWhiteboardInvitation__WEBPACK_IMPORTED_MODULE_20__.ReceivedWhiteboardInvitation;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.ReceivedDataChannelInvitation = _public_ReceivedDataChannelInvitation__WEBPACK_IMPORTED_MODULE_16__.ReceivedDataChannelInvitation;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.ReceivedPointerSharingInvitation = _public_ReceivedPointerSharingInvitation__WEBPACK_IMPORTED_MODULE_21__.ReceivedPointerSharingInvitation;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.PointerSharingRoom = _public_Session__WEBPACK_IMPORTED_MODULE_22__.PointerSharingRoom;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.Session = _public_Session__WEBPACK_IMPORTED_MODULE_22__.Session;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.UserAgent = _public_UserAgent__WEBPACK_IMPORTED_MODULE_23__.UserAgent;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.UserData = _public_UserData__WEBPACK_IMPORTED_MODULE_24__.UserData;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.CloudApi = CloudApi;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.DataChannel = _public_DataChannel__WEBPACK_IMPORTED_MODULE_26__.DataChannel;
_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.Observable = _utils_Observable__WEBPACK_IMPORTED_MODULE_27__.Observable;
/**
 * Sets log level for the Api using ApiRTC.LOG_LEVEL_<X> constants
 *
 * @global
 * @param {Integer} level log level to set
 * @returns {Void}
 */

_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.setLogLevel = function (level) {
  'use strict';

  _private_Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.setLogLevel(level);
};

var apiRTCNewlyDefined = false;

if (window.apiRTC === undefined) {
  if (( false ? 0 : _typeof(module)) === 'object' && module.exports) {
    //CommonJS compliancy
    module.exports = _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC;
  } else if (typeof define === 'function' && __webpack_require__.amdO) {
    //AMD compliancy
    var t = _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC; // workaround to keep the scope in case of webpack production build

    define(function () {
      'use strict';

      return window.apiRTC2 = window.apiRTC = t;
    });
  } //Browser global


  window.apiRTC2 = window.apiRTC = window.apiCC = window.CC = _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC;
  apiRTCNewlyDefined = true;
} else {
  console.info("APIRTC_MODULE already loaded with version :", apiRTC.version);
}

__webpack_require__(/*! ./Core/apiDB.js */ "./src/Core/apiDB.js"); //import { apiRTC_sioLoader } from './Core/sio-loader.js';





if (apiRTCNewlyDefined === true) {
  _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.init = _Core_Init_js__WEBPACK_IMPORTED_MODULE_29__.init;

  __webpack_require__(/*! ./Core/ApiCC_Methods.js */ "./src/Core/ApiCC_Methods.js");

  _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.mediaDeviceMgr = new _Core_MediaDeviceManager_js__WEBPACK_IMPORTED_MODULE_30__.MediaDeviceManager();
  _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.mediaDeviceMgr.getMediaDevices();
  _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.webRTCCompliant = _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.isWebRTCCompliant();
  _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.qoSStatCompliant = _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.isQoSStatCompliant();
  _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.screenSharingCompliant = _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_4__.apiCC.isScreenSharingCompliant();
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (apiRTC);


/***/ }),

/***/ "./src/private/ApiRTCManager.js":
/*!**************************************!*\
  !*** ./src/private/ApiRTCManager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApiRTCManager": () => (/* binding */ ApiRTCManager)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/EventEmitter */ "./src/utils/EventEmitter.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Logger */ "./src/private/Logger.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }



 //import ContactCatalog from './ContactCatalog';


var logger = _Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.get('ApiRTCManager');
var APIRTC_EVENTS = [//apiRTC v1 specific events
'sessionReady', 'incomingCall', 'callEstablished', 'userMediaSuccess', 'userMediaStop', 'userMediaError', 'callRestarting', 'error', 'receiveIMMessage', 'updatePresence', 'webRTCClientCreated', 'updateUserStatus', 'channelEvent', 'groupChatCreation', 'groupChatInvitation', 'groupChatMemberUpdate', 'addUserInGroupChatAnswer', 'receiveGroupChatMessage', 'userDataAnswer', 'fetchUserDataAnswer', 'receiveConversationList', 'receiveConversationHistory', 'receiveConversationDetailReport', 'receiveContactOccurrencesFromConversationList', 'receiveMCUSessionInvitation', 'MCUSessionCreation', 'MCUAvailableStream', 'MCUAvailableStreamUpdate', 'MCURemoveStream', 'canPlayRemoteVideo', 'recordedFileAvailable', 'receiveData', 'roomCreation', 'roomJoined', 'roomInvitation', 'roomMemberUpdate', 'receiveRoomMessage', 'contactListInRoom', 'snapShotPhotoUploaded', 'stopRecord', 'callAttempt', 'joinMCUSessionAnswer', 'hangup', 'desktopCapture', 'remoteStreamAdded', 'remoteStreamRemoved', 'switchStream', 'sendDataChannelOpen', 'sendDataChannelClose', 'sendDataChannelError', 'receiveDataChannelOpen', 'receiveDataChannelClose', 'receiveDataChannelError', 'connectedUsersListUpdate', 'onFileSended', 'onFileSending', 'onFileReceiving', 'onFileReceived', 'onFileProgress', 'onFilePending', 'recordedStreamsAvailable', 'closingWhiteBoard', 'webRTCPluginInstallation', 'onQosStatsUpdate', 'onQosChange', 'onQosAudioChange', 'onQosVideoChange', 'MCURecordedStreamsAvailable', 'MCURecordingStarted', 'MCURecordingStopped', 'ICECandidateTypeUpdate', 'disconnectionWarning', 'MCUAvailableComposite', 'MCUParticipantEjected', 'MCUStreamingStarted', 'MCUStreamingStopped', 'MCUAvailableReplay', 'MCURoomModeChanged', 'onCallStatsUpdate', 'slowLink', 'localStreamUpdated', 'remoteStreamUpdated', 'audioAmplitude', 'videoQualityChanged', 'cpuLimited', 'bandwidthLimited', 'simulcastFeedChanged', 'cloudEventOccurred', //ApiRTCManager specific events
'groupUnsubscribed', 'transferBegun', 'transferProgress', 'transferEnded'];
var SCREENSHARING_EXTENSION_ID = {
  chrome: 'mjjnofoemoepfididplbfimokpnpcoeg'
};
var SCREENSHARING_EXTENSION_CHECK_TIMEOUT = 500;
var screensharingActivated = false;
var instance = null; //private members

var apiRTCInitialized = false,
    eventsInitialized = false; //apiRTC event link wrapper function

var linkApiRTCEvent = function linkApiRTCEvent(eventType) {
  if (instance !== null && instance.isInitialized()) {
    //Removing events that are not on Core
    if (eventType === 'groupUnsubscribed' || eventType === 'transferBegun' || eventType === 'transferProgress' || eventType === 'transferEnded') {
      //logger.debug('linkApiRTCEvent but not a core event :' + eventType);
      return;
    }

    apiRTC.addEventListener(eventType, function (e) {
      logger.trace('Emiting ' + eventType, e);
      instance.eventEmitter.emit(eventType, e);
    });
  }
};

var unlinkApiRTCEvent = function unlinkApiRTCEvent(eventType) {
  if (instance !== null && instance.isInitialized()) {
    apiRTC.removeEventListener(eventType, function (e) {
      logger.trace('Emiting ' + eventType, e);
      instance.eventEmitter.emit(eventType, e);
    });
  }
};
/**
 * ApiRTCManager, Singleton
 * Serves as a normalized interface between apiRTC1 modules & apiRTC2 Classes
 */


var ApiRTCManager = /*#__PURE__*/function () {
  function ApiRTCManager() {
    _classCallCheck(this, ApiRTCManager);

    if (instance !== null) {
      throw 'Cannot construct singleton ApiRTCManager';
    }

    this.eventEmitter = new _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
    this.apiRTCSession = null;
    this.whiteBoardClient = null;
    this.pointerSharingClient = null;
    this.webRTCClient = null;
    this.dataClient = null;
    this.IMClient = null;
    this.contactDisconnectionDelay = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_DISCONNECTION_DELAY;
    instance = this;
  }
  /**
   * Returns the singleton ApiRTCManager instance
   *
   *  @returns {ApiRTCManager} instance
   */


  _createClass(ApiRTCManager, [{
    key: "onEvent",
    value:
    /**
     * Add listener to apiRTC event
     */
    function onEvent(eventType, listener) {
      if (APIRTC_EVENTS.indexOf(eventType) > -1) {
        //logger.error('adding apiRTC event :' + eventType);
        this.eventEmitter.on(eventType, listener);
      } else {
        logger.error('No such apiRTC event ' + eventType);
      }

      return this;
    }
    /**
     * Add one-time listener to apiRTC event
     */

  }, {
    key: "onceEvent",
    value: function onceEvent(eventType, listener) {
      if (APIRTC_EVENTS.indexOf(eventType) > -1) {
        this.eventEmitter.once(eventType, listener);
      } else {
        logger.error('No such apiRTC event ' + eventType);
      }
    }
    /**
     * Promise wrapper around apiRTC's sendData
     */

  }, {
    key: "sendData",
    value: function sendData(destId, data) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        if (_this.dataClient === null) {
          reject(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_APIRTC_INITIALISATION_FAILED);
        } else {
          _this.dataClient.sendData(destId, data, function (res) {
            var errorCode = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER;

            if (typeof res !== 'undefined' && res !== null) {
              if (res.reason !== 'timeoutReached' && res.reason !== 'destNotFound') {
                resolve();
              } else {
                if (res.reason === 'timerReached') {
                  errorCode = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT;
                } else if (res.reason === 'destNotFound') {
                  errorCode = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND;
                }

                reject(errorCode);
              }
            } else {
              reject(errorCode);
            }
          });
        }
      });
    }
    /**
     * Promise wrapper around apiRTC's sendMessage
     */

  }, {
    key: "sendMessage",
    value: function sendMessage(destId, content) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return new Promise(function (resolve, reject) {
        if (_this2.IMClient === null) {
          reject(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_APIRTC_INITIALISATION_FAILED);
        } else {
          _this2.IMClient.sendMessage(destId, content, function (res) {
            var errorCode = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER;

            if (typeof res !== 'undefined' && res !== null) {
              if (res.reason !== 'timeoutReached' && res.reason !== 'destNotFound') {
                resolve(res.UUCSeq);
              } else {
                if (res.reason === 'timerReached') {
                  errorCode = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT;
                } else if (res.reason === 'destNotFound') {
                  errorCode = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND;
                }

                reject(errorCode);
              }
            } else {
              reject(errorCode);
            }
          }, options);
        }
      });
    }
    /**
     * Joins a given group chat.
     * @param {string} groupChatId
     * @param {object} options
     * @return {Promise}
     */

  }, {
    key: "joinGroupChat",
    value: function joinGroupChat(groupChatId) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        if (_this3.IMClient === null) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'joinGroupChat() - cannot join group chat'));
        }

        _this3.IMClient.joinGroupChat(groupChatId);

        resolve();
      });
    }
    /**
     * Leaves a given group chat.
     * @param {string} groupChatId
     * @param {object} options
     * @return {Promise}
     */

  }, {
    key: "leaveGroupChat",
    value: function leaveGroupChat(groupChatId) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        if (_this4.IMClient === null) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'leaveGroupChat() - cannot leave group chat'));
        }

        _this4.IMClient.leaveGroupChat(groupChatId);

        resolve();
      });
    }
    /**
     * Sends a groupChatMessage.
     * @method sendMessageToGroupChat
     * @param {string} groupChatId - room identification name.
     * @param {string} data - message to send.
     * @parma {object} options
     * @parma {object} options.metadata - Optional metadata.
     * @return {Promise<number>} message unique identification number.
     */

  }, {
    key: "sendMessageToGroupChat",
    value: function sendMessageToGroupChat(groupChatId, data) {
      var _this5 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return new Promise(function (resolve, reject) {
        if (_this5.IMClient === null) {
          reject(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_APIRTC_INITIALISATION_FAILED);
        } else {
          var opts = {};

          if (_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.isTypeof(options, 'metadata', 'object')) {
            opts.metadata = options.metadata;
          }

          _this5.IMClient.sendMessageToGroupChat(groupChatId, data, function (res) {
            if (res !== null && _typeof(res) === 'object') {
              if (res.reason === 'ack') {
                return resolve(res.UUCSeq);
              } else if (res.reason === 'timeoutReached') {
                return reject(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT);
              } else if (res.reason === 'destNotFound') {
                return reject(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND);
              } else {
                return reject(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER);
              }
            } else {
              return reject(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER);
            }
          }, opts);
        }
      });
    }
    /**
     * Remove existing listener to apiRTC event
     */

  }, {
    key: "removeEventListener",
    value: function removeEventListener(eventType, listener) {
      if (listener !== null && typeof listener !== 'undefined') {
        if (APIRTC_EVENTS.indexOf(eventType) > -1) {
          this.eventEmitter.off(eventType, listener);
        } else {
          logger.error('No such apiRTC event ' + eventType);
        }
      }
    }
    /**
     * Returns whether apiRTC is initialized
     *
     *  @returns {Boolean} apiRTC initialization state
     */

  }, {
    key: "isInitialized",
    value: function isInitialized() {
      return apiRTCInitialized;
    }
    /**
     * Unsubscribes to an apiRTC presence group and updates contact catalog to remove users from unsubscribed groups
     *
     *  @param {String} group Presence group to leave and to unsubscribe to
     *  @returns {Void}
     */

  }, {
    key: "unsubscribeToPresenceGroup",
    value: function unsubscribeToPresenceGroup(group) {
      if (this.apiRTCSession !== null) {
        this.apiRTCSession.unsubscribePresenceGroup([group]);
        instance.eventEmitter.emit('groupUnsubscribed', group);
      } else {
        logger.error('apiRTC session is not initialized');
      }
    }
    /**
     * Alias for both joining and subscribing to an apiRTC presence group
     *
     *  @param {String} group Presence group to join and to subscribe to
     *  @returns {Void}
     */

  }, {
    key: "joinAndSubscribeToPresenceGroup",
    value: function joinAndSubscribeToPresenceGroup(group) {
      if (this.apiRTCSession !== null) {
        this.apiRTCSession.joinPresenceGroup([group]);
        this.apiRTCSession.subscribePresenceGroup([group]);
      } else {
        logger.error('apiRTC session is not initialized');
      }
    }
    /**
     * Alias for both leaving and unsubscribing to an apiRTC presence group
     *
     *  @param {String} group Presence group to leave and to unsubscribe to
     *  @returns {Void}
     */

  }, {
    key: "leaveAndUnsubscribeToPresenceGroup",
    value: function leaveAndUnsubscribeToPresenceGroup(group) {
      if (this.apiRTCSession !== null) {
        this.apiRTCSession.leavePresenceGroup([group]);
        this.unsubscribeToPresenceGroup(group);
      } else {
        logger.error('apiRTC session is not initialized');
      }
    }
    /**
     * Subscribes to a Cloud Event.
     * @method subscribeToCloudEvent
     * @param {string} topic
     * @param {object} headers
     */

  }, {
    key: "subscribeToCloudEvent",
    value: function subscribeToCloudEvent(topic, headers) {
      if (!this.apiRTCSession) {
        logger.error('apiRTC session is not initialized');
        return;
      }

      this.apiRTCSession.subscribeToCloudEvent(topic, headers);
    }
    /**
     * Cancels the subscription to a Cloud Event.
     * @method unsubscribeToCloudEvent
     * @param {string} topic
     * @param {object} headers
     */

  }, {
    key: "unsubscribeToCloudEvent",
    value: function unsubscribeToCloudEvent(topic, headers) {
      if (!this.apiRTCSession) {
        logger.error('apiRTC session is not initialized');
        return;
      }

      this.apiRTCSession.unsubscribeToCloudEvent(topic, headers);
    }
    /**
     * Alias for disconnecting apiRTC
     * @param {object} opts
     * @param {boolean} opts.invalidateApiCCId - Whether the current apiCCId shall not be kept.
     * @return {Void}
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      apiRTC.disconnect(opts);
      apiRTCInitialized = false;
      this.apiRTCSession = null;
      this.webRTCClient = null;
      this.dataClient = null;
      this.IMClient = null;

      if (eventsInitialized) {
        var _iterator = _createForOfIteratorHelper(APIRTC_EVENTS),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var eventType = _step.value;
            unlinkApiRTCEvent(eventType);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        eventsInitialized = false;
      }
    }
    /**
     * A promise to initialize ApiRTC
     *
     *  @param {Object} options ApiRTC init parameters
     *  @returns {Promise<string>} apiCCId in promise
     */

  }, {
    key: "initializeApiRTC",
    value: function initializeApiRTC(options) {
      logger.info('initializeApiRTC()');
      return new Promise(function (resolve, reject) {
        if (typeof options === 'undefined' || typeof options.apiKey === 'undefined') {
          reject('Invalid apiRTC initialization params');
        } else {
          var onChannelEventDuringInit = function onChannelEventDuringInit(e) {
            logger.debug('onChannelEventDuringInit()', e.detail);

            switch (e.detail.channelEvent) {
              case 'onChannelError':
                reject('Channel Error : ' + e.detail.event);
                break;

              case 'onChannelConnectError':
                reject('Channel Connect Error : ' + e.detail.event);
                break;

              case 'onChannelOpened':
                logger.debug('onChannelOpened'); //Waiting onReady to be called

                break;

              default:
                logger.debug('Unhandle case in onChannelEventDuringInit :', e.detail.channelEvent);
            }
          };

          apiRTC.addEventListener('channelEvent', onChannelEventDuringInit); //redefined callback to allow promise structure

          options.onReady = function () {
            apiRTCInitialized = true;
            instance.webRTCClient = apiRTC.session.createWebRTCClient({});
            instance.webRTCClient.setMCUConnector(options.hasOwnProperty('mcu') ? options.mcu : _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DEFAULT_MCU);

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.isPropertyTypeof(options, 'turnServerAddress', 'string')) {
              instance.webRTCClient.setClientTurnServer(options.turnServerAddress);
            }

            instance.webRTCClient.setUserAcceptOnIncomingCallBeforeGetUserMedia(true); //Disable auto acceptation for calls, it should be handled by the client through invitations

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.isPropertyTypeof(options, 'userAcceptOnIncomingDataCall', 'boolean')) {
              instance.webRTCClient.setUserAcceptOnIncomingDataCall(options.userAcceptOnIncomingDataCall); //Setting auto acceptation for calls, depending of configuration
            } else {
              instance.webRTCClient.setUserAcceptOnIncomingDataCall(true); //Disable auto acceptation for calls, it should be handled by the client through invitations
            }

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.isPropertyTypeof(options, 'userAcceptOnIncomingScreenSharingCall', 'boolean')) {
              instance.webRTCClient.setUserAcceptOnIncomingScreenSharingCall(options.userAcceptOnIncomingScreenSharingCall); //Setting auto acceptation for calls, depending of configuration
            } else {
              instance.webRTCClient.setUserAcceptOnIncomingScreenSharingCall(false); //Enable auto acceptation for screenSharing calls
            }

            instance.dataClient = apiRTC.session.createDataClient();
            instance.IMClient = apiRTC.session.createIMClient();
            instance.pointerSharingClient = apiRTC.session.createPointerSharingClient();
            instance.webRTCClient.setAllowMultipleCalls(true);
            instance.apiRTCSession = apiRTC.session; //link events to event emitter only for first init

            if (!eventsInitialized) {
              var _iterator2 = _createForOfIteratorHelper(APIRTC_EVENTS),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var eventType = _step2.value;
                  linkApiRTCEvent(eventType);
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              eventsInitialized = true;
            }

            apiRTC.removeEventListener('channelEvent', onChannelEventDuringInit);
            resolve(apiRTC.session.apiCCId);
          }; //unset apirtc components


          apiRTCInitialized = false;
          instance.apiRTCSession = null;
          instance.webRTCClient = null;
          instance.dataClient = null;
          instance.IMClient = null;
          apiRTC.init(options);
        }
      });
    }
  }, {
    key: "createWhiteBoard",
    value: function createWhiteBoard() {
      logger.debug('createWhiteBoard()'); //instance.whiteBoardClient = apiRTC.createWhiteBoard(null, "#000000", null, 60000); //Default cursor is black : "#000000"

      instance.whiteBoardClient = apiRTC.createWhiteBoard(null, "invisible", null, 60000); //Default cursor is invisible
    }
    /**
     * Alias for getMediaDevices apiRTC
     *
     *  @returns {Void}
     */

  }, {
    key: "getMediaDevices",
    value: function getMediaDevices() {
      logger.debug('ApiRTCManager::getMediaDevices()');
      return new Promise(function (resolve, reject) {
        apiRTC.getMediaDevices().then(function (sources) {
          logger.debug('ApiRTCManager::getMediaDevices(), sources :', sources);
          resolve(sources);
        })["catch"](function (err) {
          var errorMsg = 'getMediaDevices() - error';
          logger.error(errorMsg, err);
          reject(new Error(errorMsg));
        });
      });
    }
    /**
     * Alias for getUserMedia apiRTC
     *
     *  @returns {Void}
     */

  }, {
    key: "getUserMedia",
    value: function getUserMedia(gumConfiguration) {
      return new Promise(function (resolve, reject) {
        apiRTC.getUserMedia(gumConfiguration).then(function (mediaStream) {
          logger.debug('ApiRTCManager::getUserMedia() success');
          resolve(mediaStream);
        })["catch"](function (err) {
          logger.error('ApiRTCManager::getUserMedia() - Could not get user media :', err);
          reject(new Error('ApiRTCManager::getUserMedia() - Could not get user media :' + err));
        });
      });
    }
    /**
     * Alias for setAudioSourceIdInConstraint apiRTC
     *
     *  @returns {constraints}
     */

  }, {
    key: "setAudioSourceIdInConstraint",
    value: function setAudioSourceIdInConstraint(audioSourceId, constraints) {
      return apiRTC.setAudioSourceIdInConstraint(audioSourceId, constraints);
    }
    /**
     * Alias for setVideoSourceIdInConstraint apiRTC
     *
     *  @returns {constraints}
     */

  }, {
    key: "setVideoSourceIdInConstraint",
    value: function setVideoSourceIdInConstraint(audioSourceId, constraints) {
      return apiRTC.setVideoSourceIdInConstraint(audioSourceId, constraints);
    }
    /**
     * Alias for attachMediaStream apiRTC
     *
     *  @returns {Void}
     */

  }, {
    key: "attachMediaStream",
    value: function attachMediaStream(videoElt, stream) {
      apiRTC.attachMediaStream(videoElt, stream);
    }
    /**
     * Alias for detachMediaStream apiRTC
     * 
     * @return {void}
     */

  }, {
    key: "detachMediaStream",
    value: function detachMediaStream(videoElt, stream) {
      apiRTC.detachMediaStream(videoElt, stream);
    }
    /**
     * Alias for addStreamInDiv apiRTC
     *
     *  @returns {Void}
     */

  }, {
    key: "addStreamInDiv",
    value: function addStreamInDiv(stream, streamType, divId, mediaEltId, style, muted, options) {
      apiRTC.addStreamInDiv(stream, streamType, divId, mediaEltId, style, muted, options);
    }
    /**
     * Alias for removeElementFromDiv apiRTC
     *
     *  @returns {Void}
     */

  }, {
    key: "removeElementFromDiv",
    value: function removeElementFromDiv(divId, eltId) {
      logger.debug('removeElementFromDiv');
      apiRTC.removeElementFromDiv(divId, eltId);
    }
    /*
     * A promise for getting a screensharing input id from ApiRTC's Chrome extension
     *
     *  @returns {Promise<string>} screensharingInputId in promise
     */

    /*
        requestScreensharingInputId() {
            logger.info('requestScreensharingInputId()');
    
            return new Promise((resolve, reject) => {
    
                this.checkScreensharingExtensionInstallation()
                    .then(() => {
                        let extensionMessageListener =  function(e) {
                            if (e.data.callNumber === 'apiRTC2' && (typeof e.data.desktopId !== 'undefined')) {
                                window.removeEventListener('message', extensionMessageListener);
                                if (e.data.desktopId !== 'mediaError') {
                                    resolve(e.data.desktopId);
                                } else {
                                    let errorMsg = 'requestScreensharingInputId() - Could not get a screensharing input id, capture was either refused by user or the application needs to be served over https';
                                    logger.error(errorMsg);
                                    reject(new Error(errorMsg));
                                }
                            }
                        };
                        window.addEventListener('message', extensionMessageListener);
                        window.postMessage({
                            command: 'getDesktopId',
                            callNumber: 'apiRTC2',
                            remoteId: 0
                        }, '*');
                    })
                    .catch((err) => {
                        let errorMsg = 'requestScreensharingInputId() - Could not access to screensharing extension';
                        logger.error(errorMsg, err);
                        reject(new Error(errorMsg));
                    });
            });
        }
    */

  }, {
    key: "getClientId",
    value: function getClientId() {
      if (this.apiRTCSession !== null && this.apiRTCSession.apiCCWebRTCClient !== null) {
        return this.apiRTCSession.apiCCWebRTCClient.webRTCClient.clientId;
      }

      return null;
    }
  }, {
    key: "getActiveApiKey",
    value: function getActiveApiKey() {
      return typeof apiRTC.session !== 'undefined' && apiRTC.session !== null ? apiRTC.session.apiKey : null;
    }
    /**
     * A promise for installing ApiRTC's screensharing chrome extension
     *
     *  @returns {Promise<Void>}
     */

    /*
        installScreensharingExtension() {
            logger.info('installScreensharingExtension()');
            return new Promise((resolve, reject) => {
                if (chrome) {
                    chrome.webstore.install('https://chrome.google.com/webstore/detail/' + SCREENSHARING_EXTENSION_ID.chrome,
                        () => { //success callback
                            resolve();
                        },
                        (err) => { //failure callback
                            let errorMsg = 'installScreensharingExtension() - Screensharing extension was not installed';
                            logger.error(errorMsg, err);
                            reject(new Error(errorMsg));
                        });
                } else {
                    let errorMsg = 'installScreensharingExtension() - Screensharing extension is currently only available on Google Chrome';
                    logger.error(errorMsg);
                    reject(new Error(errorMsg));
                }
            });
        }
    */

    /**
     * A promise for checking if  ApiRTC's screensharing chrome extension is installed
     *
     *  @returns {Promise<Void>}
     */

    /*
        checkScreensharingExtensionInstallation() {
            logger.info('checkScreensharingExtensionInstallation()');
            return new Promise((resolve, reject) => {
                if (screensharingActivated) {
                    resolve();
                } else {
                    let extensionMessageListener = null;
                    let extensionCheckTimeOut = setTimeout(() => {
                        window.removeEventListener('message', extensionMessageListener);
                        this.installScreensharingExtension()
                            .then(() => {
                                screensharingActivated = true;
                                resolve();
                            })
                            .catch((err) => {
                                let errorMsg = 'checkScreensharingExtensionInstallation() - Screensharing extension is not installed';
                                logger.error(errorMsg, err);
                                reject(new Error(errorMsg));
                            });
                    }, SCREENSHARING_EXTENSION_CHECK_TIMEOUT);
    
                    extensionMessageListener = function(e) {
                        if (e.data === 'apiRTC-DeskstopCapture-loaded') {
                            window.removeEventListener('message', extensionMessageListener);
                            screensharingActivated = true;
                            clearTimeout(extensionCheckTimeOut);
                            resolve();
                        }
                    };
                    window.addEventListener('message', extensionMessageListener);
                    window.postMessage('apiRTC-extension', '*');
                }
            });
        }
    */

  }], [{
    key: "get",
    value: function get() {
      if (instance === null) {
        instance = new ApiRTCManager();
      }

      return instance;
    }
  }]);

  return ApiRTCManager;
}();



/***/ }),

/***/ "./src/private/CallCatalog.js":
/*!************************************!*\
  !*** ./src/private/CallCatalog.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CallCatalog": () => (/* binding */ CallCatalog)
/* harmony export */ });
/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Logger */ "./src/private/Logger.js");
/* harmony import */ var _public_Call__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../public/Call */ "./src/public/Call.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }



var logger = _Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('ConversationCatalog');
var instance = null;
/**
 * CallCatalog, Singleton
 */

var CallCatalog = /*#__PURE__*/function () {
  function CallCatalog() {
    _classCallCheck(this, CallCatalog);

    if (instance !== null) {
      throw 'Cannot construct singleton CallCatalog';
    }

    this.callList = new Map();
    instance = this;
  } //
  //* Gets a contact using it's id or creates a new one otherwise
  // *
  //  * @param {String} id Contact id to fetch
  // * @returns {Contact}
  // */

  /*
      getOrCreateContact(id) {
          let contact = null;
          if (typeof id !== 'undefined' && id !== null) {
              if (this.contactList.has(id.toString())) {
                  contact = this.contactList.get(id.toString());
              } else {//create contact if it does not exist
                  contact = new Contact(id.toString(), {});
                  this.contactList.set(id.toString(), contact);
              }
          }
          return contact;
      }
  */


  _createClass(CallCatalog, [{
    key: "getOrCreateCall",
    value: function getOrCreateCall(id, contact, options) {
      var call = null;

      if (typeof id !== 'undefined' && id !== null) {
        if (this.callList.has(id.toString())) {
          call = this.callList.get(id.toString());
        } else {
          //create contact if it does not exist
          call = new _public_Call__WEBPACK_IMPORTED_MODULE_1__.Call(id.toString(), contact, options);
          this.callList.set(id.toString(), call);
        }
      }

      return call;
    }
  }, {
    key: "getCall",
    value: function getCall(id, contact) {
      var call = null;

      if (typeof id !== 'undefined' && id !== null) {
        if (this.callList.has(id.toString())) {
          call = this.callList.get(id.toString());
        } else {
          return null;
        }
      } else if (contact) {
        var _iterator = _createForOfIteratorHelper(this.callList.values()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var c = _step.value;
            var ct = c.getContact();

            if (ct && ct.getId() === contact.getId()) {
              call = c;
              break;
            }
          } // for

        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return call;
    }
  }, {
    key: "removeCallFromList",
    value: function removeCallFromList(callId) {
      //remove call in list
      logger.log("removeCallFromList : av instance.callList :", instance.callList);

      if (instance.callList.has(callId)) {
        instance.callList["delete"](callId);
      }

      logger.log("removeCallFromList : ap instance.callList :", instance.callList);
    }
  }, {
    key: "getCalls",
    value: function getCalls() {
      return this.callList;
    }
  }], [{
    key: "get",
    value: function get() {
      if (instance === null) {
        instance = new CallCatalog();
      }

      return instance;
    }
  }]);

  return CallCatalog;
}();



/***/ }),

/***/ "./src/private/ContactCatalog.js":
/*!***************************************!*\
  !*** ./src/private/ContactCatalog.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContactCatalog": () => (/* binding */ ContactCatalog)
/* harmony export */ });
/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/EventEmitter */ "./src/utils/EventEmitter.js");
/* harmony import */ var _public_Contact__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../public/Contact */ "./src/public/Contact.js");
/* harmony import */ var _public_UserData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../public/UserData */ "./src/public/UserData.js");
/* harmony import */ var _ApiRTCManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ApiRTCManager */ "./src/private/ApiRTCManager.js");
/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Logger */ "./src/private/Logger.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }






var logger = _Logger__WEBPACK_IMPORTED_MODULE_4__.Logger.get('ContactCatalog');
var instance = null; // Keep track of user disconnecting to see if they reconnect within a time interval

var userDisconnectionTimeouts = {}; // Avoid sending too much contact catalog updates through this buffer

var updatedContactsBuffer = {
  leftGroup: {},
  joinedGroup: {},
  userDataChanged: []
};
/**
 * ContactCatalog, Singleton
 */

var ContactCatalog = /*#__PURE__*/function () {
  function ContactCatalog() {
    _classCallCheck(this, ContactCatalog);

    if (instance !== null) {
      throw 'Cannot construct singleton ContactCatalog';
    }

    this.contactList = new Map();
    this.eventEmitter = new _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    instance = this;
    var apiRTCManager = _ApiRTCManager__WEBPACK_IMPORTED_MODULE_3__.ApiRTCManager.get();
    apiRTCManager.onEvent('connectedUsersListUpdate', function (e) {
      var selfId = apiRTC.session.apiCCId.toString();
      var user = {};

      switch (e.detail.updateReason) {
        case "newConnectionState":
          if (e.detail.status === 'online') {
            logger.debug('new connection');

            var _iterator = _createForOfIteratorHelper(e.detail.usersList),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var userId = _step.value;
                user = {
                  userId: userId,
                  group: e.detail.group
                };

                if (user.userId.toString() !== selfId) {
                  updateContactListOnUserConnection(user);
                }
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          } else {
            logger.debug('new disconnection');

            var _iterator2 = _createForOfIteratorHelper(e.detail.usersList),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _userId = _step2.value;
                user = {
                  userId: _userId,
                  group: e.detail.group
                };

                if (typeof userDisconnectionTimeouts[user.group] === 'undefined') {
                  userDisconnectionTimeouts[user.group] = {};
                }

                if (user.userId.toString() !== selfId) {
                  // Disconnect this contact if it does not reconnect after a delay
                  userDisconnectionTimeouts[user.group][user.userId.toString()] = setTimeout(disconnectContact(user), apiRTCManager.contactDisconnectionDelay);
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }

          break;

        case "userDataUpdate":
          logger.debug('userDataUpdate');

          var _iterator3 = _createForOfIteratorHelper(e.detail.usersList),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _userId2 = _step3.value;
              user = {
                userId: _userId2,
                group: e.detail.group
              };

              if (user.userId.toString() !== selfId) {
                updateContactListOnUserDataUpdate(user);
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          break;

        case "callState":
          logger.debug('callState change for user'); //Check if callState change need to be managed

          var _iterator4 = _createForOfIteratorHelper(e.detail.usersList),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _userId3 = _step4.value;
              user = {
                userId: _userId3,
                group: e.detail.group
              };

              if (user.userId.toString() !== selfId) {
                updateContactListOnUserDataUpdate(user);
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          break;

        default:
          logger.warn('default case for updateReason value');
          break;
      }
    }).onEvent('groupUnsubscribed', function (group) {
      //removes group from known contacts
      var contacts = instance.getContacts(group);

      var _iterator5 = _createForOfIteratorHelper(contacts.keys()),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var key = _step5.value;
          contacts.get(key).removeFromGroup(group);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    });
  }

  _createClass(ContactCatalog, [{
    key: "onUpdate",
    value:
    /**
     * Adds a listener called when the contact catalog is updated
     */
    function onUpdate(listener) {
      this.eventEmitter.on('update', listener);
    }
    /**
     * Removes update listener
     */

  }, {
    key: "removeUpdateListener",
    value: function removeUpdateListener(listener) {
      this.eventEmitter.off('update', listener);
    }
    /**
     * Returns contact from id if known, otherwise returns null
     *
     *  @param {String} id
     *  @returns {Contact} contact
     */

  }, {
    key: "getContact",
    value: function getContact(id) {
      if (typeof id !== 'undefined' && id !== null && this.contactList.has(id.toString())) {
        return this.contactList.get(id.toString());
      } else {
        return null;
      }
    }
    /**
     * Gets a contact using it's id or creates a new one otherwise
     *
     * @param {String} id Contact id to fetch
     * @returns {Contact}
     */

  }, {
    key: "getOrCreateContact",
    value: function getOrCreateContact(id) {
      var contact = null;

      if (typeof id !== 'undefined' && id !== null) {
        if (this.contactList.has(id.toString())) {
          contact = this.contactList.get(id.toString());
        } else {
          //create contact if it does not exist
          try {
            contact = new _public_Contact__WEBPACK_IMPORTED_MODULE_1__.Contact(id.toString(), {});
            this.contactList.set(id.toString(), contact);
          } catch (e) {
            logger.debug('Contact not added : ' + e);
          }
        }
      }

      return contact;
    }
    /**
     * Returns contact list
     *
     *  @param {String} group If defined, restrict list to user inside defined group
     *  @returns {Map} contact list
     */

  }, {
    key: "getContacts",
    value: function getContacts(group) {
      if (typeof group === 'undefined' || group === null) {
        //return all contacts
        return this.contactList;
      } else {
        //returns contacts from specified group
        var res = new Map();

        var _iterator6 = _createForOfIteratorHelper(this.contactList.keys()),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var key = _step6.value;

            if (this.contactList.get(key).inGroup(group)) {
              res.set(key, this.contactList.get(key));
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        return res;
      }
    }
    /**
     * Returns contact list
     *
     *  @param {String} group If defined, restrict list to user inside defined group
     *  @returns {Map} contact list
     */

  }, {
    key: "getOnlineContacts",
    value: function getOnlineContacts(group) {
      var res = new Map();

      if (typeof group === 'undefined' || group === null) {
        var _iterator7 = _createForOfIteratorHelper(this.contactList.keys()),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var key = _step7.value;

            if (this.contactList.get(key).isOnline()) {
              //return all contacts
              res.set(key, this.contactList.get(key));
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      } else {
        //returns contacts from specified group
        var _iterator8 = _createForOfIteratorHelper(this.contactList.keys()),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var _key = _step8.value;

            if (this.contactList.get(_key).inGroup(group) && this.contactList.get(_key).isOnline()) {
              //return all contacts and in group
              res.set(_key, this.contactList.get(_key));
            }
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
      }

      return res;
    }
  }], [{
    key: "get",
    value: function get() {
      if (instance === null) {
        instance = new ContactCatalog();
      }

      return instance;
    }
  }]);

  return ContactCatalog;
}();
/**
 *  Function wrapper to disconnect a contact
 *
 *  @param {any} user
 *  @returns {() => void}
 */


function disconnectContact(user) {
  return function () {
    var userId = user.userId.toString();
    logger.info('Contact disconnected ' + userId + ' from ' + user.group);

    if (instance.contactList.has(userId)) {
      // Remove group reference in contact
      var contact = instance.contactList.get(userId);

      if (contact === undefined) {
        logger.debug('Contact not exist with userId :', userId);
        return;
      }

      contact.removeFromGroup(user.group);
      updateContactListOnUserDisconnect(user.group, contact); // Clear timeout reference if it still exists

      if (typeof userDisconnectionTimeouts[user.group] !== 'undefined' && typeof userDisconnectionTimeouts[user.group][userId] !== 'undefined') {
        delete userDisconnectionTimeouts[user.group][userId];
      }
    }
  };
}

function updateContactListOnUserDisconnect(group, contact) {
  logger.debug('updateContactListOnUserDisconnect()'); // Add contact to updated contacts buffer

  if (typeof updatedContactsBuffer.leftGroup[group] === 'undefined') {
    updatedContactsBuffer.leftGroup[group] = [];
  }

  updatedContactsBuffer.leftGroup[group].push(contact);
  emitUpdateContactEvent();
}

function emitUpdateContactEvent() {
  //only emit update event if at least one contact has been updated
  if (Object.keys(updatedContactsBuffer.leftGroup).length !== 0 || Object.keys(updatedContactsBuffer.joinedGroup).length !== 0 || updatedContactsBuffer.userDataChanged.length !== 0) {
    instance.eventEmitter.emit('update', updatedContactsBuffer); //reset buffer

    updatedContactsBuffer = {
      leftGroup: {},
      joinedGroup: {},
      userDataChanged: []
    };
  }
}

function updateContactListOnUserConnection(user) {
  logger.debug('updateContactListOnUserConnection()');
  var userId = user.userId.toString();
  var contact = null;
  var userData = apiRTC.session.getConnectedUserInfo(userId, 'userData');
  logger.debug("userData :", userData);

  try {
    user.userData = JSON.parse(userData);
  } catch (e) {
    logger.warn('userData parse error : ' + e);
  }

  if (!instance.contactList.has(userId)) {
    //create new Contact
    try {
      contact = new _public_Contact__WEBPACK_IMPORTED_MODULE_1__.Contact(userId, user.userData);
      instance.contactList.set(userId, contact);
    } catch (e) {
      logger.debug('Contact not added : ' + e);
    }

    contact = instance.contactList.get(userId);
  } else {
    contact = instance.contactList.get(user.userId); // User data changed

    if (!_public_UserData__WEBPACK_IMPORTED_MODULE_2__.UserData.equals(contact.userData, user.userData)) {
      contact.userData = new _public_UserData__WEBPACK_IMPORTED_MODULE_2__.UserData(user.userData);
      updatedContactsBuffer.userDataChanged.push(contact);
    }
  }

  if (contact === undefined) {
    logger.debug('Contact not exist with userId :', userId);
    return;
  } // User reconnected in group before disconnection timeout expired
  // Clear timeout reference if it still exists


  if (typeof userDisconnectionTimeouts[user.group] !== 'undefined' && typeof userDisconnectionTimeouts[user.group][userId] !== 'undefined') {
    clearTimeout(userDisconnectionTimeouts[user.group][userId]);
    delete userDisconnectionTimeouts[user.group][userId];
  } // User joined group


  if (!contact.inGroup(user.group)) {
    contact.addToGroup(user.group);

    if (typeof updatedContactsBuffer.joinedGroup[user.group] === 'undefined') {
      updatedContactsBuffer.joinedGroup[user.group] = [];
    }

    updatedContactsBuffer.joinedGroup[user.group].push(contact);
  }

  emitUpdateContactEvent();
}

function updateContactListOnUserDataUpdate(user) {
  logger.debug('updateContactListOnUserDataUpdate()');
  var userId = user.userId.toString();
  var contact = instance.contactList.get(user.userId);

  if (contact === undefined) {
    logger.debug('Contact not exist with userId :', userId);
    return;
  }

  var userData = apiRTC.session.getConnectedUserInfo(userId, 'userData');
  logger.debug("userData :", userData);

  try {
    user.userData = JSON.parse(userData);
  } catch (e) {
    logger.warn('userData parse error : ' + e);
  } // User data changed


  if (!_public_UserData__WEBPACK_IMPORTED_MODULE_2__.UserData.equals(contact.userData, user.userData)) {
    contact.userData = new _public_UserData__WEBPACK_IMPORTED_MODULE_2__.UserData(user.userData);
    updatedContactsBuffer.userDataChanged.push(contact);
  }

  emitUpdateContactEvent();
}



/***/ }),

/***/ "./src/private/ConversationCatalog.js":
/*!********************************************!*\
  !*** ./src/private/ConversationCatalog.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConversationCatalog": () => (/* binding */ ConversationCatalog)
/* harmony export */ });
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _public_Conversation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../public/Conversation */ "./src/public/Conversation.js");
/* harmony import */ var _public_Conference__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../public/Conference */ "./src/public/Conference.js");
/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Logger */ "./src/private/Logger.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }





var logger = _Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.get('ConversationCatalog');
var instance = null;
/**
 * ConversationCatalog, Singleton
 */

var ConversationCatalog = /*#__PURE__*/function () {
  function ConversationCatalog() {
    _classCallCheck(this, ConversationCatalog);

    if (instance !== null) {
      throw 'Cannot construct singleton ConversationCatalog';
    }

    this.conversationList = new Map();
    this.conferenceList = new Map();
    instance = this;
  }

  _createClass(ConversationCatalog, [{
    key: "deleteConversation",
    value:
    /**
     * Removes a conversation represented by a given name from this one.
     *
     * @param {string} roomname - Conversation name.
     *
     * @return {boolean} True if given conversation existed and has been removed.
     */
    function deleteConversation(roomname) {
      if (_utils_Misc__WEBPACK_IMPORTED_MODULE_0__.Misc.isTypeof(roomname, 'string') && roomname.length > 0) {
        return this.conversationList["delete"](roomname);
      }

      return false;
    }
    /**
     * Removes a conference represented by a given name from this one.
     *
     * @param {string} roomname - Conference name.
     *
     * @return {boolean} True if given conference existed and has been removed.
     */

  }, {
    key: "deleteConference",
    value: function deleteConference(roomname) {
      if (_utils_Misc__WEBPACK_IMPORTED_MODULE_0__.Misc.isTypeof(roomname, 'string') && roomname.length > 0) {
        return this.conferenceList["delete"](roomname);
      }

      return false;
    }
    /**
     * Gets a conversation using it's roomname or creates a new one otherwise
     *
     * @param {string} roomname roomname to fetch
     * @param {Object} options
     * @param {boolean} options.active
     * @param {boolean} options.meshModeEnabled - Whether the mesh mode is enabled.
     * @param {boolean} options.meshOnlyEnabled - Whether the mesh mode is the only mode allowed, i.e. no transition to another mode will occur.
     * @return {Conversation}
     */

  }, {
    key: "getOrCreateConversation",
    value: function getOrCreateConversation(roomname) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var conversation = null;

      if (typeof roomname !== 'undefined' && roomname !== null && roomname !== '') {
        if (this.conversationList.has(roomname.toString())) {
          conversation = this.conversationList.get(roomname.toString());
        } else {
          //create conversation if it does not exist
          conversation = new _public_Conversation__WEBPACK_IMPORTED_MODULE_1__.Conversation(roomname.toString(), options);
          this.conversationList.set(roomname.toString(), conversation);
        }
      } else {
        //create a conversation with a random name
        conversation = new _public_Conversation__WEBPACK_IMPORTED_MODULE_1__.Conversation(null, options);
        this.conversationList.set(conversation.getName(), conversation);
      }

      return conversation;
    }
    /**
     * Gets a conference using it's roomname or creates a new one otherwise
     *
     * @param {String} roomname roomname to fetch
     * @param {Object} options
     * @param {boolean} options.active
     * @param {boolean} options.meshModeEnabled - Whether the mesh mode is enabled.
     * @param {boolean} options.meshOnlyEnabled - Whether the mesh mode is the only mode allowed, i.e. no transition to another mode will occur.
     * @return {Conference}
     */

  }, {
    key: "getOrCreateConference",
    value: function getOrCreateConference(roomname) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var conference = null;

      if (typeof roomname !== 'undefined' && roomname !== null && roomname !== '') {
        if (this.conferenceList.has(roomname.toString())) {
          conference = this.conferenceList.get(roomname.toString());
        } else {
          //create conference if it does not exist
          conference = new _public_Conference__WEBPACK_IMPORTED_MODULE_2__.Conference(roomname.toString(), options);
          this.conferenceList.set(roomname.toString(), conference);
        }
      } else {
        //create a conference with a random name
        conference = new _public_Conference__WEBPACK_IMPORTED_MODULE_2__.Conference(null, options);
        this.conferenceList.set(conference.getName(), conference);
      }

      return conference;
    }
    /**
     * Returns conversation list
     *
     *  @returns {Map} conversation list
     */

  }, {
    key: "getConversations",
    value: function getConversations() {
      return this.conversationList;
    }
    /**
     * Returns conference list
     *
     *  @returns {Map} conference list
     */

  }, {
    key: "getConferences",
    value: function getConferences() {
      return this.conferenceList;
    }
    /**
     * Returns whether conversation is a conference from a given technical name.
     *
     * @param {string} technicalName - conversation/conference technical name.
     *
     * @returns {boolean}
     */

  }, {
    key: "isConference",
    value: function isConference(technicalName) {
      return breakDownTechnicalName(technicalName).hasOwnProperty('apiKey');
    }
  }, {
    key: "getNameFromTechnicalName",
    value: function getNameFromTechnicalName(technicalName) {
      return breakDownTechnicalName(technicalName).name;
    }
  }], [{
    key: "get",
    value: function get() {
      if (instance === null) {
        instance = new ConversationCatalog();
      }

      return instance;
    }
  }]);

  return ConversationCatalog;
}();
/* Breaks down conversation/conference technical name.
 * @param {string} technicalName - conversation/conference technical name.
 * @return {object} components.
 * @return {string} .apiKey - the apiKey (may be missing).
 * @return {string} .name - the conversation/conference name.
 */


function breakDownTechnicalName(technicalName) {
  var res = technicalName.match(/^([^:]+)[:]([^:]+)$/);

  if (res === null || res.length < 3) {
    return {
      name: technicalName
    };
  }

  return {
    apiKey: res[1],
    name: res[2]
  };
}



/***/ }),

/***/ "./src/private/Logger.js":
/*!*******************************!*\
  !*** ./src/private/Logger.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Logger": () => (/* binding */ Logger)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/* globals apiCC*/

var loggerInstances = new Map();
var logLevel = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_WARN; //logMessageFiltering is used to filter log messages before sending to cloud

var logMessageFiltering = function logMessageFiltering(args) {
  var i,
      candidate = null,
      candidateJSON = null;

  for (i = 0; i < args.length; i++) {
    if (typeof args[i] === 'string') {
      if (args[i].indexOf('"type":"invite"') !== -1) {
        //Invite message
        if (args[i].indexOf("candidate") === -1) {
          //console.error('invite without candidate');
          if (args[i].indexOf("S->C:") === -1) {
            //console.error('invite C->S:');
            args[i] = 'invite C->S: without candidate';
          } else {
            //console.error('invite S->C:');
            args[i] = 'invite S->C: without candidate';
          }
        } else {
          //console.error('invite with candidate');
          if (args[i].indexOf("S->C:") === -1) {
            //console.error('invite C->S:');
            args[i] = 'invite C->S: with candidate';
          } else {
            //console.error('invite S->C:');
            args[i] = 'invite S->C: with candidate';
          }
        }
      } else if (args[i].indexOf('"type":"200OK"') !== -1) {
        //console.error('200OK');
        if (args[i].indexOf("candidate") === -1) {
          //console.error('200OK without candidate');
          if (args[i].indexOf("S->C:") === -1) {
            //console.error('200OK C->S:');
            args[i] = '200OK C->S: without candidate';
          } else {
            //console.error('200OK S->C:');
            args[i] = '200OK S->C: without candidate';
          }
        } else {
          //console.error('200OK with candidate');
          if (args[i].indexOf("S->C:") === -1) {
            //console.error('200OK C->S:');
            args[i] = '200OK C->S: with candidate';
          } else {
            //console.error('200OK S->C:');
            args[i] = '200OK S->C: with candidate';
          }
        }
      } else if (args[i].indexOf('"type":"candidate"') !== -1) {
        //console.error('candidate');
        if (args[i].indexOf("S->C:") === -1) {
          //console.error('candidate C->S:');
          candidate = args[i].replace(/C->S: /g, '');
          candidateJSON = JSON.parse(candidate); //console.error('candidateJSON.candidate : ', candidateJSON.candidate);

          args[i] = 'candidate C->S:' + candidateJSON.candidate;
        } else {
          //console.error('candidate S->C:');
          candidate = args[i].replace(/onChannelMessage S->C: /g, '');
          candidateJSON = JSON.parse(candidate); //console.error('candidateJSON.candidate : ', candidateJSON.candidate);

          args[i] = 'candidate S->C:' + candidateJSON.candidate;
        }
      } else {//console.error('other message');
      }
    }
  } //console.log("filtered args :", args);


  return args;
};
/**
 * Logger class
 */


var Logger = /*#__PURE__*/function () {
  function Logger(category) {
    _classCallCheck(this, Logger);

    if (loggerInstances.has(category)) {
      throw new Error('Cannot construct singleton Logger');
    }

    this.category = category;
    loggerInstances.set(category, this);
  }

  _createClass(Logger, [{
    key: "trace",
    value: function trace() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      this.logMessage.apply(this, [_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_TRACE].concat(args));
    }
  }, {
    key: "log",
    value: function log() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      this.logMessage.apply(this, [_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_DEBUG].concat(args));
    }
  }, {
    key: "debug",
    value: function debug() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this.logMessage.apply(this, [_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_DEBUG].concat(args));
    }
  }, {
    key: "info",
    value: function info() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      this.logMessage.apply(this, [_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_INFO].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      this.logMessage.apply(this, [_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_WARN].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      this.logMessage.apply(this, [_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_ERROR].concat(args));
    }
  }, {
    key: "logMessage",
    value: function logMessage(level) {
      for (var _len7 = arguments.length, args = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
        args[_key7 - 1] = arguments[_key7];
      }

      if (console === null || console === undefined) {
        //Workaround for IE : console is not defined if inspector is not open
        return;
      }

      if (level <= logLevel) {
        //ignore log messages over log level
        //add time
        var baseMessage = "[".concat(new Date().toISOString(), "]");

        if (level in _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_LABELS) {
          baseMessage += "[".concat(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_LABELS[level], "]");
        }

        baseMessage += _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_PREFIX + "(".concat(this.category, ")");

        switch (level) {
          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_ERROR:
            if (console.error) {
              var _console;

              (_console = console).error.apply(_console, [baseMessage].concat(_toConsumableArray(args)));
            }

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_WARN:
            if (console.warn) {
              var _console2;

              (_console2 = console).warn.apply(_console2, [baseMessage].concat(_toConsumableArray(args)));
            }

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.LOG_LEVEL_INFO:
            if (console.info) {
              var _console3;

              (_console3 = console).info.apply(_console3, [baseMessage].concat(_toConsumableArray(args)));
            }

            break;

          default:
            if (console.log) {
              var _console4;

              (_console4 = console).log.apply(_console4, [baseMessage].concat(_toConsumableArray(args)));
            }

            break;
        }
      }

      if (typeof apiCC !== 'undefined') {
        if (apiCC.logStorageActivated) {
          //ignore log messages over logStorageLevel
          if (level <= apiCC.logStorageLevel) {
            //Filtering messages before sending to cloud
            args = logMessageFiltering(args);
            apiCC.logStorage.push(JSON.stringify({
              'name': 'log',
              'args': {
                '0': "(".concat(this.category, ")") + ':' + args
              }
            }));
          }
        }
      }
    }
  }], [{
    key: "get",
    value: function get(category) {
      if (!loggerInstances.has(category)) {
        return new Logger(category);
      }

      return loggerInstances.get(category);
    }
  }, {
    key: "setLogLevel",
    value: function setLogLevel(level) {
      if (!Number.isInteger(level) || level < 0) {
        throw 'Log level invalid';
      }

      logLevel = level;
    }
  }, {
    key: "getLogLevel",
    value: function getLogLevel() {
      return logLevel;
    }
  }]);

  return Logger;
}();



/***/ }),

/***/ "./src/public/Call.js":
/*!****************************!*\
  !*** ./src/public/Call.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Call": () => (/* binding */ Call)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _utils_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Observable */ "./src/utils/Observable.js");
/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Stream */ "./src/public/Stream.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../private/ApiRTCManager */ "./src/private/ApiRTCManager.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* globals apiCC*/






var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_4__.Logger.get('Call');
var apiRTCManager = _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_5__.ApiRTCManager.get();
var CALL_EVENTS = ['streamAdded', 'streamRemoved', 'response', 'accepted', 'declined', 'hangup', 'localStreamAvailable', 'recordAvailable', 'statsUpdate', 'error', 'disconnectionWarning', 'userMediaError', 'desktopCapture', 'remoteStreamUpdated', 'recordingStarted', 'recordingStopped', 'recordingAvailable'];
var STATS_SECTIONS = new Set(['audioSent', 'videoSent', 'audioReceived', 'videoReceived', 'quality']);

var _id = new WeakMap();

var _contact = new WeakMap();

var _status = new WeakMap();

var _isRecorded = new WeakMap();

var _apiRTCEventListeners = new WeakMap();
/**
 * Call
 *
 * Designates a 1-1 call with another contact.
 * During a call, both the user and the contact may publish and subscribe to each other's streams.
 *
 * @extends Observable
 * @fires Call#streamAdded
 * @fires Call#streamRemoved
 * @fires Call#response
 * @fires Call#accepted
 * @fires Call#declined
 * @fires Call#hangup
 * @fires Call#localStreamAvailable
 * @fires Call#recordAvailable
 * @fires Call#statsUpdate
 * @fires Call#error
 * @fires Call#disconnectionWarning
 * @fires Call#userMediaError
 * @fires Call#desktopCapture
 * @fires Call#remoteStreamUpdated
 * @fires Call#recordingStarted
 * @fires Call#recordingStopped
 * @fires Call#recordingAvailable
 */


var Call = /*#__PURE__*/function (_Observable) {
  _inherits(Call, _Observable);

  var _super = _createSuper(Call);

  /**
   * Fired when contact's stream is received from 1-1 call
   *
   * @event Call#streamAdded
   * @type {Stream}
   */

  /**
   * Fired when contact's stream is removed from 1-1 call, stream may be null
   *
   * @event Call#streamRemoved
   * @type {Stream}
   */

  /**
   * Fired when contact hangs up from 1-1 call
   * 'from' property indicates which side initiated the hangup, either 'remote' or 'local'
   *
   * @event Call#hangup
   * @type {object}
   * @property {string} from
   * @property {string} reason can be User_Busy, User_Refused_Call, User_Media_Error, Hangup_From_Callee, Hangup_From_Caller, stop_ScreenSharing, Ice_disconnected, Ice_failed, WebRTC_Plugin_Installation_needed, User_Not_Found, disconnected, call take on other device, bye on other device, DataChannel_Not_Supported
   */

  /**
   * Fired when contact accepts call
   *
   * @event Call#accepted
   * @type {Void}
   */

  /**
   * Fired when contact accepted or declined call
   *
   * @event Call#response
   * @type {Void}
   */

  /**
   * Fired when contact decline call
   *
   * @event Call#declined
   * @type {object}
   * @property {string} reason can be User_Busy, User_Refused_Call, User_Media_Error, Hangup_From_Callee, Hangup_From_Caller, stop_ScreenSharing, Ice_disconnected, Ice_failed, WebRTC_Plugin_Installation_needed, User_Not_Found, disconnected, call take on other device, bye on other device, DataChannel_Not_Supported
   */

  /**
   * Fired when local stream is available after calling the contact
   *
   * @event Call#localStreamAvailable
   * @type {Stream}
   */

  /**
   * Fired when call record is available.
   * This event is fired once the call is ended for both peers if the call was recorded.
   *
   * @event Call#recordAvailable
   * @type {object}
   * @property {string} mediaURL video file URL
   */

  /**
   * Fired when call record is available.
   * This event is fired once the call is ended for both peers if the call was recorded.
   *
   * @event Call#statsUpdate
   * @type {CallStats}
   */

  /**
   * @typedef {object} CallIceErrorDescriptor
   * @property {string} iceState - Either 'failed' or 'disconnected'.
   * @property {string} previousIceState - Either 'disconnected' or undefined.
   * @property {string} clientId - Local user ID from where this descriptor come from.
   * @property {string} remoteId - Distant user ID from where this descriptor come from.
   */

  /**
   * Fired when an error is detected
   * This event is fired once an error was detected on the call.
   *
   * @event Call#error
   * @type {object}
   * @property {String} errorCode Code description of the error. Check possible values below.
   * @property {String} errorInfo Code information about the error. Check possible values below.
   * <p>Possible errors values are the following: (errorInfo, errorCode)</p>
   * <i>Connection errors:</i>
   * <ul>
   * <li>ice disconnection detected: ICE_CONNECTION_STATE_DISCONNECTED</li>
   * <li>ice connection failed detected: ICE_CONNECTION_STATE_FAILED</li>
   * <li>distant ice disconnection detected: DISTANT_ICE_CONNECTION_STATE_DISCONNECTED</li>
   * <li>distant ice connection failed detected: DISTANT_ICE_CONNECTION_STATE_FAILED</li>
   * </ul>
   * <i>Errors on signaling processing:</i>
   * <ul>
   * <li>200OK received but callId is not matching, no process : NOT_MATCHING_CALLID_ON_200OK</li>
   * <li>Cannot find call to process Update : CALL_NOT_FOUND_ON_UPDATE</li>
   * <li>Cannot find call to process 200 Update : CALL_NOT_FOUND_ON_200UPDATE</li>
   * <li>Call aborted after calls retries (maxCallsRetriesDuration reached) : CALL_ABORTED</li>
   * </ul>
   * <i>Errors on Media establishment processing:</i>
   * <ul>
   * <li>Set local Description Failure : SET_LOCAL_DESCRIPTION_FAILURE</li>
   * <li>Set remote Description Failure : SET_REMOTE_DESCRIPTION_FAILURE</li>
   * </ul>
   * <i>Errors on calling API:</i>
   * <ul>
   * <li>parameter error when calling function: setUnidirectionalCall(): PARAMETER_ERROR_SETUNIDIRCALL</li>
   * <li>parameter error when calling function: setNtoNConf(): PARAMETER_ERROR_SETNTONCONF</li>
   * <li>parameter error when calling function: setRTPMedia(): PARAMETER_ERROR_SETRTPMEDIA</li>
   * <li>parameter error when calling function: setMediaRoutingMode(): PARAMETER_ERROR_SETMEDIAROUTINGMODE</li>
   * <li>parameter error when calling function: setUserAcceptOnIncomingCall(): PARAMETER_ERROR_SETUSERACCEPTONINCOCALL</li>
   * <li>Trying to add a listener on an unknown event: UNKNOWN_EVENT_ON_ADDLISTENER</li>
   * <li>parameter error when calling function: setAllowMultipleCalls(): PARAMETER_ERROR_SETALLOWMULTIPLECALLS</li>
   * </ul>
   * <i>Errors about recording :</i>
   * <ul>
   * <li>Room not found when starting recording: START_RECORD_ROOM_NOT_FOUND</li>
   * <li>Caller not found when starting recording: START_RECORD_CALLER_NOT_FOUND</li>
   * <li>Media not found when starting recording: START_RECORD_MEDIA_FOUND</li>
   * <li>Recording is already ongoing: START_RECORD_ALREADY_ON</li>
   * <li>Room not found when stopping recording: STOP_RECORD_ROOM_NOT_FOUND</li>
   * <li>Caller not found when stopping recording: STOP_RECORD_CALLER_NOT_FOUND</li>
   * <li>Media not found when stopping recording: STOP_RECORD_MEDIA_FOUND</li>
   * <li>Recorder not found when stopping recording: STOP_RECORD_ENDPOINT_NOT_FOUND</li>
   * <li>Recording is not started stopping recording: STOP_RECORD_NOT_STARTED</li>
   * <li>Recorder is not ready yet, record is not started: STOP_RECORD_RECORDER_NOT_READY</li>
   * </ul>
   * <i>Errors about media play:</i>
   * <ul>
   * <li>Autoplay was prevented: IOS_AUTOPLAY_PREVENTED</li>
   * </ul>
   * <i>Errors about media streams:</i>
   * <ul>
   * <li>Error during media update on call: MEDIA_UPDATE_ERROR</li>
   * </ul>
   * <i>Errors about user media:</i>
   * <ul>
   * <li>Error during media media access: USER_MEDIA_ERROR</li>
   * </ul>
   * <i>Errors about remote stream:</i>
   * <ul>
   * <li>Error during subscription: STREAM_NOT_AVAILABLE</li>
   * </ul>
   * @property {CallIceErrorDescriptor|object} descriptor Detailed descriptor of the error
   */

  /**
   * Fired when an disconnection is detected
   * This event is fired as a warning once a disconnection error was detected on the call.
   *
   * @event Call#disconnectionWarning
   * @type {object}
   * @property {string} tries number of warning send
   */

  /**
   * Fired on user media access error :
   * This event is fired when user has not granted the access to his micro and webcam or brower was not able to access medias
   *
   * @event Call#userMediaError
   * @type {object}
   *
   * @property {String} onCallEstablishment true or false, indicate whether access to media has been requested on call establishment or not (can be requested on autoAnswer feature activation)
   * @property {String} callType value can be 'media' or screenSharing
   * @property {Object} error error given by WebRTC API
   * @property {String} userMediaStreamId stream id
   * @property {Boolean} tryAudioCallActivated whether apiRTC will try to establish the call in audio only after this error detection
   */

  /**
   * Fired on user media access error :
   * This event is fired when user has not granted the access to his micro and webcam or brower was not able to access medias
   *
   * @event Call#desktopCapture
   * @type {object}
   *
   * @property {String} event event that has happened. Values can be : UserMediaError_HTTPS_needed, UserMediaError, Extension_installation_Error, Extension_not_installed, Browser_Not_Compatible
   */

  /**
   * Fired when remote stream properties changed.
   *
   * @event Call#remoteStreamUpdated
   * @type {object}
   * @property {string} callId - callId
   * @property {boolean} audio - whether an audio line has been negotiated and active.
   * @property {boolean} audioMuted - whether the audio line is muted.
   * @property {boolean} video - whether a video line has been negotiated and active.
   * @property {boolean} videoMuted - whether the video line is muted.
   */

  /**
   * Fired when a recording started.
   *
   * @event Call#recordingStarted
   * @type {RecordingInfo}
   */

  /**
   * Fired when a recording stopped.
   *
   * @event Call#recordingStopped
   * @type {RecordingInfo}
   */

  /**
   * Fired when a recording is available for play or download.
   *
   * @event Call#recordingAvailable
   * @type {RecordingInfo}
   */

  /**
   * Creates a new call
   *
   *  @param {String} id call id
   *  @param {Contact} contact called contact
   *  @returns {Call} this
   */
  function Call(id, contact) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Call);

    _this = _super.call(this, logger);
    logger.debug('Create Call with id ' + id);

    _id.set(_assertThisInitialized(_this), id);

    _contact.set(_assertThisInitialized(_this), contact);

    _this.publishedStreams = new Map();
    _this.receivedStreams = new Map();
    _this.stats = {};

    _status.set(_assertThisInitialized(_this), options.hasOwnProperty('started') && options.started ? _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_ONGOING : _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_WAITING_FOR_CALLEE);

    _isRecorded.set(_assertThisInitialized(_this), options.hasOwnProperty('isRecorded') ? options.isRecorded : false);

    if (options.isRecorded) {
      _this.confId = null;
      _this.recordingStatus = null; // Look for confId.

      for (var callIdx = apiRTCManager.webRTCClient.webRTCClient.callsTable.length; --callIdx >= 0;) {
        var c = apiRTCManager.webRTCClient.webRTCClient.callsTable[callIdx];

        if (c.callId === id && c.data) {
          _this.confId = c.data.confId;
          break;
        }
      } // for


      _isRecorded.set(_assertThisInitialized(_this), true);
    } else {
      _isRecorded.set(_assertThisInitialized(_this), false);
    }

    var apiRTCEventListeners = {};

    apiRTCEventListeners.hangup = function (e) {
      if (_this.getId() === e.detail.callId) {
        _this.destroy();
      }
    };

    apiRTCEventListeners.receiveData = function (e) {
      if (typeof e.detail.data.info !== 'undefined') {
        if (e.detail.data.info === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER && e.detail.data.invitationId.toString() === _this.getId() && _this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_WAITING_FOR_CALLEE) {
          logger.info('Call answer from ' + _this.getContact().getUsername() + ' for ' + _this.getId());

          if (e.detail.data.answer === 'accept') {
            _status.set(_assertThisInitialized(_this), _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_ONGOING);

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('accepted');

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('response', 'accepted');
          } else {
            _status.set(_assertThisInitialized(_this), _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_ENDED);

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('declined', {
              reason: 'User_Refused_Call'
            });

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('response', 'declined');
          }
        }
      }
    };

    apiRTCEventListeners.remoteStreamUpdated = function (e) {
      if (_this.getId() === e.detail.callId) {
        var remoteStreamUpdated = {
          callId: e.detail.callId,
          audio: e.detail.audioIsAvailable && e.detail.audioIsActive,
          audioMuted: e.detail.audioIsMuted,
          audioSilent: e.detail.audioIsSilent,
          video: e.detail.videoIsAvailable && e.detail.videoIsActive,
          videoMuted: e.detail.videoIsMuted,
          videoSilent: e.detail.videoIsSilent
        };

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('remoteStreamUpdated', remoteStreamUpdated);
      }
    };

    apiRTCEventListeners.MCURecordingStarted = function (e) {
      if (_isRecorded.get(_assertThisInitialized(_this)) && e.detail.roomName === _this.confId) {
        var recordingStarted = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.parseRecordingEvent('MCURecordingStarted', e.detail);

        if (recordingStarted.callId === 'COMPOSITE') {
          _this.recordingStatus = recordingStarted;

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('recordingStarted', recordingStarted);
        }
      }
    };

    apiRTCEventListeners.MCURecordingStopped = function (e) {
      if (_isRecorded.get(_assertThisInitialized(_this)) && e.detail.roomName === _this.confId) {
        var recordingStopped = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.parseRecordingEvent('MCURecordingStopped', e.detail);

        if (recordingStopped.callId === 'COMPOSITE') {
          delete _this.recordingStatus;

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('recordingStopped', recordingStopped);
        }
      }
    };

    apiRTCEventListeners.MCURecordedStreamsAvailable = function (e) {
      if (_isRecorded.get(_assertThisInitialized(_this)) && e.detail.roomName === _this.confId) {
        var recordingAvailable = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.parseRecordingEvent('MCURecordedStreamsAvailable', e.detail);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('recordingAvailable', recordingAvailable);
      }
    };

    for (var key in apiRTCEventListeners) {
      apiRTCManager.onEvent(key, apiRTCEventListeners[key]);
    }

    _apiRTCEventListeners.set(_assertThisInitialized(_this), apiRTCEventListeners);

    return _this;
  }
  /**
   * Cleans up all resources attached to this one.
   */


  _createClass(Call, [{
    key: "destroy",
    value: function destroy() {
      var listeners = _apiRTCEventListeners.get(this);

      if (listeners) {
        for (var key in listeners) {
          apiRTCManager.removeEventListener(key, listeners[key]);
        }

        _apiRTCEventListeners["delete"](this);
      }
    }
    /**
     * Returns available events for this class
     *
     *  @returns {Array<string>}
     */

  }, {
    key: "getId",
    value:
    /**
     * Returns call id
     *
     *  @returns {string} Call id
     */
    function getId() {
      return _id.get(this).toString();
    }
    /**
     * Returns whether call is recorded or not
     *
     *  @returns {boolean}
     */

  }, {
    key: "isRecorded",
    value: function isRecorded() {
      return _isRecorded.get(this);
    }
    /**
     * Returns called contact
     *
     *  @returns {Contact} Called contact
     */

  }, {
    key: "getContact",
    value: function getContact() {
      return _contact.get(this);
    }
    /**
     * Returns called status
     *
     *  @returns {Symbol} Call status, value can be CALL_STATUS_WAITING_FOR_CALLEE, CALL_STATUS_ONGOING, CALL_STATUS_ENDED
     */

  }, {
    key: "getStatus",
    value: function getStatus() {
      return _status.get(this);
    }
    /*
     * Sets call status
     *
     * @param {status} set the call status
     * @returns {void}
     */

  }, {
    key: "setStatus",
    value: function setStatus(status) {
      _status.set(this, status);
    }
    /**
     * Returns call's currently published streams
     *
     *  @returns {Streams[]} Array of call currently published streams
     */

  }, {
    key: "getPublishedStreams",
    value: function getPublishedStreams() {
      var res = [];

      var _iterator = _createForOfIteratorHelper(this.publishedStreams.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var stream = _step.value;
          res.push(stream);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return res;
    }
    /**
     * Returns call's currently received streams
     *
     *  @returns {Streams[]} Array of call currently received streams
     */

  }, {
    key: "getReceivedStreams",
    value: function getReceivedStreams() {
      var res = [];

      var _iterator2 = _createForOfIteratorHelper(this.receivedStreams.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var stream = _step2.value;
          res.push(stream);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return res;
    }
    /**
     * Stops call with contact
     *
     *  @returns {Void}
     */

  }, {
    key: "hangUp",
    value: function hangUp() {
      if (this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_ENDED) {
        logger.error('hangUp() - Call has already ended');
      } else {
        apiRTCManager.webRTCClient.hangUp(this.getId());
      }
    }
    /**
     * Returns call statistics for this one.
     *
     * @ignore
     * @returns {object} Statistics about this one.
     */

  }, {
    key: "getStats",
    value: function getStats() {
      return _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject({}, this.stats);
    }
    /**
     * Stops the currently published stream.
     *
     * @param {object} options - Options.
     *
     * @return {Promise<Stream>} When it is done.
     */

  }, {
    key: "stopPublishedStreams",
    value: function stopPublishedStreams() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return apiRTCManager.webRTCClient.webRTCClient.stopMedia(this.getId());
    }
    /**
     * Replaces the currently published stream by a given one.
     * If the first parameter is null then the second parameter must provides a property named
     * getStream. The getStream property shall be a function returning a Promise of a Stream.
     *
     * @param {Stream} newStream - New stream to be published
     * @param {object} callbacks - Callbacks.
     * @param {function} callbacks.getStream - A function returning a promise of a stream.
     * @param {object} options - Options.
     *
     * @return {Promise<Stream>} The newly assigned stream.
     */

  }, {
    key: "replacePublishedStreams",
    value: function replacePublishedStreams(newStream, callbacks) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var findStream = function findStream(userMediaStreamId) {
        if (_Stream__WEBPACK_IMPORTED_MODULE_3__._localStreams.has(userMediaStreamId)) {
          return _Stream__WEBPACK_IMPORTED_MODULE_3__._localStreams.get(userMediaStreamId);
        } else {
          var userMediaStream = apiCC.getUserMediaStream(userMediaStreamId);

          if (userMediaStream) {
            var type = 'audio';

            if (userMediaStream.video === true) {
              type = 'video';
            }

            return new _Stream__WEBPACK_IMPORTED_MODULE_3__.Stream(userMediaStream.stream, {
              type: type,
              constructor: true,
              userMediaStreamId: userMediaStream.userMediaStreamId
            });
          }
        }

        return null;
      };

      return new Promise(function (resolve, reject) {
        if (_this2.getStatus() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_ONGOING) {
          return reject(new Error('replacePublishedStreams() - Cannot replace stream as call is not ongoing'));
        } else if (newStream === null) {
          if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(callbacks, 'getStream', 'function')) {
            // Replacing stream.
            var newCallBacks = {};

            newCallBacks.getUserMediaStreamId = function () {
              return callbacks.getStream().then(function (newStream) {
                return newStream.userMediaStreamId;
              })["catch"](reject);
            };

            apiRTCManager.webRTCClient.webRTCClient.addMedia(_this2.getId(), true, null, newCallBacks).then(function (userMediaStreamId) {
              return resolve(findStream(userMediaStreamId));
            })["catch"](function (err) {
              return reject(new Error('replacePublishedStreams() - ' + err));
            });
          } else {
            apiRTCManager.webRTCClient.webRTCClient.addMedia(_this2.getId(), true, null, null).then(function (userMediaStreamId) {
              return resolve(findStream(userMediaStreamId));
            })["catch"](function (err) {
              return reject(new Error('replacePublishedStreams() - ' + err));
            });
          }
        } else {
          // Replacing stream.
          apiRTCManager.webRTCClient.webRTCClient.addMedia(_this2.getId(), true, newStream.userMediaStreamId).then(function (userMediaStreamId) {
            return resolve(findStream(userMediaStreamId));
          })["catch"](function (err) {
            return reject(new Error('replacePublishedStreams() - ' + err));
          });
        }
      });
    }
    /**
     * Returns the recoding information, if any.
     * @return {RecordingInfo|null}
     */

  }, {
    key: "getRecordingInfo",
    value: function getRecordingInfo() {
      if (_isRecorded.get(this)) {
        return this.recordingStatus;
      }

      return null;
    }
    /**
     * Starts recording the call represented by this one.
     * Only available for initially recorded call.
     * @return {Promise}
     */

  }, {
    key: "startRecording",
    value: function startRecording() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.asyncCallbacks) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startRecording() - busy', logger));
        }

        _this3.asyncCallbacks = {}; // Set timeout to handle lack of response from CCS.

        _this3.asyncCallbacks.timeoutId = setTimeout(function () {
          if (_this3.asyncCallbacks) {
            apiRTCManager.removeEventListener('error', _this3.asyncCallbacks.error);
            apiRTCManager.removeEventListener('MCURecordingStarted', _this3.asyncCallbacks.recordingStarted);
            delete _this3.asyncCallbacks;
          }

          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startRecording() - timeout', logger));
        }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_RECORDING_STARTED_DELAY); // Set error handler to handle failure.

        _this3.asyncCallbacks.error = function (e) {
          if (_this3.confId === e.detail.roomName && e.detail.callId === 'COMPOSITE' && e.detail.errorCode.indexOf('START_RECORD') >= 0) {
            // Error related to the startCompositeRecording request.
            if (_this3.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this3.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStarted', _this3.asyncCallbacks.recordingStarted);
              clearTimeout(_this3.asyncCallbacks.timeoutId);
              delete _this3.asyncCallbacks;
            }

            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startRecording() - ' + e.detail.errorInfo, logger));
          }
        }; // Set success handler.


        _this3.asyncCallbacks.recordingStarted = function (e) {
          if (_this3.confId === e.detail.roomName && e.detail.callId === 'COMPOSITE') {
            if (_this3.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this3.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStarted', _this3.asyncCallbacks.recordingStarted);
              clearTimeout(_this3.asyncCallbacks.timeoutId);
              delete _this3.asyncCallbacks;
            }

            var value = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.parseRecordingEvent('MCURecordingStarted', e.detail);
            return resolve(value);
          }
        };

        apiRTCManager.onEvent('error', _this3.asyncCallbacks.error);
        apiRTCManager.onEvent('MCURecordingStarted', _this3.asyncCallbacks.recordingStarted);
        apiRTCManager.webRTCClient.startCallRecording(_id.get(_this3));
      });
    }
    /**
     * Stops recording the call represented by this one.
     * Only available for initially recorded call.
     * @return {Promise}
     */

  }, {
    key: "stopRecording",
    value: function stopRecording() {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (_this4.asyncCallbacks) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'stopRecording() - busy', logger));
        }

        _this4.asyncCallbacks = {}; // Set timeout to handle lack of response from CCS.

        _this4.asyncCallbacks.timeoutId = setTimeout(function () {
          if (_this4.asyncCallbacks) {
            apiRTCManager.removeEventListener('error', _this4.asyncCallbacks.error);
            apiRTCManager.removeEventListener('MCURecordingStopped', _this4.asyncCallbacks.recordingStopped);
            delete _this4.asyncCallbacks;
          }

          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'stopRecording() - timeout', logger));
        }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_RECORDING_STOPPED_DELAY); // Set error handler to handle failure.

        _this4.asyncCallbacks.error = function (e) {
          if (_this4.confId === e.detail.roomName && e.detail.callId === 'COMPOSITE' && e.detail.errorCode.indexOf('STOP_RECORD') >= 0) {
            // Error related to the stopCompositeRecording request.
            if (_this4.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this4.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStopped', _this4.asyncCallbacks.recordingStopped);
              clearTimeout(_this4.asyncCallbacks.timeoutId);
              delete _this4.asyncCallbacks;
            }

            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'stopRecording() - ' + e.detail.errorInfo, logger));
          }
        }; // Set success handler.


        _this4.asyncCallbacks.recordingStopped = function (e) {
          if (_this4.confId === e.detail.roomName && e.detail.callId === 'COMPOSITE') {
            if (_this4.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this4.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStopped', _this4.asyncCallbacks.recordingStopped);
              clearTimeout(_this4.asyncCallbacks.timeoutId);
              delete _this4.asyncCallbacks;
            }

            var value = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.parseRecordingEvent('MCURecordingStopped', e.detail);
            return resolve(value);
          }
        };

        apiRTCManager.onEvent('error', _this4.asyncCallbacks.error);
        apiRTCManager.onEvent('MCURecordingStopped', _this4.asyncCallbacks.recordingStopped);
        apiRTCManager.webRTCClient.stopCallRecording(_id.get(_this4));
      });
    }
    /*
     * manage CallEstablished Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageCallEstablishedEvent",
    value: function manageCallEstablishedEvent(e) {
      logger.debug('callEstablished', e.detail, this.getId());
      var callId = e.detail.callId.toString();

      if (this.getId() === callId) {
        logger.info('callEstablished from ' + this.getContact().getUsername(), e);

        if (this.getStatus() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_ONGOING && this.getStatus() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_ENDED) {
          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('accepted');

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('response', 'accepted');

          _status.set(this, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_ONGOING);
        }
      }
    }
    /*
     * manage RemoteStreamAdded Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageRemoteStreamAddedEvent",
    value: function manageRemoteStreamAddedEvent(e) {
      logger.debug('remoteStreamAdded', e.detail, this.getId());
      var callId = e.detail.callId.toString();

      if (this.getId() === callId) {
        var type = e.detail.destCallType === 'audio' ? 'audio' : 'video';
        var screensharing = e.detail.callType === 'screenSharing';
        var newStream = new _Stream__WEBPACK_IMPORTED_MODULE_3__.Stream(e.detail.stream, {
          screensharing: screensharing,
          type: type,
          contact: this.getContact(),
          streamId: e.detail.stream.id,
          callId: e.detail.callId,
          callAudioAvailable: e.detail.audioIsAvailable,
          callAudioActive: e.detail.audioIsActive,
          callAudioMuted: e.detail.audioIsMuted,
          callVideoAvailable: e.detail.videoIsAvailable,
          callVideoActive: e.detail.videoIsActive,
          callVideoMuted: e.detail.videoIsMuted,
          constructor: true
        });
        this.receivedStreams.set(e.detail.stream.id, newStream);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('streamAdded', newStream);
      }
    }
    /*
     * manage RemoteStreamRemoved Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageRemoteStreamRemovedEvent",
    value: function manageRemoteStreamRemovedEvent(e) {
      logger.debug('remoteStreamRemoved', e.detail, this.getId());
      var callId = e.detail.callId.toString();

      if (this.getId() === callId) {
        var stream = this.receivedStreams.get(e.detail.stream.id);
        this.receivedStreams["delete"](e.detail.stream.id);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('streamRemoved', stream);
      }
    }
    /*
     * manage UserMediaSuccess Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageUserMediaSuccessEvent",
    value: function manageUserMediaSuccessEvent(e) {
      logger.debug('UserMediaSuccess', e.detail, this.getId());
      var type = null,
          callId = null;

      if (e.detail.videoIsAvailable === true) {
        type = 'video';
      } else {
        type = 'audio';
      }

      if (e.detail.callId !== null) {
        callId = e.detail.callId.toString();
      }

      if (this.getId() === callId) {
        logger.info('localStreamAvailable', e.detail);

        var newStream = _Stream__WEBPACK_IMPORTED_MODULE_3__._localStreams.get(e.detail.userMediaStreamId);

        if (!newStream) {
          newStream = new _Stream__WEBPACK_IMPORTED_MODULE_3__.Stream(e.detail.stream, {
            type: type,
            constructor: true,
            userMediaStreamId: e.detail.userMediaStreamId
          });
        }

        this.publishedStreams.set(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.guid(), newStream);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('localStreamAvailable', newStream);
      }
    }
    /*
     * manage CallStatsUpdate Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageCallStatsUpdateEvent",
    value: function manageCallStatsUpdateEvent(e) {
      // Please, do not commit any log for this event.
      if (this.getId() === e.detail.callId) {
        // Updating stats of this one.
        for (var _i = 0, _Object$keys = Object.keys(e.detail.stats); _i < _Object$keys.length; _i++) {
          var section = _Object$keys[_i];

          if (STATS_SECTIONS.has(section)) {
            this.stats[section] = e.detail.stats[section];
          }
        } // for


        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('statsUpdate', _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject({}, {
          stats: this.stats
        }));
      }
    }
    /*
     * manage Error Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageErrorEvent",
    value: function manageErrorEvent(e) {
      logger.debug('Error', e.detail, this.getId());

      if (this.getId() === e.detail.callId) {
        var error = {
          errorCode: e.detail.errorCode,
          errorInfo: e.detail.errorInfo
        };

        if (e.detail.data) {
          error.descriptor = e.detail.data;
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('error', error);
      }
    }
    /*
     * manage DisconnectionWarning Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageDisconnectionWarningEvent",
    value: function manageDisconnectionWarningEvent(e) {
      logger.debug('DisconnectionWarning', e.detail, this.getId());

      if (this.getId() === e.detail.callId) {
        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('disconnectionWarning', {
          tries: e.detail.tries
        });
      }
    }
    /*
     * manage Hangup Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageHangupEvent",
    value: function manageHangupEvent(e) {
      logger.debug('hangup', e.detail, this.getId());
      var callId = e.detail.callId.toString();
      var isDeclined = this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_WAITING_FOR_CALLEE && e.detail.hangupType === 'remote';

      if (this.getId() === callId && this.getStatus() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_ENDED) {
        _status.set(this, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_ENDED);

        logger.info('Hangup from ' + this.getContact().getUsername(), e);

        var _iterator3 = _createForOfIteratorHelper(this.receivedStreams.keys()),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var key = _step3.value;
            var stream = this.receivedStreams.get(key);
            this.receivedStreams["delete"](key);

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('streamRemoved', stream);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('hangup', {
          from: e.detail.hangupType,
          reason: e.detail.reason
        });

        if (isDeclined) {
          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('declined', {
            reason: e.detail.reason
          });

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('response', 'declined');
        }
      }
    }
    /*
     * manage RecordAvailable Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageRecordAvailableEvent",
    value: function manageRecordAvailableEvent(e) {
      logger.warn('recordedStreamsAvailable', e.detail, this.getId());

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('recordAvailable', {
        mediaURL: e.detail.mediaURL
      });
    }
    /*
     * manage userMediaError Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageUserMediaErrorEvent",
    value: function manageUserMediaErrorEvent(e) {
      logger.warn('userMediaError', e.detail, this.getId());

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('userMediaError', {
        callType: e.detail.callType,
        error: e.detail.error,
        onCallEstablishment: e.detail.onCallEstablishment,
        userMediaStreamId: e.detail.userMediaStreamId,
        tryAudioCallActivated: e.detail.tryAudioCallActivated
      });
    }
    /*
     * manage userMediaError Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageDesktopCaptureEvent",
    value: function manageDesktopCaptureEvent(e) {
      logger.warn('desktopCapture', e.detail, this.getId());

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('desktopCapture', {
        event: e.detail.event
      });
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return CALL_EVENTS;
    }
  }]);

  return Call;
}(_utils_Observable__WEBPACK_IMPORTED_MODULE_2__.Observable);



/***/ }),

/***/ "./src/public/Conference.js":
/*!**********************************!*\
  !*** ./src/public/Conference.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Conference": () => (/* binding */ Conference)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/EventEmitter */ "./src/utils/EventEmitter.js");
/* harmony import */ var _Conversation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Conversation */ "./src/public/Conversation.js");
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Session */ "./src/public/Session.js");
/* harmony import */ var _Contact__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Contact */ "./src/public/Contact.js");
/* harmony import */ var _SentInvitation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SentInvitation */ "./src/public/SentInvitation.js");
/* harmony import */ var _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../private/ConversationCatalog */ "./src/private/ConversationCatalog.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }










var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_8__.Logger.get('Conference');
var CONFERENCE_EVENTS = _Conversation__WEBPACK_IMPORTED_MODULE_3__.Conversation.getAvailableEvents().concat(['closed']);
/**
 * Conference
 *
 * A conference is a type of Conversation that may require privilege to join
 * Conference may only be created if your enterprise has the conference feature enabled on the ApiRTC cloud platform
 * @extends Conversation
 * @fires Conversation#closed
 */

var Conference = /*#__PURE__*/function (_Conversation) {
  _inherits(Conference, _Conversation);

  var _super = _createSuper(Conference);

  /**
   * Fired when conversation has been closed
   *
   * @event Conversation#closed
   * @type {void}
   */
  function Conference(name) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Conference);

    _this = _super.call(this, name, options);
    logger.info('Create conference');
    _this.conference = true;
    _this.friendlyName = options.hasOwnProperty('friendlyName') ? options.friendlyName : name;
    return _this;
  }
  /**
   * Cleans up all local resources attached to this one.
   */


  _createClass(Conference, [{
    key: "destroy",
    value: function destroy() {
      _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_7__.ConversationCatalog.get().deleteConference(this.getName());

      _get(_getPrototypeOf(Conference.prototype), "destroy", this).call(this);
    }
    /**
     * Returns available events for this class
     *
     *  @returns {string[]}
     */

  }, {
    key: "_getTechnicalName",
    value:
    /*
     * Returns this conference's technical name for signaling
     *
     *  @returns {string}
     */
    function _getTechnicalName() {
      return getConferencePrefix() + _Conversation__WEBPACK_IMPORTED_MODULE_3__._name.get(this);
    }
    /**
     * Returns this conference's name as it is displayed on your ApiRTC cloud platform
     *
     * @return {string|null}
     */

  }, {
    key: "getFriendlyName",
    value: function getFriendlyName() {
      return this.friendlyName;
    }
    /**
     * @typedef {Object} ConferenceInfo
     * @property {string} dtmfCode - The DTMF code to join via SIP.
     * @property {number} endTime - The end time (seconds since the epoch).
     * @property {boolean} hasPassword - Whether the conference requires a password to join.
     * @property {string} sipNumber - The telephone number to join the conference.
     * @property {number} startTime - The start time (seconds since the epoch).
     * @property {string} state - The state of the conference. Either 'archived'. 'closed', 'ongoing', 'open', 'scheduled'.
     * @property {string} type - The type of the conference, Either 'private' or 'public'.
     */

    /**
     * Returns the info of the conference represented by this one.
     * @return {Promise<ConferenceInfo>}
     */

  }, {
    key: "getInfo",
    value: function getInfo() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var opts = {};

        var session = _Conversation__WEBPACK_IMPORTED_MODULE_3__._mySession.get(_this2);

        if (session) {
          opts.token = session.getToken();
        }

        _Conversation__WEBPACK_IMPORTED_MODULE_3__.cloudApi.getWebconf(_this2._getTechnicalName(), opts).then(function (res) {
          return resolve({
            dtmfCode: res.dtmfCode,
            endTime: res.end,
            hasPassword: res.hasPassword,
            sipNumber: res.sipNumber,
            startTime: res.start,
            state: res.state,
            type: res.type
          });
        })["catch"](function (err) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'getInfo() - Cannot get conference info', logger));
        });
      });
    }
    /**
     * Moderator only : closes this conversations forcing every participant to leave
     *
     * @param {object} options
     * @return {Promise<void>}
     */

  }, {
    key: "close",
    value: function close() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      logger.debug('Closing ' + this.getName());
      return new Promise(function (resolve, reject) {
        if (_this3.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'close() - Conversation has to be joined to be closed', logger));
        } else if (_this3.getRole() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_MODERATOR) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_UNAUTHORIZED, 'close() - Role has to be moderator to close the conversation', logger));
        } else {
          _Conversation__WEBPACK_IMPORTED_MODULE_3__.cloudApi.closeConferenceInstance(_this3, _Conversation__WEBPACK_IMPORTED_MODULE_3__._mySession.get(_this3)).then(function () {
            logger.debug('Conversation closed successfully');
            _Conversation__WEBPACK_IMPORTED_MODULE_3__.apiRTCManager.dataClient.sendDataToGroup(_this3._getTechnicalName(), {
              event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_CLOSED_IDENTIFIER,
              instanceId: _this3.getInstanceId(),
              roomname: _this3._getTechnicalName()
            });

            _Conversation__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_this3).emit('closed');

            _this3.leave();

            resolve();
          })["catch"](function (err) {
            var errorMsg = 'close() - An error occured when closing conversation';
            var errorObj = {
              error: new Error(errorMsg),
              code: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER
            };
            logger.error(errorMsg, err);

            if (err.hasOwnProperty('code')) {
              errorObj.code = err.code;
            } else if (err.hasOwnProperty('http_code')) {
              errorObj.code = err.http_code.toString().startsWith('4') ? _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_UNAUTHORIZED : _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_SERVER_UNAVAILABLE;
            }

            reject(errorObj);
          });
        }
      });
    }
    /**
     * Invites a contact to this conversation.
     * @param {Contact} contact - The Contact to invite.
     * @param {object} options
     * @param {number} options.expirationTime - Time for an invite to expire after being sent
     * @return {SentInvitation}
     */

  }, {
    key: "sendInvitation",
    value: function sendInvitation(contact, options) {
      var _this4 = this;

      if (!options) {
        options = {};
      }

      if (!(contact instanceof _Contact__WEBPACK_IMPORTED_MODULE_5__.Contact)) {
        logger.error('Parameter is not a contact');
        return null;
      } else {
        logger.info('Invite ' + contact.getId() + ' to ' + this._getTechnicalName());

        if (!contact.isOnline()) {
          logger.warn('sendInvitation() - contact ' + contact.getUsername() + ' does not seem to be connected.');
        }

        var sentInvitationOptions = {
          receiveNotifier: new _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter()
        };

        if (options.hasOwnProperty('expirationTime')) {
          sentInvitationOptions.expirationTime = options.expirationTime;
        }

        var invitation = new _SentInvitation__WEBPACK_IMPORTED_MODULE_6__.SentInvitation(contact, this, sentInvitationOptions);
        var invitationData = {
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_INVITATION_IDENTIFIER,
          invitationId: invitation.id,
          roomname: this._getTechnicalName(),
          friendlyName: this.getFriendlyName(),
          sendTime: invitation.sendTime
        };
        invitation.type = 'conference';

        if (_Conversation__WEBPACK_IMPORTED_MODULE_3__._password.get(this) !== null) {
          // Add conversation password to invitation if known
          invitationData.password = _Conversation__WEBPACK_IMPORTED_MODULE_3__._password.get(this);
        }

        _Conversation__WEBPACK_IMPORTED_MODULE_3__.apiRTCManager.sendData(contact.getId(), invitationData).then(function () {
          sentInvitationOptions.receiveNotifier.emit('receive');
        })["catch"](function (errCode) {
          var newError = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(errCode, 'Invitation not delivered', logger);

          _Conversation__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_this4).emit('messageNotDelivered', {
            error: newError,
            contact: contact,
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_INVITATION_IDENTIFIER
          });
        });
        return invitation;
      }
    }
    /**
     * Returns the tags associated to the conference represented by this one.
     * @return {Promise<EnterpriseTag[]>} List of enterprise tags.
     */

  }, {
    key: "getTags",
    value: function getTags() {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        var session = _Session__WEBPACK_IMPORTED_MODULE_4__.Session.getActiveSession();

        if (!session) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_ALLOWED, 'getTags() - no session found', logger));
        }

        var enterprise = session.getUserAgent().getEnterprise();

        if (!enterprise) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_ALLOWED, 'getTags() - no enterprise found', logger));
        }

        enterprise.getTags(_this5).then(function (res) {
          var tags = [];

          for (var idx = 0; idx < res.length; idx += 1) {
            if (res[idx].selected === true) {
              tags.push(res[idx]);
            }
          } // for


          return resolve(tags);
        })["catch"](function (err) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_ALLOWED, 'getTags() - cannot get tags', logger, {
            fromError: err
          }));
        });
      });
    }
    /**
     * Sets the tags to the conference represented by this one.
     * @param {EnterpriseTag[]} List of enterprise tags.
     * @return {Promise}
     */

  }, {
    key: "setTags",
    value: function setTags(tags) {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        if (!Array.isArray(tags)) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'setTags() - wrong tags', logger));
        }

        if (!_this6.webconfId) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_ALLOWED, 'setTags() - no webconf found', logger));
        }

        var session = _Session__WEBPACK_IMPORTED_MODULE_4__.Session.getActiveSession();

        if (!session) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_ALLOWED, 'setTags() - no session found', logger));
        }

        var enterprise = session.getUserAgent().getEnterprise();

        if (!enterprise) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_ALLOWED, 'setTags() - no enterprise found', logger));
        }

        var token = session.getToken();

        if (!token) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_ALLOWED, 'setTags() - no token found', logger));
        }

        var tagIds = [];

        for (var tagIdx = 0; tagIdx < tags.length; tagIdx += 1) {
          if (!tags[tagIdx].hasOwnProperty('id')) {
            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'setTags() - wrong tags', logger));
          }

          tagIds.push(tags[tagIdx].id);
        } // for


        _Conversation__WEBPACK_IMPORTED_MODULE_3__.cloudApi.updateWebconfTags(enterprise.getId(), _this6.webconfId, tagIds, token).then(function () {
          return resolve();
        })["catch"](function (err) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'setTags() - cannot set tags', logger, {
            fromError: err
          }));
        });
      });
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return CONFERENCE_EVENTS;
    }
  }]);

  return Conference;
}(_Conversation__WEBPACK_IMPORTED_MODULE_3__.Conversation);

var getConferencePrefix = function getConferencePrefix() {
  return _Conversation__WEBPACK_IMPORTED_MODULE_3__.apiRTCManager.getActiveApiKey() + ':';
};



/***/ }),

/***/ "./src/public/Contact.js":
/*!*******************************!*\
  !*** ./src/public/Contact.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Contact": () => (/* binding */ Contact)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _utils_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Observable */ "./src/utils/Observable.js");
/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Stream */ "./src/public/Stream.js");
/* harmony import */ var _Conversation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Conversation */ "./src/public/Conversation.js");
/* harmony import */ var _DataChannel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DataChannel */ "./src/public/DataChannel.js");
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Session */ "./src/public/Session.js");
/* harmony import */ var _UserData__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./UserData */ "./src/public/UserData.js");
/* harmony import */ var _ReceivedConversationInvitation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ReceivedConversationInvitation */ "./src/public/ReceivedConversationInvitation.js");
/* harmony import */ var _ReceivedCallInvitation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ReceivedCallInvitation */ "./src/public/ReceivedCallInvitation.js");
/* harmony import */ var _ReceivedFileTransferInvitation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ReceivedFileTransferInvitation */ "./src/public/ReceivedFileTransferInvitation.js");
/* harmony import */ var _ReceivedDataChannelInvitation__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ReceivedDataChannelInvitation */ "./src/public/ReceivedDataChannelInvitation.js");
/* harmony import */ var _ReceivedWhiteboardInvitation__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ReceivedWhiteboardInvitation */ "./src/public/ReceivedWhiteboardInvitation.js");
/* harmony import */ var _SentInvitation__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./SentInvitation */ "./src/public/SentInvitation.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../private/ApiRTCManager */ "./src/private/ApiRTCManager.js");
/* harmony import */ var _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @apizee/cloudapi-js-sdk/CloudAPI */ "./node_modules/@apizee/cloudapi-js-sdk/CloudAPI.js");
/* harmony import */ var _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../private/ConversationCatalog */ "./src/private/ConversationCatalog.js");
/* harmony import */ var _private_CallCatalog__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../private/CallCatalog */ "./src/private/CallCatalog.js");
/* harmony import */ var _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../Core/BrowserInfo */ "./src/Core/BrowserInfo.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }







 //import {Call} from './Call';














var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_14__.Logger.get('Contact');
var apiRTCManager = _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_15__.ApiRTCManager.get();
var cloudApi = new _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_16__["default"]();
var callCatalog = _private_CallCatalog__WEBPACK_IMPORTED_MODULE_18__.CallCatalog.get();
var CONTACT_EVENTS = ['message', 'conversationInvitation', 'data', 'joinGroup', 'leaveGroup', 'whiteboardInvitation', 'fileSentSuccessfully', 'fileTransferInvitation', 'fileTransferProgress', 'dataChannelInvitation', 'incomingCall', 'newMediaAvailable', 'customEvent', 'fileTransferError', 'incomingScreenSharingCall', 'incomingScreenSharingCallInvitation']; //stream reference for 1-1 calls

var _loadedMessagesUUID = new WeakMap();

var _id = new WeakMap();

var contactSessionIdCache = new Map();
/**
 * Contact
 *
 * Designates another user which may or may not be currently connected
 *
 * @extends Observable
 * @fires Contact#message
 * @fires Contact#conversationInvitation
 * @fires Contact#dataChannelInvitation
 * @fires Contact#data
 * @fires Contact#joinGroup
 * @fires Contact#leaveGroup
 * @fires Contact#whiteboardInvitation
 * @fires Contact#fileSentSuccessfully
 * @fires Contact#fileTransferProgress
 * @fires Contact#fileTransferError
 * @fires Contact#newMediaAvailable
 * @fires Contact#customEvent
 * @fires Contact#incomingCall
 * @fires Contact#incomingScreenSharingCall
 * @fires Contact#incomingScreenSharingCallInvitation
 */

var Contact = /*#__PURE__*/function (_Observable) {
  _inherits(Contact, _Observable);

  var _super = _createSuper(Contact);

  /**
   * Receive message from contact event
   *
   * @event Contact#message
   * @type {object}
   * @property {string} content - content of the message
   * @property {integer} uuid - message unique id
   * @property {date} time - date of when the message was received
   */

  /**
   * Contact conversation invitation event
   *
   * @event Contact#conversationInvitation
   * @type {ReceivedConversationInvitation}
   */

  /**
   * Contact whiteboard invitation event
   *
   * @event Contact#whiteboardInvitation
   * @type {ReceivedWhiteboardInvitation}
   */

  /**
   * Contact file transfer invitation event
   *
   * @event Contact#fileTransferInvitation
   * @type {ReceivedFileTransferInvitation}
   */

  /**
   * Contact file transfer invitation event
   *
   * @event Contact#dataChannelInvitation
   * @type {ReceivedDataChannelInvitation}
   */

  /**
   * Fired when file was successfully sent to contact
   *
   * @event Contact#fileSentSuccessfully
   * @type {object}
   * @property {FileInfo} fileInfo
   * @property {TransferInformation} transferInformation
   */

  /**
   * Fired during file transfer
   *
   * @event Contact#fileTransferProgress
   * @type {object}
   * @property {FileInfo} fileInfo
   * @property {TransferInformation} transferInformation
   */

  /**
   * Fired during file transfer if an error occured
   *
   * @event Contact#fileTransferError
   * @type {object}
   * @property {object} error
   * @property {string} invitationId
   */

  /**
   * Fired when user receives an incoming call
   *
   * @event Contact#incomingCall
   * @type {ReceivedCallInvitation}
   */

  /**
   * Fired when user receives an incoming screenSharing call
   *
   * @event Contact#incomingScreenSharingCall
   * @type {Call}
   */

  /**
   * Fired when user receives an incoming screenSharing call Invitation
   *
   * @event Contact#incomingScreenSharingCallInvitation
   * @type {ReceivedCallInvitation}
   */

  /**
   * Receive data from contact event
   *
   * @event Contact#data
   * @type {object}
   */

  /**
   * When contact joins a group
   *
   * @event Contact#joinGroup
   * @type {string}
   */

  /**
   * When contact leaves a group
   *
   * @event Contact#leaveGroup
   * @type {string}
   */

  /**
   * When a new media has been pushed by the contact to the cloud and is available
   *
   * @event Contact#newMediaAvailable
   * @type {CloudMediaInfo}
   */

  /**
   * Fired when a custom data event has been received from the contact
   *
   * @event Contact#customEvent
   * @type {object}
   * @property {string} event event identifier
   * @property {object} content
   * @property {Conversation} conversation Associated conversation, field may not be present
   */

  /**
   * Creates a new contact
   *
   *  @param {string} id contact user id
   *  @param {Object} userData
   *  @returns {Contact} this
   */
  function Contact(id) {
    var _this;

    var userData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Contact);

    _this = _super.call(this, logger);
    logger.debug('Create Contact with id ' + id);
    logger.debug('Create Contact with userData :', userData);

    _id.set(_assertThisInitialized(_this), id.toString());

    _this.groups = [];
    _this.previousMessages = [];
    _this.userData = new _UserData__WEBPACK_IMPORTED_MODULE_7__.UserData(userData);
    _this.enterprise = null;
    _this.streams = new Map();
    _this.profile = null;
    _this.fileTransfers = [];
    _this.promises = [];

    _loadedMessagesUUID.set(_assertThisInitialized(_this), []);

    apiRTCManager.onEvent('roomInvitation', function (e) {
      if (e.detail.senderId !== null && e.detail.senderId !== undefined) {
        if (e.detail.roomType === 'whiteBoard' && e.detail.senderId.toString() === _this.getId()) {
          logger.info('Received whiteboard invitation from ' + _this.getUsername());
          var invitationOpts = {};

          if (e.detail.cloudConvId) {
            invitationOpts.cloudConvId = e.detail.cloudConvId;
          }

          if (e.detail.webconf === true) {
            invitationOpts.webconf = true;
          }

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('whiteboardInvitation', new _ReceivedWhiteboardInvitation__WEBPACK_IMPORTED_MODULE_12__.ReceivedWhiteboardInvitation(_assertThisInitialized(_this), e.detail.roomId, invitationOpts));
        }
      }
    }).onEvent('receiveIMMessage', function (e) {
      if (e.detail.senderId.toString() === _this.getId()) {
        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('message', {
          content: e.detail.message,
          uuid: e.detail.UUCSeq,
          time: e.detail.time
        });

        _this.addMessageToHistory(e.detail.message, Math.round(e.detail.time.getTime() / 1000), e.detail.UUCSeq, true);
      }
    })
    /*
                .onEvent('receiveRoomMessage', (e) => {
                    //logger.info('receiveRoomMessage event: ', e);
                })
    */
    .onEvent('receiveData', function (e) {
      if (e.detail.senderId.toString() === _this.getId()) {
        logger.debug('Received data e.detail.data : ', e.detail.data);
        var data = e.detail.data;
        var conversation = null;
        var conversationCatalog = _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_17__.ConversationCatalog.get(); // Check if conversation / conference is referenced in data

        if (typeof data.roomname !== 'undefined') {
          if (conversationCatalog.isConference(data.roomname)) {
            conversation = conversationCatalog.getOrCreateConference(conversationCatalog.getNameFromTechnicalName(data.roomname));
          } else {
            conversation = conversationCatalog.getOrCreateConversation(conversationCatalog.getNameFromTechnicalName(data.roomname));
          }
        }

        if (typeof data.event !== 'undefined') {
          switch (data.event) {
            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_PERSISTENT_DATA_UPDATE_IDENTIFIER:
            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER:
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_DATA_IDENTIFIER:
              logger.trace('Received data from ' + _this.getUsername(), data.content);

              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('data', data.content);

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_INVITATION_IDENTIFIER:
              if (conversation !== null) {
                logger.debug('Received conversation invitation from ' + _this.getId());
                var options = {};

                if (data.hasOwnProperty('password')) {
                  options.password = data.password;
                }

                _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('conversationInvitation', new _ReceivedConversationInvitation__WEBPACK_IMPORTED_MODULE_8__.ReceivedConversationInvitation(_assertThisInitialized(_this), data, conversation, options));
              }

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_FILEINFO_IDENTIFIER:
              logger.debug('Received file info from ' + _this.getUsername(), data.fileInfo);
              var callId = data.callId.toString();

              _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsFileInfo.set(callId, data.fileInfo);

              if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsOnHold.has(callId)) {
                var invitation = null;

                if (apiRTC.userAgentInstance.currentSession.invitationsMap.has(_this.getId() + '-sendfile-' + callId)) {
                  invitation = apiRTC.userAgentInstance.currentSession.invitationsMap.get(_this.getId() + '-sendfile-' + callId);
                  logger.debug('invitation already exist :', invitation);
                } else {
                  invitation = new _ReceivedFileTransferInvitation__WEBPACK_IMPORTED_MODULE_10__.ReceivedFileTransferInvitation(_assertThisInitialized(_this), callId, data.fileInfo);
                  apiRTC.userAgentInstance.currentSession.invitationsMap.set(_this.getId() + '-sendfile-' + callId, invitation);
                }

                _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('fileTransferInvitation', invitation);
              }

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_DATACHANNEL_INVITATION:
              logger.debug('Received datachannel invitation from ' + _this.getUsername());

              _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataChannelInvitations.set(data.callId.toString(), true);

              if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsOnHold.has(data.callId.toString())) {
                _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('dataChannelInvitation', new _ReceivedDataChannelInvitation__WEBPACK_IMPORTED_MODULE_11__.ReceivedDataChannelInvitation(_assertThisInitialized(_this), data.callId.toString()));
              }

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_NEW_MEDIA_IDENTIFIER:
              logger.debug('New media available from ' + _this.getUsername(), data.fileinfo);

              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('newMediaAvailable', {
                media: data.media
              });

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_EVENTCENTER_DATA_REQUEST:
              logger.debug('New request for event center data from ' + _this.getUsername());
              var storedData = apiRTC.eventCenter.getStoredData();

              if (storedData === undefined) {
                logger.error("Can't send event center stored data, it's undefined");
                return;
              }

              logger.debug('Sending requested event center data');

              _this.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_EVENTCENTER_DATA_ANSWER, {
                data: storedData
              });

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_EVENTCENTER_DATA_ANSWER:
              logger.debug('New event center data from ' + _this.getUsername());

              if (data.data === undefined) {
                logger.error("Can't handle remote event center data, it's undefined");
                return;
              }

              apiRTC.eventCenter.handleDataAnswer(data.data);
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_REMOTE_AUDIO_FLOW_STATUS_IDENTIFIER:
              logger.debug('New getAudioFlowStatus from ' + data.requesterId + ' on stream ' + data.streamId);

              var requestorRemoteAudio = _this.getContact(data.requesterId);

              var streamRemoteAudio = _this.getLocalStreamPublished();

              if (streamRemoteAudio === null) {
                return _this.sendToContactRemoteStreamError('No stream found on remote', requestorRemoteAudio, data);
              }

              requestorRemoteAudio.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_REMOTE_AUDIO_FLOW_STATUS_RESULT_IDENTIFIER, {
                callId: data.callId,
                streamId: data.streamId,
                timeout: data.timeout,
                audioFlowStatus: streamRemoteAudio.getAudioFlowStatus()
              });
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_REMOTE_VIDEO_FLOW_STATUS_IDENTIFIER:
              logger.debug('New getVideoFlowStatus from ' + data.requesterId + ' on stream ' + data.streamId);

              var requestorRemoteVideo = _this.getContact(data.requesterId);

              var streamRemoteVideo = _this.getLocalStreamPublished();

              if (streamRemoteVideo === null) {
                return _this.sendToContactRemoteStreamError('No stream found on remote', requestorRemoteVideo, data);
              }

              requestorRemoteVideo.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_REMOTE_VIDEO_FLOW_STATUS_RESULT_IDENTIFIER, {
                callId: data.callId,
                streamId: data.streamId,
                timeout: data.timeout,
                videoFlowStatus: streamRemoteVideo.getVideoFlowStatus()
              });
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_SETTINGS_IDENTIFIER:
              logger.debug('New getSettings from ' + data.requesterId);

              var requestorSettings = _this.getContact(data.requesterId);

              var streamSettings = _this.getLocalStreamPublished();

              if (streamSettings === null) {
                return _this.sendToContactRemoteStreamError('No stream found on remote', requestorSettings, data);
              }

              streamSettings.getSettings().then(function (settings) {
                requestorSettings.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_SETTINGS_RESULT_IDENTIFIER, {
                  callId: data.callId,
                  streamId: data.streamId,
                  timeout: data.timeout,
                  settings: settings
                });
              })["catch"](function (e) {
                _this.sendToContactRemoteStreamError(e.message, requestorSettings, data);
              });
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_CAPABILITIES_IDENTIFIER:
              logger.debug('New getCapabilities from ' + data.requesterId);

              var requestorCapabilities = _this.getContact(data.requesterId);

              var streamCapabilities = _this.getLocalStreamPublished();

              if (streamCapabilities === null) {
                return _this.sendToContactRemoteStreamError('No stream found on remote', requestorCapabilities, data);
              }

              streamCapabilities.getCapabilities().then(function (capabilities) {
                requestorCapabilities.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_CAPABILITIES_RESULT_IDENTIFIER, {
                  callId: data.callId,
                  streamId: data.streamId,
                  timeout: data.timeout,
                  capabilities: capabilities
                });
              })["catch"](function (e) {
                _this.sendToContactRemoteStreamError(e.message, requestorCapabilities, data);
              });
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_CONSTRAINTS_IDENTIFIER:
              logger.debug('New getConstraints from ' + data.requesterId);

              var requestorConstraints = _this.getContact(data.requesterId);

              var streamConstraints = _this.getLocalStreamPublished();

              if (streamConstraints === null) {
                return _this.sendToContactRemoteStreamError('No stream found on remote', requestorConstraints, data);
              }

              streamConstraints.getConstraints().then(function (constraints) {
                requestorConstraints.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_CONSTRAINTS_RESULT_IDENTIFIER, {
                  callId: data.callId,
                  streamId: data.streamId,
                  timeout: data.timeout,
                  constraints: constraints
                });
              })["catch"](function (e) {
                _this.sendToContactRemoteStreamError(e.message, requestorConstraints, data);
              });
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_APPLY_CONSTRAINTS_IDENTIFIER:
              var streamConstraintsSetRemotely = _this.getLocalStreamPublished();

              var requestorConstraintsSetRemotely = _this.getContact(data.requesterId);

              streamConstraintsSetRemotely.applyConstraints(data.constraints).then(function () {
                requestorConstraintsSetRemotely.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_APPLY_CONSTRAINTS_RESULT_IDENTIFIER, {
                  callId: data.callId,
                  streamId: data.streamId,
                  timeout: data.timeout
                });
              })["catch"](function (e) {
                _this.sendToContactRemoteStreamError(e.message, requestorConstraintsSetRemotely, data);
              });
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_REMOTE_AUDIO_FLOW_STATUS_RESULT_IDENTIFIER:
              logger.debug('getRemoteAudioFlowStatus result :', data);

              var streamRemoteAudioResult = _this.getRemoteStreamSubscribed(data.callId, data.streamId);

              if (streamRemoteAudioResult === null) {
                logger.error('Can\'t find the local stream to resolve the request..');
              } else {
                streamRemoteAudioResult.resolvePendingPromise(data.timeout, data.audioFlowStatus);
              }

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_REMOTE_VIDEO_FLOW_STATUS_RESULT_IDENTIFIER:
              logger.debug('getRemoteVideoFlowStatus result :', data);

              var streamRemoteVideoResult = _this.getRemoteStreamSubscribed(data.callId, data.streamId);

              if (streamRemoteVideoResult === null) {
                logger.error('Can\'t find the local stream to resolve the request..');
              } else {
                streamRemoteVideoResult.resolvePendingPromise(data.timeout, data.videoFlowStatus);
              }

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_SETTINGS_RESULT_IDENTIFIER:
              logger.debug('remote getSettings result :', data);

              var streamSettingsResult = _this.getRemoteStreamSubscribed(data.callId, data.streamId);

              if (streamSettingsResult === null) {
                logger.error('Can\'t find the local stream to resolve the request..');
              } else {
                streamSettingsResult.resolvePendingPromise(data.timeout, data.settings);
              }

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_CAPABILITIES_RESULT_IDENTIFIER:
              logger.debug('remote getCapabilities result :', data);

              var streamCapabilitiesResult = _this.getRemoteStreamSubscribed(data.callId, data.streamId);

              if (streamCapabilitiesResult === null) {
                logger.error('Can\'t find the local stream to resolve the request..');
              } else {
                streamCapabilitiesResult.resolvePendingPromise(data.timeout, data.capabilities);
              }

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_CONSTRAINTS_RESULT_IDENTIFIER:
              logger.debug('remote getConstraints result :', data);

              var streamConstraintsResult = _this.getRemoteStreamSubscribed(data.callId, data.streamId);

              if (streamConstraintsResult === null) {
                logger.error('Can\'t find the local stream to resolve the request..');
              } else {
                streamConstraintsResult.resolvePendingPromise(data.timeout, data.constraints);
              }

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_REMOTE_ERROR:
              logger.debug('remote stream request error:', data);

              var streamErrorResult = _this.getRemoteStreamSubscribed(data.callId, data.streamId);

              if (streamErrorResult === null) {
                logger.error('Can\'t find the local stream to reject the request..');
              } else {
                streamErrorResult.rejectPendingPromise(data.timeout, data.message);
              }

              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_APPLY_CONSTRAINTS_RESULT_IDENTIFIER:
              logger.debug('remote applyConstraints result :', data);

              var streamApplyConstraintsResult = _this.getRemoteStreamSubscribed(data.callId, data.streamId);

              if (streamApplyConstraintsResult === null) {
                logger.error('Can\'t find the local stream to resolve the request..');
              } else {
                streamApplyConstraintsResult.resolvePendingPromise(data.timeout, data.constraints);
              }

              break;

            default:
              var eventData = {
                event: data.event,
                content: data
              };

              if (conversation !== null) {
                eventData.conversation = conversation;
              }

              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('customEvent', eventData);

              break;
          }
        }
      }
    }).onEvent('incomingCall', function (e) {
      if (e.detail.callerId.toString() === _this.getId()) {
        var callId = e.detail.callId.toString();

        if (e.detail.callType === 'data') {
          // Datachannel
          logger.debug('Received file transfer invitation from ' + _this.getUsername());

          if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsFileInfo.has(callId)) {
            var fileInfo = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsFileInfo.get(callId);

            var invitation = null;

            if (apiRTC.userAgentInstance.currentSession.invitationsMap.has(_this.getId() + '-sendfile-' + callId)) {
              invitation = apiRTC.userAgentInstance.currentSession.invitationsMap.get(_this.getId() + '-sendfile-' + callId);
              logger.debug('invitation already exist :', invitation);
            } else {
              invitation = new _ReceivedFileTransferInvitation__WEBPACK_IMPORTED_MODULE_10__.ReceivedFileTransferInvitation(_assertThisInitialized(_this), callId, fileInfo);
              apiRTC.userAgentInstance.currentSession.invitationsMap.set(_this.getId() + '-sendfile-' + callId, invitation);
            }

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('fileTransferInvitation', invitation);
          } else if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataChannelInvitations.has(callId)) {
            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('dataChannelInvitation', new _ReceivedDataChannelInvitation__WEBPACK_IMPORTED_MODULE_11__.ReceivedDataChannelInvitation(_assertThisInitialized(_this), callId));
          } else {
            logger.info('File information has not been received yet, putting invitation on hold');

            _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsOnHold.set(callId);
          }
        } else if (e.detail.callType === 'screenSharing') {
          if (apiRTC.session.apiCCWebRTCClient.webRTCClient.userAcceptOnIncomingScreenSharingCall === true) {
            logger.debug('Received screenSharingCallInvitation from ' + _this.getUsername());

            var _invitation = new _ReceivedCallInvitation__WEBPACK_IMPORTED_MODULE_9__.ReceivedCallInvitation(_assertThisInitialized(_this), callId, e.detail.callType, {
              isRecorded: e.detail.hasOwnProperty('recordedCall') ? e.detail.recordedCall : false
            });

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('incomingScreenSharingCallInvitation', _invitation);
          } else {
            logger.debug('Received screenSharingCall from ' + _this.getUsername());
            var call = callCatalog.getOrCreateCall(callId, _assertThisInitialized(_this), {
              started: true,
              isRecorded: e.detail.hasOwnProperty('recordedCall') ? e.detail.recordedCall : false
            });

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('incomingScreenSharingCall', call);
          }
        } else {
          // Standard call
          logger.info('Received call invitation from ' + _this.getUsername());

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('incomingCall', new _ReceivedCallInvitation__WEBPACK_IMPORTED_MODULE_9__.ReceivedCallInvitation(_assertThisInitialized(_this), callId, e.detail.callType, {
            isRecorded: e.detail.hasOwnProperty('recordedCall') ? e.detail.recordedCall : false
          }));
        }
      }
    }).onEvent('hangup', function (e) {
      var callId = e.detail.callId.toString();
      /*
                      if (this.getId() ===  e.detail.remoteId.toString() && this.fileTransfers.includes(callId)) {
                          logger.info('File transfer finished from ' + this.getUsername());
                          this.fileTransfers.splice(this.fileTransfers.indexOf(callId), 1);
                      }
      */

      if (_this.getId() === e.detail.remoteId.toString()) {
        logger.debug('hangup event :', e.detail);

        if (_this.fileTransfers.includes(callId)) {
          logger.info('File transfer finished from ' + _this.getUsername());

          _this.fileTransfers.splice(_this.fileTransfers.indexOf(callId), 1);
        }
      }
    }).onEvent('sendDataChannelError', function (e) {
      var callId = e.detail.callId.toString();

      if (_this.getId() === e.detail.remoteId.toString() && _this.fileTransfers.includes(callId)) {
        logger.info('File transfer error from ' + _this.getUsername());

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('fileTransferError', {
          error: 'sendDataChannelError',
          invitationId: callId
        });
      }
    }).onEvent('fetchUserDataAnswer', function (e) {
      if (_this.getId() === e.detail.id.toString()) {
        _this.userData = new _UserData__WEBPACK_IMPORTED_MODULE_7__.UserData(e.detail.userData);

        _this.promises.forEach(function (promise) {
          if (e.detail.timeout === promise.timeout) {
            clearTimeout(promise.timeout);
            promise.resolve(e.detail.userData);
          }
        });
      }
    });
    return _this;
  }
  /**
   * Returns available events for this class
   *
   *  @returns {Array<string>}
   */


  _createClass(Contact, [{
    key: "getId",
    value:
    /**
     * Returns contact's user id
     *
     *  @returns {string} Contact id
     */
    function getId() {
      return _id.get(this);
    }
  }, {
    key: "id",
    get: function get() {
      logger.warn('contact.id is deprecated, please use contact.getId() instead');
      return this.getId();
    }
    /**
     * Returns contact's cloud profile information
     * Profile information is accessible whether contact is online or offline as long as they have created an account
     *  @param {string} bearerToken cloud bearerToken
     *  @param {Boolean} forceUpdate forces profile update; optional, defaults to false
     *  @returns {Promise<object>} Profile information in promise
     */

  }, {
    key: "fetchProfileInformation",
    value: function fetchProfileInformation(bearerToken) {
      var _this2 = this;

      var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return new Promise(function (resolve, reject) {
        if (_this2.profile !== null && !forceUpdate) {
          // Get profile from cache
          resolve(_this2.profile);
        } else {
          cloudApi.getUserProfile(apiRTCManager.getActiveApiKey(), _this2.getId(), bearerToken).then(function (res) {
            _this2.profile = res;
            resolve(res);
          })["catch"](reject);
        }
      });
    }
    /**
     * Returns contact's active streams
     *
     *  @returns {Stream[]} Contact active streams
     */

  }, {
    key: "getActiveStreams",
    value: function getActiveStreams() {
      return this.streams;
    }
    /**
     * Set contact's active streams
     *
     *  @ignore
     *  @param {Stream} stream Stream instance
     */

  }, {
    key: "setActiveStreams",
    value: function setActiveStreams(stream) {
      this.streams.set(stream.getId(), stream);
    }
  }, {
    key: "getLocalStreamWithCallId",
    value: function getLocalStreamWithCallId(callId) {
      var result = null;
      var streams = _Stream__WEBPACK_IMPORTED_MODULE_3__.Stream.getLocalStreams();
      var nextStream = streams.next();

      while (!nextStream.done) {
        var stream = nextStream.value;
        var conversations = stream.publishedInConversations.values();
        var nextConv = conversations.next();

        while (!nextConv.done) {
          var convId = nextConv.value;

          if (convId === callId) {
            result = stream;
          }

          nextConv = conversations.next();
        }

        nextStream = streams.next();
      }

      return result;
    }
    /**
     * Helper to add a new message to this contact's conversation history
     *
     * @ignore
     * @param {string} content
     * @param {number} timestamp
     * @param {string} uuid
     * @param {Boolean} fromContact
     * @returns {Void}
     */

  }, {
    key: "addMessageToHistory",
    value: function addMessageToHistory(content, timestamp, uuid, fromContact) {
      if (_loadedMessagesUUID.get(this).indexOf(uuid.toString()) === -1) {
        this.previousMessages.push({
          content: content,
          timestamp: timestamp,
          uuid: uuid,
          fromContact: fromContact
        });

        _loadedMessagesUUID.get(this).push(uuid.toString());
      }
    }
    /**
     * @typedef ConversationMessage
     * @type {Object}
     * @property {string} content
     * @property {number} timestamp
     * @property {string} uuid
     * @property {Boolean} fromContact
     */

    /**
     * Returns contact's previous messages
     *
     *  @returns {ConversationMessage[]} previous conversation messages
     */

  }, {
    key: "getPreviousMessages",
    value: function getPreviousMessages() {
      // Sort previousMessages using their timestamps
      this.previousMessages.sort(function (a, b) {
        return new Date(b.timestamp) - new Date(a.timestamp);
      });
      return this.previousMessages;
    }
    /**
     * Returns contact's user data
     *
     *  @returns {Object} contact's userdata
     */

  }, {
    key: "getUserData",
    value: function getUserData() {
      return this.userData;
    }
    /**
     * To use on a disconnected contact : returns contact's user data
     *
     *  @returns {Object} contact's userdata
     */

  }, {
    key: "fetchUserData",
    value: function fetchUserData() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        var rejectFn = function rejectFn() {
          reject('Timeout error during fetchUserData() process');
        };

        var timeout = setTimeout(rejectFn, 5000);

        _this3.promises.push({
          timeout: timeout,
          resolve: resolve
        });

        apiRTC.session.fetchUserData({
          apiKey: apiRTCManager.getActiveApiKey(),
          id: _this3.getId(),
          timeout: timeout
        });
      });
    }
    /**
     * Returns contact's username
     *
     *  @returns {string} contact's username
     */

  }, {
    key: "getUsername",
    value: function getUsername() {
      if (this.userData.get('username') !== null) {
        return this.userData.get('username');
      } else if (this.userData.get('nickname') !== null) {
        return this.userData.get('nickname');
      } else {
        return this.getId();
      }
    }
    /**
     * Returns contact's photo url
     *
     *  @returns {string} contact's photo url
     */

  }, {
    key: "getPhotoUrl",
    value: function getPhotoUrl() {
      if (this.userData.get('photo_url') !== null) {
        return this.userData.get('photo_url');
      } else if (this.userData.get('photoUrl') !== null) {
        return this.userData.get('photoUrl');
      } else {
        return null;
      }
    }
    /**
     * @typedef WebSessionInfo
     * @type {Object}
     * @property {string} webSessionId
     * @property {string} conversationId
     * @property {string} siteKey
     */

    /**
     * Fetches webSession information for this contact from cloud
     *
     *  @param {Session} session
     *  @returns {Promise<WebSessionInfo>} Web session information in promise
     */

  }, {
    key: "fetchWebSessionInformation",
    value: function fetchWebSessionInformation(session) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (!(session instanceof _Session__WEBPACK_IMPORTED_MODULE_6__.Session)) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'fetchWebSessionInformation() - parameter is not an instance of apiRTC.Session', logger));
        } else if (contactSessionIdCache.has(_this4.getId() + ':' + session.getId())) {
          // Cache system
          resolve(contactSessionIdCache.get(_this4.getId() + ':' + session.getId()));
        } else {
          cloudApi.getWebSession(session, _this4, apiRTCManager.getActiveApiKey()).then(function (webSessionInfo) {
            // Save to cache
            contactSessionIdCache.set(_this4.getId() + ':' + session.getId(), webSessionInfo);
            resolve(webSessionInfo);
          })["catch"](function (err) {
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'fetchWebSessionInformation() - could not fetch web session information', logger));
          });
        }
      });
    }
    /**
     * @typedef SessionHistoryOptions
     * @type {Object}
     * @property {number} count optional : How many messages shold be fetched
     * @property {number} lastMessTimestamp optional : Date to fetch messages from
     * @property {number} lastUUID optional : first message uuid to fetch from
     * @property {Boolean} onlyDestMessage optional : only fetch messages sent by contact
    */

    /**
     * Loads message history for this contact from cloud
     *
     *  @param {Session} session
     *  @param {SessionHistoryOptions} options
     *  @returns {Promise<void>}
     */

  }, {
    key: "loadMessageHistory",
    value: function loadMessageHistory(session) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        _this5.fetchWebSessionInformation(session).then(function (webSessionInfo) {
          return cloudApi.getSessionHistory(webSessionInfo.webSessionId, session.getToken(), options);
        }).then(function (res) {
          logger.debug('loadMessageHistory() - got messages', res.messages);

          var _iterator = _createForOfIteratorHelper(res.messages),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var message = _step.value;

              _this5.addMessageToHistory(message.value, message.timestamp, message.uuid, message.destId.toString() !== _this5.getId());
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          resolve();
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'loadMessageHistory() - could not load session history', logger));
        });
      });
    }
    /**
     *  Adds contact to group (private)
     *
     *  @private
     *  @param {String} group
     *  @returns {Void}
     */

  }, {
    key: "addToGroup",
    value: function addToGroup(group) {
      if (!this.inGroup(group)) {
        this.groups.push(group);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('joinGroup', group);
      }
    }
    /**
     * Removes contact from group (private)
     *
     *  @private
     *  @param {String} group
     *  @returns {Void}
     */

  }, {
    key: "removeFromGroup",
    value: function removeFromGroup(group) {
      if (this.inGroup(group)) {
        this.groups.splice(this.groups.indexOf(group), 1);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('leaveGroup', group);
      }
    }
    /**
     * Checks whether the contact is known to be inside a group
     *
     *  @param {String} group
     *  @returns {Boolean}
     */

  }, {
    key: "inGroup",
    value: function inGroup(group) {
      return this.groups.includes(group);
    }
    /**
     * Checks whether the contact is online or not
     * NOTE : A contact will be shown online only if it is currently in a group subscribed by the user
     *
     *  @returns {Boolean}
     */

  }, {
    key: "isOnline",
    value: function isOnline() {
      return this.groups.length !== 0;
    }
    /**
     * Sends data message to contact, prefer the use of Contact.sendFile() in case of large data objects
     *
     *  @param {Object} data data to send
     *  @returns {Promise<void>}
     */

  }, {
    key: "sendData",
    value: function sendData(data) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this.isOnline()) {
        logger.warn('sendData() - contact ' + this.getUsername() + ' does not seem to be connected.');
      }

      return new Promise(function (resolve, reject) {
        apiRTCManager.sendData(_this6.getId(), {
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_DATA_IDENTIFIER,
          content: data
        }).then(resolve)["catch"](function (err) {
          switch (err) {
            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT, 'sendData() - Data transmission timed out ', logger));
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND, 'sendData() - Contact was not found ', logger));
              break;

            default:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendData() - Data transmission timed out ', logger));
              break;
          }
        });
      });
    }
    /**
     * This function start all remote control process on contact.
     * 
     * @param {number} id_contact contact id of controller contact
     * @param {object} conv actual conversation 
     * @returns {Promise<void>} 
     */

  }, {
    key: "sendRemoteControlInvitation",
    value: function sendRemoteControlInvitation(id_contact, conv) {
      var _this7 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var sendOptions;
      var pathToConsoleTest = "http://localhost:5501/document/aic_agent_signed.exe";
      var pathToConsole = "https://cdn.apizee.com/apiRTC/aic-console.exe";
      return new Promise(function (resolve, reject) {
        if (!_this7.isOnline()) {
          reject("sendRemoteControlInvitation() - contact " + _this7.getUsername() + " must be connected");
        } //TEST LES OPTIONS
        //  SEND DOWNLOAD APP


        if (Object.keys(options).length === 0) {
          if (conv) {
            sendOptions = {
              event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_REMOTE_CONNECTION_APP,
              content: pathToConsoleTest,
              contactID: id_contact,
              convName: conv.getName()
            };
          } else {
            reject("sendRemoteControlInvitation() - Argument not valids");
          }
        } else {
          //  SEND DATA COMMAND
          sendOptions = {
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_DATA_COMMAND,
            content: options
          };
        }

        apiRTCManager.sendData(_this7.getId(), sendOptions).then(function () {
          resolve();
        })["catch"](function (err) {
          switch (err) {
            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT, 'sendRemoteControlInvitation() - App transmission timed out ', logger));
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND, 'sendRemoteControlInvitation() - Contact was not found ', logger));
              break;

            default:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendRemoteControlInvitation() - Data transmission timed out by unthrow error ' + err, logger));
              break;
          }
        }); //resolve
      });
    }
    /**
     * Work with sendRemoteControlInvitation - callback send to agent the client screen resolution and the remote stream id
     * 
     * @ignore
     * @param {Object} screenResolution 
     * @param {number} streamID 
     * @param {Object} options 
     * @returns {Promise<void>}
     */

  }, {
    key: "sendRemoteControlInvitationCallback",
    value: function sendRemoteControlInvitationCallback(screenResolution, streamID, id_client) {
      var _this8 = this;

      if (!this.isOnline()) {
        logger.warn('sendRemoteControlInvitationcallback() - contact ' + this.getUsername() + ' does not seem to be connected.');
      }

      return new Promise(function (resolve, reject) {
        apiRTCManager.sendData(_this8.getId(), {
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_REMOTE_CONNECTION_APP_CALLBACK,
          content: screenResolution,
          id: streamID,
          id_client: id_client
        }).then(function () {
          resolve();
        })["catch"](function (err) {
          switch (err) {
            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT, 'sendRemoteControlInvitationCallback() - Data transmission timed out ', logger));
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND, 'sendRemoteControlInvitationCallback() - Contact was not found ', logger));
              break;

            default:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendRemoteControlInvitationCallback() - Data transmission timed out by unknonwn error', logger));
              break;
          }
        });
      });
    }
    /**
     * Sends custom data event to contact
     *
     *  @param {string} event event key
     *  @param {Object} content data to send
     *  @returns {Promise<void>}
     */

  }, {
    key: "sendCustomEvent",
    value: function sendCustomEvent(event) {
      var _this9 = this;

      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this.isOnline()) {
        logger.warn('sendCustomEvent() - contact ' + this.getUsername() + ' does not seem to be connected.');
      }

      return new Promise(function (resolve, reject) {
        var data = content;
        data.event = event;
        apiRTCManager.sendData(_this9.getId(), data).then(resolve)["catch"](function (err) {
          switch (err) {
            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT, 'sendCustomEvent() - Data transmission timed out ', logger));
              break;

            case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND, 'sendCustomEvent() - Contact was not found ', logger));
              break;

            default:
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendCustomEvent() - Data transmission timed out ', logger));
              break;
          }
        });
      });
    }
    /**
     * @typedef sendMessageOptions
     * @type {Object}
     * @property {Session} session Set this option to save messages in cloud
     */

    /**
     * Sends string message to contact
     *
     *  @param {String} message message to send
     *  @param {sendMessageOptions} options
     *  @returns {Promise<number>} Sent message uuid in promise
     */

  }, {
    key: "sendMessage",
    value: function sendMessage(message) {
      var _this10 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this.isOnline()) {
        logger.warn('sendMessage() - contact ' + this.getUsername() + ' does not seem to be connected.');
      }

      var sendMessageOptions = null; // Helper promise for getting apiRTC sendmessage options

      var getSendMessageOptions = function getSendMessageOptions() {
        return new Promise(function (resolve, reject) {
          if (options.hasOwnProperty('session')) {
            _this10.fetchWebSessionInformation(options.session).then(function (webSessionInfo) {
              resolve({
                save: true,
                cloudSessionId: webSessionInfo.webSessionId,
                //convId: webSessionInfo.conversationId,
                apiRTCId: options.session.getId()
              });
            })["catch"](reject);
          } else {
            resolve({});
          }
        });
      };

      return new Promise(function (resolve, reject) {
        if (typeof message !== 'string') {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'sendMessage() - message parameter is not instance of string', logger));
        } else {
          getSendMessageOptions().then(function (opts) {
            sendMessageOptions = opts;
            logger.info('sendMessage() - with options :', sendMessageOptions);
            return apiRTCManager.sendMessage(_this10.getId(), message, sendMessageOptions);
          }, function (err) {
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendMessage() - Error occured when fetching options for sending message', logger));
          }).then(function (UUCSeq) {
            _this10.addMessageToHistory(message, Math.floor(Date.now() / 1000), UUCSeq, false);

            resolve(UUCSeq);
          }, function (err) {
            switch (err) {
              case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT:
                reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT, 'sendMessage() - Data transmission timed out ', logger));
                break;

              case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND:
                reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND, 'sendMessage() - Contact was not found ', logger));
                break;

              default:
                reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendMessage() - Data transmission timed out ', logger));
                break;
            }
          });
        }
      });
    }
    /**
     * Invites the contact to a conversation
     *
     *  @param {Conversation} conversation
     *  @param {Object} options
     *  @returns {SentInvitation}
     */

  }, {
    key: "inviteTo",
    value: function inviteTo(conversation) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.sendConversationInvitation(conversation, options);
    }
    /*
     * DEPRECATED IN API : inviteTo() is prefered
     * Invites the contact to a conversation
     *
     *  @param {Conversation} conversation
     *  @param {Object} options
     *  @returns {SentInvitation}
     */

  }, {
    key: "sendConversationInvitation",
    value: function sendConversationInvitation(conversation) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!(conversation instanceof _Conversation__WEBPACK_IMPORTED_MODULE_4__.Conversation)) {
        logger.error('sendConversationInvitation() - Parameter is not a conversation');
        return null;
      } else {
        return conversation.sendInvitation(this, options);
      }
    }
    /**
     * Invites the contact to a whiteboard session
     *
     * @param {string} roomId - Whiteboard room id
     * @param {object} options
     * @param {object} options.context
     * @param {string} options.cloudConversationId - Cloud Conversation ID (if any).
     * @return {SentInvitation}
     */

  }, {
    key: "sendWhiteboardInvitation",
    value: function sendWhiteboardInvitation(roomId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (apiRTCManager.whiteBoardClient.roomId !== roomId) {
        apiRTCManager.whiteBoardClient.leaveRoom();
        apiRTCManager.whiteBoardClient.start();
        apiRTCManager.whiteBoardClient.joinRoom(roomId);
      }

      var context = options.context ? options.context : null;
      var opts = {};

      if (options.cloudConversationId) {
        opts.convId = options.cloudConversationId;
      }

      apiRTCManager.whiteBoardClient.inviteInRoom(roomId, this.getId(), context, opts);
      var invitation = new _SentInvitation__WEBPACK_IMPORTED_MODULE_13__.SentInvitation(this, null);
      invitation.id = 'wb-' + roomId;
      invitation.type = 'whiteboard';
      return invitation;
    }
    /**
     * @typedef CallOptions
     * @type {Object}
     *
     * @property {Boolean} audioOnly sets the call to audio only, defaults to false
     * @property {String} mediaTypeForOutgoingCall This enables to choose the media type to establish a call.
     * Value can be : VIDEO (audio and video will be used to establish call), AUDIO (audio only), VIDEOONLY, NONE (establishing call without sharing any media)
     * @property {String} mediaRoutingMode This enables to choose the media routing mode.
     * Value can be : hostOnly, stun, stunOnly, turn, turnOnly
     * @property {String} turnServerAddress This enables to change the turn server used for the call
     * @property {Boolean} record True to activate the call recording on server side
     * @property {String} muted This parameter enables to start a muted call.
     * Value can be : VIDEO (audio and video will be muted), AUDIOONLY (only audio will be muted), VIDEOONLY (only video will be muted)
     * @property {String} cloudConversationId - Set Cloud Conversation ID.
     * @property {Boolean} preferVP9Codec True to activate VP9 as preferred codec
     */

    /**
     * Invites the contact to a 1-1 call
     *
     *  @param {Stream} stream Optional, if set the stream will be used during the call, otherwise it will be generated and it will be available through the Call#localStreamAvailable event
     *  @param {CallOptions} options
     *  @returns {Call}
     */

  }, {
    key: "call",
    value: function call(stream) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        mediaTypeForOutgoingCall: 'VIDEO',
        record: false
      };

      if (!this.isOnline()) {
        logger.warn('call() - contact ' + this.getUsername() + ' does not seem to be connected.');
      }

      var callId;
      var data = {};
      var callConfiguration = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject({}, options);
      var audioOnly = options.hasOwnProperty('audioOnly') ? options.audioOnly : false;

      if (options.hasOwnProperty('record')) {
        if (callConfiguration.record === undefined || callConfiguration.record === null) {
          callConfiguration.record = options.record;
        }
      } // Stream management


      if (stream !== null && stream instanceof _Stream__WEBPACK_IMPORTED_MODULE_3__.Stream) {
        callConfiguration.userMediaStreamId = stream.userMediaStreamId;

        if (stream.isScreensharing()) {
          callConfiguration.forceCallType = 'screenSharing';
        }
      } // cloudConversationId


      if (callConfiguration.cloudConversationId) {
        data.cloudConvId = callConfiguration.cloudConversationId;
        delete callConfiguration.cloudConversationId;
      } // Start apiRTC call


      if (audioOnly) {
        callId = apiRTCManager.webRTCClient.callAudio(this.getId(), data, callConfiguration);
      } else {
        callId = apiRTCManager.webRTCClient.call(this.getId(), data, callConfiguration);
      }

      var call = callCatalog.getOrCreateCall(callId, this, {
        isRecorded: callConfiguration.record
      });
      return call;
    }
    /**
     * @typedef ShareScreenOptions
     * @type {Object}
     *
     * @property {JSON} captureSourceType This enables to choose what the user will be propose to share between screen, applications, browser tab and audio.
     * Usage is different depending the browser :
     * - on Chrome, captureSourceTypevalue value is an array that can be ["screen", "window", "tab", "audio"]. This array is used to restrict what will be proposed to the user
     * - on Firefox, captureSourceTypevalue value is a string that can be "screen", "window" or "application". This string is used to choose what will be proposed to the user
     */

    /**
     * Share screen
     *
     *  @param {ShareScreenOptions} options
     *  @returns {Call}
     */

  }, {
    key: "shareScreen",
    value: function shareScreen() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.isOnline()) {
        logger.warn('call() - contact ' + this.getUsername() + ' does not seem to be connected.');
      }

      var data = {},
          callId = null,
          callConfiguration = options,
          captureSourceType = options.captureSourceType;
      logger.warn('call() - contact ' + this.getUsername() + ' does not seem to be connected.');
      callId = apiRTCManager.webRTCClient.shareScreen(this.getId(), data, captureSourceType);
      var call = callCatalog.getOrCreateCall(callId, this, {
        isRecorded: callConfiguration.record
      });
      return call;
    }
    /**
     * Invites the contact to a data channel session
     *
     *  @param {Object} options
     *  @returns {DataChannel}
     */

  }, {
    key: "startDataChannel",
    value: function startDataChannel() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.isOnline()) {
        logger.warn('startDataChannel() - contact ' + this.getUsername() + ' does not seem to be connected.');
      }

      if (_Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_19__.browser === 'Edge' && _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_19__.browser_major_version < 79) {
        logger.warn('Cannot startDataChannel as it is not supported on Edge');
        return;
      }

      var callId = apiRTCManager.webRTCClient.startDataChannel(this.getId()); // Send invitation

      apiRTCManager.sendData(this.getId(), {
        callId: callId,
        event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_DATACHANNEL_INVITATION
      });
      var dataChannel = new _DataChannel__WEBPACK_IMPORTED_MODULE_5__.DataChannel(callId, this, {
        type: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_TYPE_SEND
      });
      return dataChannel;
    }
    /**
     * @typedef FileInfo
     * You can add additionnal fields if you need to
     * @type {Object}
     * @property {String} name
     * @property {String} type
     */

    /**
     * @typedef TransferInformation
     * @type {Object}
     * @property {string} uuid file identifier
     * @property {number} fileSize total size of the file being transfered
     * @property {number} remainingSize remaining data size to be transfered
     * @property {number} percentage progress percentage of the transfer
     * @property {number} sendChunkNb transfer chunk number
     * @property {number} transferDuration current duration of the transfer
     * @property {boolean} lastPacket is this the last packet?
     */

    /**
     * Invites the contact to a file transfer and sends the data once the contact accepts
     *
     *  @param {FileInfo} fileInfo relevant file information for the contact
     *  @param {any} data Data to be sent
     *  @returns {SentInvitation} or null if an error occured
     */

  }, {
    key: "sendFile",
    value: function sendFile(fileInfo, data) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!this.isOnline()) {
        logger.warn('sendFile() - contact ' + this.getUsername() + ' does not seem to be connected.');
      }

      if (_Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_19__.browser === 'Edge' && _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_19__.browser_major_version < 79) {
        logger.warn('Cannot sendFile as Datachannel is not supported on Edge');
        return null;
      }

      var callId = apiRTCManager.webRTCClient.startDataChannel(this.getId());
      var self = this;

      if (callId === undefined) {
        logger.warn('Error on startDataChannel');
        return null;
      } // Send file information


      apiRTCManager.sendData(this.getId(), {
        fileInfo: fileInfo,
        callId: callId,
        event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_FILEINFO_IDENTIFIER
      }); // Manage data channel for single file transfer

      var sendDataChannelOpenHandler = function sendDataChannelOpenHandler(e) {
        logger.debug('sendFile() - DataChannel open', e.detail);

        if (e.detail.callId.toString() === callId.toString()) {
          apiRTCManager.webRTCClient.sendDataWithCallId(callId, {
            "file": data,
            "name": fileInfo.name,
            "type": fileInfo.type
          }, function (progress) {
            logger.trace('sendFile() - progress : ', progress);
            var transferInformation = {
              uuid: progress.uuid,
              fileSize: progress.fileSize,
              remainingSize: progress.remainingSize,
              percentage: progress.percentage,
              sendChunkNb: progress.sendChunkNb,
              transferDuration: progress.transferDuration,
              lastPacket: progress.lastPacket
            };

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(self).emit('fileTransferProgress', {
              fileInfo: fileInfo,
              transferInformation: transferInformation
            });

            if (progress.transferEnded) {
              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(self).emit('fileSentSuccessfully', {
                fileInfo: fileInfo,
                transferInformation: transferInformation
              });
            }
          });
          apiRTCManager.removeEventListener('sendDataChannelOpen', sendDataChannelOpenHandler);
        }
      };

      apiRTCManager.onEvent('sendDataChannelOpen', sendDataChannelOpenHandler);
      this.fileTransfers.push(callId.toString());
      var invitation = new _SentInvitation__WEBPACK_IMPORTED_MODULE_13__.SentInvitation(this, null);
      invitation.id = callId.toString();
      invitation.type = 'sendFile';
      invitation.on('response', function () {
        if (invitation.getStatus() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ACCEPTED) {
          logger.log('sendFile() - invitation has not been accepted, cleaning listeners');
        }
      });
      return invitation;
    }
    /**
     * Pushes media to be shared with this contact via the cloud
     *
     *  @param {string} media dataURI media
     *  @param {Session} session
     *  @param {object} options
     *  @returns {Promise<CloudMediaInfo>}
     */

  }, {
    key: "pushMedia",
    value: function pushMedia(media, session) {
      var _this11 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return new Promise(function (resolve, reject) {
        _this11.fetchWebSessionInformation(session).then(function (webSessionInfo) {
          options.token = session.token;
          return cloudApi.pushConversationMedia(webSessionInfo.conversationId, media, apiRTCManager.getActiveApiKey(), options);
        }).then(function (res) {
          apiRTCManager.sendData(_this11.getId(), {
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_NEW_MEDIA_IDENTIFIER,
            media: {
              url: res.url,
              id: res.id
            }
          });
          resolve({
            url: res.url,
            id: res.id
          });
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'pushMedia() - failed to push media', logger));
        });
      });
    }
    /**
     * Fetches media shared with this contact via the cloud
     *
     *  @param {Session} session
     *  @param {object} options
     *  @returns {Promise<Array<object>>} mediaList in promise
     */

  }, {
    key: "fetchMediaList",
    value: function fetchMediaList(session) {
      var _this12 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      logger.debug('fetchMediaList()');
      return new Promise(function (resolve, reject) {
        _this12.fetchWebSessionInformation(session).then(function (webSessionInfo) {
          options.token = session.getToken();
          return cloudApi.getConversationMediaList(webSessionInfo.conversationId, apiRTCManager.getActiveApiKey(), options);
        }).then(resolve)["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'getMediaList() - failed to get media list', logger));
        });
      });
    }
    /**
     * Sends request to retrieve contact's event center records.
     * Answer comes as CONTACT_EVENTCENTER_DATA_ANSWER event
     * @returns {Promise<void>}
     */

  }, {
    key: "sendEventCenterDataRequest",
    value: function sendEventCenterDataRequest() {
      return this.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_EVENTCENTER_DATA_REQUEST);
    } // assuming the user only have 1 active published stream

  }, {
    key: "getLocalStreamPublished",
    value: function getLocalStreamPublished() {
      var streams = _Stream__WEBPACK_IMPORTED_MODULE_3__.Stream.getLocalStreams();
      var st = streams.next();

      if (st.value === undefined) {
        return null;
      }

      return st.value;
    }
  }, {
    key: "getRemoteStreamSubscribed",
    value: function getRemoteStreamSubscribed(callId, streamId) {
      var callSubsc = _Session__WEBPACK_IMPORTED_MODULE_6__.Session.getActiveSession().getCall(callId);

      if (callSubsc) {
        logger.debug('remote stream is associated to a call');
        var settingsStreams = callSubsc.getReceivedStreams();

        var _iterator2 = _createForOfIteratorHelper(settingsStreams),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var streamSubs = _step2.value;

            if (streamSubs.getId() === streamId) {
              return streamSubs;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else {
        var activeConversationsSettings = _Session__WEBPACK_IMPORTED_MODULE_6__.Session.getActiveSession().getActiveConversations();
        var activeConferencessSettings = _Session__WEBPACK_IMPORTED_MODULE_6__.Session.getActiveSession().getActiveConferences();

        for (var prop in activeConversationsSettings) {
          var stream = activeConversationsSettings[prop].getSubscribedStream(streamId);

          if (stream !== undefined) {
            logger.debug('remote stream is associated to a conversation');
            return stream;
          }
        }

        for (var _prop in activeConferencessSettings) {
          var _stream = activeConferencessSettings[_prop].getSubscribedStream(streamId);

          if (_stream !== undefined) {
            logger.debug('remote stream is associated to a conference');
            return _stream;
          }
        }
      }

      return null;
    }
  }, {
    key: "getContact",
    value: function getContact(contactId) {
      return _Session__WEBPACK_IMPORTED_MODULE_6__.Session.getActiveSession().getOrCreateContact(contactId);
    }
  }, {
    key: "sendToContactRemoteStreamError",
    value: function sendToContactRemoteStreamError(message, contact, data) {
      logger.debug('sendToContactRemoteStreamError', message, contact, data);
      contact.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_REMOTE_ERROR, {
        callId: data.callId,
        streamId: data.streamId,
        timeout: data.timeout,
        message: message
      });
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return CONTACT_EVENTS;
    }
  }]);

  return Contact;
}(_utils_Observable__WEBPACK_IMPORTED_MODULE_2__.Observable);



/***/ }),

/***/ "./src/public/Conversation.js":
/*!************************************!*\
  !*** ./src/public/Conversation.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Conversation": () => (/* binding */ Conversation),
/* harmony export */   "_apiRTCEventListeners": () => (/* binding */ _apiRTCEventListeners),
/* harmony export */   "_eventEmitter": () => (/* reexport safe */ _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter),
/* harmony export */   "_instanceId": () => (/* binding */ _instanceId),
/* harmony export */   "_moderator": () => (/* binding */ _moderator),
/* harmony export */   "_mySession": () => (/* binding */ _mySession),
/* harmony export */   "_name": () => (/* binding */ _name),
/* harmony export */   "_password": () => (/* binding */ _password),
/* harmony export */   "_role": () => (/* binding */ _role),
/* harmony export */   "apiRTCManager": () => (/* binding */ apiRTCManager),
/* harmony export */   "cloudApi": () => (/* binding */ cloudApi),
/* harmony export */   "contactCatalog": () => (/* binding */ contactCatalog),
/* harmony export */   "parseStreamingEvent": () => (/* binding */ parseStreamingEvent)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/EventEmitter */ "./src/utils/EventEmitter.js");
/* harmony import */ var _utils_Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Observable */ "./src/utils/Observable.js");
/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Stream */ "./src/public/Stream.js");
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Session */ "./src/public/Session.js");
/* harmony import */ var _Contact__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Contact */ "./src/public/Contact.js");
/* harmony import */ var _SentInvitation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SentInvitation */ "./src/public/SentInvitation.js");
/* harmony import */ var _ConversationCall__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ConversationCall */ "./src/public/ConversationCall.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../private/ApiRTCManager */ "./src/private/ApiRTCManager.js");
/* harmony import */ var _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @apizee/cloudapi-js-sdk/CloudAPI */ "./node_modules/@apizee/cloudapi-js-sdk/CloudAPI.js");
/* harmony import */ var _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../private/ContactCatalog */ "./src/private/ContactCatalog.js");
/* harmony import */ var _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../private/ConversationCatalog */ "./src/private/ConversationCatalog.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* globals apiCC*/














var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_9__.Logger.get('Conversation');
var apiRTCManager = _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_10__.ApiRTCManager.get();
var cloudApi = new _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_11__["default"]();
var contactCatalog = _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_12__.ContactCatalog.get();
var CONVERSATION_EVENTS = ['adaptationTriggered', 'audioAmplitude', 'availableStreamsUpdated', 'bandwidthLimited', 'callStatsUpdate', 'compositeListChanged', 'contactJoined', 'contactJoinedWaitingRoom', 'contactLeft', 'contactLeftWaitingRoom', 'cpuLimited', 'customEvent', 'data', 'disconnectionWarning', 'entryAllowed', 'entryDenied', 'error', 'hangup', 'joined', 'left', 'localStreamUpdated', 'message', 'messageNotDelivered', 'moderatorConnected', 'newMediaAvailable', 'newWhiteboardSession', 'participantEjected', 'persistentDataUpdated', 'pointerLocationChanged', 'pointerSharingEnabled', 'recordingAvailable', 'recordingStarted', 'recordingStopped', 'remoteStreamUpdated', 'replayListChanged', 'roomModeChanged', 'simulcastFeedChanged', 'slowLink', 'streamAdded', 'streamListChanged', 'streamRemoved', 'streamingStarted', 'streamingStopped', 'transferPending', 'transferBegun', 'transferEnded', 'transferProgress', 'whiteboardRoomMemberUpdate', 'videoQualityChanged', 'waitingForModeratorAcceptance'];
var TYPES = new Set(['CHAT', 'CALL', 'GROUP_CHAT', 'WEBCONF', 'REPORT', 'REPORT_PART', 'TICKET', 'EVENT', 'OTHER', 'BOT']);
var CALL_STATS_SECTIONS = new Set(['audioSent', 'videoSent', 'audioReceived', 'videoReceived', 'quality']);
var CALL_FATAL_ERRORS = new Set(['CALL_ABORTED', 'SET_LOCAL_DESCRIPTION_FAILURE', 'SET_REMOTE_DESCRIPTION_FAILURE']); //Private fields

var _name = new WeakMap();

var _type = new WeakMap();

var _data = new WeakMap();

var _cloudConversationId = new WeakMap();

var _role = new WeakMap();

var _moderator = new WeakMap();

var _subscribedStreams = new WeakMap();

var _mySession = new WeakMap();

var _listeners = new WeakMap();

var _apiRTCEventListeners = new WeakMap();

var _waitingRoomContactCache = new WeakMap();

var _password = new WeakMap();

var _instanceId = new WeakMap();
/**
 * Conversation
 *
 * Users are able to interact with each other by entering a conversation in a N-N fashion.
 * The client is able to listen to conversation events that will be fired once the conversation is joined
 *
 * @extends Observable
 * @fires Conversation#audioAmplitude
 * @fires Conversation#availableStreamsUpdated
 * @fires Conversation#callStatsUpdate
 * @fires Conversation#contactJoined
 * @fires Conversation#contactJoinedWaitingRoom
 * @fires Conversation#contactLeft
 * @fires Conversation#contactLeftWaitingRoom
 * @fires Conversation#customEvent
 * @fires Conversation#data
 * @fires Conversation#disconnectionWarning
 * @fires Conversation#error
 * @fires Conversation#hangup
 * @fires Conversation#joined
 * @fires Conversation#left
 * @fires Conversation#localStreamUpdated
 * @fires Conversation#message
 * @fires Conversation#messageNotDelivered
 * @fires Conversation#moderatorConnected
 * @fires Conversation#newMediaAvailable
 * @fires Conversation#newWhiteboardSession
 * @fires Conversation#participantEjected
 * @fires Conversation#persistentDataUpdated
 * @fires Conversation#pointerLocationChanged
 * @fires Conversation#pointerSharingEnabled
 * @fires Conversation#recordingAvailable
 * @fires Conversation#recordingStarted
 * @fires Conversation#recordingStopped
 * @fires Conversation#remoteStreamUpdated
 * @fires Conversation#roomModeChanged
 * @fires Conversation#slowLink
 * @fires Conversation#streamAdded
 * @fires Conversation#streamListChanged
 * @fires Conversation#streamRemoved
 * @fires Conversation#streamingStarted
 * @fires Conversation#streamingStopped
 * @fires Conversation#transferBegun
 * @fires Conversation#transferEnded
 * @fires Conversation#transferProgress
 * @fires Conversation#waitingForModeratorAcceptance
 * @fires Conversation#whiteboardRoomMemberUpdate
 */


var Conversation = /*#__PURE__*/function (_Observable) {
  _inherits(Conversation, _Observable);

  var _super = _createSuper(Conversation);

  /**
   * Fired when a message is received from contact in the conversation
   *
   * @event Conversation#message
   * @type {object}
   * @property {string} content - content of the message
   * @property {Contact} sender
   * @property {Date} time - receive time
   */

  /**
   * @event Conversation#messageNotDelivered
   * @type {Object}
   * @property {ApiRTCError} error - Hint.
   * @property {Contact} contact - Message recipient.
   * @property {String} event - Event (optional).
   * @property {String} command - Command (optional).
   */

  /**
   * Fired when a stream is received from this conversation after a subscription
   *
   * @event Conversation#streamAdded
   * @type {Stream}
   */

  /**
   * Fired when stream is removed from this conversation after an unsubscription
   *
   * @event Conversation#streamRemoved
   * @type {Stream}
   */

  /**
   * Fired when available streams in conversation have been updated
   *
   * @event Conversation#availableStreamsUpdated
   * @type {StreamInfo[]}
   */

  /**
   * Fired when a change occurs in the available stream list. An entry in the
   * available stream list represents a stream that has been successfully
   * published by one of the participants and that one can subscribe to.
   *
   * @example <caption>use streamListChanged events</caption>
   * conversation.on('streamListChanged', function (streamInfo) {
   *     if (streamInfo.listEventType === 'added') {
   *         // A new stream has been published.
   *         // Add it to me own list copy?
   *         if (streamInfo.isRemote) {
   *             // The stream has been published by an other participant.
   *             // Subscribe to it?
   *         } else {
   *             // The stream has been published by me.
   *             // Subscribe to it?
   *         }
   *     } else if (streamInfo.listEventType === 'removed') {
   *         // A stream has been unpublished.
   *         // Remove it from with own list copy.
   *     } else if (streamInfo.listEventType === 'updated') {
   *         // Properties of the published stream has changed.
   *     }
   * });
   *
   * @event Conversation#streamListChanged
   * @type {StreamInfo}
   */

  /**
   * Fired when data is received from a contact within the conversation
   *
   * @event Conversation#data
   * @type {object}
   * @property {object} content - data
   * @property {Contact} sender
   */

  /**
   * Fired when a contact joined the conversation
   *
   * @event Conversation#contactJoined
   * @type {Contact}
   */

  /**
   * Fired when a contact left the conversation
   *
   * @event Conversation#contactLeft
   * @type {Contact}
   */

  /**
   * Fired when a contact in the conversation starts a new whiteboard session
   *
   * @event Conversation#newWhiteboardSession
   * @type {object}
   * @property {Contact} sender
   */

  /**
   * Fired when a member connect or disconnect from whiteboard room.
   *
   * @event Session#whiteboardRoomMemberUpdate
   * @type {object}
   * @property {string} roomId event identifier
   * @property {string} status online / offline
   * @property {Contact[]} contacts contacts updated
   */

  /**
   * Fired when a custom data event has been received from a contact within the conversation.
   *
   * @event Conversation#customEvent
   * @type {object}
   * @property {string} event event identifier
   * @property {Contact} sender
   * @property {object} content
   */

  /**
   * Fired when conversation has been joined by the user.
   *
   * @event Conversation#joined
   * @type {void}
   */

  /**
   * Fired when conversation has been left by the user.
   *
   * @event Conversation#left
   * @type {void}
   */

  /**
   * Fired when conversation persistent data has been updated.
   *
   * @event Conversation#persistentDataUpdated
   * @type {object}
   */

  /**
   * Fired when pointer sharing is enabled or disabled.
   * @event Conversation#pointerSharingEnabled
   * @type {object}
   * @property {boolean} enabled - True when enabled, false when disabled.
   */

  /**
   * Fired when a pointer location changed.
   *
   * @event Conversation#pointerLocationChanged
   * @type {object}
   * @property {Contact} sender - sender.
   * @property {object} source - source identifier.
   * @property {number} x - The X coordinate of the mouse pointer in source coordinates.
   * @property {number} y - The Y coordinate of the mouse pointer in source coordinates.
   * @property {object} data - Optional data.
   */

  /**
   * Fired when a slow link is detected.
   * An optional advice can be set. When advice is 'subscribeToAudioComposite', the
   * application should start the audio composite (#startComposite) and then subscribe
   * to the audio composite stream instead of subscribing to every stream individually.
   *
   * @event Conversation#slowLink
   * @type {object}
   * @property {string} callId - Call ID.
   * @property {(number|string)} streamId - Stream ID.
   * @property {string} advice - Optional advice.
   */

  /**
   * Fired when local stream properties changed.
   *
   * @event Conversation#localStreamUpdated
   * @type {object}
   * @property {string} callId - Call ID.
   * @property {string} streamId - Stream ID.
   * @property {boolean} audio - Whether an audio line has been negotiated and active.
   * @property {boolean} audioMuted - Whether the audio line is muted.
   * @property {boolean} video - Whether a video line has been negotiated and active.
   * @property {boolean} videoMuted - Whether the video line is muted.
   * @property {string} cause - Either 'adaptation' or 'userAction'.
   */

  /**
   * Fired when remote stream properties changed.
   *
   * @event Conversation#remoteStreamUpdated
   * @type {object}
   * @property {string} callId - Call ID.
   * @property {number} streamId - Stream ID.
   * @property {boolean} audio - Whether an audio line has been negotiated and active.
   * @property {boolean} audioMuted - Whether the audio line is muted.
   * @property {boolean} video - whether a video line has been negotiated and active.
   * @property {boolean} videoMuted - Whether the video line is muted.
   * @property {string} cause - Either 'adaptation' or 'userAction'.
   */

  /**
   * Fired when a new media is available in the conversation.
   *
   * @event Conversation#newMediaAvailable
   * @type {object}
   * @property {Contact} sender
   * @property {CloudMediaInfo} media
   */

  /**
   * Fired when a transfer is pending (push data).
   *
   * @event Conversation#transferPending
   * @type {object}
   * @property {string} id - transfer id.
   * @property {string} name - filename.
   * @property {number} rank
   */

  /**
   * Fired when a transfer begun (push data).
   *
   * @event Conversation#transferBegun
   * @type {object}
   * @property {string} id - transfer id.
   * @property {string} name - filename.
   */

  /**
   * Fired with progress status during a transfer (push data).
   *
   * @event Conversation#transferProgress
   * @type {object}
   * @property {string} id - transfer id.
   * @property {string} name - filename.
   * @property {number} size - total transfered byte count.
   * @property {number} remBytes - remaining byte count.
   * @property {number} percentage - progress ratio.
   */

  /**
   * Fired when a transfer ended (push data).
   *
   * @event Conversation#transferEnded
   * @type {object}
   * @property {string} id - transfer id.
   * @property {string} name - filename.
   */

  /**
   * Fired when a recording started.
   *
   * @event Conversation#recordingStarted
   * @type {RecordingInfo}
   */

  /**
   * Fired when a recording stopped.
   *
   * @event Conversation#recordingStopped
   * @type {RecordingInfo}
   */

  /**
   * Fired when a recording is available for play or download.
   *
   * @event Conversation#recordingAvailable
   * @type {RecordingInfo}
   */

  /**
   * Fired when a disconnection happened on conversation stream
   *
   * @event Conversation#disconnectionWarning
   * @type {object}
   * @property {StreamInfo[]} streamInfo Stream information
   */

  /**
   * Fired when a publish or subscribe is terminated.
   *
   * @event Conversation#hangup
   * @type {object}
   * @property {string} from - 'local' or 'remote'.
   * @property {string} reason - Hangup reason.
   * @property {(number|string)} streamId - Stream ID.
   */

  /**
   * @typedef {object} ConversationIceErrorDescriptor
   * @property {string} iceState - Either 'failed' or 'disconnected'.
   * @property {string} previousIceState - Either 'disconnected' or undefined.
   * @property {string} mode - Either 'mesh' or 'sfu'.
   * @property {string} type - Either 'publish' or 'subscribe'.
   * @property {string} clientId - Local user ID from where this descriptor come from.
   * @property {string} remoteId - Distant user ID from where this descriptor come from.
   * @property {object} mesh - Additional information when mode is 'mesh'.
   * @property {string} mesh.callerId - User ID of caller (subscriber).
   * @property {string} mesh.callerCallId - Call ID for the caller (subscriber).
   * @property {string} mesh.calleeId - User ID of the feed.
   * @property {string} mesh.calleeCallId - Call ID of the feed.
   * @property {object} stream - Feed information when type is 'subscribe'.
   * @property {object} stream.attributes - Feed attributes when type is 'subscribe'.
   * @property {object} stream.attributes.callerId - User ID of the feed.
   * @property {object} stream.attributes.callId - Call ID of the feed.
   */

  /**
   * Fired when an error happened on conversation stream
   *
   * @event Conversation#error
   * @type {object}
   * @property {(number|string)} streamId Stream ID.
   * @property {StreamInfo[]} streamInfo Stream information
   * @property {string} errorCode Code description of the error. Check possible values below.
   * @property {string} errorInfo Code information about the error. Check possible values below.
   * <p>Possible errors values are the following: (errorInfo, errorCode)</p>
   * <i>Connection errors:</i>
   * <ul>
   * <li>ice disconnection detected: ICE_CONNECTION_STATE_DISCONNECTED</li>
   * <li>ice connection failed detected: ICE_CONNECTION_STATE_FAILED</li>
   * <li>distant ice disconnection detected: DISTANT_ICE_CONNECTION_STATE_DISCONNECTED</li>
   * <li>distant ice connection failed detected: DISTANT_ICE_CONNECTION_STATE_FAILED</li>
   * </ul>
   * <i>Errors on signaling processing:</i>
   * <ul>
   * <li>200OK received but callId is not matching, no process : NOT_MATCHING_CALLID_ON_200OK</li>
   * <li>Cannot find call to process Update : CALL_NOT_FOUND_ON_UPDATE</li>
   * <li>Cannot find call to process 200 Update : CALL_NOT_FOUND_ON_200UPDATE</li>
   * <li>Call aborted after calls retries (maxCallsRetriesDuration reached) : CALL_ABORTED</li>
   * </ul>
   * <i>Errors on Media establishment processing:</i>
   * <ul>
   * <li>Set local Description Failure : SET_LOCAL_DESCRIPTION_FAILURE</li>
   * <li>Set remote Description Failure : SET_REMOTE_DESCRIPTION_FAILURE</li>
   * </ul>
   * <i>Errors on calling API:</i>
   * <ul>
   * <li>parameter error when calling function: setUnidirectionalCall(): PARAMETER_ERROR_SETUNIDIRCALL</li>
   * <li>parameter error when calling function: setNtoNConf(): PARAMETER_ERROR_SETNTONCONF</li>
   * <li>parameter error when calling function: setRTPMedia(): PARAMETER_ERROR_SETRTPMEDIA</li>
   * <li>parameter error when calling function: setMediaRoutingMode(): PARAMETER_ERROR_SETMEDIAROUTINGMODE</li>
   * <li>parameter error when calling function: setUserAcceptOnIncomingCall(): PARAMETER_ERROR_SETUSERACCEPTONINCOCALL</li>
   * <li>Trying to add a listener on an unknown event: UNKNOWN_EVENT_ON_ADDLISTENER</li>
   * <li>parameter error when calling function: setAllowMultipleCalls(): PARAMETER_ERROR_SETALLOWMULTIPLECALLS</li>
   * </ul>
   * <i>Errors about recording :</i>
   * <ul>
   * <li>Room not found when starting recording: START_RECORD_ROOM_NOT_FOUND</li>
   * <li>Caller not found when starting recording: START_RECORD_CALLER_NOT_FOUND</li>
   * <li>Media not found when starting recording: START_RECORD_MEDIA_FOUND</li>
   * <li>Recording is already ongoing: START_RECORD_ALREADY_ON</li>
   * <li>Room not found when stopping recording: STOP_RECORD_ROOM_NOT_FOUND</li>
   * <li>Caller not found when stopping recording: STOP_RECORD_CALLER_NOT_FOUND</li>
   * <li>Media not found when stopping recording: STOP_RECORD_MEDIA_FOUND</li>
   * <li>Recorder not found when stopping recording: STOP_RECORD_ENDPOINT_NOT_FOUND</li>
   * <li>Recording is not started stopping recording: STOP_RECORD_NOT_STARTED</li>
   * <li>Recorder is not ready yet, record is not started: STOP_RECORD_RECORDER_NOT_READY</li>
   * </ul>
   * <i>Errors about media play:</i>
   * <ul>
   * <li>Autoplay was prevented: IOS_AUTOPLAY_PREVENTED</li>
   * </ul>
   * <i>Errors about media streams:</i>
   * <ul>
   * <li>Error during media update on call: MEDIA_UPDATE_ERROR</li>
   * </ul>
   * <i>Errors about user media:</i>
   * <ul>
   * <li>Error during media media access: USER_MEDIA_ERROR</li>
   * </ul>
   * <i>Errors about remote stream:</i>
   * <ul>
   * <li>Error during subscription: STREAM_NOT_AVAILABLE</li>
   * </ul>
   * @property {ConversationIceErrorDescriptor|object} descriptor Detailed descriptor of the error
   */

  /**
   * @event Conversation#callStatsUpdate
   * @type {object}
   * @property {(number|string)} streamId - Stream ID.
   * @property {string} callId - Call ID.
   * @property {boolean} mesh - Whether the stats belongs to one of the sub-calls of a published stream in mesh mode.
   * @property {Contact} contact - If mesh is true, the contact to whom the stream is sent to.
   * @property {CallStats} stats
   */

  /**
   * Fired when the audio amplitude change happened on conversation stream (indicating user speaking or not)
   * @event Conversation#audioAmplitude
   * @type {object}
   * @property {(number|string)} streamId - Stream ID.
   * @property {string} callId - Call ID.
   * @property {number} amplitude
   * @property {boolean} isSpeaking
   * @property {object} descriptor - Deprecated.
   */

  /**
   * Fired when a participant has been ejected from the conference.
   *
   * @event Conversation#participantEjected
   * @type {object}
   * @property {boolean} self
   * @property {Contact} contact
   */

  /**
   * Fired when the mode of conference room is changing or changed.
   *
   * @event Conversation#roomModeChanged
   * @type {object}
   * @property {string} oldMode - Represents the previous mode, being replaced (or replaced) by the new mode. Either 'mesh' or 'sfu'.
   * @property {string} newMode - Represents the new mode, replacing the previous mode. Either 'mesh' or 'sfu'.
   * @property {string} state - Represents the state of the room mode change. Either 'ongoing' or 'complete'.
   */

  /**
   * Fired when the simulcast selection feed changed.
   * @event Conversation#simulcastFeedChanged
   * @type {object}
   * @property {number} streamId - Stream ID.
   * @property {string} callId - Call ID.
   * @property {object} simulcast
   * @property {string} simulcast.streamQuality - Substream selection. Either 'high', 'medium' or 'low'.
   * @property {string} simulcast.streamFrameRate - Temporal layer selection. Either 'high', 'medium' or 'low'.
   */

  /**
   * Contact joined the waiting room event (moderator only)
   *
   * @event Conversation#contactJoinedWaitingRoom
   * @type {Contact}
   */

  /**
   * Contact left the waiting room event (moderator only)
   *
   * @event Conversation#contactLeftWaitingRoom
   * @type {Contact}
   */

  /**
   * Fired when entering the waiting room of a conversation, requiring the moderator to accept before joining the room
   *
   * @event Conversation#waitingForModeratorAcceptance
   * @type {object}
   * @property {Contact} moderator
   */

  /**
   * Fired when moderator joined the conversation
   *
   * @event Conversation#moderatorConnected
   * @type {object}
   * @property {Contact} moderator
   */

  /**
   * Fired when moderator allows user to enter
   *
   * @event Conversation#entryAllowed
   * @type {void}
   */

  /**
   * Fired when moderator denies user to enter
   *
   * @event Conversation#entryDenied
   * @type {void}
   */
  function Conversation(name) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Conversation);

    _this = _super.call(this, logger);
    logger.debug('Create Conversation');

    if (typeof name === 'undefined' || name === null) {
      _name.set(_assertThisInitialized(_this), _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.guid().toString());
    } else {
      _name.set(_assertThisInitialized(_this), name.toString());
    }

    _type.set(_assertThisInitialized(_this), 'OTHER'); // options.


    _this.active = !Object.prototype.hasOwnProperty.call(options, 'active') || typeof options.active !== 'boolean' ? true : options.active;
    _this.meshModeEnabled = options.meshModeEnabled === true;
    _this.meshOnlyEnabled = options.meshOnlyEnabled === true;
    _this.moderationEnabled = options.moderationEnabled === true;
    _this.moderator = options.moderator === true; // Represents all conversation calls of this one.
    // This includes both publish calls and subscribe calls (not yet).

    _this.conversationCalls = new Map(); // Represents all callIds associated to this one.

    _this.callIdToStreamId = new Map();
    _this.token = null;
    _this.sessionId = null; // Cloud webconf ID (only for scheduled private conference).

    _this.webconfId = null; // Represents all streams available for subscription.

    _this.conversationStreams = new Map(); // Represents all local streams published in this one.

    _this.conversationPublishedStreams = new Map();
    _this.groupChatStatus = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED;
    _this.status = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED;
    _this.whiteboardStarted = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WHITEBOARD_NOT_STARTED;
    _this.pointerSharingState = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STATE_IDLE;
    _this.pointerSharingAutoInvite = false;
    _this.pgroupWaitingRoomSubscribedTo = false;

    _role.set(_assertThisInitialized(_this), null);

    _moderator.set(_assertThisInitialized(_this), null);

    _subscribedStreams.set(_assertThisInitialized(_this), new Map()); //keep reference for subscribed streams


    _cloudConversationId.set(_assertThisInitialized(_this), null);

    _mySession.set(_assertThisInitialized(_this), null);

    _data.set(_assertThisInitialized(_this), {});

    _waitingRoomContactCache.set(_assertThisInitialized(_this), new Map()); //for contactJoined & contactLeft events (moderator only)


    _instanceId.set(_assertThisInitialized(_this), null);

    _password.set(_assertThisInitialized(_this), null);

    _this.transferCallIds = []; // Represents the available bandwidth to be used for publish or subscribe

    _this.uploadCap = null;
    _this.downloadCap = null; // List of stream reservation, sorted by priority, in descending order

    _this.reservedStreams = [];
    var listeners = {};
    listeners.contactCatalog = {};

    listeners.contactCatalog.onUpdate = function (contactList) {
      logger.debug('onUpdate: contactList', contactList);

      var technicalName = _this._getTechnicalName(); //check for contacts who joined the conversation


      if (contactList.joinedGroup[technicalName] !== undefined) {
        var _iterator = _createForOfIteratorHelper(contactList.joinedGroup[technicalName]),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var contact = _step.value;
            logger.debug(contact.getUsername() + ' joined conversation ' + _this.getName());

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('contactJoined', contact);

            if (_this.pointerSharingState === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STATE_ACTIVE && _this.pointerSharingAutoInvite === true) {
              apiRTCManager.pointerSharingClient.inviteInRoom(technicalName, contact.getId());
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } else {
        logger.debug('not an event joinedGroup for conversation');
      } //check for contacts who left the conversation


      if (contactList.leftGroup[technicalName] !== undefined) {
        var _iterator2 = _createForOfIteratorHelper(contactList.leftGroup[technicalName]),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _contact = _step2.value;
            logger.debug(_contact.getUsername() + ' left conversation ' + _this.getName());

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('contactLeft', _contact);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else {
        logger.debug('not an event leftGroup for conversation');
      }

      if (_this.getRole() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_MODERATOR) {
        var newWaitingRoomContactList = contactCatalog.getContacts(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WAITING_ROOM_PREFIX + technicalName); // Check for contacts who left the waiting room.

        var _iterator3 = _createForOfIteratorHelper(_waitingRoomContactCache.get(_assertThisInitialized(_this)).keys()),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var contactId = _step3.value;

            if (!newWaitingRoomContactList.has(contactId)) {
              var _contact2 = contactCatalog.getContact(contactId);

              if (_contact2 !== null) {
                logger.debug(_contact2.getUsername() + ' left waiting room ' + _this.getName());

                _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('contactLeftWaitingRoom', _contact2);
              }
            }
          } // for
          // Check for contacts who joined the waiting room.

        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        newWaitingRoomContactList.forEach(function (contact, contactId) {
          if (!_waitingRoomContactCache.get(_assertThisInitialized(_this)).has(contactId) && contact !== null) {
            logger.debug(contact.getUsername() + ' joined waiting room ' + _this.getName());

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('contactJoinedWaitingRoom', contact); // Notify moderator presence (izeeconf comptability).


            apiRTCManager.sendData(contactId, {
              event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_MODERATOR_CONNECTED_IDENTIFIER,
              command: 'conversationModeratorConnected',
              // izeeconf compatibility
              roomname: technicalName
            })["catch"](function (errCode) {
              var newError = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(errCode, 'Notification not delivered', logger);

              _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('messageNotDelivered', {
                error: newError,
                contact: contact,
                event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_MODERATOR_CONNECTED_IDENTIFIER,
                command: 'conversationModeratorConnected'
              });
            });
          }
        });

        _waitingRoomContactCache.set(_assertThisInitialized(_this), newWaitingRoomContactList);
      }
    };

    contactCatalog.onUpdate(listeners.contactCatalog.onUpdate); // Notify new contacts for moderator presence.

    _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).on('contactJoined', function (contact) {
      if (_this.getRole() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_MODERATOR) {
        //notify moderator presence (izeeconf comptability)
        apiRTCManager.sendData(contact.getId(), {
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_MODERATOR_CONNECTED_IDENTIFIER,
          command: 'conversationModeratorConnected',
          //izeeconf compatibility
          roomname: _this._getTechnicalName()
        })["catch"](function (errCode) {
          var newError = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(errCode, 'Notification not delivered', logger);

          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('messageNotDelivered', {
            error: newError,
            contact: contact,
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_MODERATOR_CONNECTED_IDENTIFIER,
            command: 'conversationModeratorConnected'
          });
        });
      }
    });

    listeners.apiRTCManager = {};

    listeners.apiRTCManager.receiveData = function (e) {
      var data = e.detail.data;

      if (data.roomname !== _this._getTechnicalName()) {
        return;
      }

      var sender = contactCatalog.getOrCreateContact(e.detail.senderId);

      if (data.event) {
        switch (data.event) {
          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_SEND_DATA_IDENTIFIER:
            if (_this.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
              break;
            }

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('data', {
              sender: sender,
              content: data.content
            });

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_NEW_MEDIA_IDENTIFIER:
            if (_this.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
              break;
            }

            logger.info('New media available in conversation', data.media);

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('newMediaAvailable', {
              sender: sender,
              media: data.media
            });

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_PERSISTENT_DATA_UPDATE_IDENTIFIER:
            if (_this.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
              break;
            }

            _this.updateData();

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_MODERATOR_CONNECTED_IDENTIFIER:
            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('moderatorConnected', sender);

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_CLOSED_IDENTIFIER:
            if (data.instanceId === _this.getInstanceId()) {
              logger.info('Conference ' + _this.getName() + ' has been closed...');

              _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('closed');

              _this.leave();
            }

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_ANSWER_IDENTIFIER:
            if (data.access === undefined || data.access === null) {
              logger.error('Conversation join answer has no access data');
              break;
            }

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit(data.access ? 'entryAllowed' : 'entryDenied');

            break;

          default:
            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('customEvent', {
              event: data.event,
              content: data,
              sender: sender
            });

            break;
        }
      } else if (data.command === 'new_snapshot') {
        //izeeconf compatibility
        if (_this.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return;
        }

        logger.info('New media available in conversation', data.value.snapshot);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('newMediaAvailable', {
          sender: sender,
          media: data.value.snapshot
        });
      } else {
        logger.debug('Unprocessed conversation message', data);
      }
    };

    listeners.apiRTCManager.receiveGroupChatMessage = function (e) {
      if ((_this.status === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED || _this.groupChatStatus === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) && e.detail.groupChatId.toString() === _this._getTechnicalName()) {
        var contact = contactCatalog.getOrCreateContact(e.detail.senderId);
        var message = {
          sender: contact,
          sender_id: e.detail.senderId,
          content: e.detail.message,
          time: new Date()
        };

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(e.detail, 'metadata', 'object')) {
          message.metadata = e.detail.metadata;
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('message', message);
      }
    };

    listeners.apiRTCManager.receiveRoomMessage = function (e) {
      if (e.detail.roomType === 'pointerSharing' && _this.pointerSharingState === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STATE_ACTIVE && e.detail.message.type === 'pointerLocation' && e.detail.roomId === _this._getTechnicalName()) {
        var sender = contactCatalog.getOrCreateContact(e.detail.senderId);
        var pointerLocationChanged = {
          sender: sender,
          source: e.detail.message.source,
          x: e.detail.message.x,
          y: e.detail.message.y
        };

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(e.detail.message, 'data', 'object')) {
          pointerLocationChanged.data = e.detail.message.data;
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('pointerLocationChanged', pointerLocationChanged);
      }
    };

    listeners.apiRTCManager.roomInvitation = function (e) {
      logger.info('roomInvitation event handler ', e);

      if (e.detail.roomId.toString() === _this._getTechnicalName()) {
        logger.info('roomInvitation for actual conversation', e);

        if (e.detail.roomType === 'whiteBoard') {
          if (_this.status === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
            var sender = contactCatalog.getOrCreateContact(e.detail.senderId);

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('newWhiteboardSession', {
              sender: sender
            });
          }
        } else if (e.detail.roomType === 'pointerSharing') {
          _enablePointerSharing(_assertThisInitialized(_this), false, true).then(function () {})["catch"](function (err) {});
        }
      }
    };

    listeners.apiRTCManager.onFilePending = function (e) {
      if (_this.transferCallIds.includes(e.detail.callId)) {
        var newEvent = {
          id: e.detail.callId,
          name: e.detail.name,
          rank: e.detail.rank
        };

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('transferPending', newEvent);
      }
    };

    listeners.apiRTCManager.onFileSending = function (e) {
      if (_this.transferCallIds.includes(e.detail.callId)) {
        var newEvent = {
          id: e.detail.callId,
          name: e.detail.name
        };

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('transferBegun', newEvent);
      }
    };

    listeners.apiRTCManager.onFileProgress = function (e) {
      if (_this.transferCallIds.includes(e.detail.callId)) {
        var newEvent = {
          id: e.detail.callId,
          name: e.detail.name,
          size: e.detail.fileSize,
          remBytes: e.detail.remainingSize,
          percentage: e.detail.percentage
        };

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('transferProgress', newEvent);
      }
    };

    listeners.apiRTCManager.onFileSended = function (e) {
      var idx = _this.transferCallIds.indexOf(e.detail.callId);

      if (idx >= 0) {
        var newEvent = {
          id: e.detail.callId,
          name: e.detail.name
        };

        if (e.detail.error) {
          newEvent.error = e.detail.error;
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('transferEnded', newEvent);

        _this.transferCallIds.splice(idx, 1);
      }
    };

    for (var key in listeners.apiRTCManager) {
      apiRTCManager.onEvent(key, listeners.apiRTCManager[key]);
    }

    _listeners.set(_assertThisInitialized(_this), listeners);

    var apiRTCEventListeners = {};

    apiRTCEventListeners.MCUAvailableStream = function (info) {
      var _iterator4 = _createForOfIteratorHelper(info.detail.streams),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var streamData = _step4.value;

          if (streamData.room === _this._getTechnicalName()) {
            // checks if available stream is one of room's
            var contact = contactCatalog.getOrCreateContact(streamData.attributes.callerId);
            var streamInfo = {
              contact: contact,
              isRemote: info.detail.isRemoteStream,
              hasAudio: streamData.audio,
              hasVideo: streamData.video,
              isAudioMuted: streamData.audioMuted,
              isVideoMuted: streamData.videoMuted,
              isScreensharing: streamData.attributes.callType === 'screenSharing' || streamData.attributes.callType === 'screenSharingWithAudio',
              isSIP: streamData.sip === true,
              isSimulcast: streamData.simulcast === true,
              streamId: streamData.id,
              type: 'regular',
              callId: streamData.attributes.callId,
              descriptor: streamData.attributes.descriptor,
              context: streamData.context
            };

            _this.conversationStreams.set(streamInfo.streamId, streamInfo);

            var streamListChangedEvent = {
              listEventType: 'added'
            };
            _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject(streamListChangedEvent, streamInfo);

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('streamListChanged', streamListChangedEvent);
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      logger.debug('Nb stream into conversation :' + _this.conversationStreams.size);
      var availableStreams = {};

      var _iterator5 = _createForOfIteratorHelper(_this.conversationStreams.keys()),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _key = _step5.value;
          availableStreams[_key] = _this.conversationStreams.get(_key);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('availableStreamsUpdated', availableStreams);
    };

    apiRTCEventListeners.MCUAvailableStreamUpdate = function (info) {
      var _iterator6 = _createForOfIteratorHelper(info.detail.streams),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var streamData = _step6.value;

          if (streamData.room === _this._getTechnicalName()) {
            // checks if available stream is one of room's
            var streamInfo = _this.conversationStreams.get(streamData.id);

            if (streamInfo && streamInfo.type === 'regular') {
              streamInfo.hasAudio = streamData.audio;
              streamInfo.hasVideo = streamData.video;
              streamInfo.isAudioMuted = streamData.audioMuted;
              streamInfo.isVideoMuted = streamData.videoMuted;
              streamInfo.descriptor = streamData.attributes.descriptor;
              var streamListChangedEvent = {
                listEventType: 'updated'
              };
              _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject(streamListChangedEvent, streamInfo);

              _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('streamListChanged', streamListChangedEvent); // Apply priority change.


              if (streamInfo.descriptor && Object.prototype.hasOwnProperty.call(streamInfo.descriptor, 'priority')) {
                _this.changeStreamPriority(streamInfo.streamId, true, streamInfo.descriptor.priority);
              }
            }
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      logger.debug('Nb stream into conversation :' + _this.conversationStreams.size);
      var availableStreams = {};

      var _iterator7 = _createForOfIteratorHelper(_this.conversationStreams.keys()),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var _key2 = _step7.value;
          availableStreams[_key2] = _this.conversationStreams.get(_key2);
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('availableStreamsUpdated', availableStreams);
    };

    apiRTCEventListeners.MCUAvailableComposite = function (info) {
      var _iterator8 = _createForOfIteratorHelper(info.detail.streams),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var streamData = _step8.value;

          if (streamData.room === _this._getTechnicalName()) {
            var streamInfo = {
              isRemote: info.detail.isRemoteStream,
              hasAudio: streamData.audio,
              hasVideo: streamData.video,
              isAudioMuted: streamData.audioMuted,
              isVideoMuted: streamData.videoMuted,
              isScreensharing: streamData.attributes.callType === 'screenSharing' || streamData.attributes.callType === 'screenSharingWithAudio',
              isSIP: streamData.sip === true,
              streamId: streamData.id,
              type: 'composite',
              callId: streamData.attributes.callId,
              descriptor: streamData.attributes.descriptor,
              context: streamData.context
            };

            _this.conversationStreams.set(streamInfo.streamId, streamInfo);

            var streamListChangedEvent = {
              listEventType: 'added'
            };
            _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject(streamListChangedEvent, streamInfo);

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('compositeListChanged', streamListChangedEvent);
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    };

    apiRTCEventListeners.MCUAvailableReplay = function (info) {
      var _iterator9 = _createForOfIteratorHelper(info.detail.streams),
          _step9;

      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var streamData = _step9.value;

          if (streamData.room === _this._getTechnicalName()) {
            var contact = contactCatalog.getOrCreateContact(streamData.attributes.callerId);
            var streamInfo = {
              contact: contact,
              isRemote: info.detail.isRemoteStream,
              hasAudio: streamData.audio,
              hasVideo: streamData.video,
              isAudioMuted: streamData.audioMuted,
              isVideoMuted: streamData.videoMuted,
              isScreensharing: streamData.attributes.callType === 'screenSharing' || streamData.attributes.callType === 'screenSharingWithAudio',
              isSIP: streamData.sip === true,
              streamId: streamData.id,
              type: 'replay',
              callId: streamData.attributes.callId,
              descriptor: streamData.attributes.descriptor,
              context: streamData.context
            };

            _this.conversationStreams.set(streamInfo.streamId, streamInfo);

            var streamListChangedEvent = {
              listEventType: 'added'
            };
            _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject(streamListChangedEvent, streamInfo);

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('replayListChanged', streamListChangedEvent);
          }
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }
    };

    apiRTCEventListeners.MCURemoveStream = function (info) {
      // Check if stream is one of conversation's
      if (_this.conversationStreams.has(info.detail.streamId)) {
        var streamListChangedEvent = {
          listEventType: 'removed'
        };
        _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject(streamListChangedEvent, _this.conversationStreams.get(info.detail.streamId));

        if (streamListChangedEvent.type === 'regular') {
          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('streamListChanged', streamListChangedEvent);
        } else if (streamListChangedEvent.type === 'composite') {
          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('compositeListChanged', streamListChangedEvent);
        }

        _this.conversationStreams["delete"](info.detail.streamId);

        logger.debug('Nb stream into conversation :' + _this.conversationStreams.size);
        var availableStreams = {};

        var _iterator10 = _createForOfIteratorHelper(_this.conversationStreams.keys()),
            _step10;

        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var _key3 = _step10.value;
            availableStreams[_key3] = _this.conversationStreams.get(_key3);
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('availableStreamsUpdated', availableStreams);
      } else {
        logger.debug("Not a conversation's stream");
      }
    };

    apiRTCEventListeners.remoteStreamAdded = function (e) {
      // Check if call is one of conversation's
      if (_this.callIdToStreamId.has(e.detail.callId)) {
        logger.info('remoteStreamAdded', e.detail);
        var contact = contactCatalog.getOrCreateContact(e.detail.remoteId);

        var streamId = _this.callIdToStreamId.get(e.detail.callId);

        var subscribedStreams = _subscribedStreams.get(_assertThisInitialized(_this));

        if (subscribedStreams.has(streamId)) {
          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('streamRemoved', subscribedStreams.get(streamId));
        }

        var type = e.detail.callType === 'audio' ? 'audio' : 'video';
        var screensharing = e.detail.callType === 'screenSharing';
        var newStream = new _Stream__WEBPACK_IMPORTED_MODULE_4__.Stream(e.detail.stream, {
          type: type,
          contact: contact,
          streamId: streamId,
          callId: e.detail.callId,
          callAudioAvailable: e.detail.audioIsAvailable,
          callAudioActive: e.detail.audioIsActive,
          callAudioMuted: e.detail.audioIsMuted,
          callVideoAvailable: e.detail.videoIsAvailable,
          callVideoActive: e.detail.videoIsActive,
          callVideoMuted: e.detail.videoIsMuted,
          screensharing: screensharing,
          constructor: true
        });
        newStream.publishedInConversations.set(_this.getName(), e.detail.callId);

        _subscribedStreams.get(_assertThisInitialized(_this)).set(streamId, newStream);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('streamAdded', newStream); //Set contact active streams


        var stream = _this.getSubscribedStream(streamId);

        contact.setActiveStreams(stream);
      }
    };

    apiRTCEventListeners.remoteStreamRemoved = function (e) {
      if (_this.callIdToStreamId.has(e.detail.callId)) {
        var streamId = _this.callIdToStreamId.get(e.detail.callId);

        var subscribedStreams = _subscribedStreams.get(_assertThisInitialized(_this));

        if (subscribedStreams.has(streamId)) {
          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('streamRemoved', subscribedStreams.get(streamId));

          subscribedStreams["delete"](streamId);
        }
      }
    };

    apiRTCEventListeners.roomMemberUpdate = function (e) {
      logger.info('roomMemberUpdate event handler ', e);
      var contacts = [];

      var _iterator11 = _createForOfIteratorHelper(e.detail.contactList),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var c = _step11.value;
          contacts.push(contactCatalog.getOrCreateContact(c.contactId));
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }

      if (e.detail.roomType === 'whiteBoard') {
        logger.info('Received whiteboard room member update');

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('whiteboardRoomMemberUpdate', {
          contacts: contacts,
          roomId: e.detail.roomId,
          status: e.detail.status
        });
      }
    };

    apiRTCEventListeners.slowLink = function (e) {
      if (_this.callIdToStreamId.has(e.detail.callId)) {
        var streamId = _this.callIdToStreamId.get(e.detail.callId);

        var slowLink = {
          callId: e.detail.callId,
          streamId: streamId
        };

        if (e.detail.advice) {
          slowLink.advice = e.detail.advice;
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('slowLink', slowLink);
      }
    };

    apiRTCEventListeners.videoQualityChanged = function (e) {
      if (_this.callIdToStreamId.has(e.detail.callId)) {
        var streamId = _this.callIdToStreamId.get(e.detail.callId);

        var videoQualityChanged = {
          callId: e.detail.callId,
          streamId: streamId,
          hint: e.detail.hint,
          profileType: e.detail.profileType
        };

        if (e.detail.bitrate) {
          videoQualityChanged.bitrate = e.detail.bitrate;
        }

        if (e.detail.width && e.detail.height) {
          videoQualityChanged.width = e.detail.width;
          videoQualityChanged.height = e.detail.height;
        }

        if (e.detail.frameRate) {
          videoQualityChanged.frameRate = e.detail.frameRate;
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('videoQualityChanged', videoQualityChanged);
      }
    };

    apiRTCEventListeners.simulcastFeedChanged = function (e) {
      if (_this.callIdToStreamId.has(e.detail.callId)) {
        var streamId = _this.callIdToStreamId.get(e.detail.callId);

        var simulcastFeedChanged = {
          callId: e.detail.callId,
          streamId: streamId,
          simulcast: e.detail.simulcast
        };

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('simulcastFeedChanged', simulcastFeedChanged);
      }
    };

    apiRTCEventListeners.localStreamUpdated = function (e) {
      if (e.detail.onCall && _this.callIdToStreamId.has(e.detail.callId)) {
        var localStreamUpdated = {
          callId: e.detail.callId,
          streamId: e.detail.userMediaStreamId,
          audio: e.detail.audioIsAvailable && e.detail.audioIsActive,
          audioMuted: e.detail.audioIsMuted,
          audioSilent: e.detail.audioIsSilent,
          video: e.detail.videoIsAvailable && e.detail.videoIsActive,
          videoMuted: e.detail.videoIsMuted,
          videoSilent: e.detail.videoIsSilent,
          cause: e.detail.cause
        };

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('localStreamUpdated', localStreamUpdated);
      }
    };

    apiRTCEventListeners.remoteStreamUpdated = function (e) {
      var _e$detail = e.detail,
          callId = _e$detail.callId,
          cause = _e$detail.cause;

      if (_this.callIdToStreamId.has(callId) && (cause === 'adaptation' || cause === 'userAction')) {
        var streamId = _this.callIdToStreamId.get(callId);

        var remoteStreamUpdated = {
          callId: callId,
          streamId: streamId,
          audio: e.detail.audioIsAvailable && e.detail.audioIsActive,
          audioMuted: e.detail.audioIsMuted,
          audioSilent: e.detail.audioIsSilent,
          video: e.detail.videoIsAvailable && e.detail.videoIsActive,
          videoMuted: e.detail.videoIsMuted,
          videoSilent: e.detail.videoIsSilent,
          cause: cause
        };
        setTimeout(function () {
          // This timeout is useful because Stream also listens to remoteStreamUpdated
          // events in order to change its internal state.
          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('remoteStreamUpdated', remoteStreamUpdated);
        });
      }
    };

    apiRTCEventListeners.MCURecordingStarted = function (e) {
      if (e.detail.roomName === _this._getTechnicalName()) {
        var recordingStarted = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.parseRecordingEvent('MCURecordingStarted', e.detail);

        if (recordingStarted.callId === 'COMPOSITE') {
          _this.recordingStatus = recordingStarted;
        } else {
          var convCall = _this.conversationCalls.get(recordingStarted.callId);

          if (convCall) {
            convCall.recordingStatus = recordingStarted;
          }
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('recordingStarted', recordingStarted);
      }
    };

    apiRTCEventListeners.MCURecordingStopped = function (e) {
      if (e.detail.roomName === _this._getTechnicalName()) {
        var recordingStopped = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.parseRecordingEvent('MCURecordingStopped', e.detail);

        if (recordingStopped.callId === 'COMPOSITE') {
          delete _this.recordingStatus;
        } else {
          var convCall = _this.conversationCalls.get(recordingStopped.callId);

          if (convCall) {
            delete convCall.recordingStatus;
          }
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('recordingStopped', recordingStopped);
      }
    };

    apiRTCEventListeners.MCURecordedStreamsAvailable = function (e) {
      if (e.detail.roomName === _this._getTechnicalName()) {
        var recordingAvailable = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.parseRecordingEvent('MCURecordedStreamsAvailable', e.detail);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('recordingAvailable', recordingAvailable);
      }
    };

    apiRTCEventListeners.MCUStreamingStarted = function (e) {
      if (e.detail.roomName === _this._getTechnicalName()) {
        var streamingStarted = parseStreamingEvent('MCUStreamingStarted', e.detail);

        var convCall = _this.conversationCalls.get(streamingStarted.callId);

        if (convCall) {
          convCall.streamingStatus = streamingStarted;
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('streamingStarted', streamingStarted);
      }
    };

    apiRTCEventListeners.MCUStreamingStopped = function (e) {
      if (e.detail.roomName === _this._getTechnicalName()) {
        var streamingStopped = parseStreamingEvent('MCUStreamingStopped', e.detail);

        var convCall = _this.conversationCalls.get(streamingStopped.callId);

        if (convCall) {
          delete convCall.streamingStatus;
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('streamingStopped', streamingStopped);
      }
    };

    apiRTCEventListeners.onCallStatsUpdate = function (e) {
      if (_this.callIdToStreamId.has(e.detail.callId)) {
        var streamId = _this.callIdToStreamId.get(e.detail.callId);

        var callStatsUpdate = {
          callId: e.detail.callId,
          streamId: streamId,
          stats: {}
        };

        if (e.detail.userId) {
          // In mesh mode.
          callStatsUpdate.mesh = true;
          callStatsUpdate.userId = e.detail.userId;
          callStatsUpdate.contact = contactCatalog.getOrCreateContact(e.detail.userId);
        }

        for (var _i = 0, _Object$keys = Object.keys(e.detail.stats); _i < _Object$keys.length; _i++) {
          var section = _Object$keys[_i];

          if (CALL_STATS_SECTIONS.has(section)) {
            callStatsUpdate.stats[section] = e.detail.stats[section];
          }
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('callStatsUpdate', callStatsUpdate);
      }
    };

    apiRTCEventListeners.cpuLimited = function (e) {
      if (_this.callIdToStreamId.has(e.detail.callId)) {
        var streamId = _this.callIdToStreamId.get(e.detail.callId);

        var cpuLimited = {
          callId: e.detail.callId,
          streamId: streamId,
          encodeUsagePercent: e.detail.encodeUsagePercent
        };

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('cpuLimited', cpuLimited);
      }
    };

    apiRTCEventListeners.bandwidthLimited = function (e) {
      if (_this.callIdToStreamId.has(e.detail.callId)) {
        var streamId = _this.callIdToStreamId.get(e.detail.callId);

        var bandwidthLimited = {
          callId: e.detail.callId,
          streamId: streamId,
          resolutionChanged: true
        };

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('bandwidthLimited', bandwidthLimited);
      }
    };

    apiRTCEventListeners.audioAmplitude = function (e) {
      if (_this.callIdToStreamId.has(e.detail.callId)) {
        var streamId = _this.callIdToStreamId.get(e.detail.callId);

        var audioAmplitude = {
          callId: e.detail.callId,
          streamId: streamId,
          amplitude: e.detail.descriptor.amplitude,
          isSpeaking: e.detail.descriptor.isSpeaking,
          descriptor: {
            // legacy
            amplitude: e.detail.descriptor.amplitude,
            isSpeaking: e.detail.descriptor.isSpeaking
          }
        };

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('audioAmplitude', audioAmplitude);
      }
    };

    apiRTCEventListeners.hangup = function (e) {
      if (_this.callIdToStreamId.has(e.detail.callId)) {
        var streamId = _this.callIdToStreamId.get(e.detail.callId);

        var subscribedStreams = _subscribedStreams.get(_assertThisInitialized(_this));

        if (subscribedStreams.has(streamId)) {
          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('streamRemoved', subscribedStreams.get(streamId));

          subscribedStreams["delete"](streamId);
        }

        if (e.detail.reason !== 'restarted' && e.detail.reason !== 'disconnected' && e.detail.reason !== 'Broken_by_MCU' && e.detail.reason !== 'RTC_Setup_Timeout') {
          if (_this.conversationCalls.has(e.detail.callId)) {
            // publish
            destroyPublishCall(_assertThisInitialized(_this), e.detail.callId);
          } else {
            // subscribe
            _this.callIdToStreamId["delete"](e.detail.callId);

            _this.releaseResources(streamId, {
              isRemote: true,
              triggerAdaptation: true
            });
          }

          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('hangup', {
            from: e.detail.hangupType,
            reason: e.detail.reason,
            streamId: streamId
          });
        }
      }
    };

    apiRTCEventListeners.callRestarting = function (e) {
      if (_this.callIdToStreamId.has(e.detail.oldCallId)) {
        var streamId = _this.callIdToStreamId.get(e.detail.oldCallId);

        _this.callIdToStreamId["delete"](e.detail.oldCallId);

        _this.callIdToStreamId.set(e.detail.newCallId, streamId);
      }
    };

    apiRTCEventListeners.MCUParticipantEjected = function (e) {
      if (_this._getTechnicalName() === e.detail.roomId) {
        var session = _mySession.get(_assertThisInitialized(_this));

        if (e.detail.clientId === session.getId()) {
          _this.leave()["catch"](function (err) {
            logger.error('leave', err);
          }).then(function () {
            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('participantEjected', {
              self: true
            });
          });
        } else {
          var contact = contactCatalog.getOrCreateContact(e.detail.clientId);

          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('participantEjected', {
            self: false,
            contact: contact
          });
        }
      }
    };

    apiRTCEventListeners.MCURoomModeChanged = function (e) {
      if (_this._getTechnicalName() === e.detail.roomId) {
        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).emit('roomModeChanged', {
          oldMode: e.detail.oldMode,
          newMode: e.detail.newMode,
          state: e.detail.state
        });
      }
    };

    _apiRTCEventListeners.set(_assertThisInitialized(_this), apiRTCEventListeners);

    _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_assertThisInitialized(_this)).on('left', function () {
      if (_this.pgroupWaitingRoomSubscribedTo) {
        apiRTCManager.apiRTCSession.unsubscribePresenceGroup([_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WAITING_ROOM_PREFIX + _this._getTechnicalName()]);
        _this.pgroupWaitingRoomSubscribedTo = false;
      }

      _role.set(_assertThisInitialized(_this), null);

      _moderator.set(_assertThisInitialized(_this), null);

      _mySession.set(_assertThisInitialized(_this), null);

      _instanceId.set(_assertThisInitialized(_this), null);
    });

    return _this;
  }
  /**
   * Cleans up all local resources attached to this one.
   */


  _createClass(Conversation, [{
    key: "destroy",
    value: function destroy() {
      _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_13__.ConversationCatalog.get().deleteConversation(this.getName());

      var listeners = _listeners.get(this);

      if (listeners) {
        if (listeners.apiRTCManager) {
          for (var key in listeners.apiRTCManager) {
            apiRTCManager.removeEventListener(key, listeners.apiRTCManager[key]);
          }
        }

        if (listeners.contactCatalog) {
          contactCatalog.removeUpdateListener(listeners.contactCatalog.onUpdate);
        }

        _listeners["delete"](this);
      }
    }
    /**
     * Returns available events for this class
     *
     *  @returns {Array<string>}
     */

  }, {
    key: "getStatus",
    value:
    /**
     * Returns conversation status
     *
     * @returns {Symbol}
     */
    function getStatus() {
      return this.status;
    }
    /**
     * Returns this conversation's room name
     *
     *  @returns {string}
     */

  }, {
    key: "getName",
    value: function getName() {
      return _name.get(this).toString();
    }
    /*
     * Returns this conversation's technical name for signaling
     *
     * @ignore
     * @returns {string}
     */

  }, {
    key: "_getTechnicalName",
    value: function _getTechnicalName() {
      return _name.get(this).toString();
    }
    /**
     * Returns UserAgent's role for this conversation, will be set to null if conversation is not joined
     *
     * @return {string|null}
     */

  }, {
    key: "getRole",
    value: function getRole() {
      return _role.get(this);
    }
    /**
     * Returns instance id for this conversation, will be set to null if conversation is not joined
     *
     * @return {string|null}
     */

  }, {
    key: "getInstanceId",
    value: function getInstanceId() {
      return _instanceId.get(this);
    }
    /**
     * Returns this conference's name as it is displayed on your ApiRTC cloud platform
     *
     * @return {string|null}
     */

  }, {
    key: "getFriendlyName",
    value: function getFriendlyName() {
      return null;
    }
    /**
     * Returns conversation moderator.
     *
     * @return {Contact|null} moderator or null if no moderator or moderator unknown
     */

  }, {
    key: "getModerator",
    value: function getModerator() {
      return _moderator.get(this);
    }
    /*
     * Returns the type of the conversation represented by this one.
     * @ignore
     * @return {string} The type ('CHAT', 'CALL', 'GROUP_CHAT', 'WEBCONF', 'REPORT', 'REPORT_PART', 'TICKET', 'EVENT', 'OTHER', 'BOT').
     */

  }, {
    key: "getType",
    value: function getType() {
      return _type.get(this);
    }
    /*
     * Sets the type of this one. Shall be done before binding to cloud.
     * @ignore
     * @param {string} type - New type ('CHAT', 'CALL', 'GROUP_CHAT', 'WEBCONF', 'REPORT', 'REPORT_PART', 'TICKET', 'EVENT', 'OTHER', 'BOT').
     * @return {boolean} True on success, false otherwise.
     */

  }, {
    key: "setType",
    value: function setType(type) {
      if (this.isBound()) {
        return false;
      }

      if (!TYPES.has(type)) {
        return false;
      }

      _type.set(this, type);

      return true;
    }
    /**
     * Returns ApiRTC cloud conversation id for this conversation, will be set to null if conversation is not joined
     * @return {string}
     */

  }, {
    key: "getCloudConversationId",
    value: function getCloudConversationId() {
      var res = _cloudConversationId.get(this);

      return res ? res.toString() : null;
    }
    /**
     * Binds the conversation represented by this one to cloud.
     * @param {object} options
     * @param {Session} options.session - Session.
     * @return {Promise<string>}
     */

  }, {
    key: "bind",
    value: function bind(options) {
      var _this2 = this;

      if (!options) {
        options = {};
      }

      var cloudConvId = _cloudConversationId.get(this);

      if (cloudConvId !== null) {
        return Promise.resolve(String(cloudConvId));
      }

      return new Promise(function (resolve, reject) {
        getOrCreateConversation(_this2, options).then(function (res) {
          resolve(String(res.id));
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_HTTP, 'bind() - cannot bind conversation', logger, {
            fromError: err
          }));
        });
      });
    }
    /**
     * Tests whether the conversation represented by this one is bound to cloud.
     * @return {boolean} True if this one is bound to cloud, false otherwise.
     */

  }, {
    key: "isBound",
    value: function isBound() {
      return _cloudConversationId.get(this) !== null;
    }
    /**
     * @return {Boolean} True if the group chat has been joined, false otherwise.
     */

  }, {
    key: "isGroupChatJoined",
    value: function isGroupChatJoined() {
      return this.groupChatStatus === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED;
    }
    /**
     * Joins group chat.
     * @return {Promise}
     */

  }, {
    key: "joinGroupChat",
    value: function joinGroupChat() {
      var _this3 = this;

      var isPresentInContactList = function isPresentInContactList(contactList, contactId) {
        var idx = contactList.length;

        while (--idx >= 0) {
          if (contactList[idx].contactId === contactId) {
            return true;
          }
        }

        return false;
      };

      var join = function join() {
        return new Promise(function (resolve, reject) {
          if (_this3.asyncCallbacks) {
            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'joinGroupChat() - busy', logger));
          }

          _this3.asyncCallbacks = {};
          _this3.asyncCallbacks.timeoutId = setTimeout(function () {
            apiRTCManager.removeEventListener('groupChatMemberUpdate', _this3.asyncCallbacks.groupChatMemberUpdate);
            delete _this3.asyncCallbacks;
            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'joinGroupChat() - timeout', logger));
          }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_GROUP_CHAT_MEMBER_UPDATE_DELAY);

          _this3.asyncCallbacks.groupChatMemberUpdate = function (e) {
            if (e.detail.groupChatId === _this3._getTechnicalName() && e.detail.status === 'online' && isPresentInContactList(e.detail.contactList, apiRTCManager.getClientId())) {
              if (_this3.asyncCallbacks) {
                apiRTCManager.removeEventListener('groupChatMemberUpdate', _this3.asyncCallbacks.groupChatMemberUpdate);
                clearTimeout(_this3.asyncCallbacks.timeoutId);
                delete _this3.asyncCallbacks;
              }

              return resolve();
            }
          };

          apiRTCManager.onEvent('groupChatMemberUpdate', _this3.asyncCallbacks.groupChatMemberUpdate);
          apiRTCManager.joinGroupChat(_this3._getTechnicalName());
        });
      };

      return new Promise(function (resolve, reject) {
        if (_this3.groupChatStatus !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'joinGroupChat() - cannot join group chat', logger));
        }

        _this3.bind().then(function () {
          return join();
        }).then(function () {
          _this3.groupChatStatus = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED;
          apiRTCManager.joinAndSubscribeToPresenceGroup(_this3._getTechnicalName());
          resolve();
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'joinGroupChat() - cannot join group chat', logger, {
            fromError: err
          }));
        });
      });
    }
    /**
     * Leaves group chat.
     * @return {Promise}
     */

  }, {
    key: "leaveGroupChat",
    value: function leaveGroupChat() {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (_this4.groupChatStatus !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'leaveGroupChat() - group chat not joined', logger));
        }

        if (_this4.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'leaveGroupChat() - webconf active', logger));
        }

        apiRTCManager.leaveGroupChat(_this4._getTechnicalName()).then(function () {
          _this4.groupChatStatus = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED;
          apiRTCManager.leaveAndUnsubscribeToPresenceGroup(_this4._getTechnicalName());
          resolve();
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'leaveGroupChat() - cannot leave group chat', logger, {
            fromError: err
          }));
        });
      });
    }
    /**
     * Checks if the conversation is joined
     *
     * @return {Boolean}
     */

  }, {
    key: "isJoined",
    value: function isJoined() {
      return this.status === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED;
    }
    /**
     * Represents a simulcast stream quality (a.k.a. substream).
     * @typedef {Object} SimulcastQualityOptions
     * @property {number} maxBitrate - The maximum outgoing bitrate. In kbps.
     * @property {number} scaleResolutionDownBy - The resolution scaling factor for medium and low quality. Optional.
     */

    /**
     * Represents the encodings preferences for simulcasting. Encodings are
     * devided into three substreams (high, medium and low), each one with its
     * own properties.
     * For every substream, the maxBitrate property is mandatory and the
     * scaleResolutionDownBy property is optional.
     * Regarding the maxBitrate property, it is recommended to set sensible
     * values: the value must be different for every substream, with the highest
     * value for the high substream and the lowest value for the low substream.
     * Regarding the scaleResolutionDownBy property, it is recommended to either
     * not set the value at all, or to set to 2 the medium substream and to 4
     * the low substream.
     * @typedef {Object} SimulcastEncodingsOptions
     * @property {SimulcastQualityOptions} high - The highest quality.
     * @property {SimulcastQualityOptions} medium - The intermediate quality.
     * @property {SimulcastQualityOptions} low - The lowest quality.
     */

    /**
     * Represents user preferences for simulcasting.
     * The object itself activates the simulcast feature.
     * The outgoing bitrate may be configured with either the maxBitrate
     * property or with the encodings property.
     * If none of the properties is defined, the default settings will be:
     * <pre><code>
     * {
     *     high:   { maxBitrate: 900 },
     *     medium: { maxBitrate: 300, scaleResolutionDownBy: 2 },
     *     low:    { maxBitrate: 100, scaleResolutionDownBy: 4  }
     * }
     * </code></pre>
     * @typedef {SimulcastOptions} Simulcast
     * @property {number} maxBitrate - The maximum outgoing bitrate. In kbps. Optional.
     * @property {SimulcastEncodingsOptions} encodings - If maxBitrate is undefined. Optional.
     */

    /**
     * @typedef PublishOptions
     * @type {Object}
     * @property {String} turnServerAddress - Modify the turn server used for the call.
     * @property {Object} qos - QoS preferences.
     * @property {Number} qos.videoMinBitrate - Defines minimum video bitrate.
     * @property {String} qos.videoMinQuality - Defines minimum video quality (one of excellent, good, medium or bad).
     * @property {Number} qos.videoStartBitrate - Defines start video bitrate.
     * @property {String} qos.videoStartQuality - Defines start video quality (one of upper, excellent, good, medium or bad).
     * @property {Boolean} qos.videoForbidInactive - Forbids video disabling.
     * @property {Object} audioLabels - Array of string(s). Used for stream selection, for conversation recording.
     * @property {Object} videoLabels - Array of string(s). Used for stream selection, for conversation recording.
     * @property {Boolean} audioOnly - true if publish is to be done in audio only. Video is used by default.
     * @property {Boolean} videoOnly - true if publish is to be done in video only. Video is used by default, audioOnly parameter is used in priority.
     * @property {Object} context - User defined context.
     * @property {Boolean} distributedBroadcastEnabled - Whether the broadcast of given stream can be distributed on multiple conference servers.
     * @property {SimulcastOptions} simulcast - To activate and configure simulcasting.
     */
    //TODO Test and add in PublishOptions doc

    /*
        {Boolean} private : true if publish is to be done for the user only. This stream will not be shared with other participant in the conference : this can be used for instance to record the stream. Default value is false
        {Boolean} record : true if this stream has to be recorded on the server. Default value is false
    */

    /**
     * Does the stream is currently published in conversation
     *
     * @param {Stream} stream Stream for which you want to know the publish status
     * @returns {boolean}
     */

  }, {
    key: "isPublishedStream",
    value: function isPublishedStream(stream) {
      return stream.publishedInConversations.has(this.getName());
    }
    /**
     * Publish stream to conversation
     * The stream will be able to be subscribed by other contacts within the conversation
     *
     * @param {Stream} stream - Stream to publish
     * @param {PublishOptions} options - Publish options.
     * @returns {Promise<Stream>} Published stream in promise.
     */

  }, {
    key: "publish",
    value: function publish(stream, options) {
      var _this5 = this;

      if (!options) {
        options = {};
      }

      return new Promise(function (resolve, reject) {
        if (_this5.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'publish() - conversation not joined', logger));
        } else if (!(stream instanceof _Stream__WEBPACK_IMPORTED_MODULE_4__.Stream)) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'publish() - No stream specified', logger));
        } else if (_this5.isPublishedStream(stream)) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'publish() - Stream is already published in this conversation!', logger));
        } else {
          var callConfiguration = {};
          callConfiguration.userMediaStreamId = stream.userMediaStreamId;

          if (options !== null && _typeof(options) === 'object') {
            callConfiguration.audioOnly = options.audioOnly;
            callConfiguration.videoOnly = options.videoOnly;
            callConfiguration["private"] = options["private"];
            callConfiguration.record = options.record;
            callConfiguration.turnServerAddress = options.turnServerAddress;
            callConfiguration.profileType = options.profileType;
            callConfiguration.priority = options.priority;
            callConfiguration.downgradeProfileList = options.downgradeProfileList;
            callConfiguration.distributedBroadcastEnabled = options.distributedBroadcastEnabled;
          }

          if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'mediaType', 'string')) {
            callConfiguration.mediaType = options.mediaType;

            if (callConfiguration.audioOnly) {
              callConfiguration.mediaType = "AUDIOONLY";
            }

            if (callConfiguration.videoOnly) {
              callConfiguration.mediaType = "VIDEOONLY";
            }
          } // QOS preferences.


          if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'qos', 'object')) {
            callConfiguration.qos = {};

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options.qos, 'videoMinBitrate', 'number')) {
              callConfiguration.qos.videoMinBitrate = options.qos.videoMinBitrate;
            }

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options.qos, 'videoMinQuality', 'string')) {
              callConfiguration.qos.videoMinQuality = options.qos.videoMinQuality;
            }

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options.qos, 'videoStartBitrate', 'number')) {
              callConfiguration.qos.videoStartBitrate = options.qos.videoStartBitrate;
            }

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options.qos, 'videoStartQuality', 'string')) {
              callConfiguration.qos.videoStartQuality = options.qos.videoStartQuality;
            }

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options.qos, 'videoForbidInactive', 'boolean')) {
              callConfiguration.qos.videoForbidInactive = options.qos.videoForbidInactive;
            }
          } // Simulcast


          if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'simulcast', 'object') && !callConfiguration.audioOnly) {
            callConfiguration.simulcast = {};

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options.simulcast, 'mode', 'string') && ['RID', 'SDP'].indexOf(options.simulcast.mode) >= 0) {
              callConfiguration.simulcast.mode = options.simulcast.mode;
            }

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options.simulcast, 'maxBitrate', 'number')) {
              callConfiguration.simulcast.maxBitrate = options.simulcast.maxBitrate;
            } else if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options.simulcast, 'encodings', 'object')) {
              callConfiguration.simulcast.encodings = Object.assign({}, options.simulcast.encodings);
            }
          } // audioLabels and videoLabels for recording.


          ['audioLabels', 'videoLabels'].forEach(function (item) {
            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(options, item, 'array')) {
              callConfiguration[item] = [];
              options[item].forEach(function (l) {
                if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(l, 'string')) {
                  callConfiguration[item].push(l);
                }
              });
            }
          });

          if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'context', 'object')) {
            callConfiguration.context = options.context;
          } // robust video


          var bitrate = null;

          if (stream.hasVideo() && _this5.getNetworkCap({
            capacity: true
          }) && options.profileType && options.downgradeProfileList) {
            // Look for bitrate of future call
            for (var idx = options.downgradeProfileList.length; --idx >= 0;) {
              if (options.downgradeProfileList[idx].name === options.profileType) {
                if (options.downgradeProfileList[idx].bitrate) {
                  bitrate = options.downgradeProfileList[idx].bitrate;
                }

                break;
              }
            } // for

          }

          if (bitrate) {
            // Test whether there is available bandwidth
            if (!_this5.reserveResources(options.profileType, bitrate, stream.userMediaStreamId, false, options.priority, {
              isVideoOnly: !stream.hasAudio(),
              isVideoMuted: callConfiguration.audioOnly,
              control: true
            })) {
              // Requested bandwidth not available
              // Look for streams with lower priority for video track to disable
              if (!_this5.disableLowerPriorityVideo(false, bitrate, options.priority)) {
                // No stream with lower priority
                if (!stream.hasAudio()) {
                  // No audio and video not possible.
                  return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'publish() - not enough bandwidth', logger));
                } // Remove video track


                callConfiguration.audioOnly = true;
              }
            } // Reserve resources


            _this5.reserveResources(options.profileType, bitrate, stream.userMediaStreamId, false, options.priority, {
              isVideoOnly: !stream.hasAudio(),
              isVideoMuted: callConfiguration.audioOnly
            });
          }

          logger.info('callConfiguration:', callConfiguration);
          var forceScreenSharingCallType = stream.isScreensharing();
          var callId = apiRTCManager.webRTCClient.publish(_this5.sessionId, _this5.sessionId, _this5.token, callConfiguration, {}, {
            forceScreenSharingCallType: forceScreenSharingCallType
          });

          if (!callId) {
            _this5.releaseResources(stream.userMediaStreamId);

            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'publish() - failed to establish call', logger));
          }

          _this5.conversationCalls.set(callId, new _ConversationCall__WEBPACK_IMPORTED_MODULE_8__.ConversationCall(_this5, callId, stream));

          stream.publishedInConversations.set(_this5.getName(), callId); //Adding entry in callIdToStreamId

          _this5.callIdToStreamId.set(callId, stream.userMediaStreamId);

          var streamInfo = {
            contact: null,
            isRemote: false,
            hasAudio: stream.hasAudio(),
            hasVideo: stream.hasVideo(),
            isScreensharing: stream.isScreensharing(),
            streamId: stream.userMediaStreamId,
            callId: callId
          };

          _this5.conversationPublishedStreams.set(stream.userMediaStreamId, streamInfo); // Set listeners for promise resolution/rejection


          var handlers = {};

          handlers.callEstablishedHandler = function (e) {
            if (e.detail.callId.toString() === callId.toString()) {
              apiRTCManager.removeEventListener('callEstablished', handlers.callEstablishedHandler);

              _this5.removeListener('error', handlers.errorHandler);

              resolve(stream);
            }
          };

          apiRTCManager.onEvent('callEstablished', handlers.callEstablishedHandler);

          handlers.errorHandler = function (error) {
            if (error.callId === callId) {
              apiRTCManager.removeEventListener('callEstablished', handlers.callEstablishedHandler);

              _this5.removeListener('error', handlers.errorHandler);

              _this5.releaseResources(stream.userMediaStreamId);

              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'publish() - ' + error.errorInfo, logger));
            }
          };

          _this5.on('error', handlers.errorHandler);
        }
      });
    }
    /**
     * Unpublishes currently published stream to conversation
     * If other users within the conversation subscribed to this stream, it will be stopped on their side
     *
     * @param {Stream} stream Stream to unpublish
     * @param {Object} options
     * @returns {Void}
     */

  }, {
    key: "unpublish",
    value: function unpublish(stream, options) {
      if (!options) {
        options = {};
      }

      if (!(stream instanceof _Stream__WEBPACK_IMPORTED_MODULE_4__.Stream)) {
        logger.error('unpublish() - No stream specified', stream);
      } else if (!this.isPublishedStream(stream)) {
        logger.error('unpublish() - Stream is not publishing to conversation');
      } else {
        var callId = stream.publishedInConversations.get(this.getName()); // Stream#publishedInConversations is used by Conbversation#isPublishedStream
        // to known whether a stream is published: delete before calling unpublish
        // so Conversation#unpublish can be called only once per stream/call.

        var triggerAdaptation = !options.noTriggerAdaptation;
        destroyPublishCall(this, callId, {
          stream: stream,
          triggerAdaptation: triggerAdaptation
        });

        if (apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.unpublish(callId);
        }
      }
    }
    /**
     * @typedef RecordingInfo
     * @type {Object}
     * @property {String} roomName - Room name.
     * @property {String} callId - Call identifier.
     * @property {String} recordType - Type of record. Either 'userStream' or 'composite'.
     * @property {String} convId - Conversation identifier.
     * @property {String} mediaId - Media identifier.
     * @property {String} mediaURL - Media URL.
     * @property {String} recordedFileName - File name.
     */

    /**
     * @typedef StreamingInfo
     * @type {Object}
     * @property {String} roomName
     * @property {String} callId
     * @property {String} clientId
     */

    /**
     * Returns the conversation call handle for a given stream.
     * @param {Stream} stream - A stream (result of publish).
     * @return {ConversationCall|null} A conversation call handle on success, null otherwise.
     */

  }, {
    key: "getConversationCall",
    value: function getConversationCall(stream) {
      if (!stream) {
        return null;
      }

      var callId = stream.publishedInConversations.get(this.getName());

      if (!callId) {
        return null;
      }

      return this.conversationCalls.get(callId);
    }
    /**
     * @ignore
     */

  }, {
    key: "getCallId",
    value: function getCallId(stream) {
      return stream.publishedInConversations.get(this.getName());
    }
    /**
     * @typedef ConferenceAccessStatus
     * @type {Object}
     * @property {string} access - Either GRANTED or NEED_MODERATOR_ACCEPTATION.
     * @property {string} role - Either moderator, contributor or guest.
     * @property {string} moderator - User id of conference moderator.
     * @property {string} friendlyName - Display name of the conference.
     */

    /**
     * Returns the access status of the conference represented by this one.
     *
     * @param {object} options - Optional data.
     * @param {boolean} options.force - Whether not to use cache.
     * @param {string} options.password - Conference password (if necessary).
     * @param {Session} options.session
     * @return {Promise<ConferenceAccessStatus>}
     */

  }, {
    key: "checkAccess",
    value: function checkAccess(options) {
      var _this6 = this;

      if (!options) {
        options = {};
      }

      return new Promise(function (resolve, reject) {
        if (options.force !== true && _this6.accessStatus) {
          return resolve(_this6.accessStatus);
        } else {
          if (!options.hasOwnProperty('session') && _Session__WEBPACK_IMPORTED_MODULE_5__.Session.getActiveSession() !== null) {
            options.session = _Session__WEBPACK_IMPORTED_MODULE_5__.Session.getActiveSession();
          }

          _this6.bind(options).then(function (convId) {
            options.convId = convId;
            return cloudApi.checkConferenceAccess(_this6._getTechnicalName(), apiRTCManager.getActiveApiKey(), options);
          }).then(function (res) {
            if (res.access !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ACCESS_GRANTED && res.access !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_NEED_MODERATOR_ACCEPTATION) {
              logger.warn('checkAccess() - unknown access response:', res.access);
            }

            if (res.role !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_MODERATOR && res.role !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_CONTRIBUTOR && res.role !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_GUEST) {
              logger.warn('checkAccess() - unknown role response:', res.role);
            }

            if (res.hasOwnProperty('webconfId')) {
              _this6.webconfId = res.webconfId;
              delete res.webconfId;
            }

            _this6.accessStatus = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject({}, res);
            return resolve(_this6.accessStatus);
          })["catch"](function (err) {
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_APIRTC_INITIALISATION_FAILED, 'checkAccess() - cannot check access', logger, {
              fromError: err
            }));
          });
        }
      });
    }
    /**
     * @typedef JoinOptions
     * @property {Session} session - Needed if user is moderator and to save group messages to cloud
     * @property {string} password - Used for password-protected conferences
     * @property {boolean} qualityAdaptationEnabled - Enables quality adaptation and disables slowLink adaptation.
     */

    /**
     * @typedef JoinResult
     * @property {string} mode - Either 'mesh' or undefined.
     * @property {boolean} meshOnly - Whether the mesh mode is the only mode allowed, i.e. no transition to another mode will occur.
     */

    /**
     * Connects to a conversation if not already joined
     * Once in the conversation, the user will be able to see other contacts inside it, send and receive messages, publish streams and subscribe to conversation's streams
     *
     *  @param {JoinOptions} options - Optional data.
     *  @returns {Promise<JoinResult>}
     */

  }, {
    key: "join",
    value: function join() {
      var _this7 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      logger.debug('Joining ' + this.getName());
      return new Promise(function (resolve, reject) {
        if (_this7.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'join() - cannot join conversation', logger));
        }

        options = Object.assign({}, options);
        var qualityAdaptationEnabled = false;

        if (options.qualityAdaptationEnabled) {
          qualityAdaptationEnabled = true;
          delete options.qualityAdaptationEnabled;
        }

        var supportedVideoCodecs = null;

        if (options.supportedVideoCodecs) {
          supportedVideoCodecs = options.supportedVideoCodecs;
          delete options.supportedVideoCodecs;
        }

        _this7.checkAccess(options).then(function (res) {
          if (!_this7.conference) {
            if (res.type !== 'public') {
              return Promise.reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_UNAUTHORIZED, 'join() - wrong conference type', logger));
            } else if (res.access !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ACCESS_GRANTED) {
              return Promise.reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_UNAUTHORIZED, 'join() - access to conference not granted', logger));
            }
          }

          return handleConversationModeration(_this7, res);
        }).then(function (res) {
          _role.set(_this7, res.role);

          _this7.status = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINING;

          if (_this7.conference) {
            // Memorize password for invitations
            if (options.hasOwnProperty('password')) {
              _password.set(_this7, options.password);
            }

            _this7.friendlyName = res.hasOwnProperty('friendlyName') ? res.friendlyName : _this7.friendlyName;

            _instanceId.set(_this7, res.instanceId);

            return updateConferencePresence(_this7, _mySession.get(_this7), apiRTCManager.getActiveApiKey());
          }
        }).then(function () {
          var self = _this7;

          var joinMCUSessionAnswerHandler = function joinMCUSessionAnswerHandler(e) {
            logger.debug('joinMCUSessionAnswer', self._getTechnicalName(), e.detail);

            if (e.detail.roomId.toString() === self._getTechnicalName()) {
              if (e.detail.result && e.detail.result.failed) {
                logger.error('Conversation ' + self.getName() + ' join failed', e.detail);
                this.status = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED;
                var reason = e.detail.result.reason ? e.detail.result.reason : 'join failed';
                return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_UNAUTHORIZED, 'join() - ' + reason, logger));
              }

              logger.info('Conversation ' + self.getName() + ' joined', e.detail);
              apiRTCManager.removeEventListener('joinMCUSessionAnswer', joinMCUSessionAnswerHandler); //avoid event being retriggered

              self.status = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED;
              self.token = e.detail.token;
              self.sessionId = e.detail.sessionId;
              self.mode = e.detail.mode;
              self.conversationStreams = new Map();

              var apiRTCEventListeners = _apiRTCEventListeners.get(self); //Link apirtc event listeners on conversation joined so they can be removed when conversation is left


              apiRTCManager.onEvent('MCUAvailableStream', apiRTCEventListeners.MCUAvailableStream).onEvent('MCUAvailableStreamUpdate', apiRTCEventListeners.MCUAvailableStreamUpdate).onEvent('MCURemoveStream', apiRTCEventListeners.MCURemoveStream).onEvent('MCUAvailableComposite', apiRTCEventListeners.MCUAvailableComposite).onEvent('MCUAvailableReplay', apiRTCEventListeners.MCUAvailableReplay).onEvent('MCUParticipantEjected', apiRTCEventListeners.MCUParticipantEjected).onEvent('remoteStreamAdded', apiRTCEventListeners.remoteStreamAdded).onEvent('remoteStreamRemoved', apiRTCEventListeners.remoteStreamRemoved).onEvent('roomMemberUpdate', apiRTCEventListeners.roomMemberUpdate).onEvent('slowLink', apiRTCEventListeners.slowLink).onEvent('localStreamUpdated', apiRTCEventListeners.localStreamUpdated).onEvent('remoteStreamUpdated', apiRTCEventListeners.remoteStreamUpdated).onEvent('simulcastFeedChanged', apiRTCEventListeners.simulcastFeedChanged).onEvent('MCURecordingStarted', apiRTCEventListeners.MCURecordingStarted).onEvent('MCURecordingStopped', apiRTCEventListeners.MCURecordingStopped).onEvent('MCURecordedStreamsAvailable', apiRTCEventListeners.MCURecordedStreamsAvailable).onEvent('MCUStreamingStarted', apiRTCEventListeners.MCUStreamingStarted).onEvent('MCUStreamingStopped', apiRTCEventListeners.MCUStreamingStopped).onEvent('MCURoomModeChanged', apiRTCEventListeners.MCURoomModeChanged).onEvent('onCallStatsUpdate', apiRTCEventListeners.onCallStatsUpdate).onEvent('hangup', apiRTCEventListeners.hangup).onEvent('callRestarting', apiRTCEventListeners.callRestarting).onEvent('audioAmplitude', apiRTCEventListeners.audioAmplitude).onEvent('videoQualityChanged', apiRTCEventListeners.videoQualityChanged).onEvent('cpuLimited', apiRTCEventListeners.cpuLimited).onEvent('bandwidthLimited', apiRTCEventListeners.bandwidthLimited);

              if (self.conference) {
                self.updateData();
              }

              if (self.getRole() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_MODERATOR) {
                // Make moderator subscribes to conversation's waiting room.
                apiRTCManager.apiRTCSession.subscribePresenceGroup([_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WAITING_ROOM_PREFIX + self._getTechnicalName()]);
                self.pgroupWaitingRoomSubscribedTo = true;
              }

              if (self.groupChatStatus !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED) {
                self.groupChatStatus = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED;
              }

              _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(self).emit('joined');

              var _result = {};

              if (e.detail.mode === 'mesh') {
                _result.mode = 'mesh';

                if (e.detail.meshOnly === true) {
                  _result.meshOnly = true;
                }
              }

              resolve(_result);
            }
          };

          apiRTCManager.onEvent('joinMCUSessionAnswer', joinMCUSessionAnswerHandler);
          var joinOpts = {};
          joinOpts.convId = _this7.getCloudConversationId();

          if (_this7.meshModeEnabled) {
            joinOpts.meshModeEnabled = _this7.meshModeEnabled;
          }

          if (_this7.meshOnlyEnabled) {
            joinOpts.meshOnlyEnabled = _this7.meshOnlyEnabled;
          }

          if (!_this7.conference) {
            if (_this7.moderationEnabled) {
              joinOpts.moderationEnabled = true;
            }

            if (_this7.getRole() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_MODERATOR) {
              joinOpts.moderator = true;
            }
          }

          if (qualityAdaptationEnabled) {
            joinOpts.qualityAdaptationEnabled = true;
          }

          if (supportedVideoCodecs) {
            joinOpts.supportedVideoCodecs = supportedVideoCodecs;
          }

          var result = apiRTCManager.webRTCClient.joinMCUSession(_this7._getTechnicalName(), joinOpts);

          if (result instanceof Error) {
            apiRTCManager.removeEventListener('joinMCUSessionAnswer', joinMCUSessionAnswerHandler); //avoid event being retriggered

            self.status = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED;
            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'join() - cannot join conversation :' + result.message, logger));
          }
        })["catch"](function (err) {
          _this7.status = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED;
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'join() - cannot join conversation', logger, {
            fromError: err
          }));
        });
      });
    }
    /**
     * Cancels an ongoing join request.
     * @return {boolean} true on success, false otherwise.
     */

  }, {
    key: "cancelJoin",
    value: function cancelJoin() {
      if (this.cancelJoin0 !== null && typeof this.cancelJoin0 === 'function') {
        return this.cancelJoin0();
      }

      return false;
    }
    /**
     * Ejects a given contact from the converation.
     * @param {Contact} contact - The contact to eject.
     * @param {object} data - User data (optional).
     * @return {Promise<void>}
     */

  }, {
    key: "eject",
    value: function eject(contact, data) {
      var _this8 = this;

      return new Promise(function (resolve, reject) {
        if (_this8.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'eject() - conference not joined', logger));
        } else if (_this8.getRole() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_MODERATOR) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_UNAUTHORIZED, 'eject() - only moderator can eject a contact', logger));
        }

        var context = {}; // Set timeout to handle lack of response from CCS.

        context.timeoutId = setTimeout(function () {
          if (context) {
            apiRTCManager.removeEventListener('MCUParticipantEjected', context.ejected);
            context = false;
          }

          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'eject() - timeout', logger));
        }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_PARTICIPANT_EJECTION_DELAY);

        context.ejected = function (e) {
          if (e.detail.roomId === _this8._getTechnicalName() && e.detail.clientId === contact.getId()) {
            // The participant has been ejected.
            if (context) {
              clearTimeout(context.timeoutId);
              apiRTCManager.removeEventListener('MCUParticipantEjected', context.ejected);
              context = false;
            }

            return resolve();
          }
        };

        apiRTCManager.onEvent('MCUParticipantEjected', context.ejected);
        apiRTCManager.webRTCClient.ejectParticipantFromMCUSession(contact.getId(), data);
      });
    }
    /**
     * Allows entry to contact in waiting room as moderator.
     * @param {Contact} contact - The contact to grant access to.
     * @param {object} options
     * @param {string} options.invitationId
     * @param {string} options.answer
     * @param {boolean} options.ackEnabled
     * @return {Promise<void>}
     */

  }, {
    key: "allowEntry",
    value: function allowEntry(contact, options) {
      var _this9 = this;

      if (!options) {
        options = {};
      }

      return new Promise(function (resolve, reject) {
        if (_this9.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'allowEntry() - conference not joined', logger));
        } else if (!(contact instanceof _Contact__WEBPACK_IMPORTED_MODULE_6__.Contact)) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'allowEntry() - parameter is not an instance of apiRTC.Contact', logger));
        } else if (_this9.getRole() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_MODERATOR) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_UNAUTHORIZED, 'allowEntry() - only moderator can allow entry to a contact', logger));
        }

        var data = {
          roomname: _this9._getTechnicalName(),
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_ANSWER_IDENTIFIER,
          access: true,
          //izeeconf compatibility
          command: 'access',
          value: {
            access: true
          }
        };

        if (options.hasOwnProperty('invitationId')) {
          data.invitationId = options.invitationId;
        }

        if (options.hasOwnProperty('answer')) {
          data.answer = options.answer;
        }

        apiRTCManager.sendData(contact.getId(), data)["catch"](function (errCode) {
          var newError = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(errCode, 'Notification not delivered', logger);

          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_this9).emit('messageNotDelivered', {
            error: newError,
            contact: contact,
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_ANSWER_IDENTIFIER,
            command: 'access'
          });
        });

        if (options.ackEnabled === true) {
          // Keep sending access granted until acknowledged.
          var intervalId = setInterval(function () {
            data.command = 'access-new';
            apiRTCManager.sendData(contact.getId(), data)["catch"](function (errCode) {
              var newError = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(errCode, 'Notification not delivered', logger);

              _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_this9).emit('messageNotDelivered', {
                error: newError,
                contact: contact,
                event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_ANSWER_IDENTIFIER,
                command: 'access'
              });
            });
          }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_REQUEST_INTERVAL);

          var receiveDataHandler = function receiveDataHandler(e) {
            var sender = contactCatalog.getOrCreateContact(e.detail.senderId);

            if (e.detail.hasOwnProperty('data') && e.detail.data.command === 'access-ack' && e.detail.data.roomname === _this9._getTechnicalName() && sender.getId() === contact.getId()) {
              clearInterval(intervalId);
              apiRTCManager.removeEventListener('receiveData', receiveDataHandler);
            }
          };

          apiRTCManager.onEvent('receiveData', receiveDataHandler);
        }

        return resolve();
      });
    }
    /**
     * Denies entry to contact in waiting room as moderator.
     * @param {Contact} contact - The contact to deny access to.
     * @param {object} options
     * @param {string} options.invitationId
     * @param {string} options.answer
     * @param {string} options.reason
     * @return {Promise<void>}
     */

  }, {
    key: "denyEntry",
    value: function denyEntry(contact, options) {
      var _this10 = this;

      if (!options) {
        options = {};
      }

      return new Promise(function (resolve, reject) {
        if (_this10.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'denyEntry() - conference not joined', logger));
        } else if (!(contact instanceof _Contact__WEBPACK_IMPORTED_MODULE_6__.Contact)) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'denyEntry() - parameter is not an instance of apiRTC.Contact', logger));
        } else if (_this10.getRole() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_MODERATOR) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_UNAUTHORIZED, 'denyEntry() - only moderator can deny entry to a contact', logger));
        }

        var data = {
          roomname: _this10._getTechnicalName(),
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_ANSWER_IDENTIFIER,
          access: false,
          //izeeconf compatibility
          command: 'access',
          value: {
            access: false
          }
        };

        if (options.hasOwnProperty('invitationId')) {
          data.invitationId = options.invitationId;
        }

        if (options.hasOwnProperty('answer')) {
          data.answer = options.answer;
        }

        if (options.hasOwnProperty('reason')) {
          data.reason = options.reason;
        }

        apiRTCManager.sendData(contact.getId(), data)["catch"](function (errCode) {
          var newError = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(errCode, 'Notification not delivered', logger);

          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_this10).emit('messageNotDelivered', {
            error: newError,
            contact: contact,
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_ANSWER_IDENTIFIER,
            command: 'access'
          });
        });
        return resolve();
      });
    }
    /**
     * Sends join request to moderator, if in waiting room.
     * @ignore
     * @return {void}
     */

  }, {
    key: "sendJoinRequest",
    value: function sendJoinRequest() {
      var _this11 = this;

      if (this.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_WAITING) {
        logger.error('sendJoinRequest() - Not in conversation\'s waiting room, cannot send join request');
        return;
      }

      if (this.joinRequestIntervalId) {
        // Interval already set.
        return;
      }

      var moderatorId = getConversationModeratorId(this);

      if (!moderatorId) {
        return;
      }

      apiRTCManager.sendData(moderatorId, {
        roomname: this._getTechnicalName(),
        event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_REQUEST_IDENTIFIER,
        invitationId: this._getTechnicalName(),
        sendTime: Date.now(),
        command: 'userWaiting',
        // izeeconf compatibility
        value: {
          username: getUserAgentUsername()
        }
      })["catch"](function (errCode) {
        var newError = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(errCode, 'Notification not delivered', logger);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_this11).emit('messageNotDelivered', {
          error: newError,
          contact: _this11.getModerator(),
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_REQUEST_IDENTIFIER,
          command: 'userWaiting'
        });
      });
      this.joinRequestIntervalId = setInterval(function () {
        apiRTCManager.sendData(moderatorId, {
          roomname: _this11._getTechnicalName(),
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_REQUEST_IDENTIFIER,
          invitationId: _this11._getTechnicalName(),
          sendTime: Date.now(),
          command: 'userWaiting-new',
          // izeeconf compatibility
          value: {
            username: getUserAgentUsername()
          }
        })["catch"](function (errCode) {
          var newError = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(errCode, 'Notification not delivered', logger);

          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_this11).emit('messageNotDelivered', {
            error: newError,
            contact: _this11.getModerator(),
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_REQUEST_IDENTIFIER,
            command: 'userWaiting-new'
          });
        });
      }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_REQUEST_INTERVAL);
    }
    /**
     * Leaves conversation
     * The user will automatically stop publishing its streams to the conversation and stop subscribing to streams from the conversation.
     * The user will no longer receive events from the conversation
     * The user will no longer see who's within the conversation
     *
     * @return {Promise}
     */

  }, {
    key: "leave",
    value: function leave() {
      var _this12 = this;

      return new Promise(function (resolve, reject) {
        if (_this12.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'leave() - webconf not joined', logger));
        }

        var apiRTCEventListeners = _apiRTCEventListeners.get(_this12); //destroy conversation listeners


        for (var _i2 = 0, _Object$keys2 = Object.keys(apiRTCEventListeners); _i2 < _Object$keys2.length; _i2++) {
          var key = _Object$keys2[_i2];
          logger.info('Session, removing apiRTCManager event :', key);
          var listener = apiRTCEventListeners[key];
          apiRTCManager.removeEventListener(key, listener);
        }

        var _iterator12 = _createForOfIteratorHelper(_this12.conversationStreams.keys()),
            _step12;

        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var _key4 = _step12.value;
            logger.trace('Leave() - unsubscribe to ' + _key4);
            apiRTCManager.webRTCClient.unsubscribe(_key4);
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }

        _enablePointerSharing(_this12, false, false).then(function () {})["catch"](function (err) {});

        apiRTCManager.IMClient.leaveGroupChat(_this12._getTechnicalName());

        if (_this12.whiteboardStarted === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WHITEBOARD_STARTED) {
          if (apiRTCManager.whiteBoardClient.roomId === _this12._getTechnicalName()) {
            apiRTCManager.whiteBoardClient.leaveRoom();
            apiRTCManager.whiteBoardClient.stop();
            _this12.whiteboardStarted = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WHITEBOARD_NOT_STARTED;
          }
        }

        apiRTCManager.webRTCClient.leaveMCUSession();
        _this12.conversationStreams = new Map();
        _this12.status = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED;

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_this12).emit('left');

        resolve();
      });
    }
    /**
     * @typedef SubscribeOptions
     * @type {Object}
     * @property {Boolean} audioOnly : true if publish is to be done in audio only. Video is used by default
     * @property {Boolean} videoOnly : true if publish is to be done in video only. Video is used by default, audioOnly parameter is used in priority.
     * @property {String} turnServerAddress This enables to change the turn server used for the call
     * @property {Object} qos - QoS preferences.
     * @property {Boolean} qos.videoForbidInactive - Forbids video disabling.
     * @property {Object} simulcast
     * @property {string} simulcast.streamQuality - Substream selection. Either 'high', 'medium' or 'low'. Default is 'high'.
     * @property {string} simulcast.streamFrameRate - Temporal layer selection. Either 'high', 'medium' or 'low'. Default is 'high'.
     */

    /**
     * Subscribes to a stream.
     *
     * The subscription will automatically stop if the contact publishing the stream unpublishes it.
     *
     * The Conversation#streamAdded event will be fired when the stream becomes available.
     * The Conversation#streamRemoved event will be fired when the stream is no longer available.
     * The Conversation#hangup event will be fired the subscription is terminated.
     *
     * Note that multiple Conversation#streamAdded and Conversation#streamRemoved events might be
     * fired in case failure correction.
     *
     * @param {(number|string)} streamId - Stream ID. Represents the stream to subscribe to.
     * @param {SubscribeOptions} options
     * @return {Promise}
     */

  }, {
    key: "subscribeToStream",
    value: function subscribeToStream(streamId, options) {
      var _this13 = this;

      if (!options) {
        options = {};
      }

      logger.debug('subscribeToMedia', streamId);

      if (!this.isJoined()) {
        return Promise.reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'subscribeToMedia() - conversation not joined', logger));
      }

      var callConfiguration = {};

      if (options.turnServerAddress !== null && options.turnServerAddress !== undefined) {
        callConfiguration.turnServerAddress = options.turnServerAddress;
      } // QOS preferences.


      if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'qos', 'object')) {
        callConfiguration.qos = {};

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options.qos, 'videoForbidInactive', 'boolean')) {
          callConfiguration.qos.videoForbidInactive = options.qos.videoForbidInactive;
        }
      }

      var parsedStreamId = Number(streamId);
      var stream = apiRTCManager.webRTCClient.getStreamFromList(parsedStreamId);
      var streamInfo = this.conversationStreams.get(parsedStreamId);

      if (!stream || !streamInfo) {
        return Promise.reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'subscribeToMedia() - no such stream', logger));
      } // Simulcast preferences


      if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'simulcast', 'object')) {
        var ALLOWED_PREFS = ['high', 'medium', 'low'];
        callConfiguration.simulcast = {};

        if (options.simulcast.streamQuality) {
          if (ALLOWED_PREFS.indexOf(options.simulcast.streamQuality) >= 0) {
            callConfiguration.simulcast.streamQuality = options.simulcast.streamQuality;
          } else {
            // Let the system choose the value.
            callConfiguration.simulcast.streamQuality = 'default';
          }
        }

        if (options.simulcast.streamFrameRate) {
          if (ALLOWED_PREFS.indexOf(options.simulcast.streamFrameRate) >= 0) {
            callConfiguration.simulcast.streamFrameRate = options.simulcast.streamFrameRate;
          } else {
            // Let the system choose the value.
            callConfiguration.simulcast.streamFrameRate = 'default';
          }
        }
      }

      return new Promise(function (resolve, reject) {
        var mediaType = 'VIDEO';

        if (streamInfo.hasVideo && _this13.getNetworkCap({
          capacity: true
        }) && _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(streamInfo, 'descriptor', 'object')) {
          // robust video
          var descr = streamInfo.descriptor; // Test whether there is enough bandwidth to subscribe.

          if (!_this13.reserveResources(descr.profileType, descr.bitrate, parsedStreamId, true, descr.priority, {
            isVideoOnly: !streamInfo.hasAudio,
            isVideoMuted: options.audioOnly,
            control: true
          })) {
            // Requested bandwidth not available.
            // Disable video track of streams with lower priority.
            if (!_this13.disableLowerPriorityVideo(true, descr.bitrate, descr.priority)) {
              // Not possible.
              if (!streamInfo.hasAudio) {
                // No audio and video not possible
                return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'subscribeToMedia() - not enough bandwidth', logger));
              } // Disable video


              options.audioOnly = true;
            }
          }

          _this13.reserveResources(descr.profileType, descr.bitrate, parsedStreamId, true, descr.priority, {
            isVideoOnly: !streamInfo.hasAudio,
            isVideoMuted: options.audioOnly
          });
        }

        if (options.audioOnly === true) {
          mediaType = 'AUDIOONLY';
        } else if (options.videoOnly === true) {
          mediaType = 'VIDEOONLY';
        }

        var callId = apiRTCManager.webRTCClient.subscribe([stream], mediaType, {}, callConfiguration, options)[0];

        if (!callId) {
          _this13.releaseResources(parsedStreamId);

          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'subscribeToMedia() - stream not available', logger));
        } // Set callId to streamId association map


        _this13.callIdToStreamId.set(callId, parsedStreamId);

        logger.debug('Subscribed to stream ' + streamId + ' through call ' + callId); // Set listeners for promise resolution/rejection

        var handlers = {};

        handlers.streamAddedHandler = function (newStream) {
          if (newStream.streamId === parsedStreamId) {
            _this13.removeListener('streamAdded', handlers.streamAddedHandler);

            _this13.removeListener('error', handlers.errorHandler);

            resolve(newStream);
          }
        };

        _this13.on('streamAdded', handlers.streamAddedHandler);

        handlers.errorHandler = function (error) {
          if (error.callId === callId) {
            _this13.removeListener('streamAdded', handlers.streamAddedHandler);

            _this13.removeListener('error', handlers.errorHandler);

            _this13.releaseResources(parsedStreamId);

            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'subscribeToMedia() - ' + error.errorInfo, logger));
          }
        };

        _this13.on('error', handlers.errorHandler);
      });
    }
    /**
     * Updates the call configuration for a given subscribed stream.
     *
     * @param {String} streamId - Stream identifier.
     * @param {SubscribeOptions} options - New call configuration.
     * @return {Promise} When it is done.
     */

  }, {
    key: "updateSubscribedStream",
    value: function updateSubscribedStream(streamId, options) {
      if (!options) {
        options = {};
      }

      var parsedStreamId = Number(streamId);

      if (!_subscribedStreams.get(this).has(parsedStreamId)) {
        logger.error('updateSubscribedStream() - Conversation stream ' + streamId + ' does not exist or was not subscribed to');
        return Promise.reject('wrong streamId');
      }

      var stream = _subscribedStreams.get(this).get(parsedStreamId);

      if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(options.simulcast, 'object')) {
        // Only handle the simulcast parameters.
        return apiRTCManager.webRTCClient.webRTCClient.updateSimulcastFeedOnCall(stream.callId, options.simulcast);
      }

      var mediaType = 'VIDEO';

      if (options.audioOnly === true) {
        mediaType = 'AUDIOONLY';
      } else if (options.videoOnly === true) {
        mediaType = 'VIDEOONLY';
      }

      return apiRTCManager.webRTCClient.webRTCClient.updateMediaTypeOnCall(stream.callId, mediaType);
    }
    /**
     * Unsubscribes from a conversation's stream
     * The stream will be stopped on the user's side
     *
     *  @param {String} streamId
     *  @returns {Void}
     */

  }, {
    key: "unsubscribeToStream",
    value: function unsubscribeToStream(streamId, options) {
      if (!options) {
        options = {};
      }

      var parsedStreamId = Number(streamId);
      apiRTCManager.webRTCClient.unsubscribe(parsedStreamId);
      var triggerAdaptation = !options.noTriggerAdaptation;
      this.releaseResources(streamId, {
        isRemote: true,
        triggerAdaptation: triggerAdaptation
      });
    }
    /*
     * Alias for Conversation.subscribeToStream()
     *
     *  @param {String} streamId
     *  @param {SubscribeOptions} options
     *  @returns {Promise<Stream>}
     */

  }, {
    key: "subscribeToMedia",
    value: function subscribeToMedia(streamId, options) {
      return this.subscribeToStream(streamId, options);
    }
    /*
     * Alias for Conversation.unsubscribeToStream()
     *
     *  @param {String} streamId
     *  @returns {Void}
     */

  }, {
    key: "unsubscribeToMedia",
    value: function unsubscribeToMedia(streamId) {
      this.unsubscribeToStream(streamId);
    }
    /**
     * Starts recording the conversation represented by this one.
     *
     * The <i>audioOnly</i> and <i>videoOnly</i> parameters allow you to directly select
     * audio/video input for all streams in the room. For custom stream selection,
     * you shall let those parameters aside and use the following parameters instead: <i>mode</i>,
     * <i>labelEnabled</i>, <i>labels</i>.
     *
     * The <i>mode</i> parameter allows you to configure how streams will rendered in the media
     * file. In the <i>complete</i> mode, selected audio-only streams will occupied the same amount
     * of place than video streams. In the <i>efficient</i> mode, selected audio-only streams will
     * not occupied any video space. In the <i>audioOnly</i> mode, only the audio part of selected
     * streams will be rendered and the media file will not contain any video component.
     *
     * The <i>labelEnabled</i> parameter activates the use of label(s) for stream selection.
     *
     * The <i>labels</i> parameter allows you to select stream(s). Only streams with matching label
     * will be rendered in the final media file.
     *
     * @param {Object} options - Recording preferences.
     * @param {boolean} options.audioOnly - Whether to record only audio.
     * @param {boolean} options.videoOnly - Whether to record only video.
     * @param {string} options.customIdInFilename - This string will be added to the name of the final file.
     * @param {string} options.mode - Recording mode. Either 'complete' (default), 'efficient', 'audioOnly'.
     * @param {boolean} options.labelEnabled - Whether streams are selected based on label(s).
     * @param {Object} options.labels - Array of labels (string) to select stream in the room.
     * @param {Object} options.data - Additional user data.
     * @param {number} options.ttl - The time to live (in seconds) of the recording after being successfully created. By default, the data is persistent.
     *
     * @return {Promise<RecordingInfo>}
     */

  }, {
    key: "startRecording",
    value: function startRecording(options) {
      var _this14 = this;

      if (!options) {
        options = {};
      }

      return new Promise(function (resolve, reject) {
        if (_this14.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startRecording() - conversation not joined', logger));
        } else if (_this14.asyncCallbacks) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startRecording() - busy', logger));
        }

        _this14.asyncCallbacks = {}; // Set timeout to handle lack of response from CCS.

        _this14.asyncCallbacks.timeoutId = setTimeout(function () {
          if (_this14.asyncCallbacks) {
            apiRTCManager.removeEventListener('error', _this14.asyncCallbacks.error);
            apiRTCManager.removeEventListener('MCURecordingStarted', _this14.asyncCallbacks.recordingStarted);
            delete _this14.asyncCallbacks;
          }

          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startRecording() - timeout', logger));
        }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_RECORDING_STARTED_DELAY); // Set error handler to handle failure.

        _this14.asyncCallbacks.error = function (e) {
          var convId = String(e.detail.convId);

          if (convId === _this14.getCloudConversationId() && e.detail.callId === 'COMPOSITE' && e.detail.errorCode.indexOf('START_RECORD') >= 0) {
            // Error related to the startCompositeRecording request.
            if (_this14.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this14.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStarted', _this14.asyncCallbacks.recordingStarted);
              clearTimeout(_this14.asyncCallbacks.timeoutId);
              delete _this14.asyncCallbacks;
            }

            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startRecording() - ' + e.detail.errorInfo, logger));
          }
        }; // Set success handler.


        _this14.asyncCallbacks.recordingStarted = function (e) {
          var convId = String(e.detail.convId);

          if (convId === _this14.getCloudConversationId() && e.detail.callId === 'COMPOSITE') {
            if (_this14.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this14.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStarted', _this14.asyncCallbacks.recordingStarted);
              clearTimeout(_this14.asyncCallbacks.timeoutId);
              delete _this14.asyncCallbacks;
            }

            var value = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.parseRecordingEvent('MCURecordingStarted', e.detail);
            return resolve(value);
          }
        };

        apiRTCManager.onEvent('error', _this14.asyncCallbacks.error);
        apiRTCManager.onEvent('MCURecordingStarted', _this14.asyncCallbacks.recordingStarted);
        var mediaType = 'AUDIO-VIDEO';

        if (options.audioOnly === true) {
          mediaType = 'AUDIO-ONLY';
        } else if (options.videoOnly === true) {
          mediaType = 'VIDEO-ONLY';
        }

        var customIdInFilename = 'composite';

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'customIdInFilename', 'string')) {
          customIdInFilename = options.customIdInFilename;
        }

        var data = {};

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'data', 'object')) {
          data = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject({}, options.data);
        }

        if (['complete', 'efficient', 'audioOnly'].indexOf(options.mode) >= 0) {
          data.mode = options.mode;
        } else {
          data.mode = 'complete';
        }

        data.labelEnabled = options.labelEnabled === true;

        if (data.labelEnabled === true) {
          data.labels = [];

          if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(options.labels, 'array')) {
            options.labels.forEach(function (l) {
              if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(l, 'string')) {
                data.labels.push(l);
              }
            });
          }
        }

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(options, 'ttl', 'number') && options.ttl > 0) {
          data.ttl = options.ttl;
        }

        apiRTCManager.webRTCClient.startCompositeRecording(mediaType, customIdInFilename, _this14.getCloudConversationId(), data);
      });
    }
    /**
     * Stops recording.
     *
     * @return {Promise<RecordingInfo>}
     */

  }, {
    key: "stopRecording",
    value: function stopRecording() {
      var _this15 = this;

      return new Promise(function (resolve, reject) {
        if (_this15.asyncCallbacks) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'stopRecording() - busy', logger));
        }

        _this15.asyncCallbacks = {}; // Set timeout to handle lack of response from CCS.

        _this15.asyncCallbacks.timeoutId = setTimeout(function () {
          if (_this15.asyncCallbacks) {
            apiRTCManager.removeEventListener('error', _this15.asyncCallbacks.error);
            apiRTCManager.removeEventListener('MCURecordingStopped', _this15.asyncCallbacks.recordingStopped);
            delete _this15.asyncCallbacks;
          } // Do not reject on timeout as recordingStopped event is fairly new.


          return resolve(_this15.recordingStatus);
        }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_RECORDING_STOPPED_DELAY); // Set error handler to handle failure.

        _this15.asyncCallbacks.error = function (e) {
          var convId = String(e.detail.convId);

          if (convId === _this15.getCloudConversationId() && e.detail.callId === 'COMPOSITE' && e.detail.errorCode.indexOf('STOP_RECORD') >= 0) {
            // Error related to the startCompositeRecording request.
            if (_this15.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this15.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStopped', _this15.asyncCallbacks.recordingStopped);
              clearTimeout(_this15.asyncCallbacks.timeoutId);
              delete _this15.asyncCallbacks;
            }

            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'stopRecording() - ' + e.detail.errorInfo, logger));
          }
        }; // Set success handler.


        _this15.asyncCallbacks.recordingStopped = function (e) {
          var convId = String(e.detail.convId);

          if (convId === _this15.getCloudConversationId() && e.detail.callId === 'COMPOSITE') {
            if (_this15.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this15.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStopped', _this15.asyncCallbacks.recordingStopped);
              clearTimeout(_this15.asyncCallbacks.timeoutId);
              delete _this15.asyncCallbacks;
            }

            var value = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.parseRecordingEvent('MCURecordingStopped', e.detail);
            return resolve(value);
          }
        };

        apiRTCManager.onEvent('error', _this15.asyncCallbacks.error);
        apiRTCManager.onEvent('MCURecordingStopped', _this15.asyncCallbacks.recordingStopped);
        apiRTCManager.webRTCClient.stopCompositeRecording();
      });
    }
    /**
     * @typedef CallStats
     * @type {Object}
     * @property {Object} audioSent - Statistics about audio sent.
     * @property {Object} videoSent - Statistics about video sent.
     * @property {Object} audioReceived - Statistics about audio received.
     * @property {Object} videoReceived - Statistics about video received.
     * @property {Object} quality - Overall quality score.
     */

    /**
     * Returns contact list for conversation
     *
     * @returns {Object<string, Contact>} contact list
     */

  }, {
    key: "getContacts",
    value: function getContacts() {
      logger.debug('getContacts()');
      var res = {};

      if (!this.isBound()) {
        logger.warn('getContacts() - Cannot get contacts as conversation is not joined');
      } else {
        var contacts = _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_12__.ContactCatalog.get().getContacts(this._getTechnicalName());

        var _iterator13 = _createForOfIteratorHelper(contacts.keys()),
            _step13;

        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var key = _step13.value;
            res[key] = contacts.get(key);
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }

      return res;
    }
    /**
     * Returns contacts list for conversation
     *
     * @returns {number} contacts number
     */

  }, {
    key: "getContactsNumber",
    value: function getContactsNumber() {
      logger.debug('getContactsNumber()');
      var res = 0;

      if (!this.isBound()) {
        logger.warn('getContactsNumber() - Cannot get contacts as conversation is not joined');
      } else {
        res = _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_12__.ContactCatalog.get().getContacts(this._getTechnicalName()).size;
      }

      return res;
    }
    /**
     * Return all published streams
     * 
     * @returns {Map} Map.Streams
     */

  }, {
    key: "getPublishedStreams",
    value: function getPublishedStreams() {
      logger.debug('getPublishedStream()');
      return this.conversationStreams;
    }
    /**
     * Returns conversation persistent data
     *
     *  @returns {Object} data
     */

  }, {
    key: "getData",
    value: function getData() {
      logger.debug('getData()');

      if (!this.isBound()) {
        logger.warn('getData() - Cannot get most recent data as conversation is not joined, you may want to call Conversation.updateData() instead');
      }

      return _data.get(this);
    }
    /**
     * Sets conversation persistent data (cloud user only)
     *
     *  @param {Object} data
     *  @return {Promise<void>}
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var _this16 = this;

      return new Promise(function (resolve, reject) {
        _this16.bind().then(function () {
          return cloudApi.setConversationData(_cloudConversationId.get(_this16), JSON.stringify(data), apiRTCManager.getActiveApiKey(), {
            token: _mySession.get(_this16).token
          });
        }).then(function () {
          _data.set(_this16, data);

          apiRTCManager.dataClient.sendDataToGroup(_this16._getTechnicalName(), {
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_PERSISTENT_DATA_UPDATE_IDENTIFIER,
            roomname: _this16._getTechnicalName()
          });
          resolve();
        })["catch"](function () {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'setData() - cannot set conversation data', logger));
        });
      });
    }
    /**
     * Forces conversation persistent data update
     *
     * @returns {Promise<Object>} data in promise
     */

  }, {
    key: "updateData",
    value: function updateData() {
      var _this17 = this;

      var fetch = function fetch() {
        if (_this17.isBound()) {
          return getOrCreateConversation(_this17);
        } else {
          return _this17.bind();
        }
      };

      return new Promise(function (resolve, reject) {
        fetch().then(function () {
          resolve();

          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_this17).emit('persistentDataUpdated', _data.get(_this17));
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'updateData() - cannot update conversation data', logger, {
            fromError: err
          }));
        });
      });
    }
    /**
     * @typedef StreamInfo
     * @type {Object}
     * @property {string} streamId - Stream identifier.
     * @property {Contact} contact - Owner of the stream, null if self or composite.
     * @property {boolean} hasAudio - Whether the audio track is active.
     * @property {boolean} hasVideo - Whether the video track is active.
     * @property {boolean} isAudioMuted - Whether the audio track is muted.
     * @property {boolean} isVideoMuted - Whether the video track is muted.
     * @property {boolean} isScreensharing - Whether the stream is a screen share.
     * @property {boolean} isSIP - Whether the stream comes from a SIP gateway.
     * @property {boolean} isRemote - Whether the stream belongs to a contact (not self).
     * @property {Date} time - receive time
     * @property {string} callId - Call ID.
     * @property {string} type - Either 'regular', 'composite' or 'replay'.
     */

    /**
     * Returns information for media streams available in the conversation
    * @deprecated
    * @returns {StreamInfo[]} contact list
    */

  }, {
    key: "getAvailableMediaList",
    value: function getAvailableMediaList() {
      logger.warn('Function deprecated, please use Conversation.getAvailableStreamList() instead');
      return this.getAvailableStreamList();
    }
    /**
     * Returns information for media streams available in the conversation
     * Deprecated in favor of streamListChanged event.
     * @deprecated
     * @returns {StreamInfo[]} contact list
     */

  }, {
    key: "getAvailableStreamList",
    value: function getAvailableStreamList() {
      var res = [];

      var _iterator14 = _createForOfIteratorHelper(this.conversationStreams.keys()),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var key = _step14.value;
          res.push(this.conversationStreams.get(key));
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }

      return res;
    }
    /**
     * Returns information for the media stream
     * @property {string} streamId
     * @returns {StreamInfo} stream information
     */

  }, {
    key: "getStreamInfo",
    value: function getStreamInfo(streamId) {
      return this.conversationStreams.get(streamId);
    }
    /**
     * Returns subscribed stream with its identifier
     * @property {string} streamId
     * @returns {Stream} stream
     */

  }, {
    key: "getSubscribedStream",
    value: function getSubscribedStream(streamId) {
      return _subscribedStreams.get(this).get(Number(streamId));
    }
    /*
     * DEPRECATED : Links the whiteboard client to this conversation
     *
     *  @returns {Void}
     */

  }, {
    key: "linkWhiteboardClientToConversation",
    value: function linkWhiteboardClientToConversation() {
      logger.warn('DEPRECATED : linkWhiteboardClientToConversation : no more needed');
    }
    /**
     * Starts a new whiteboard session for this conversation and notifies contacts in conversation
     *
     * @property {string} canvasId Identifier of the canvas to use for whiteboard
     * @property {string} cursorColor=invisible User cursor color, sets the user cursor color that will be seen by other participants. Set to '#000000' to have a black cursor.
     * @return {Promise}
     */

  }, {
    key: "startNewWhiteboardSession",
    value: function startNewWhiteboardSession(canvasId, cursorColor) {
      var _this18 = this;

      logger.debug('startNewWhiteboardSession()');
      return new Promise(function (resolve, reject) {
        _this18.bind().then(function () {
          if (_this18.asyncCallbacks) {
            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startNewWhiteboardSession() - busy', logger));
          }

          if (_this18.whiteboardStarted !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WHITEBOARD_NOT_STARTED) {
            // Legacy.
            return resolve();
          }

          apiRTCManager.whiteBoardClient.start();
          _this18.asyncCallbacks = {};

          _this18.asyncCallbacks.ackHandler = function (e) {
            var detail = e.detail;

            if (detail.roomId !== _this18._getTechnicalName() || detail.roomType !== 'whiteBoard') {
              return;
            }

            if (detail.eventType === 'roomCreation' && detail.status === 'roomCreated' || detail.eventType === 'roomJoined' && detail.status === 'roomJoined') {
              if (_this18.asyncCallbacks) {
                apiRTCManager.removeEventListener('roomCreation', _this18.asyncCallbacks.ackHandler);
                apiRTCManager.removeEventListener('roomJoined', _this18.asyncCallbacks.ackHandler);
                clearTimeout(_this18.asyncCallbacks.timeoutId);
                delete _this18.asyncCallbacks;
              }

              apiRTCManager.whiteBoardClient.setCanvas(canvasId);

              if (cursorColor !== null && cursorColor !== undefined) {
                apiRTCManager.whiteBoardClient.setUserCursorColor(cursorColor);
              }

              apiRTCManager.whiteBoardClient.deleteHistory();
              _this18.whiteboardStarted = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WHITEBOARD_STARTED;
              resolve();
            }
          };

          apiRTCManager.onEvent('roomCreation', _this18.asyncCallbacks.ackHandler);
          apiRTCManager.onEvent('roomJoined', _this18.asyncCallbacks.ackHandler);
          _this18.asyncCallbacks.timeoutId = setTimeout(function () {
            if (_this18.asyncCallbacks) {
              apiRTCManager.removeEventListener('roomCreation', _this18.asyncCallbacks.ackHandler);
              apiRTCManager.removeEventListener('roomJoined', _this18.asyncCallbacks.ackHandler);
              delete _this18.asyncCallbacks;
            }

            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startNewWhiteboardSession() - timeout', logger));
          }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WHITEBOARD_START_DELAY);

          var convId = _this18.getCloudConversationId();

          apiRTCManager.whiteBoardClient.joinRoom(_this18._getTechnicalName(), {
            convId: convId,
            webconf: true
          });
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startNewWhiteboardSession() - cannot start whiteboard session', logger, {
            fromError: err
          }));
        });
      });
    }
    /**
     * Stops whiteboard session for this conversation and notifies contacts in conversation
     *
     * @return {Promise}
     */

  }, {
    key: "stopNewWhiteboardSession",
    value: function stopNewWhiteboardSession() {
      var _this19 = this;

      logger.debug('stopNewWhiteboardSession()');
      return new Promise(function (resolve, reject) {
        _this19.bind().then(function () {
          if (_this19.whiteboardStarted === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WHITEBOARD_STARTED) {
            if (apiRTCManager.whiteBoardClient.roomId === _this19._getTechnicalName()) {
              apiRTCManager.whiteBoardClient.leaveRoom();
              apiRTCManager.whiteBoardClient.stop();
              _this19.whiteboardStarted = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WHITEBOARD_NOT_STARTED;
              resolve();
            } else {
              logger.error('Whiteboard session is not joined for this conversation!');
              return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'stopWhiteBoard() - whiteboard not joined', logger));
            }
          } else {
            logger.error('Conversation is not joined!');
            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'stopWhiteBoard() - Conversation not joined', logger));
          }
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'stopNewWhiteboardSession() - cannot stop whiteboard session', logger, {
            fromError: err
          }));
        });
      });
    }
    /**
     * Enables or disables pointer sharing for this one.
     *
     * @param {boolean} enabled - true to enable, false to disable.
     *
     * @return {Promise}
     */

  }, {
    key: "enablePointerSharing",
    value: function enablePointerSharing(enabled) {
      return _enablePointerSharing(this, true, enabled);
    }
    /**
     * Sends a given pointer location to every other participant.
     *
     * @param {object} source - The display source identifier.
     * @param {number} x - The X coordinate of the mouse pointer in source coordinates.
     * @param {number} y - The Y coordinate of the mouse pointer in source coordinates.
     * @param {object} data - Optional data to send with.
     */

  }, {
    key: "sendPointerLocation",
    value: function sendPointerLocation(source, x, y, data) {
      apiRTCManager.pointerSharingClient.sendPointerLocation(this._getTechnicalName(), source, x, y, data);
    }
    /**
     * Sends data message to contacts in conversation.
     *
     * @param {Object} data - Data to send.
     * @return {Promise}
     */

  }, {
    key: "sendData",
    value: function sendData(data) {
      var _this20 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        _this20.bind().then(function () {
          apiRTCManager.dataClient.sendDataToGroup(_this20._getTechnicalName(), {
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_SEND_DATA_IDENTIFIER,
            content: data,
            roomname: _this20._getTechnicalName()
          });
          resolve();
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendData() - cannot send data', logger));
        });
      });
    }
    /**
     * Sends raw data message to contacts in conversation, for backwards compatibility purposes
     * Equivalent to Session.sendRawData() but to send to everyone in the conversation
     *
     * @param {Object} data data to send
     * @return {Promise}
     */

  }, {
    key: "sendRawData",
    value: function sendRawData(data) {
      var _this21 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        _this21.bind().then(function () {
          apiRTCManager.dataClient.sendDataToGroup(_this21._getTechnicalName(), data);
          resolve();
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendRawData() - cannot send data', logger));
        });
      });
    }
    /**
     * Sends a custom data event to everyone in the conversation
     *
     * @param {string} event event key
     * @param {Object} content
     * @return {Promise}
     */

  }, {
    key: "sendCustomEvent",
    value: function sendCustomEvent(event) {
      var _this22 = this;

      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        _this22.bind().then(function () {
          var data = content;
          data.event = event;
          data.roomname = _this22._getTechnicalName();
          apiRTCManager.dataClient.sendDataToGroup(_this22._getTechnicalName(), data);
          resolve();
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendCustomEvent() - cannot send data', logger));
        });
      });
    }
    /**
     * Sends string message to contacts in conversation
     *
     * @param {String} message - message to send
     * @param {Object} options - options
     * @param {Object} options.metadata - Optional user metadata.
     * @param {Object} options.token - Optional token to overload the Session.getToken() token.
     * @return {Promise<number>} - Promise with message uuid.
     */

  }, {
    key: "sendMessage",
    value: function sendMessage(message, options) {
      var _this23 = this;

      if (!options) {
        options = {};
      }

      var save = function save(uuid) {
        return new Promise(function (resolve, reject) {
          var session = _mySession.get(_this23);

          if (session !== null) {
            cloudApi.saveGroupChatMessage(_this23, session, apiRTCManager.getActiveApiKey(), message, uuid, options).then(function () {
              resolve(uuid);
            })["catch"](reject);
          } else {
            resolve(uuid);
          }
        });
      };

      return new Promise(function (resolve, reject) {
        if (_this23.groupChatStatus !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED && _this23.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'sendMessage() - group chat not joined', logger));
        } else if (message === null || typeof message !== 'string') {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'sendMessage() - wrong type of message', logger));
        } else {
          _this23.bind().then(function () {
            var opts = {};

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(options, 'metadata', 'object')) {
              opts.metadata = options.metadata;
            }

            return apiRTCManager.sendMessageToGroupChat(_this23._getTechnicalName(), message, opts);
          }).then(function (uuid) {
            return save(uuid);
          }).then(resolve)["catch"](function (err) {
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendMessage() - cannot send message', logger, {
              fromError: err
            }));
          });
        }
      });
    }
    /**
     * @typedef CloudMediaInfo
     * @type {Object}
     * @property {string} url
     * @property {string} id
     */

    /**
     * Pushes media specific to this conversation
     *
     *  @param {string} media dataURI media
     *  @param {object} options
     *  @param {string} options.filename - Mandatory when overwriting.
     *  @param {boolean} options.overwrite - Whether the overwriting is enabled. By default, overwriting is not enabled.
     *  @param {number} options.ttl - The time to live of the data after being successfully pushed. By default, the data is persistent.
     *  @returns {Promise<CloudMediaInfo>} cloud media info in promise
     */

  }, {
    key: "pushMedia",
    value: function pushMedia(media, options) {
      var _this24 = this;

      if (!options) {
        options = {};
      }

      return new Promise(function (resolve, reject) {
        _this24.bind().then(function () {
          if (!options.hasOwnProperty('token')) {
            options.token = _mySession.get(_this24).token;
          }

          return cloudApi.pushConversationMedia(_cloudConversationId.get(_this24), media, apiRTCManager.getActiveApiKey(), options);
        }).then(function (res) {
          // Notify conversation that new media is available
          apiRTCManager.dataClient.sendDataToGroup(_this24._getTechnicalName(), {
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_NEW_MEDIA_IDENTIFIER,
            roomname: _this24._getTechnicalName(),
            media: {
              url: res.url,
              id: res.id
            },
            // Izeeconf compatibililty
            command: 'new_snapshot',
            value: {
              snapshot: res.url
            }
          });
          resolve({
            url: res.url,
            id: res.id
          });
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'pushMedia() - cannot push media', logger, {
            fromError: err
          }));
        });
      });
    }
    /**
     * @typedef PushDataBufferDescriptor
     * @type {Object}
     * @property {ArrayBuffer} buffer - The buffer to transfer.
     * @property {String} filename - The name of the data.
     * @property {String} filetype - The MIME type of the data.
     * @property {String} sourceType - An optional source type.
     * @property {boolean} overwrite - Whether the overwriting is enabled. By default, overwriting is not enabled.
     * @property {number} ttl - The time to live (in seconds) of the data after being successfully pushed. By default, the data is persistent.
     * @property {boolean} checksumEnabled - Whether the checksum validation is enabled. Enabled by default.
     * @property {Object} metadata - Optional user data.
     */

    /**
     * @typedef PushDataFileDescriptor
     * @type {Object}
     * @property {File} file - The file to transfer.
     * @property {String} filename - Optional override of the file name.
     * @property {String} filetype - Optional override of the MIME type.
     * @property {String} sourceType - An optional source type.
     * @property {boolean} overwrite - Whether the overwriting is enabled. By default, overwriting is not enabled.
     * @property {number} ttl - The time to live (in seconds) of the data after being successfully pushed. By default, the data is persistent.
     * @property {boolean} checksumEnabled - Whether the checksum validation is enabled. Enabled by default.
     * @property {Object} metadata - Optional user data.
     */

    /**
     * @typedef PushDataOptions
     * @type {Object}
     * @property {String} token token
     * @property {Session} session apiRTC session
     * @property {String} turnServerAddress This enables to change the turn server used for the call
     */

    /**
     * Pushes data to this one.
     * @param data {PushDataFileDescriptor|PushDataBufferDescriptor} data - Descriptor of the data to transfer.
     * @param options {PushDataOptions}
     * @return {Promise<CloudMediaInfo>}
     */

  }, {
    key: "pushData",
    value: function pushData(data) {
      var _this25 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      options = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject({}, options);
      return new Promise(function (resolve, reject) {
        if (apiRTCManager.webRTCClient.webRTCClient.dataChannelCapable !== true || options.forceHTTP === true) {
          // fallback: HTTP POST
          if (data.file) {
            var params = {};

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(data, 'metadata', 'object')) {
              try {
                params.metadata = JSON.stringify(data.metadata);
              } catch (e) {
                logger.error('JSON.stringify', e);
              }
            }

            params.asFile = true;

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(data, 'filename', 'string')) {
              params.filename = data.filename;
            } else {
              params.filename = data.file.name;
            }

            if (data.overwrite === true) {
              params.overwrite = true;
            }

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(data, 'ttl', 'number') && data.ttl > 0) {
              params.ttl = data.ttl;
            }

            _this25.pushMedia(data.file, params).then(resolve)["catch"](reject);
          } else {
            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'pushData() - missing file', logger));
          }
        } else {
          // normal case: data channel
          _this25.bind().then(function () {
            var technicalName = _this25._getTechnicalName();

            var callConfiguration = {};

            if (options.hasOwnProperty('turnServerAddress')) {
              callConfiguration.turnServerAddress = options.turnServerAddress;
              delete options.turnServerAddress;
            }

            var callId = apiRTCManager.webRTCClient.webRTCClient.pushData(_this25.getCloudConversationId(), data, callConfiguration, {
              success: function success(status) {
                if (status.state === 'complete') {
                  // Notify conversation that new media is available
                  apiRTCManager.dataClient.sendDataToGroup(technicalName, {
                    event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_NEW_MEDIA_IDENTIFIER,
                    roomname: technicalName,
                    media: {
                      url: status.mediaURL,
                      id: status.mediaId
                    },
                    // Izeeconf compatibililty
                    command: 'new_snapshot',
                    value: {
                      snapshot: status.mediaURL
                    }
                  });
                  resolve({
                    url: status.mediaURL,
                    id: status.mediaId
                  });
                } else {
                  return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'pushData() - cannot push data', logger));
                }
              },
              failure: function failure(err, callId) {
                if (err === 'iceFailed') {
                  // Fallback in HTTP.
                  var opts = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.assignObject({}, options);
                  opts.forceHTTP = true;

                  _this25.pushData(data, opts).then(resolve)["catch"](reject);

                  return;
                } else if (err === 'timeout') {
                  // In this case, no onFileSended event is to be expected.
                  // Clean transfer table.
                  if (callId) {
                    var idx = _this25.transferCallIds.indexOf(callId);

                    if (idx >= 0) {
                      _this25.transferCallIds.splice(idx, 1);
                    }
                  }

                  return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT, 'pushData() - push data timed out', logger));
                } else if (err === 'canceled') {
                  return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OPERATION_CANCELED, 'pushData() - push data canceled', logger));
                }

                return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'pushData() - cannot push data', logger, {
                  fromError: err
                }));
              }
            });

            if (!callId) {
              // failure
              return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'pushData() - cannot push data', logger));
            }

            _this25.transferCallIds.push(callId);
          })["catch"](function (err) {
            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'pushData() - cannot push data', logger, {
              fromError: err
            }));
          });
        }
      });
    }
    /**
     * Cancels an ongoing push data operation.
     * @param {String} id - Push data operation identifier (from transferPending or transferBegun events).
     * @return {Promise}
     */

  }, {
    key: "cancelPushData",
    value: function cancelPushData(id) {
      var _this26 = this;

      return new Promise(function (resolve, reject) {
        if (!_this26.transferCallIds.includes(id)) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'cancelPushData() - no such push data', logger));
        }

        var err = apiRTCManager.webRTCClient.webRTCClient.cancelPushData(id);

        if (err) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'cancelPushData() - ' + err, logger));
        }

        resolve();
      });
    }
    /**
     * Fetches media specific to this conversation
     *
     * @param {Session} session - May be null.
     * @param {object} options
     * @param {string} options.token
     * @returns {Promise<object>} mediaList
     */

  }, {
    key: "fetchMediaList",
    value: function fetchMediaList(session, options) {
      var _this27 = this;

      if (!options) {
        options = {};
      }

      return new Promise(function (resolve, reject) {
        _this27.bind().then(function () {
          if (!Object.prototype.hasOwnProperty.call(options, 'token')) {
            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(session, 'object') && session instanceof _Session__WEBPACK_IMPORTED_MODULE_5__.Session) {
              options.token = session.getToken();
            } else {
              options.token = _mySession.get(_this27).token;
            }
          }

          return cloudApi.getConversationMediaList(_cloudConversationId.get(_this27), apiRTCManager.getActiveApiKey(), options);
        }).then(resolve)["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'fetchMediaList() - cannot fetch media list', logger, {
            fromError: err
          }));
        });
      });
    }
    /**
     * Returns contacts in the waiting room, returns empty if conversation is not joined or user is not a moderator
     *
     * @returns {Object<string, Contact>} contact list
     */

  }, {
    key: "getWaitingRoomContacts",
    value: function getWaitingRoomContacts() {
      logger.debug('getWaitingRoomContacts()');
      var res = {};

      if (this.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
        logger.error('getWaitingRoomContacts() - Conversation is not joined, cannot get waiting room contacts');
      } else if (this.getRole() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_MODERATOR) {
        logger.error('getWaitingRoomContacts() - Role is not moderator, cannot get waiting room contacts');
      } else {
        var contacts = _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_12__.ContactCatalog.get().getContacts(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WAITING_ROOM_PREFIX + this._getTechnicalName());

        var _iterator15 = _createForOfIteratorHelper(contacts.keys()),
            _step15;

        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var key = _step15.value;
            res[key] = contacts.get(key);
          }
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
      }

      return res;
    }
    /**
     * @typedef ConversationMessage
     * @type {Object}
     * @property {string} content - content of the message
     * @property {Contact} sender
     * @property {string} sender_id
     * @property {Date} timestamp - message send time
     * @property {Date} date - message send time
     * @property {string} display_name - username of the sender
     */

    /**
     * Loads message history for this conversation
     *
     * @param {Session} session - May be null.
     * @param {Object} options
     * @param {string} options.token
     * @return {Promise<Array<ConversationMessage>>}
     */

  }, {
    key: "fetchMessageHistory",
    value: function fetchMessageHistory(session) {
      var _this28 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        _this28.bind().then(function () {
          if (Object.prototype.hasOwnProperty.call(options, 'token')) {
            return cloudApi.loadGroupChatMessages(_this28, null, options.token);
          } else {
            if (!_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(session, 'object') || !(session instanceof _Session__WEBPACK_IMPORTED_MODULE_5__.Session)) {
              session = _mySession.get(_this28);
            }

            return cloudApi.loadGroupChatMessages(_this28, session);
          }
        }).then(function (res) {
          var messages = res.map(function (message) {
            var m = {
              content: message.content,
              timestamp: message.created_at * 1000,
              date: new Date(message.created_at * 1000),
              sender_id: message.user_id,
              display_name: message.display_name
            };

            if (message.user_id.toString() !== session.getId()) {
              m.sender = session.getOrCreateContact(message.user_id);
            }

            return m;
          });
          resolve(messages);
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'fetchMessageHistory() - cannot fetch message history', logger));
        });
      });
    }
    /**
     * Invites a contact to this conversation
     *
     * @param {Contact} contact to invite
     * @param {Object} options
     * @param {number} options.expirationTime Time for an invite to expire after being sent
     * @return {SentInvitation}
     */

  }, {
    key: "sendInvitation",
    value: function sendInvitation(contact, options) {
      var _this29 = this;

      if (!options) {
        options = {};
      }

      if (!(contact instanceof _Contact__WEBPACK_IMPORTED_MODULE_6__.Contact)) {
        logger.error('Parameter is not a contact');
        return null;
      } else {
        logger.info('Invite ' + contact.getId() + ' to ' + this._getTechnicalName());

        if (!contact.isOnline()) {
          logger.warn('sendInvitation() - contact ' + contact.getUsername() + ' does not seem to be connected.');
        }

        var sentInvitationOptions = {
          receiveNotifier: new _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter()
        };

        if (options.hasOwnProperty('expirationTime')) {
          sentInvitationOptions.expirationTime = options.expirationTime;
        }

        var invitation = new _SentInvitation__WEBPACK_IMPORTED_MODULE_7__.SentInvitation(contact, this, sentInvitationOptions);
        invitation.type = 'conversation';
        var invitationData = {
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_INVITATION_IDENTIFIER,
          invitationId: invitation.id,
          roomname: this._getTechnicalName(),
          sendTime: invitation.sendTime,
          conversationTypes: []
        };

        if (this.status === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          invitationData.conversationTypes.push('WEBCONF');
        } else if (this.groupChatStatus === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          invitationData.conversationTypes.push('GROUP_CHAT');
        }

        apiRTCManager.sendData(contact.getId(), invitationData).then(function () {
          sentInvitationOptions.receiveNotifier.emit('receive');
        })["catch"](function (errCode) {
          var newError = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(errCode, 'Invitation not delivered', logger);

          _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(_this29).emit('messageNotDelivered', {
            error: newError,
            contact: contact,
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_INVITATION_IDENTIFIER
          });
        });
        return invitation;
      }
    }
    /**
     * Tests whether the call represented by this one is recorded.
     * @return {boolean}
     */

  }, {
    key: "isRecorded",
    value: function isRecorded() {
      return !!this.recordingStatus;
    }
    /**
     * Returns the recoding information, if any.
     * @return {RecordingInfo|null}
     */

  }, {
    key: "getRecordingInfo",
    value: function getRecordingInfo() {
      if (this.isRecorded()) {
        return this.recordingStatus;
      }

      return null;
    }
    /**
     * Sets the network capacity of this one. Shall be done to enable resource reservation.
     * @param {number} upload - Available upload bandwidth
     * @param {number} download - Available download bandwidth
     * @return {boolean} True on success, false otherwise.
     */

  }, {
    key: "setNetworkCap",
    value: function setNetworkCap(upload, download) {
      if (typeof upload !== 'number' || typeof download !== 'number') {
        logger.error('setNetworkCap - wrong cap', upload, download);
        return false;
      }

      if (upload <= 0 || download <= 0) {
        // Deactivate resource reservation.
        this.uploadCap = null;
        this.downloadCap = null;
        return true;
      }

      this.uploadCap = upload;
      this.downloadCap = download;
      return true;
    }
    /**
     * Gets the network capacity of this one.
     * @param {object} options
     * @param {object} options.capacity - Returns the overall capacity rather than the remaining available bandwidth.
     * @return {number[]|null} available upload bandwidth and available download bandwidth
     */

  }, {
    key: "getNetworkCap",
    value: function getNetworkCap() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.uploadCap || !this.downloadCap) {
        return null;
      }

      if (options.capacity) {
        return [this.uploadCap, this.downloadCap];
      }

      var uploadCap = this.uploadCap;
      var downloadCap = this.downloadCap;

      for (var idx = this.reservedStreams.length; --idx >= 0;) {
        if (this.reservedStreams[idx].isVideoMuted) {
          continue;
        }

        if (this.reservedStreams[idx].isRemote) {
          // subscribe
          downloadCap -= this.reservedStreams[idx].resource;
        } else {
          // publish
          uploadCap -= this.reservedStreams[idx].resource;
        }
      } // for


      return [uploadCap, downloadCap];
    }
    /**
     * @ignore
     * @typedef StreamResourceReservation
     * @property {number|string} streamId - The Stream ID.
     * @property {string} profileType - The profile type/name.
     * @property {number} resource - The bitrate.
     * @property {number} priority - The stream priority.
     * @property {boolean} isRemote - True for subscribe stream, false for publish stream.
     * @property {boolean} isVideoOnly - Whether the stream has no audio track.
     * @property {boolean} isVideoMuted - Whether the stream has no video, either no video track or just muted.
     */

    /**
     * Returns the StreamResourceReservation for a given stream ID.
     * @ignore
     * @param {string} streamId - Stream ID.
     * @returns {StreamResourceReservation|null} Stream resource reservation on success, null otherwise.
     */

  }, {
    key: "getStreamResourceReservation",
    value: function getStreamResourceReservation(streamId) {
      for (var idx = this.reservedStreams.length; --idx >= 0;) {
        if (this.reservedStreams[idx].streamId === streamId) {
          return this.reservedStreams[idx];
        }
      } // for


      return null;
    }
    /**
     * Reserves network bandwidth.
     * @ignore
     * @param {string} profileType
     * @param {number} resource - A bitrate
     * @param {string} streamId - streamId
     * @param {string} isRemote - True if the stream is remote, false if it is local.
     * @param {number} priority
     * @param {object} options
     * @param {boolean} options.isVideoOnly - Whether the stream has no audio track.
     * @param {boolean} options.isVideoMuted - Whether the video track is not active.
     * @param {boolean} options.control - Whether to merely control bandwidth availability rather than to actually reserve said bandwidth.
     * @return {boolean} True if enough resource is available, false otherwise.
     */

  }, {
    key: "reserveResources",
    value: function reserveResources(profileType, resource, streamId, isRemote, priority) {
      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
      logger.debug('reserveResources', streamId);

      if (this.getStreamResourceReservation(streamId)) {
        throw new Error('reserveResources - already reserved stream');
      }

      var availableBW = false;
      var streamRes = {
        streamId: streamId,
        profileType: profileType,
        priority: priority,
        resource: resource,
        isRemote: isRemote
      };
      streamRes.isVideoOnly = !!options.isVideoOnly;

      if (options.isVideoMuted) {
        // Video track is not active.
        streamRes.isVideoMuted = true;
        availableBW = true;
      } else {
        // Video track is active.
        streamRes.isVideoMuted = false; // Check for bandwidth availability

        var networkCap = this.getNetworkCap();

        if (isRemote) {
          // subscribe
          availableBW = networkCap[1] >= streamRes.resource;
        } else {
          // publish
          availableBW = networkCap[0] >= streamRes.resource;
        }
      }

      if (options.control) {
        return availableBW;
      }

      if (!availableBW) {
        throw new Error('reserveResources - no such bandwidth availability');
      }

      this.reservedStreams.push(streamRes);
      this.reservedStreams.sort(function (a, b) {
        return a.priority > b.priority ? -1 : a.priority === b.priority ? 0 : 1;
      });
      logger.debug('reservedStreams', this.reservedStreams);
      return true;
    }
    /**
     * Releases network bandwidth.
     * @ignore
     * @param {string} streamId
     * @param {object} options
     * @param {boolean} options.isRemote - True for subscribe call, false for publish call.
     * @param {boolean} options.triggerAdaptation - Whether to trigger an adaptation.
     * @return {boolean} True on success, false otherwise.
     */

  }, {
    key: "releaseResources",
    value: function releaseResources(streamId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!this.getNetworkCap({
        capacity: true
      })) {
        return false;
      }

      logger.debug('releaseResources', streamId); // Remove stream reservation

      var found = false;

      for (var idx = this.reservedStreams.length; --idx >= 0;) {
        if (this.reservedStreams[idx].streamId === streamId) {
          this.reservedStreams.splice(idx, 1);
          found = true;
          break;
        }
      } // for


      logger.debug('reservedStreams', this.reservedStreams);

      if (found && options.triggerAdaptation) {
        this.enableHigherPriorityVideo(!!options.isRemote);
      }

      return found;
    }
    /**
     * Changes the priority of a given stream.
     * For publish call, from ConversationCall#changeStreamPriority.
     * For subscribe call, from 'MCUAvailableStreamUpdate' event.
     * @ignore
     * @param {string} streamId - Stream ID.
     * @param {boolean} isRemote - True for subscribe call, false for publish call.
     * @param {number} priority - The new priority.
     * @return {boolean}
     */

  }, {
    key: "changeStreamPriority",
    value: function changeStreamPriority(streamId, isRemote, priority) {
      logger.debug('changeStreamPriority', streamId, isRemote, priority); // Look for stream reservation.

      var resStream = null;

      for (var idx = this.reservedStreams.length; --idx >= 0;) {
        if (this.reservedStreams[idx].isRemote !== isRemote) {
          continue;
        }

        if (this.reservedStreams[idx].streamId === streamId) {
          resStream = this.reservedStreams[idx];
          break;
        }
      } // for


      if (!resStream || resStream.priority === priority) {
        return false;
      } // Apply change and reorder reservation list.


      resStream.priority = priority;
      this.reservedStreams.sort(function (a, b) {
        return a.priority > b.priority ? -1 : a.priority === b.priority ? 0 : 1;
      });
      logger.debug('reservedStreams', this.reservedStreams); // Look for adaptation.

      if (resStream.isVideoMuted) {
        // Video track not currently active.
        // Look for adaptation.
        if (this.disableLowerPriorityVideo(resStream.isRemote, resStream.resource, resStream.priority)) {
          // Enough bandwidth found.
          // Activate video of current stream.
          enableVideoTrack(this, resStream);
        }
      } else {
        // Video track already active.
        // Look for adaptation.
        if (this.enableHigherPriorityVideo(resStream.isRemote, {
          resource: resStream.resource,
          priority: resStream.priority,
          control: true
        })) {
          // Higher priority video can be activated.
          // Deactivate video of current stream.
          disableVideoTrack(this, resStream); // Activate higher priority video.

          this.enableHigherPriorityVideo(resStream.isRemote);
        }
      }

      return true;
    }
    /**
     * Disables the video track of streams with lower priority to release a given resource.
     * @ignore
     * @param {boolean} isRemote - True for subscribe call, false for publish call.
     * @param {number} resource - The bandwidth availability to look for.
     * @param {number} priority - The priority not to exceed.
     * @return {boolean} True on success, false otherwise.
     */

  }, {
    key: "disableLowerPriorityVideo",
    value: function disableLowerPriorityVideo(isRemote, resource, priority) {
      logger.debug('disableLowerPriorityVideo', isRemote, resource, priority); // Look for streams with lower priority.

      var resStreams = [];
      var resourceAcc = 0; // Streams with the lowest priority are at the end.

      for (var idx = this.reservedStreams.length; --idx >= 0;) {
        if (this.reservedStreams[idx].isRemote !== isRemote || this.reservedStreams[idx].isVideoMuted || this.reservedStreams[idx].priority >= priority) {
          continue;
        }

        resStreams.push(this.reservedStreams[idx]);
        resourceAcc += this.reservedStreams[idx].resource;

        if (resourceAcc >= resource) {
          // Found enough streams.
          break;
        }
      } // for


      if (resStreams.length === 0 || resourceAcc < resource) {
        // no such streams
        return false;
      }

      for (var _idx = resStreams.length; --_idx >= 0;) {
        disableVideoTrack(this, resStreams[_idx]);
      } // for


      return true;
    }
    /**
     * Enables the video track of higher priority streams.
     * @ignore
     * @param {boolean} isRemote
     * @param {object} options
     * @param {object} options.resource - The bandwidth to add to current bandwidth availability.
     * @param {object} options.priority - The priority not to look under.
     * @param {object} options.control - Whether to merely control the possibility to gather the requested bandwidth rather than to actually release it.
     * @return {boolean} True if the video of a stream has been activated, false otherwise.
     */

  }, {
    key: "enableHigherPriorityVideo",
    value: function enableHigherPriorityVideo(isRemote) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      logger.debug('enableHigherPriorityVideo', isRemote);
      var networkCap = this.getNetworkCap();
      var cap = isRemote ? networkCap[1] : networkCap[0];

      if (options.resource && options.resource > 0) {
        cap += options.resource;
      }

      var resStreams = []; // Streams with highest priority are at the beginning.

      for (var idx = 0; idx < this.reservedStreams.length; idx += 1) {
        if (this.reservedStreams[idx].isRemote !== isRemote || !this.reservedStreams[idx].isVideoMuted) {
          continue;
        }

        if (Object.prototype.hasOwnProperty.call(options, 'priority') && this.reservedStreams[idx].priority <= options.priority) {
          continue;
        }

        if (this.reservedStreams[idx].resource <= cap) {
          cap -= this.reservedStreams[idx].resource;
          resStreams.push(this.reservedStreams[idx]);
        }
      } // for


      if (resStreams.length === 0) {
        // no such streams
        return false;
      }

      if (options.control) {
        return true;
      }

      for (var _idx2 = resStreams.length; --_idx2 >= 0;) {
        enableVideoTrack(this, resStreams[_idx2]);
      } // for


      return true;
    }
    /**
     * Starts the composite stream on the video bridge.
     * @return {Promise}
     */

  }, {
    key: "startComposite",
    value: function startComposite() {
      var _this30 = this;

      return new Promise(function (resolve, reject) {
        if (_this30.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startComposite() - conversation not joined', logger));
        }

        apiRTCManager.webRTCClient.startComposite(_this30._getTechnicalName());
        resolve();
      });
    }
    /**
     * Stops the composite stream on the video bridge.
     * @return {Promise}
     */

  }, {
    key: "stopComposite",
    value: function stopComposite() {
      var _this31 = this;

      return new Promise(function (resolve, reject) {
        if (_this31.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'stopComposite() - conversation not joined', logger));
        }

        apiRTCManager.webRTCClient.stopComposite(_this31._getTechnicalName());
        resolve();
      });
    }
    /*
     * Calls given a phone number.
     * @param {string} phoneNumber
     * @return {Promise<void>}
     */

  }, {
    key: "callVoIP",
    value: function callVoIP(phoneNumber) {
      var _this32 = this;

      return new Promise(function (resolve, reject) {
        if (!phoneNumber || typeof phoneNumber !== 'string') {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'callVoIP() - wrong phoneNumber', logger));
        } else if (_this32.status !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'callVoIP() - conversation not joined', logger));
        }

        apiRTCManager.webRTCClient.webRTCClient.MCUClient.inviteVoIP(_this32._getTechnicalName(), _this32.getCloudConversationId(), phoneNumber).then(resolve)["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'callVoIP() - ' + err.message, logger));
        });
      });
    }
    /*
     * manage DisconnectionWarning Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageDisconnectionWarningEvent",
    value: function manageDisconnectionWarningEvent(e) {
      logger.debug('manageDisconnectionWarningEvent', e.detail);
      var streamInfo = {}; // Check if call is one of conversation's

      if (this.callIdToStreamId.has(e.detail.callId)) {
        logger.debug('call is linked with conversation'); //let contact = contactCatalog.getOrCreateContact(e.detail.remoteId);

        var streamId = this.callIdToStreamId.get(e.detail.callId);

        if (e.detail.settingUpType === 'publish' || e.detail.settingUpType === 'shareScreen') {
          //logger.debug('this.conversationPublishedStreams', this.conversationPublishedStreams);
          streamInfo = this.conversationPublishedStreams.get(streamId);
        } else {
          //logger.debug('this.conversationStreams', this.conversationStreams);
          streamInfo = this.conversationStreams.get(streamId);
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(this).emit('disconnectionWarning', {
          streamInfo: streamInfo
        });
      } else {
        logger.debug('call is not linked with conversation');
      }
    }
    /*
     * manage Error Event
     *
     *  @param {event} received event from Session
     *  @returns {void}
     */

  }, {
    key: "manageErrorEvent",
    value: function manageErrorEvent(e) {
      logger.debug('manageErrorEvent', e.detail);
      var streamInfo = {};

      if (e.detail.errorCode === 'DISTANT_ICE_CONNECTION_STATE_DISCONNECTED' || e.detail.errorCode === 'DISTANT_ICE_CONNECTION_STATE_FAILED') {
        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(this).emit('error', {
          errorCode: e.detail.errorCode,
          errorInfo: e.detail.errorInfo,
          descriptor: e.detail.data
        });
      } else if (this.callIdToStreamId.has(e.detail.callId)) {
        // Check if call is one of conversation's
        logger.debug('call is linked with conversation'); //let contact = contactCatalog.getOrCreateContact(e.detail.remoteId);

        var streamId = this.callIdToStreamId.get(e.detail.callId);

        if (e.detail.settingUpType === 'publish') {
          //logger.debug('this.conversationPublishedStreams', this.conversationPublishedStreams);
          streamInfo = this.conversationPublishedStreams.get(streamId);
        } else {
          //logger.debug('this.conversationStreams', this.conversationStreams);
          streamInfo = this.conversationStreams.get(streamId);
        }

        var error = {
          streamInfo: streamInfo,
          errorCode: e.detail.errorCode,
          errorInfo: e.detail.errorInfo,
          callId: e.detail.callId,
          streamId: streamId
        };

        if (e.detail.data) {
          error.descriptor = e.detail.data;
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(this).emit('error', error); // Close call if fatal error


        if (CALL_FATAL_ERRORS.has(e.detail.errorCode)) {
          var convCall = this.conversationCalls.get(e.detail.callId);

          if (convCall) {
            // publish
            this.unpublish(convCall.stream);
          } else {
            // subscribe
            this.unsubscribeToStream(streamId);

            if (e.detail.errorCode === 'CALL_ABORTED') {
              // Special case for CALL_ABORTED.
              // The call does not exist in the Core stack when receiving the error event.
              // This means that the above unsubscribeToStream will not trigger any hangup event.
              // We need to clean the call right away.
              this.callIdToStreamId["delete"](e.detail.callId);
            }
          }
        }
      } else {
        logger.debug('call is not linked with conversation');
      }
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return CONVERSATION_EVENTS;
    }
  }]);

  return Conversation;
}(_utils_Observable__WEBPACK_IMPORTED_MODULE_3__.Observable);
/**
 * @return {string}
 */


var getUserAgentUsername = function getUserAgentUsername() {
  var ret = 'guest';

  if (apiRTC.userAgentInstance) {
    var name = apiRTC.userAgentInstance.getUsername();

    if (name) {
      ret = name;
    }
  }

  return ret;
};
/*
 * @ignore
 * @typedef CloudConversation
 * @type {Object}
 * @property {Number} id
 * @property {Object} data
 * @property {String} typeString
 */

/*
 * Gets conversation from cloud. Creates it if necessary.
 * @ignore
 * @method getOrCreateConversation
 * @param {Conversation} conversation
 * @param {object} options
 * @param {Session} options.session - Session.
 * @return {Promise<CloudConversation>}
 */


var getOrCreateConversation = function getOrCreateConversation(conversation) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return new Promise(function (resolve, reject) {
    var session = null;

    if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'session', 'object') && options.session instanceof _Session__WEBPACK_IMPORTED_MODULE_5__.Session) {
      session = options.session;
    } else if (_Session__WEBPACK_IMPORTED_MODULE_5__.Session.getActiveSession() !== null) {
      session = _Session__WEBPACK_IMPORTED_MODULE_5__.Session.getActiveSession();
    } else {
      return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'getOrCreateConversation() - missing session', logger));
    }

    var opts = {};
    opts.token = session.getToken();
    opts.active = conversation.active;
    cloudApi.getOrCreateConversation(conversation, apiRTCManager.getActiveApiKey(), opts).then(function (res) {
      if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(res, 'public_id', 'string')) {
        res.id = res.public_id;
        delete res.public_id;
      }

      _cloudConversationId.set(conversation, res.id);

      _data.set(conversation, res.data);

      if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(res.typeString, 'string') && TYPES.has(res.typeString)) {
        _type.set(conversation, res.typeString);
      }

      _mySession.set(conversation, session);

      resolve(res);
    })["catch"](function (err) {
      _cloudConversationId.set(conversation, null);

      _data.set(conversation, null);

      _type.set(conversation, null);

      reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_HTTP, 'getOrCreateConversation() - cannot get/create conversation', logger, {
        fromError: err
      }));
    });
  });
};

var getConversationModeratorId = function getConversationModeratorId(conversation) {
  var moderator = conversation.getModerator();

  if (!moderator) {
    // The moderator is NOT known.
    if (!conversation.conference && conversation.moderationEnabled) {
      // The conversation is moderated.
      // Use a placeholder that will be resolved by CCS.
      return '#';
    }

    return null;
  }

  return moderator.getId();
};

var handleConversationModeration = function handleConversationModeration(conversation, accessStatus) {
  return new Promise(function (resolve, reject) {
    if (conversation.conference) {
      // Conference (Cloud).
      if (accessStatus.access === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ACCESS_GRANTED) {
        return resolve(accessStatus);
      } else if (accessStatus.access === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_NEED_MODERATOR_ACCEPTATION) {
        var moderator = contactCatalog.getOrCreateContact(accessStatus.moderator);

        _moderator.set(conversation, moderator);

        handleConversationWaitingRoom(conversation).then(function () {
          resolve(accessStatus);
        })["catch"](reject);
      } else {
        return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'You were not allowed to join the conference'));
      }
    } else if (conversation.moderationEnabled) {
      // Conversation.
      // Moderation is enabled.
      if (conversation.moderator) {
        // Moderation is enabled and the UserAgent is one of the moderators.
        return resolve(Object.assign(accessStatus, {
          access: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ACCESS_GRANTED,
          role: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_MODERATOR
        }));
      } else {
        // Moderation is enabled and the UserAgent is NOT one of the moderators.
        handleConversationWaitingRoom(conversation).then(function () {
          resolve(Object.assign(accessStatus, {
            access: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_NEED_MODERATOR_ACCEPTATION,
            role: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_GUEST
          }));
        })["catch"](reject);
      }
    } else {
      // Conversation.
      // Moderation is NOT enabled.
      return resolve(Object.assign(accessStatus, {
        access: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ACCESS_GRANTED,
        role: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_ROLE_GUEST
      }));
    }
  });
};

var handleConversationWaitingRoom = function handleConversationWaitingRoom(conversation) {
  return new Promise(function (resolve, reject) {
    var moderator = conversation.getModerator();
    conversation.status = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_WAITING;
    var presenceGroupJoined = false;
    var joinPresenceGroupTimeoutId = setTimeout(function () {
      var options = {};
      options.doneByApiRTC = true;
      apiRTCManager.apiRTCSession.joinPresenceGroup([_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WAITING_ROOM_PREFIX + conversation._getTechnicalName()], options);
      presenceGroupJoined = true;
    }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.JOIN_WAITING_ROOM_PRESENCE_GROUP_TIMEOUT);

    if (moderator) {
      _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(conversation).emit('waitingForModeratorAcceptance', moderator);
    }

    var invitation = new _SentInvitation__WEBPACK_IMPORTED_MODULE_7__.SentInvitation(moderator, conversation);
    invitation.id = conversation._getTechnicalName();
    invitation.type = conversation.conference ? 'conference' : 'conversation';
    conversation.sendJoinRequest();

    var receiveDataHandler = function receiveDataHandler(e) {
      logger.debug('dataMessage (waitingRoom)', e.detail);
      var data = e.detail.data;

      if (data.roomname !== conversation._getTechnicalName()) {
        return;
      }

      var senderId = e.detail.senderId.toString();

      if (data.command === 'access' || data.command === 'access-new' || data.event === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_ANSWER_IDENTIFIER) {
        // JoinRequest response from one of the moderators.
        delete conversation.cancelJoin0;

        if (conversation.joinRequestIntervalId) {
          clearInterval(conversation.joinRequestIntervalId);
          delete conversation.joinRequestIntervalId;
        }

        apiRTCManager.removeEventListener('receiveData', receiveDataHandler);

        if (presenceGroupJoined === true) {
          var options = {};
          options.doneByApiRTC = true; //Leave Waiting room group

          apiRTCManager.apiRTCSession.leavePresenceGroup([_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WAITING_ROOM_PREFIX + conversation._getTechnicalName()], options);
        } else if (joinPresenceGroupTimeoutId) {
          clearTimeout(joinPresenceGroupTimeoutId);
        }

        if (data.value.hasOwnProperty('access') && data.value.access || data.access) {
          // Send ack back.
          apiRTCManager.sendData(senderId, {
            roomname: conversation._getTechnicalName(),
            command: 'access-ack'
          })["catch"](function (errCode) {
            var newError = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(errCode, 'Notification not delivered', logger);

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(conversation).emit('messageNotDelivered', {
              error: newError,
              contact: moderator,
              command: 'access-ack'
            });
          });
          resolve();
        } else {
          conversation.status = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED;
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_ALLOWED, 'You were not allowed to join the conversation', logger));
        }
      } else if (data.event === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_MODERATOR_CONNECTED_IDENTIFIER && data.roomname === conversation._getTechnicalName()) {
        // Moderator notified presence to waiting room.
        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(conversation).emit('moderatorConnected', contactCatalog.getOrCreateContact(senderId));
      }
    };

    apiRTCManager.onEvent('receiveData', receiveDataHandler); // Moderator response on invitation

    invitation.onResponse(function (status) {
      apiRTCManager.removeEventListener('receiveData', receiveDataHandler);

      if (presenceGroupJoined === true) {
        var options = {};
        options.doneByApiRTC = true; //Leave Waiting room group

        apiRTCManager.apiRTCSession.leavePresenceGroup([_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WAITING_ROOM_PREFIX + conversation._getTechnicalName()]);
      } else if (joinPresenceGroupTimeoutId) {
        clearTimeout(joinPresenceGroupTimeoutId);
      }

      if (status === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ACCEPTED) {
        resolve();
      } else {
        conversation.status = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED;
        reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_ALLOWED, 'You were not allowed to join the conversation', logger));
      }
    });

    conversation.cancelJoin0 = function () {
      delete conversation.cancelJoin0;

      if (conversation.joinRequestIntervalId) {
        clearInterval(conversation.joinRequestIntervalId);
        delete conversation.joinRequestIntervalId;
      }

      apiRTCManager.removeEventListener('receiveData', receiveDataHandler);

      if (presenceGroupJoined === true) {
        var options = {};
        options.doneByApiRTC = true; //Leave Waiting room group

        apiRTCManager.apiRTCSession.leavePresenceGroup([_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_WAITING_ROOM_PREFIX + conversation._getTechnicalName()], options);
      } else if (joinPresenceGroupTimeoutId) {
        clearTimeout(joinPresenceGroupTimeoutId);
      }

      conversation.status = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_NOT_JOINED;
      reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OPERATION_CANCELED, 'Operation canceled', logger));
      return true;
    };
  });
};
/**
 * Wrapper for updateConferencePresence so it always resolves.
 * @return {Promise<any>} Always resolved.
 */


var updateConferencePresence = function updateConferencePresence(conversation, session, apiKey) {
  return new Promise(function (resolve) {
    cloudApi.updateConferencePresence(conversation, session, apiKey).then(resolve, function (err) {
      logger.warn('updateConferencePresence', err);
      resolve();
    });
  });
};
/*
 * Destroys a publish call.
 * @ignore
 * @method destroyPublishCall
 * @param {Conversation} conversation
 * @param {String} callId
 * @param {object} options
 * @param {Stream} options.stream
 * @param {boolean} options.triggerAdaptation - For robust video.
 */


var destroyPublishCall = function destroyPublishCall(conversation, callId) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var stream = options.stream;

  if (!stream) {
    var convCall = conversation.conversationCalls.get(callId);

    if (!convCall) {
      return false;
    }

    stream = convCall.stream;
  }

  if (options.noTriggerAdaptation) {
    conversation.releaseResources(stream.userMediaStreamId);
  } else {
    conversation.releaseResources(stream.userMediaStreamId, {
      triggerAdaptation: true
    });
  }

  stream.publishedInConversations["delete"](conversation.getName());
  conversation.conversationPublishedStreams["delete"](stream.userMediaStreamId);
  conversation.callIdToStreamId["delete"](callId);
  conversation.conversationCalls["delete"](callId);
  return true;
};
/**
 * Disables the video track of a given stream. Stops the call if the stream is video only.
 * @ignore
 * @method disableVideoTrack
 * @param {Conversation} conversation
 * @param {StreamResourceReservation} resStream
 */


var disableVideoTrack = function disableVideoTrack(conversation, resStream) {
  var adaptationTriggered = {
    streamId: resStream.streamId,
    isRemote: resStream.isRemote
  }; // Deactivate video track or stop call.

  if (!resStream.isRemote) {
    // Publish call.
    if (resStream.isVideoOnly) {
      // No audio track.
      // Stop call.
      adaptationTriggered.action = 'hangup';

      var stream = _Stream__WEBPACK_IMPORTED_MODULE_4__._localStreams.get(resStream.streamId);

      var convCall = conversation.getConversationCall(stream);

      if (convCall) {
        adaptationTriggered.callId = convCall.callId;
      }

      logger.debug('disableVideoTrack - hangup', resStream.streamId);
      conversation.unpublish(stream, {
        noTriggerAdaptation: true
      });
    } else {
      // Audio track present.
      // Deactivate video track.
      var _convCall = conversation.getConversationCall(_Stream__WEBPACK_IMPORTED_MODULE_4__._localStreams.get(resStream.streamId));

      if (_convCall) {
        adaptationTriggered.action = 'disableTrack';
        adaptationTriggered.trackType = 'video';
        adaptationTriggered.callId = _convCall.callId;
        logger.debug('disableVideoTrack - disable video track', resStream.streamId);

        _convCall.updatePublishedStream('video', false)["catch"](function (err) {
          logger.error('disableVideoTrack - updatePublishedStream', err);
        });

        resStream.isVideoMuted = true;
      } else {
        adaptationTriggered = null;
      }
    }
  } else {
    // Subscribe call.
    if (resStream.isVideoOnly) {
      // No audio track.
      // Stop call.
      adaptationTriggered.action = 'hangup';

      var _stream = _subscribedStreams.get(conversation).get(resStream.streamId);

      if (_stream) {
        adaptationTriggered.callId = _stream.callId;
      }

      logger.debug('disableVideoTrack - hangup', resStream.streamId);
      conversation.unsubscribeToStream(resStream.streamId, {
        noTriggerAdaptation: true
      });
    } else {
      // Audio track present.
      adaptationTriggered.action = 'disableTrack';
      adaptationTriggered.trackType = 'video';

      var _stream2 = _subscribedStreams.get(conversation).get(resStream.streamId);

      if (_stream2) {
        adaptationTriggered.callId = _stream2.callId;
      }

      logger.debug('disableVideoTrack - disable video track', resStream.streamId);
      conversation.updateSubscribedStream(resStream.streamId, {
        audioOnly: true
      })["catch"](function (err) {
        logger.error('disableVideoTrack - updateSubscribedStream', err);
      });
      resStream.isVideoMuted = true;
    }
  }

  if (adaptationTriggered) {
    _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(conversation).emit('adaptationTriggered', adaptationTriggered);
  }
};
/**
 * Enables the video track of a given stream.
 * @ignore
 * @method enableVideoTrack
 * @param {Conversation} conversation
 * @param {StreamResourceReservation} resStream
 */


var enableVideoTrack = function enableVideoTrack(conversation, resStream) {
  var adaptationTriggered = {
    streamId: resStream.streamId,
    isRemote: resStream.isRemote,
    action: 'enableTrack',
    trackType: 'video'
  }; // Activate video track.

  if (!resStream.isRemote) {
    // Publish call.
    var convCall = conversation.getConversationCall(_Stream__WEBPACK_IMPORTED_MODULE_4__._localStreams.get(resStream.streamId));

    if (convCall) {
      adaptationTriggered.callId = convCall.callId;
      logger.debug('enableVideoTrack - enable video track', resStream.streamId);
      convCall.updatePublishedStream('video', true)["catch"](function (err) {
        logger.error('enableVideoTrack - updatePublishedStream', err);
      });
      resStream.isVideoMuted = false;
    } else {
      adaptationTriggered = null;
    }
  } else {
    // Subscribe call.
    var stream = _subscribedStreams.get(conversation).get(resStream.streamId);

    if (stream) {
      adaptationTriggered.callId = stream.callId;
    }

    logger.debug('enableVideoTrack - enable video track', resStream.streamId);
    conversation.updateSubscribedStream(resStream.streamId, {
      audioOnly: false
    })["catch"](function (err) {
      logger.error('enableVideoTrack - updateSubscribedStream', err);
    });
    resStream.isVideoMuted = false;
  }

  if (adaptationTriggered) {
    _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(conversation).emit('adaptationTriggered', adaptationTriggered);
  }
};
/*
 * @ignore
 * @method Conversation#enablePointerSharing
 * @description Enables or disables pointer sharing for a given conversation.
 * @param {Conversation} conversation
 * @param {boolean} initiator - whether caller has initiator role.
 * @param {boolean} enabled - true to enable, false to disable.
 * @return {Promise<string>}
 */


var _enablePointerSharing = function _enablePointerSharing(conversation, initiator, enabled) {
  if (enabled === true) {
    if (conversation.pointerSharingState === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STATE_IDLE) {
      conversation.pointerSharingState = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STATE_JOINING;
      return new Promise(function (resolve, reject) {
        apiRTCManager.pointerSharingClient.joinRoom(conversation._getTechnicalName(), {
          success: function success(roomId) {
            conversation.pointerSharingState = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STATE_ACTIVE;

            if (initiator === true) {
              conversation.pointerSharingAutoInvite = true;
            }

            var pointerSharingEnabled = {
              enabled: true,
              roomId: roomId
            };

            _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(conversation).emit('pointerSharingEnabled', pointerSharingEnabled);

            resolve();

            if (conversation.pointerSharingAutoInvite === true) {
              // Inviting everyone present.
              contactCatalog.getContacts(conversation._getTechnicalName()).forEach(function (contact) {
                apiRTCManager.pointerSharingClient.inviteInRoom(conversation._getTechnicalName(), contact.getId());
              });
            }
          },
          failure: function failure(err, roomId) {
            conversation.pointerSharingState = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STATE_IDLE;
            conversation.pointerSharingAutoInvite = false;
            reject(err);
          }
        });
      });
    } else {
      return Promise.reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'enablePointerSharing() - cannot enable pointer sharing'));
    }
  } else if (enabled === false) {
    if (conversation.pointerSharingState === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STATE_ACTIVE) {
      conversation.pointerSharingState = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STATE_LEAVING;
      return new Promise(function (resolve, reject) {
        apiRTCManager.pointerSharingClient.leaveRoom(conversation._getTechnicalName());
        conversation.pointerSharingState = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STATE_IDLE;
        conversation.pointerSharingAutoInvite = false;
        var pointerSharingEnabled = {
          enabled: false,
          roomId: conversation._getTechnicalName()
        };

        _utils_Observable__WEBPACK_IMPORTED_MODULE_3__._eventEmitter.get(conversation).emit('pointerSharingEnabled', pointerSharingEnabled);

        resolve();
      });
    } else {
      return Promise.reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'enablePointerSharing() - cannot disable pointer sharing'));
    }
  }

  return Promise.reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'enablePointerSharing() - cannot enable/disable pointer sharing'));
};
/*
 * Parses given streaming event.
 * @ignore
 * @method parseStreamingEvent
 * @param {string} eventName - Either 'MCUStreamingStarted' or 'MCUStreamingStopped'.
 * @param {object} eventDetail
 * @param {object} eventDetail.roomName
 * @param {object} eventDetail.callId
 * @param {object} eventDetail.clientId
 * @return {object}
 */


var parseStreamingEvent = function parseStreamingEvent(eventName, eventDetail) {
  var res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  ['roomName', 'callId', 'clientId'].forEach(function (e) {
    if (eventDetail.hasOwnProperty(e)) {
      // Force string is required for old conversation id (integer)
      res[e] = String(eventDetail[e]);
    }
  });
  return res;
};



/***/ }),

/***/ "./src/public/ConversationCall.js":
/*!****************************************!*\
  !*** ./src/public/ConversationCall.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConversationCall": () => (/* binding */ ConversationCall)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Observable */ "./src/utils/Observable.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../private/ApiRTCManager */ "./src/private/ApiRTCManager.js");
/* harmony import */ var _Conversation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Conversation */ "./src/public/Conversation.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Stream */ "./src/public/Stream.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* globals apiCC*/







var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_5__.Logger.get('ConversationCall');
var apiRTCManager = _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_3__.ApiRTCManager.get();
/**
 * Represents a call within the context of a conversation/conference.
 *
 * @extends Observable
 */

var ConversationCall = /*#__PURE__*/function (_Observable) {
  _inherits(ConversationCall, _Observable);

  var _super = _createSuper(ConversationCall);

  function ConversationCall(conversation, callId, stream) {
    var _this;

    _classCallCheck(this, ConversationCall);

    _this = _super.call(this, logger);
    _this.conversation = conversation;
    _this.callId = callId;
    _this.stream = stream;
    return _this;
  }
  /*
   * Releases all resources.
   */
  //    destroy() {}
  //    hangUp() {}

  /**
   * Returns the conversation
   *
   * @return {Conversation}
   */


  _createClass(ConversationCall, [{
    key: "getConversation",
    value: function getConversation() {
      return this.conversation;
    }
    /**
     * Returns the call id of the call represented by this one.
     *
     * @return {string} Call id.
     */

  }, {
    key: "getCallId",
    value: function getCallId() {
      return this.callId;
    }
    /**
     * Returns the stream at play in the call represented by this one.
     *
     * @return {Stream} A stream.
     */

  }, {
    key: "getStream",
    value: function getStream() {
      return this.stream;
    }
    /**
     * Tests whether the call represented by this one is recorded.
     * @return {boolean}
     */

  }, {
    key: "isRecorded",
    value: function isRecorded() {
      return !!this.recordingStatus;
    }
    /**
     * Returns the recoding information, if any.
     * @return {RecordingInfo|null}
     */

  }, {
    key: "getRecordingInfo",
    value: function getRecordingInfo() {
      if (this.isRecorded()) {
        return this.recordingStatus;
      }

      return null;
    }
    /**
     * Tests whether the call represented by this one is streamed.
     * @return {boolean}
     */

  }, {
    key: "isStreamed",
    value: function isStreamed() {
      return !!this.streamingStatus;
    }
    /**
     * Returns the streaming information, if any.
     * @return {StreamingInfo|null}
     */

  }, {
    key: "getStreamingInfo",
    value: function getStreamingInfo() {
      if (this.isStreamed()) {
        return this.streamingStatus;
      }

      return null;
    }
    /**
     * Starts recording the currently published stream.
     *
     * @param {Object} options - Recording preferences.
     * @param {boolean} options.audioOnly - Whether to record only audio.
     * @param {boolean} options.videoOnly - Whether to record only video.
     * @param {string} options.customIdInFilename - This string will be added to the name of the final file.
     * @param {object} options.data - User data.
     * @param {number} options.ttl - The time to live (in seconds) of the recording after being successfully created. By default, the data is persistent.
     *
     * @return {Promise<RecordingInfo>}
     */

  }, {
    key: "startRecordingPublishedStream",
    value: function startRecordingPublishedStream(options) {
      var _this2 = this;

      if (!options) {
        options = {};
      }

      return new Promise(function (resolve, reject) {
        if (_this2.asyncCallbacks) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startRecordingPublishedStream() - busy', logger));
        }

        _this2.asyncCallbacks = {}; // Set timeout to handle lack of response from CCS.

        _this2.asyncCallbacks.timeoutId = setTimeout(function () {
          if (_this2.asyncCallbacks) {
            apiRTCManager.removeEventListener('error', _this2.asyncCallbacks.error);
            apiRTCManager.removeEventListener('MCURecordingStarted', _this2.asyncCallbacks.recordingStarted);
            delete _this2.asyncCallbacks;
          }

          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startRecordingPublishedStream() - timeout', logger));
        }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_RECORDING_STARTED_DELAY); // Set error handler to handle failure.

        _this2.asyncCallbacks.error = function (e) {
          var convId = String(e.detail.convId);

          if (convId === _this2.conversation.getCloudConversationId() && e.detail.callId === _this2.callId && e.detail.errorCode.indexOf('START_RECORD') >= 0) {
            // Error related to the startCompositeRecording request.
            if (_this2.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this2.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStarted', _this2.asyncCallbacks.recordingStarted);
              clearTimeout(_this2.asyncCallbacks.timeoutId);
              delete _this2.asyncCallbacks;
            }

            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startRecordingPublishedStream() - ' + e.detail.errorInfo, logger));
          }
        }; // Set success handler.


        _this2.asyncCallbacks.recordingStarted = function (e) {
          var convId = String(e.detail.convId);

          if (convId === _this2.conversation.getCloudConversationId() && e.detail.callId === _this2.callId) {
            if (_this2.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this2.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStarted', _this2.asyncCallbacks.recordingStarted);
              clearTimeout(_this2.asyncCallbacks.timeoutId);
              delete _this2.asyncCallbacks;
            }

            var value = _utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.parseRecordingEvent('MCURecordingStarted', e.detail);
            return resolve(value);
          }
        };

        apiRTCManager.onEvent('error', _this2.asyncCallbacks.error);
        apiRTCManager.onEvent('MCURecordingStarted', _this2.asyncCallbacks.recordingStarted);
        var mediaType = 'AUDIO-VIDEO';

        if (options.audioOnly === true) {
          mediaType = 'AUDIO-ONLY';
        } else if (options.videoOnly === true) {
          mediaType = 'VIDEO-ONLY';
        }

        var customIdInFilename = 'userStream';

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.isPropertyTypeof(options, 'customIdInFilename', 'string')) {
          customIdInFilename = options.customIdInFilename;
        }

        var data = {};

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.isPropertyTypeof(options, 'data', 'object')) {
          data = Object.assign({}, options.data);
        }

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.isPropertyTypeof(options, 'ttl', 'number') && options.ttl > 0) {
          data.ttl = options.ttl;
        }

        apiRTCManager.webRTCClient.startRecording(mediaType, customIdInFilename, _this2.conversation.getCloudConversationId(), _this2.callId, data);
      });
    }
    /**
     * Stops recording.
     *
     * @return {Promise<RecordingInfo>}
     */

  }, {
    key: "stopRecordingPublishedStream",
    value: function stopRecordingPublishedStream() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.asyncCallbacks) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'stopRecordingPublishedStream() - busy', logger));
        }

        _this3.asyncCallbacks = {}; // Set timeout to handle lack of response from CCS.

        _this3.asyncCallbacks.timeoutId = setTimeout(function () {
          if (_this3.asyncCallbacks) {
            apiRTCManager.removeEventListener('error', _this3.asyncCallbacks.error);
            apiRTCManager.removeEventListener('MCURecordingStopped', _this3.asyncCallbacks.recordingStopped);
            delete _this3.asyncCallbacks;
          } // Do not reject on timeout as recordingStopped event is fairly new.


          return resolve(_this3.recordingStatus);
        }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_RECORDING_STOPPED_DELAY); // Set error handler to handle failure.

        _this3.asyncCallbacks.error = function (e) {
          var convId = String(e.detail.convId);

          if (convId === _this3.conversation.getCloudConversationId() && e.detail.callId === _this3.callId && e.detail.errorCode.indexOf('STOP_RECORD') >= 0) {
            // Error related to the startCompositeRecording request.
            if (_this3.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this3.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStopped', _this3.asyncCallbacks.recordingStopped);
              clearTimeout(_this3.asyncCallbacks.timeoutId);
              delete _this3.asyncCallbacks;
            }

            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'stopRecordingPublishedStream() - ' + e.detail.errorInfo, logger));
          }
        }; // Set success handler.


        _this3.asyncCallbacks.recordingStopped = function (e) {
          var convId = String(e.detail.convId);

          if (convId === _this3.conversation.getCloudConversationId() && e.detail.callId === _this3.callId) {
            if (_this3.asyncCallbacks) {
              apiRTCManager.removeEventListener('error', _this3.asyncCallbacks.error);
              apiRTCManager.removeEventListener('MCURecordingStopped', _this3.asyncCallbacks.recordingStopped);
              clearTimeout(_this3.asyncCallbacks.timeoutId);
              delete _this3.asyncCallbacks;
            }

            var value = _utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.parseRecordingEvent('MCURecordingStopped', e.detail);
            return resolve(value);
          }
        };

        apiRTCManager.onEvent('error', _this3.asyncCallbacks.error);
        apiRTCManager.onEvent('MCURecordingStopped', _this3.asyncCallbacks.recordingStopped);
        apiRTCManager.webRTCClient.stopRecording(_this3.callId);
      });
    }
    /**
     * Replaces the currently published stream by a given one.
     * If the first parameter is null then the second parameter must provides a property named
     * getStream. The getStream property shall be a function returning a Promise of a Stream.
     *
     * @param {Stream} newStream - A new stream.
     * @param {object} callbacks - Callbacks.
     * @param {function} callbacks.getStream - A function returning a promise of a stream.
     * @param {object} options - Options.
     *
     * @return {Promise<Stream>} The newly assigned stream.
     */

  }, {
    key: "replacePublishedStream",
    value: function replacePublishedStream(newStream, callbacks) {
      var _this4 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var findStream = function findStream(userMediaStreamId) {
        if (_Stream__WEBPACK_IMPORTED_MODULE_6__._localStreams.has(userMediaStreamId)) {
          return _Stream__WEBPACK_IMPORTED_MODULE_6__._localStreams.get(userMediaStreamId);
        } else {
          var userMediaStream = apiCC.getUserMediaStream(userMediaStreamId);

          if (userMediaStream) {
            var type = 'audio';

            if (userMediaStream.video === true) {
              type = 'video';
            }

            return new _Stream__WEBPACK_IMPORTED_MODULE_6__.Stream(userMediaStream.stream, {
              type: type,
              constructor: true,
              userMediaStreamId: userMediaStream.userMediaStreamId
            });
          }
        }

        return null;
      };

      return new Promise(function (resolve, reject) {
        if (newStream === null) {
          if (!_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.isPropertyTypeof(callbacks, 'getStream', 'function')) {
            return reject(new Error('replacePublishedStream() - Cannot replace stream, wrong arguments'));
          } // The current stream is removed from conversation.


          _this4.stream.publishedInConversations["delete"](_this4.conversation.getName());

          _this4.conversation.conversationPublishedStreams["delete"](_this4.stream.userMediaStreamId); // Replacing stream.


          var newCallBacks = {};

          newCallBacks.getUserMediaStreamId = function () {
            return callbacks.getStream().then(function (newStream) {
              // Setting up new stream.
              _this4.stream = newStream;
              newStream.publishedInConversations.set(_this4.conversation.getName(), _this4.callId);

              _this4.conversation.callIdToStreamId.set(_this4.callId, newStream.userMediaStreamId);

              var streamInfo = {
                contact: null,
                isRemote: false,
                hasAudio: newStream.hasAudio(),
                hasVideo: newStream.hasVideo(),
                isScreensharing: newStream.isScreensharing(),
                streamId: newStream.userMediaStreamId,
                callId: _this4.callId
              };

              _this4.conversation.conversationPublishedStreams.set(newStream.userMediaStreamId, streamInfo);

              return newStream.userMediaStreamId;
            })["catch"](reject);
          };

          apiRTCManager.webRTCClient.webRTCClient.addMedia(_this4.callId, true, null, newCallBacks).then(function (userMediaStreamId) {
            return resolve(findStream(userMediaStreamId));
          })["catch"](function (err) {
            return reject(new Error('replacePublishedStream() - ' + err));
          });
        } else {
          // The current stream is removed from conversation.
          _this4.stream.publishedInConversations["delete"](_this4.conversation.getName());

          _this4.conversation.conversationPublishedStreams["delete"](_this4.stream.userMediaStreamId); // Replacing stream.


          apiRTCManager.webRTCClient.webRTCClient.addMedia(_this4.callId, true, newStream.userMediaStreamId).then(function (userMediaStreamId) {
            return resolve(newStream);
          })["catch"](function (err) {
            return reject(new Error('replacePublishedStream() - ' + err));
          }); // Setting up new stream.

          _this4.stream = newStream;
          newStream.publishedInConversations.set(_this4.conversation.getName(), _this4.callId);

          _this4.conversation.callIdToStreamId.set(_this4.callId, newStream.userMediaStreamId);

          var streamInfo = {
            contact: null,
            isRemote: false,
            hasAudio: newStream.hasAudio(),
            hasVideo: newStream.hasVideo(),
            isScreensharing: newStream.isScreensharing(),
            streamId: newStream.userMediaStreamId,
            callId: _this4.callId
          };

          _this4.conversation.conversationPublishedStreams.set(newStream.userMediaStreamId, streamInfo);
        }
      });
    }
    /**
     * @typedef {Object} StreamingOptions
     * @property {string} service
     * @property {string} server
     * @property {string} streamKey
     */

    /**
     * Starts streaming.
     * @param {StreamingOptions} options
     * @return {Promise<StreamingInfo>}
     */

  }, {
    key: "startStreaming",
    value: function startStreaming() {
      var _this5 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Promise(function (resolve, reject) {
        if (_this5.asyncCallbacks) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startStreaming() - busy', logger));
        }

        var res = apiRTCManager.webRTCClient.startStreaming(options.service, options.server, options.streamKey, _this5.callId);

        if (res) {
          _this5.asyncCallbacks = {}; // Set timeout to handle lack of response from CCS.

          _this5.asyncCallbacks.timeoutId = setTimeout(function () {
            if (_this5.asyncCallbacks) {
              apiRTCManager.removeEventListener('MCUStreamingStarted', _this5.asyncCallbacks.streamingStarted);
              delete _this5.asyncCallbacks;
            }

            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'startStreaming() - timeout', logger));
          }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STREAMING_STARTED_DELAY); // Set success handler.

          _this5.asyncCallbacks.streamingStarted = function (e) {
            if (e.detail.roomName === _this5.conversation._getTechnicalName() && e.detail.callId === _this5.callId) {
              if (_this5.asyncCallbacks) {
                apiRTCManager.removeEventListener('MCUStreamingStarted', _this5.asyncCallbacks.streamingStarted);
                clearTimeout(_this5.asyncCallbacks.timeoutId);
                delete _this5.asyncCallbacks;
              }

              var value = (0,_Conversation__WEBPACK_IMPORTED_MODULE_4__.parseStreamingEvent)('MCUStreamingStarted', e.detail);
              return resolve(value);
            }
          };

          apiRTCManager.onEvent('MCUStreamingStarted', _this5.asyncCallbacks.streamingStarted);
        } else {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'startStreaming() - cannot start streaming', logger));
        }
      });
    }
    /**
     * Stops streaming.
     * @return {Promise<StreamingInfo>}
     */

  }, {
    key: "stopStreaming",
    value: function stopStreaming() {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        if (_this6.asyncCallbacks) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'stopStreaming() - busy', logger));
        }

        var res = apiRTCManager.webRTCClient.stopStreaming(_this6.callId);

        if (res) {
          _this6.asyncCallbacks = {}; // Set timeout to handle lack of response from CCS.

          _this6.asyncCallbacks.timeoutId = setTimeout(function () {
            if (_this6.asyncCallbacks) {
              apiRTCManager.removeEventListener('MCUStreamingStopped', _this6.asyncCallbacks.streamingStopped);
              delete _this6.asyncCallbacks;
            }

            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'stopStreaming() - timeout', logger));
          }, _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STREAMING_STOPPED_DELAY); // Set success handler.

          _this6.asyncCallbacks.streamingStopped = function (e) {
            if (e.detail.roomName === _this6.conversation._getTechnicalName() && e.detail.callId === _this6.callId) {
              if (_this6.asyncCallbacks) {
                apiRTCManager.removeEventListener('MCUStreamingStopped', _this6.asyncCallbacks.streamingStopped);
                clearTimeout(_this6.asyncCallbacks.timeoutId);
                delete _this6.asyncCallbacks;
              }

              var value = (0,_Conversation__WEBPACK_IMPORTED_MODULE_4__.parseStreamingEvent)('MCUStreamingStopped', e.detail);
              return resolve(value);
            }
          };

          apiRTCManager.onEvent('MCUStreamingStopped', _this6.asyncCallbacks.streamingStopped);
        } else {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'stopStreaming() - cannot stop streaming', logger));
        }
      });
    }
    /**
     * Changes the priority of the stream represented by this one.
     * @param {number} priority
     * @return {Promise}
     */

  }, {
    key: "changeStreamPriority",
    value: function changeStreamPriority(priority) {
      var _this7 = this;

      return new Promise(function (resolve, reject) {
        var res = apiRTCManager.webRTCClient.changeStreamPriority(_this7.callId, priority);

        if (!res) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'changeStreamPriority() - cannot change stream priority', logger));
        }

        _this7.conversation.changeStreamPriority(_this7.stream.userMediaStreamId, false, priority);

        return resolve();
      });
    }
    /**
     * Activates or deactivates either the audio track or the video track.
     * @ignore
     * @param {string} trackType - Either 'audio' or 'video'.
     * @param {boolean} enabled
     * @return {Promise}
     */

  }, {
    key: "updatePublishedStream",
    value: function updatePublishedStream(trackType, enabled) {
      var _this8 = this;

      return new Promise(function (resolve, reject) {
        if (trackType !== 'audio' && trackType !== 'video') {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_BAD_PARAMETER, 'updatePublishedStream() - wrong type', logger));
        }

        var direction = enabled ? 'sendonly' : 'inactive';
        var res = apiRTCManager.webRTCClient.webRTCClient.processUpdateStream(_this8.callId, trackType, direction);

        if (!res) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_2__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'updatePublishedStream() - cannot update', logger));
        }

        return resolve();
      });
    }
  }]);

  return ConversationCall;
}(_utils_Observable__WEBPACK_IMPORTED_MODULE_1__.Observable);



/***/ }),

/***/ "./src/public/DataChannel.js":
/*!***********************************!*\
  !*** ./src/public/DataChannel.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DataChannel": () => (/* binding */ DataChannel)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _utils_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Observable */ "./src/utils/Observable.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../private/ApiRTCManager */ "./src/private/ApiRTCManager.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.get('DataChannel');
var apiRTCManager = _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_4__.ApiRTCManager.get();
var DATACHANNEL_EVENTS = ['response', 'accepted', 'declined', 'error', 'opened', 'closed', 'error', 'transferProgress', 'transferComplete', 'dataReceived', 'ended'];

var _id = new WeakMap();

var _contact = new WeakMap();

var _status = new WeakMap();

var _type = new WeakMap();
/**
 * DataChannel
 *
 * Designates a 1-1 datachannel session with another contact.
 * The datachannel session allows one user to send large amounts of data to the contact via P2P.
 *
 * @extends Observable
 * @fires DataChannel#response
 * @fires DataChannel#accepted
 * @fires DataChannel#declined
 * @fires DataChannel#opened
 * @fires DataChannel#closed
 * @fires DataChannel#ended
 * @fires DataChannel#transferProgress
 * @fires DataChannel#transferComplete
 * @fires DataChannel#dataReceived
 * @fires DataChannel#error
 */


var DataChannel = /*#__PURE__*/function (_Observable) {
  _inherits(DataChannel, _Observable);

  var _super = _createSuper(DataChannel);

  /**
   * When contact hangs up from 1-1 datachannel, 'from' property indicates which side initiated the ended, either 'remote' or 'local'
   *
   * @event DataChannel#ended
   * @type {object}
   * @property {string} from
   */

  /**
   * When contact accepts datachannel
   *
   * @event DataChannel#accepted
   * @type {Void}
   */

  /**
   * When contact accepted or declined datachannel
   *
   * @event DataChannel#response
   * @type {Void}
   */

  /**
   * When contact decline datachannel
   *
   * @event DataChannel#declined
   * @type {Void}
   */

  /**
   * Fired periodically during a data transfer
   *
   * @event DataChannel#transferProgress
   * @type {TransferInformation}
   */

  /**
   * Fired at the end of a data transfer
   *
   * @event DataChannel#transferComplete
   * @type {TransferInformation}
   */

  /**
   * Fired at the end of a data transfer when data has been received
   *
   * @event DataChannel#dataReceived
   * @type {object}
   * @property {string} uuid
   * @property {string} data
   */

  /**
   * When the data channel effectively opened
   *
   * @event DataChannel#opened
   * @type {Void}
   */

  /**
   * When the data channel effectively closed
   *
   * @event DataChannel#closed
   * @type {Void}
   */

  /**
   * When the data channel returns an error
   *
   * @event DataChannel#error
   * @type {Void}
   */

  /**
   * Creates a new call
   *
   *  @param {String} id call id
   *  @param {Contact} contact called contact
   *  @returns {DataChannel} this
   */
  function DataChannel(id, contact) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, DataChannel);

    _this = _super.call(this, logger);
    logger.debug('Create DataChannel with id ' + id);

    _id.set(_assertThisInitialized(_this), id);

    _contact.set(_assertThisInitialized(_this), contact);

    _type.set(_assertThisInitialized(_this), _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_TYPE_RECEIVE);

    if (options.hasOwnProperty('type')) {
      if (options.type === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_TYPE_RECEIVE) {
        _type.set(_assertThisInitialized(_this), _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_TYPE_RECEIVE);
      } else if (options.type === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_TYPE_SEND) {
        _type.set(_assertThisInitialized(_this), _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_TYPE_SEND);
      }
    }

    _status.set(_assertThisInitialized(_this), _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_STATUS_WAITING);

    apiRTCManager.onEvent('receiveData', function (e) {
      if (typeof e.detail.data.info !== 'undefined') {
        if (e.detail.data.info === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER && e.detail.data.invitationId.toString() === _this.getId() && _this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_STATUS_WAITING) {
          logger.info('DataChannel answer from ' + _this.getContact().getUsername() + ' for ' + _this.getId());

          if (e.detail.data.answer === 'accept') {
            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('accepted');
          } else {
            _status.set(_assertThisInitialized(_this), _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_STATUS_ENDED);

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('declined');
          }

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('response');
        }
      }
    }).onEvent('callEstablished', function (e) {
      var callId = e.detail.callId.toString();

      if (_this.getId() === callId) {
        logger.info('callEstablished from ' + _this.getContact().getUsername(), e);

        if (_this.getStatus() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_STATUS_ONGOING && _this.getStatus() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_STATUS_ENDED) {
          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('accepted');
        }
      }
    }).onEvent('hangup', function (e) {
      var callId = e.detail.callId.toString();
      var isDeclined = _this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_STATUS_WAITING && e.detail.hangupType === 'remote';

      if (_this.getId() === callId && _this.getStatus() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_STATUS_ENDED) {
        _status.set(_assertThisInitialized(_this), _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_STATUS_ENDED);

        logger.info('Hangup from ' + _this.getContact().getUsername(), e);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('ended', {
          from: e.detail.hangupType
        });

        if (isDeclined) {
          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('declined');
        }
      }
    }).onEvent('onFileReceived', function (e) {
      if (e.detail.callId.toString() === _this.getId()) {
        var data = e.detail.data;
        var reader = new FileReader();
        reader.addEventListener('loadend', function () {
          try {
            var file = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.arrayBuffertoString(reader.result);
            logger.info('dataReceived !');

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('dataReceived', {
              uuid: data.uuid,
              data: file
            });
          } catch (err) {
            logger.error('dataReceived Error', err);
          }
        });
        reader.readAsArrayBuffer(data.file);
      }
    }).onEvent('onFileProgress', function (e) {
      if (e.detail.callId.toString() === _this.getId()) {
        var detail = e.detail;
        logger.trace('file transfering', detail);
        var transferInformation = {
          uuid: detail.uuid,
          fileSize: detail.fileSize,
          remainingSize: detail.remainingSize,
          percentage: detail.percentage,
          sendChunkNb: detail.sendChunkNb,
          transferDuration: detail.transferDuration,
          lastPacket: detail.lastPacket
        };

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('transferProgress', transferInformation);

        if (detail.transferEnded) {
          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('transferComplete', transferInformation);
        }
      }
    }).onEvent('receiveDataChannelError', function (e) {
      var callId = e.detail.callId.toString();

      if (_this.getId() === callId) {
        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('error', 'receiveDataChannelError');
      }
    }).onEvent('sendDataChannelError', function (e) {
      var callId = e.detail.callId.toString();

      if (_this.getId() === callId) {
        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('error', 'sendDataChannelError');
      }
    }).onEvent('receiveDataChannelClose', function (e) {
      var callId = e.detail.callId.toString();

      if (_this.getId() === callId) {
        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('closed');
      }
    }).onEvent('sendDataChannelClose', function (e) {
      var callId = e.detail.callId.toString();

      if (_this.getId() === callId) {
        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('closed');
      }
    }).onEvent('receiveDataChannelOpen', function (e) {
      var callId = e.detail.callId.toString();

      if (_this.getId() === callId) {
        _status.set(_assertThisInitialized(_this), _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_STATUS_ONGOING);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('opened');
      }
    }).onEvent('sendDataChannelOpen', function (e) {
      var callId = e.detail.callId.toString();

      if (_this.getId() === callId) {
        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('opened');
      }
    });
    return _this;
  }
  /**
   * Returns available events for this class
   *
   *  @returns {Array<string>}
   */


  _createClass(DataChannel, [{
    key: "getId",
    value:
    /**
     * Returns datachannel session id
     *
     *  @returns {string} DataChannel id
     */
    function getId() {
      return _id.get(this).toString();
    }
    /**
     * Returns called contact
     *
     *  @returns {Contact} DataChannel contact
     */

  }, {
    key: "getContact",
    value: function getContact() {
      return _contact.get(this);
    }
    /**
     * Returns datachannel session type
     *
     *  @returns {Symbol} DataChannel type
     */

  }, {
    key: "getType",
    value: function getType() {
      return _type.get(this);
    }
    /**
     * Returns datachannel session status
     *
     *  @returns {Symbol} DataChannel status, value can be DATACHANNEL_STATUS_WAITING, DATACHANNEL_STATUS_ONGOING, DATACHANNEL_STATUS_ENDED
     */

  }, {
    key: "getStatus",
    value: function getStatus() {
      return _status.get(this);
    }
    /**
     * @typedef FileInfo
     * You can add additionnal fields if you need to
     * @type {Object}
     * @property {String} name
     * @property {String} type
     */

    /**
     * Sends data over data channel (send side only)
     *  @param {any} data
     *  @param {FileInfo} fileInfo relevant file information for the contact
     *  @returns {Promise<string>} uuid of the data transfered
     */

  }, {
    key: "sendData",
    value: function sendData(data) {
      var _this2 = this;

      var fileInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        var resolved = false;

        if (_this2.getStatus() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_STATUS_ONGOING) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'Cannot send data as datachannel session is not ongoing', logger));
        } else if (_this2.getType() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_TYPE_SEND) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'Cannot send data as datachannel session is receiving only', logger));
        } else {
          apiRTCManager.webRTCClient.sendDataWithCallId(_this2.getId(), {
            file: data,
            name: fileInfo.name,
            type: fileInfo.type
          }, function (progress) {
            if (!resolved) {
              resolved = true;
              resolve(progress.uuid);
            }

            logger.trace('sendData() - progress : ', progress);
            var transferInformation = {
              uuid: progress.uuid,
              fileSize: progress.fileSize,
              remainingSize: progress.remainingSize,
              percentage: progress.percentage,
              sendChunkNb: progress.sendChunkNb,
              transferDuration: progress.transferDuration,
              lastPacket: progress.lastPacket
            };

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_this2).emit('transferProgress', transferInformation);

            if (progress.transferEnded) {
              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_this2).emit('transferComplete', transferInformation);
            }
          });
        }
      });
    }
    /**
     * Stops datachannel session with contact
     *
     *  @returns {Void}
     */

  }, {
    key: "close",
    value: function close() {
      if (this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_STATUS_ENDED) {
        logger.error('close() - DataChannel session has already ended');
      } else {
        apiRTCManager.webRTCClient.hangUp(this.getId());
      }
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return DATACHANNEL_EVENTS;
    }
  }]);

  return DataChannel;
}(_utils_Observable__WEBPACK_IMPORTED_MODULE_2__.Observable);



/***/ }),

/***/ "./src/public/Enterprise.js":
/*!**********************************!*\
  !*** ./src/public/Enterprise.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Enterprise": () => (/* binding */ Enterprise)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Session */ "./src/public/Session.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../private/ApiRTCManager */ "./src/private/ApiRTCManager.js");
/* harmony import */ var _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @apizee/cloudapi-js-sdk/CloudAPI */ "./node_modules/@apizee/cloudapi-js-sdk/CloudAPI.js");
/* harmony import */ var _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../private/ConversationCatalog */ "./src/private/ConversationCatalog.js");
/* harmony import */ var _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../private/ContactCatalog */ "./src/private/ContactCatalog.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }









var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.get('Session');
var apiRTCManager = _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_4__.ApiRTCManager.get();
var cloudApi = new _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_5__["default"]();
var contactCatalog = _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_7__.ContactCatalog.get();
var conversationCatalog = _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_6__.ConversationCatalog.get();
var ENTERPRISE_NOT_LOADED = Symbol('ENTERPRISE_NOT_LOADED'),
    ENTERPRISE_LOADED = Symbol('ENTERPRISE_LOADED');

var _session = new WeakMap();

var _id = new WeakMap();

var _apiKey = new WeakMap();
/**
 * Enterprise
 *
 * This class refers to the user's enterprise.
 *
 */


var Enterprise = /*#__PURE__*/function () {
  function Enterprise(id, apikey, session) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Enterprise);

    logger.info('Create Enterprise');

    if (!(session instanceof _Session__WEBPACK_IMPORTED_MODULE_2__.Session)) {
      throw 'Cannot create Enterprise without a session';
    }

    _session.set(this, session);

    _apiKey.set(this, apikey);

    _id.set(this, id);

    this.status = ENTERPRISE_NOT_LOADED;
  }
  /**
   * @typedef fetchEnterpriseInformationOptions
   * @type {Object}
   * @property {string} id optional
   * @property {string} apiKey optional
   * @property {string} siteKey optional
   * @property {string} cloudUrl optional
   */

  /**
   * @typedef EnterpriseInformation
   * @type {Object}
   * @property {string} id
   * @property {string} name
   * @property {string} logo
   * @property {string} city
   * @property {string} address
   * @property {any} timeRanges
   * @property {string} preferedCCS
   * @property {string} apiKey
   */

  /**
   * Fetch enterprise information from apiKey if available
   *  @param {string} bearerToken
   *  @param {fetchEnterpriseInformationOptions} options
   *  @returns {Promise<EnterpriseInformation>} Enterprise information in promise
   */


  _createClass(Enterprise, [{
    key: "getSession",
    value:
    /**
     * Returns the session connected to this enterprise
     *
     * @returns {Session} session
     */
    function getSession() {
      return _session.get(this);
    }
    /**
     * Returns this enterprise id
     *
     * @returns {string} id
     */

  }, {
    key: "getId",
    value: function getId() {
      return _id.get(this).toString();
    }
    /**
     * Returns this enterprise apiKey
     *
     * @returns {string} session
     */

  }, {
    key: "getApiKey",
    value: function getApiKey() {
      return _apiKey.get(this).toString();
    }
    /**
     * A promise for loading enterprise data
     *
     *  @returns {Promise<void>}
     */

  }, {
    key: "load",
    value: function load() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        cloudApi.getEnterpriseUserList(_this.getId(), _this.getSession().getToken()).then(function (json) {
          logger.info('Enterprise loaded!', json); // Load enterprise contact list

          var _iterator = _createForOfIteratorHelper(json.users),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var user = _step.value;

              if (_this.getSession().user.userId.toString() !== user.id.toString()) {
                //ignore self
                var contact = contactCatalog.getOrCreateContact(user.id);
                contact.profile = user;
                contact.enterprise = _this;

                if (contact.userData.get('username') === null) {
                  contact.userData.setProp('username', user.username);
                }

                if (contact.userData.get('photo_url') === null) {
                  contact.userData.setProp('photo_url', user.photo_url);
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          _this.status = ENTERPRISE_LOADED;
          resolve();
        })["catch"](function (err) {
          var errorMsg = 'load() - Enterprise load error';
          var errorObj = {
            error: new Error(errorMsg),
            code: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER
          };

          if (err.hasOwnProperty('code')) {
            errorObj.code = err.code;
          } else if (err.hasOwnProperty('http_code')) {
            if (err.http_code.toString().startsWith('4')) {
              errorObj.code = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_INVALID_CREDENTIALS;
            } else {
              errorObj.code = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_SERVER_UNAVAILABLE;
            }
          }

          logger.error(errorMsg, err);
          reject(errorObj);
        });
      });
    }
    /**
     *  Returns contact list for enterprise
     *
     *  @returns {Object<string, Contact>} contact list
     */

  }, {
    key: "getContacts",
    value: function getContacts() {
      var res = {};

      if (this.status !== ENTERPRISE_LOADED) {
        logger.error('Enterprise is not loaded, unable to getContacts');
      } else {
        var contacts = contactCatalog.getContacts();

        var _iterator2 = _createForOfIteratorHelper(contacts.keys()),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var key = _step2.value;
            var contact = contacts.get(key);

            if (contact.enterprise !== null && contact.enterprise.id.toString() === this.getId()) {
              res[contact.getId()] = contact;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      return res;
    }
    /**
     *  Returns configuration for enterprise TODO
     *  @ignore
     *  @returns {Configuration} enterprise configuration
     */

  }, {
    key: "getConfiguration",
    value: function getConfiguration() {
      /*
      if (this.status === ENTERPRISE_LOADED) {
          return null;
          //TODO
      }else {
          logger.error('Enterprise is not loaded, unable to getConfiguration');
          return null;
      }
      */
      return null;
    }
    /**
     * @typedef UploadOptions
     * @type {Object}
     * @property {string} title
     * @property {string} description
     * @property {string} type
     */

    /**
     * A promise for uploading a file to the cloud
     *
     *  @param {Blob} file
     *  @param {UploadOptions} options
     *  @returns {Promise<string>} url in promise
     */

  }, {
    key: "uploadFile",
    value: function uploadFile(file) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        logger.info('uploadFile()');

        if (_this2.status === ENTERPRISE_LOADED) {
          cloudApi.uploadFile(file, _this2.getSession().getToken(), options).then(function (result) {
            resolve(result.url);
          })["catch"](function (err) {
            logger.error(err);
            reject(err);
          });
        } else {
          logger.error('Enterprise is not loaded, cannot upload file');
          reject(new Error('Enterprise is not loaded, cannot upload file'));
        }
      });
    }
    /**
     * @deprecated
     * Returns enterprise conferences available to the user
     *
     *  @returns {Promise<Object<string, Conference>>} conference list in promise
     */

  }, {
    key: "getAvailableConferences",
    value: function getAvailableConferences() {
      var _this3 = this;

      logger.info('getAvailableConferences()');
      return new Promise(function (resolve, reject) {
        var res = {};
        cloudApi.getConferenceList(_this3.getSession().getToken()).then(function (result) {
          var _iterator3 = _createForOfIteratorHelper(result),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var conf = _step3.value;
              res[conf.hash] = conversationCatalog.getOrCreateConference(conf.hash);
              res[conf.hash].friendlyName = conf.friendlyName;
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          resolve(res);
        })["catch"](function (err) {
          logger.error(err);
          reject(err);
        });
      });
    }
    /**
     * Returns a Conference for a given name.
     *
     * @param {string} name - A conference name.
     *
     * @return {Promise<Conference>} Conference on promise.
     */

  }, {
    key: "getConference",
    value: function getConference(name) {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        var opts = {};
        opts.token = _this4.getSession().getToken();
        cloudApi.getWebconf(name, opts).then(function (res) {
          return resolve(conversationCatalog.getOrCreateConference(res.hash));
        })["catch"](function (err) {
          logger.error('getConference', err);
          return reject(err);
        });
      });
    }
    /**
     * @typedef PrivateConferenceCreationOptions
     * @type {Object}
     * @property {string} password optional: if this conference is to be protected via a password, if this option is not set, users will need moderator approval to enter the conference
     * @property {string} friendlyName optional: friendly name for this conference to display in your ApiRTC cloud platform
    */

    /**
     * Create a new private conference on the cloud
     *
     *  @param {PrivateConferenceCreationOptions} options
     *  @returns {Promise<Conference>} newly created private conference in promise
     */

  }, {
    key: "createPrivateConference",
    value: function createPrivateConference() {
      var _this5 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      logger.info('createPrivateConference()');
      return new Promise(function (resolve, reject) {
        var friendlyName = options.hasOwnProperty('friendlyName') ? options.friendlyName : _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.guid();
        var conference = null;

        var token = _this5.getSession().getToken();

        cloudApi.createConference(token, friendlyName, options).then(function (res) {
          conference = conversationCatalog.getOrCreateConference(res.hash);
          conference.friendlyName = friendlyName;
          var password = options.hasOwnProperty('password') ? options.password : '';
          return conference.join({
            password: password,
            session: _this5.getSession()
          });
        }).then(function () {
          resolve(conference);
        })["catch"](function (err) {
          var errorMsg = 'createPrivateConference() - Could not create conference';
          logger.error(errorMsg, err);
          reject(new Error(errorMsg));
        });
      });
    }
    /**
     * @typedef {object} EnterpriseTag
     * @property {string} id
     * @property {string} name
     * @property {boolean} selected
     */

    /**
     * Returns the tag list associated to the enterprise represented by this one.
     * @param {Conference} - Optional conference.
     * @param {object} options
     * @return {Promise<array<EnterpriseTag>>}
     */

  }, {
    key: "getTags",
    value: function getTags(conference) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        var opts = {};

        if (conference && conference.hasOwnProperty('webconfId')) {
          opts.webconfId = conference.webconfId;
        }

        cloudApi.getEnterpriseTagList(_this6.getId(), _this6.getSession().getToken(), opts).then(function (res) {
          if (res.hasOwnProperty('tags') && Array.isArray(res.tags)) {
            return resolve(res.tags);
          } else {
            return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'getTags() - unexpected response', logger));
          }
        })["catch"](function (err) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'getTags() - cannot get tags', logger, {
            fromError: err
          }));
        });
      });
    }
  }], [{
    key: "fetchEnterpriseInformation",
    value: function fetchEnterpriseInformation(bearerToken) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options.hasOwnProperty('cloudUrl')) {
        cloudApi.setCloudURL(options.cloudUrl);
      }

      return cloudApi.getEnterpriseInformation(options, bearerToken);
    }
    /**
     * @typedef fetchSiteAgentsOptions
     * @type {Object}
     * @property {boolean} usePresence optional
     * @property {boolean} useAcd optional
     * @property {string} cloudUrl optional
     * @property {string} convId optional
     */

    /**
     * @typedef Agent
     * @type {Object}
     * @property {Contact} contact
     * @property {string} title
     * @property {string} nickname
     * @property {boolean} isPrefered
     */

    /**
     * Fetch agents from a site using its sitekey
     *
     *  @param {string} siteKey
     *  @param {fetchSiteAgentsOptions} options
     *  @returns {Promise<Array<Agent>>} Enterprise information in promise
     */

  }, {
    key: "fetchSiteAgents",
    value: function fetchSiteAgents(siteKey) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        if (options.hasOwnProperty('cloudUrl')) {
          cloudApi.setCloudURL(options.cloudUrl);
        }

        var res = [];
        cloudApi.getSiteAgents(apiRTCManager.getActiveApiKey(), siteKey, options).then(function (agents) {
          var _iterator4 = _createForOfIteratorHelper(agents),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var agent = _step4.value;
              res.push({
                contact: contactCatalog.getOrCreateContact(agent.id),
                title: agent.title,
                nickname: agent.nickname,
                isPrefered: agent.isPrefered
              });
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          resolve(res);
        })["catch"](function (err) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'fetchSiteAgents() - could not fetch site agents', logger));
        });
      });
    }
  }]);

  return Enterprise;
}();



/***/ }),

/***/ "./src/public/EventCenter.js":
/*!***********************************!*\
  !*** ./src/public/EventCenter.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventCenter": () => (/* binding */ EventCenter)
/* harmony export */ });
/* harmony import */ var _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/BrowserInfo */ "./src/Core/BrowserInfo.js");
/* harmony import */ var _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/ApiCC.js */ "./src/Core/ApiCC.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }




var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_2__.Logger.get('EventCenter');
var STORAGE_KEY = 'eventCenterData';
var MAX_RECORDS = 100;
var LOG_PREFIX = '[EVENTCENTER]';
var LOG_REMOTE_PREFIX = '[REMOTE-EVENTCENTER]';
/**
 * EventCenter is used to centralized and stored the different events that can happened on apiRTC
 * Ex : UserMediaMedia or iceDisconnection error,
 * @link https://apizee.atlassian.net/wiki/spaces/IN/pages/286884058/Event+Center
 */

var EventCenter = /*#__PURE__*/function () {
  function EventCenter() {
    var _this = this;

    _classCallCheck(this, EventCenter);

    this.consoleOutputEnabled = false;
    this.storageDisabled = false;

    if (typeof apiRTC_React === 'undefined') {
      document.addEventListener('error', function (event) {
        _this.handleErrorEvent(event);
      });
      document.addEventListener('userMediaError', function (event) {
        _this.handleErrorEvent(event);
      });
    }
  }

  _createClass(EventCenter, [{
    key: "handleErrorEvent",
    value: function handleErrorEvent(event) {
      var data = event.detail;

      if (this.storageDisabled === true) {
        logger.debug("Event Center is disabled");
        return;
      }

      if (data === undefined) {
        logger.error("Can't handle error event: data is undefined");
        return;
      }

      var result = {};
      var resultForSentry = {};
      var userId = 'UNKNOWN';
      result.type = event.type;

      for (var _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];

        if (key !== 'eventType') {
          result[key] = data[key];
        }
      }

      result.systemInfo = {
        apiRTC: _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_1__.apiCC.version,
        app: _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_0__.applicationType,
        device: _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_0__.deviceType,
        osName: _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_0__.osName,
        osVersion: _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_0__.osVersion,
        browser: _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_0__.browser,
        browser_version: _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_0__.browser_version
      };

      if (_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_1__.apiCC.session !== null && _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_1__.apiCC.session !== undefined) {
        userId = _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_1__.apiCC.session.apiCCId;
      } else if (_Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_1__.apiCC.initApiCCId !== null && _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_1__.apiCC.initApiCCId !== undefined) {
        userId = _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_1__.apiCC.initApiCCId;
      }

      result.userInfo = {
        apiCCId: userId,
        apiKey: apiRTC.initApiKey
      };
      var stored = localStorage.getItem(STORAGE_KEY);

      if (!stored) {
        stored = [];
      } else {
        stored = JSON.parse(stored);
      }

      stored.unshift(result);

      if (stored.length > MAX_RECORDS) {
        stored.splice(MAX_RECORDS, stored.length - MAX_RECORDS);
      }

      localStorage.setItem(STORAGE_KEY, JSON.stringify(stored));

      if (this.consoleOutputEnabled) {
        logger.error(LOG_PREFIX, result);
      }
      /*global Sentry*/


      if (typeof Sentry !== 'undefined') {
        if (event.detail.errorCode !== 'USER_MEDIA_ERROR') {
          resultForSentry.type = event.type;

          if (event.detail.error) {
            resultForSentry.error = event.detail.error;
          }

          if (event.detail.errorInfo) {
            resultForSentry.errorInfo = event.detail.errorInfo;
          }

          if (event.detail.errorCode) {
            resultForSentry.errorCode = event.detail.errorCode;
          }

          if (event.detail.callId) {
            resultForSentry.callId = event.detail.callId;
          }

          if (event.detail.convId) {
            resultForSentry.convId = event.detail.convId;
          }

          if (event.detail.gumConfig) {
            if (event.detail.gumConfig.video === false) {
              resultForSentry.gumConfigVideo = false;
            } else {
              resultForSentry.gumConfigVideo = true;
            }
          }

          Sentry.withScope(function (scope) {
            scope.setTag('event-center', true);
            scope.setTag("userId", _Core_ApiCC_js__WEBPACK_IMPORTED_MODULE_1__.apiCC.session.apiCCId);
            Sentry.captureException(new Error(JSON.stringify(resultForSentry)));
          });
        } else {
          logger.debug("Filtering error event for USER_MEDIA_ERROR for Sentry");
        }
      }
    }
    /*
     * Remote event center
     */

  }, {
    key: "handleDataAnswer",
    value: function handleDataAnswer(data) {
      if (!data) {
        logger.debug(LOG_REMOTE_PREFIX + ': ' + this.getUsername() + ' has no event records');
        return;
      }

      data.map(function (element) {
        logger.debug(LOG_REMOTE_PREFIX + ': ', element);
      });
    }
    /**
     * Returns stored events
     *
     *  @returns {Object<events>}
     */

  }, {
    key: "getStoredData",
    value: function getStoredData() {
      var stored = localStorage.getItem(STORAGE_KEY);

      if (stored === undefined) {
        logger.warn('No data was stored by event center');
        return null;
      }

      return JSON.parse(stored);
    }
    /**
     * Clear stored events
     */

  }, {
    key: "clearStoredData",
    value: function clearStoredData() {
      localStorage.removeItem(STORAGE_KEY);
    }
    /**
     * Activate console output
     * @param {boolean} enabled - Whether to activate console output (default is false).
     */

  }, {
    key: "enableConsoleOutput",
    value: function enableConsoleOutput(enabled) {
      this.consoleOutputEnabled = enabled;
    }
    /**
     * Disable EventCenter storage.
     * EventCenter is completely disabled, no storage in localStorage and no console output.
     * @param {boolean} disabled - Whether to deactivate EventCenter storage (default is false).
     */

  }, {
    key: "disableStorage",
    value: function disableStorage(disabled) {
      this.storageDisabled = disabled;
    }
  }]);

  return EventCenter;
}();

/***/ }),

/***/ "./src/public/Invitation.js":
/*!**********************************!*\
  !*** ./src/public/Invitation.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Invitation": () => (/* binding */ Invitation),
/* harmony export */   "_eventEmitter": () => (/* reexport safe */ _utils_Observable__WEBPACK_IMPORTED_MODULE_1__._eventEmitter),
/* harmony export */   "_status": () => (/* binding */ _status)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Observable */ "./src/utils/Observable.js");
/* harmony import */ var _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../private/ApiRTCManager */ "./src/private/ApiRTCManager.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.get('Invitation'); //Private inheritated variables

var _status = new WeakMap();

var INVITATION_EVENTS = ['statusChange'];
/**
 * Invitation
 * @ignore
 * @abstract
 */
// @fires Invitation#statusChange

var Invitation = /*#__PURE__*/function (_Observable) {
  _inherits(Invitation, _Observable);

  var _super = _createSuper(Invitation);

  /*
   * Emitted invitation status change
   * @event Invitation#statusChange
   * @type {StatusChangeInfo}
   */

  /**
   * @typedef StatusChangeInfo
   * @type {Object}
   * @property {Symbol} status
   * @property {string} id - id of the invitation
   */
  function Invitation() {
    var _this;

    _classCallCheck(this, Invitation);

    _this = _super.call(this, logger); //logger.debug('Create Invitation');

    _this.id = null;

    _status.set(_assertThisInitialized(_this), _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY);

    _this.apiRTCManager = _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_2__.ApiRTCManager.get();
    _this.type = 'not_defined'; //value can be call, conversation, conference, whiteboard, dataChannel, or sendFile

    return _this;
  }
  /*
   * Returns available events for this class
   *
   *  @returns {Array<string>}
   */


  _createClass(Invitation, [{
    key: "setStatus",
    value: function setStatus(status) {
      _status.set(this, status);

      _utils_Observable__WEBPACK_IMPORTED_MODULE_1__._eventEmitter.get(this).emit('statusChange', {
        status: status,
        id: this.id
      });
    }
    /**
     * Returns invitation status
     *
     *  @returns {Symbol} invitation status
     */

  }, {
    key: "getStatus",
    value: function getStatus() {
      return _status.get(this);
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return INVITATION_EVENTS;
    }
  }]);

  return Invitation;
}(_utils_Observable__WEBPACK_IMPORTED_MODULE_1__.Observable);



/***/ }),

/***/ "./src/public/MediaDevice.js":
/*!***********************************!*\
  !*** ./src/public/MediaDevice.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MediaDevice": () => (/* binding */ MediaDevice)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }


var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('MediaDevice');
/**
 * MediaDevice
 *
 * A media device is a device detected by the browser which can be used to create streams
 *
 */

var MediaDevice = /*#__PURE__*/function () {
  function MediaDevice(id, type, label, capabilities) {
    _classCallCheck(this, MediaDevice);

    logger.trace('Create ' + type + ' MediaDevice');
    this.id = id;
    this.type = type;
    this.label = label;
    this.capabilities = capabilities;
  }
  /**
   * Returns device id
   *
   *  @returns {string}
   */


  _createClass(MediaDevice, [{
    key: "getId",
    value: function getId() {
      return this.id.toString();
    }
    /**
     * Returns device type
     *
     *  @returns {string}
     */

  }, {
    key: "getType",
    value: function getType() {
      return this.type;
    }
    /**
     * Returns device label
     *
     *  @returns {string}
     */

  }, {
    key: "getLabel",
    value: function getLabel() {
      return this.label;
    }
    /**
     * Is the mediaDevice a camera?
     *
     *  @returns {boolean}
     */

  }, {
    key: "isCamera",
    value: function isCamera() {
      return this.type === 'videoinput';
    }
    /**
     * Is the mediaDevice an audio source
     *
     *  @returns {boolean}
     */

  }, {
    key: "isMicrophone",
    value: function isMicrophone() {
      return this.type === 'audioinput';
    }
    /**
     * Is the mediaDevice an audio output
     *
     *  @returns {boolean}
     */

  }, {
    key: "isAudioOutput",
    value: function isAudioOutput() {
      return this.type === 'audiooutput';
    }
    /**
     * Returns device capabities
     *
     *  @returns {MediaTrackCapabilities}
     */

  }, {
    key: "getCapabilities",
    value: function getCapabilities() {
      return this.capabilities;
    }
  }]);

  return MediaDevice;
}();



/***/ }),

/***/ "./src/public/ReceivedCallInvitation.js":
/*!**********************************************!*\
  !*** ./src/public/ReceivedCallInvitation.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReceivedCallInvitation": () => (/* binding */ ReceivedCallInvitation)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReceivedInvitation */ "./src/public/ReceivedInvitation.js");
/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Stream */ "./src/public/Stream.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _private_CallCatalog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../private/CallCatalog */ "./src/private/CallCatalog.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }







var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_4__.Logger.get('ReceivedInvitation');
var callCatalog = _private_CallCatalog__WEBPACK_IMPORTED_MODULE_5__.CallCatalog.get();
var RECEIVED_CALL_INVITATION_EVENTS = ['expired', 'statusChange'];
/**
 * ReceivedCallInvitation
 *
 * Defines an invitation received by this client for a call
 *  @extends ReceivedInvitation
 *  @fires ReceivedCallInvitation#expired
 */

var ReceivedCallInvitation = /*#__PURE__*/function (_ReceivedInvitation) {
  _inherits(ReceivedCallInvitation, _ReceivedInvitation);

  var _super = _createSuper(ReceivedCallInvitation);

  /**
   * Fired when the call invitation has expired (eg. caller cancelled call)
   *
   * @event ReceivedCallInvitation#expired
   * @type {Void}
   * @deprecated Please note that this event is now deprecated as we have added a statusChange event
   */
  function ReceivedCallInvitation(sender, id, callType) {
    var _this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, ReceivedCallInvitation);

    _this = _super.call(this, sender, id);
    logger.info('Create ReceivedCallInvitation with call type ' + callType);
    _this.type = 'call';
    _this.callType = callType;
    _this.isRecordedCall = options.hasOwnProperty('isRecorded') ? options.isRecorded : false;
    _this.call = callCatalog.getOrCreateCall(_this.id, _this.sender, {
      isRecorded: _this.isRecorded()
    });

    _this.apiRTCManager.onEvent('hangup', function (e) {
      var callId = e.detail.callId.toString();

      if (_this.id.toString() === callId) {
        //In case caller hangs up before call has been accepted
        if (_this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          _this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_EXPIRED);

          _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('expired'); //DEPRECATED with event statusChange

        }
      }
    });

    return _this;
  }
  /**
   * Returns available events for this class
   *
   *  @returns {Array<string>}
   */


  _createClass(ReceivedCallInvitation, [{
    key: "getCallType",
    value:
    /**
     * Returns call type
     *
     *  @returns {String}
     */
    function getCallType() {
      return this.callType;
    }
    /**
     * Returns whether call is recorded or not
     *
     *  @returns {boolean}
     */

  }, {
    key: "isRecorded",
    value: function isRecorded() {
      return this.isRecordedCall;
    }
    /**
     * @typedef AnswerOptions
     * @type {Object}
     * @property {String} mediaTypeForIncomingCall This enables to choose the media type to establish a call.
     * Value can be : VIDEO (audio and video will be used to establish call), AUDIO (audio only), VIDEOONLY, NONE (establishing call without sharing any media)
     * @property {String} mediaRoutingMode This enables to choose the media routing mode.
     * Value can be : hostOnly, stun, stunOnly, turn, turnOnly
     * @property {String} turnServerAddress This enables to change the turn server used for the call
     * @property {String} muted This parameter enables to start a muted call.
     * Value can be : VIDEO (audio and video will be muted), AUDIOONLY (only audio will be muted), VIDEOONLY (only video will be muted)
     * @property {Boolean} preferVP9Codec True to activate VP9 as preferred codec
     */

    /**
     * Accepts this invitation & notifies sender, returns Call object through Promise
     *
     *  @param {Stream} stream Optional, if set, the stream will be published for this call
     *  @param {AnswerOptions} options
     *  @returns {Promise<Call>} accepted call in promise
     */

  }, {
    key: "accept",
    value: function accept(stream) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        var audioOnly = _this2.getCallType() === 'audio' ? true : false;
        var shouldAnswerWithStream = true;
        var callConfiguration = options;

        if (options.hasOwnProperty('audioOnly')) {
          audioOnly = options.audioOnly;
          delete options.audioOnly;

          if (callConfiguration.mediaTypeForIncomingCall === undefined || callConfiguration.mediaTypeForIncomingCall === null) {
            if (options.audioOnly === true) {
              callConfiguration.mediaTypeForIncomingCall = 'AUDIO';
            }
          }
        }

        if (options.hasOwnProperty('noStream')) {
          callConfiguration.mediaTypeForIncomingCall = 'NONE';
          shouldAnswerWithStream = false;
        }

        if (callConfiguration.mediaTypeForIncomingCall === 'NONE') {
          shouldAnswerWithStream = false;
        }

        if (_this2.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          _this2.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ACCEPTED); //send notification to sender


          _this2.apiRTCManager.sendData(_this2.sender.getId(), {
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
            invitationId: _this2.id,
            answer: 'accept'
          });

          _this2.call.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CALL_STATUS_ONGOING);

          if (shouldAnswerWithStream && stream !== null && stream instanceof _Stream__WEBPACK_IMPORTED_MODULE_3__.Stream) {
            logger.debug('accept() - A stream was preselected; audio only : ', audioOnly);
            callConfiguration.userMediaStreamId = stream.userMediaStreamId;
          }

          _this2.apiRTCManager.webRTCClient.acceptCall(_this2.id, callConfiguration);

          resolve(_this2.call);
        } else {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_INVITATION_STATE_INVALID, 'accept() - Cannot join this call, invitation state invalid', logger));
        }
      });
    }
    /**
     * Declines the call invitation & notifies sender
     *
     *  @returns {Void}
     */

  }, {
    key: "decline",
    value: function decline(reason) {
      if (this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
        this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_DECLINED); //send notification to sender

        this.apiRTCManager.sendData(this.sender.getId(), {
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
          invitationId: this.id,
          reason: reason,
          answer: 'decline'
        });
        this.apiRTCManager.webRTCClient.refuseCall(this.id);
      }
    }
    /**
     * Returns associated conversation
     *
     *  @returns {Call}
     */

  }, {
    key: "getCall",
    value: function getCall() {
      return this.call;
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return RECEIVED_CALL_INVITATION_EVENTS;
    }
  }]);

  return ReceivedCallInvitation;
}(_ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__.ReceivedInvitation);



/***/ }),

/***/ "./src/public/ReceivedConversationInvitation.js":
/*!******************************************************!*\
  !*** ./src/public/ReceivedConversationInvitation.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReceivedConversationInvitation": () => (/* binding */ ReceivedConversationInvitation)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReceivedInvitation */ "./src/public/ReceivedInvitation.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.get('ReceivedInvitation');

var _options = new WeakMap();
/**
 * ReceivedConversationInvitation
 *
 * @extends ReceivedInvitation
 * Defines an invitation received by this client
 */


var ReceivedConversationInvitation = /*#__PURE__*/function (_ReceivedInvitation) {
  _inherits(ReceivedConversationInvitation, _ReceivedInvitation);

  var _super = _createSuper(ReceivedConversationInvitation);

  function ReceivedConversationInvitation(sender, data, conversation) {
    var _this;

    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, ReceivedConversationInvitation);

    _this = _super.call(this, sender, data.invitationId);
    logger.info('Create ReceivedConversationInvitation');
    _this.conversation = conversation;
    _this.type = 'conversation';
    _this.invitationData = data;

    _options.set(_assertThisInitialized(_this), options);

    return _this;
  }
  /**
   * Accepts this invitation & notifies sender
   *
   * @param {Stream} stream - Optional, if set, the stream will be published in the joined conversation.
   * @param {Object} options - join conversation options
   * @return {Promise<Conversation>} Conversation
   */


  _createClass(ReceivedConversationInvitation, [{
    key: "accept",
    value: function accept(stream) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var joinWebconf = function joinWebconf() {
        return new Promise(function (resolve, reject) {
          var joinOptions = _options.get(_this2);

          if (options.hasOwnProperty('password')) {
            joinOptions.password = options.password;
          }

          if (options.hasOwnProperty('session')) {
            joinOptions.session = options.session;
          }

          _this2.conversation.join(joinOptions).then(function () {
            if (typeof stream !== 'undefined' && stream !== null) {
              _this2.conversation.publish(stream);
            }

            resolve(_this2.conversation);
          })["catch"](function (err) {
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'accept() - cannot join webconf', logger, {
              fromError: err
            }));
          });
        });
      };

      var joinGroupChat = function joinGroupChat() {
        return new Promise(function (resolve, reject) {
          _this2.conversation.joinGroupChat().then(function () {
            resolve(_this2.conversation);
          })["catch"](function (err) {
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'accept() - cannot join groupChat', logger, {
              fromError: err
            }));
          });
        });
      };

      return new Promise(function (resolve, reject) {
        if (_this2.getStatus() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'accept() - cannot accept invitation', logger));
        }

        _this2.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ACCEPTED); //send notification to sender


        _this2.apiRTCManager.sendData(_this2.sender.getId(), {
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
          invitationId: _this2.id,
          answer: 'accept'
        });

        if (_this2.invitationData && _this2.invitationData.conversationTypes) {
          if (_this2.invitationData.conversationTypes.indexOf('WEBCONF') >= 0) {
            return joinWebconf().then(resolve)["catch"](reject);
          } else if (_this2.invitationData.conversationTypes.indexOf('GROUP_CHAT') >= 0) {
            return joinGroupChat().then(resolve)["catch"](reject);
          }
        } else {
          // Default.
          return joinWebconf().then(resolve)["catch"](reject);
        }
      });
    }
    /**
     * Declines this invitation & notifies sender
     *
     * @return {Void}
     */

  }, {
    key: "decline",
    value: function decline(reason) {
      if (this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
        this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_DECLINED); //send notification to sender

        this.apiRTCManager.sendData(this.sender.getId(), {
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
          invitationId: this.id,
          reason: reason,
          answer: 'decline'
        });
      }
    }
    /**
     * Returns associated conversation
     *
     * @return {Conversation}
     */

  }, {
    key: "getConversation",
    value: function getConversation() {
      return this.conversation;
    }
  }]);

  return ReceivedConversationInvitation;
}(_ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__.ReceivedInvitation);



/***/ }),

/***/ "./src/public/ReceivedConversationJoinRequest.js":
/*!*******************************************************!*\
  !*** ./src/public/ReceivedConversationJoinRequest.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReceivedConversationJoinRequest": () => (/* binding */ ReceivedConversationJoinRequest)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReceivedInvitation */ "./src/public/ReceivedInvitation.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.get('ReceivedInvitation');
/**
 * ReceivedConversationJoinRequest
 *
 * Defines an conversation join request received by this client (as a moderator)
 *  @extends ReceivedInvitation
 */

var ReceivedConversationJoinRequest = /*#__PURE__*/function (_ReceivedInvitation) {
  _inherits(ReceivedConversationJoinRequest, _ReceivedInvitation);

  var _super = _createSuper(ReceivedConversationJoinRequest);

  function ReceivedConversationJoinRequest(sender, conversation, id) {
    var _this;

    _classCallCheck(this, ReceivedConversationJoinRequest);

    _this = _super.call(this, sender, id);
    logger.info('Create ReceivedConversationJoinRequest');
    _this.type = 'conversationJoinRequest';

    if (conversation) {
      _this.conversation = conversation;
    } else {
      _this.conversation = null;
    }

    return _this;
  }
  /**
   * Returns the conversation associated to this request.
   *
   * @return {Conversation}
   */


  _createClass(ReceivedConversationJoinRequest, [{
    key: "getConversation",
    value: function getConversation() {
      return this.conversation;
    }
    /**
     * Accepts the join request & notifies sender
     *
     * @return {Promise}
     */

  }, {
    key: "accept",
    value: function accept() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (_this2.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          _this2.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ACCEPTED);

          if (_this2.conversation) {
            _this2.conversation.allowEntry(_this2.sender, {
              invitationId: _this2.id,
              answer: 'accept',
              ackEnabled: true
            }).then(resolve)["catch"](reject);
          } else {
            // Send notification to sender
            _this2.apiRTCManager.sendData(_this2.sender.getId(), {
              roomname: _this2.id,
              event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
              invitationId: _this2.id,
              answer: 'accept',
              //izeeconf compatibility
              command: 'access',
              value: {
                access: true
              }
            });

            resolve();
          }
        } else {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_INVITATION_STATE_INVALID, 'accept() - Cannot accept request, invitation state invalid', logger));
        }
      });
    }
    /**
     * Declines this invitation & notifies sender
     *
     * @return {Promise}
     */

  }, {
    key: "decline",
    value: function decline(reason) {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          _this3.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_DECLINED);

          if (_this3.conversation) {
            _this3.conversation.denyEntry(_this3.sender, {
              invitationId: _this3.id,
              answer: 'decline',
              reason: reason
            }).then(resolve)["catch"](reject);
          } else {
            // Send notification to sender
            _this3.apiRTCManager.sendData(_this3.sender.getId(), {
              roomname: _this3.id,
              event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
              invitationId: _this3.id,
              reason: reason,
              answer: 'decline',
              //izeeconf compatibility
              command: 'access',
              value: {
                access: false
              }
            });

            resolve();
          }
        } else {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_INVITATION_STATE_INVALID, 'decline() - Cannot decline request, invitation state invalid', logger));
        }
      });
    }
  }]);

  return ReceivedConversationJoinRequest;
}(_ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__.ReceivedInvitation);



/***/ }),

/***/ "./src/public/ReceivedDataChannelInvitation.js":
/*!*****************************************************!*\
  !*** ./src/public/ReceivedDataChannelInvitation.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReceivedDataChannelInvitation": () => (/* binding */ ReceivedDataChannelInvitation)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReceivedInvitation */ "./src/public/ReceivedInvitation.js");
/* harmony import */ var _DataChannel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DataChannel */ "./src/public/DataChannel.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_4__.Logger.get('ReceivedInvitation');
var RECEIVED_DATACHANNEL_INVITATION_EVENTS = ['expired', 'statusChange'];
/**
 * ReceivedDataChannelInvitation
 *
 * Defines an invitation received by this client for a call
 *  @extends ReceivedInvitation
 *  @fires ReceivedDataChannelInvitation#expired
 */

var ReceivedDataChannelInvitation = /*#__PURE__*/function (_ReceivedInvitation) {
  _inherits(ReceivedDataChannelInvitation, _ReceivedInvitation);

  var _super = _createSuper(ReceivedDataChannelInvitation);

  /**
   * When the call invitation has expired (eg. caller cancelled call)
   *
   * @event ReceivedDataChannelInvitation#expired
   * @type {Void}
   * @deprecated Please note that this event is now deprecated as we have added a statusChange event
   */
  function ReceivedDataChannelInvitation(sender, id) {
    var _this;

    _classCallCheck(this, ReceivedDataChannelInvitation);

    _this = _super.call(this, sender, id);
    logger.info('Create ReceivedDataChannelInvitation ');
    _this.type = 'dataChannel';

    _this.apiRTCManager.onEvent('hangup', function (e) {
      var callId = e.detail.callId.toString();

      if (_this.id.toString() === callId) {
        //In case caller hangs up before call has been accepted
        if (_this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          _this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_EXPIRED);

          _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('expired'); //DEPRECATED with statusChange event

        }
      }
    });

    return _this;
  }
  /**
   * Returns available events for this class
   *
   *  @returns {Array<string>}
   */


  _createClass(ReceivedDataChannelInvitation, [{
    key: "accept",
    value:
    /**
     * Accepts this invitation & notifies sender
     *
     *  @param {object} options
     *  @returns {Promise<DataChannel>} accepted DataChannel session in promise
     */
    function accept() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Promise(function (resolve, reject) {
        if (_this2.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          _this2.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ACCEPTED); //send notification to sender


          _this2.apiRTCManager.sendData(_this2.sender.getId(), {
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
            invitationId: _this2.id,
            answer: 'accept'
          });

          var call = new _DataChannel__WEBPACK_IMPORTED_MODULE_3__.DataChannel(_this2.id, _this2.sender, {
            started: true,
            type: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DATACHANNEL_TYPE_SEND
          }); //Accepting call without media

          var callConfiguration = {
            mediaTypeForIncomingCall: 'DATA'
          };

          _this2.apiRTCManager.webRTCClient.acceptCall(_this2.id, callConfiguration);

          resolve(call);
        } else {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_INVITATION_STATE_INVALID, 'accept() - Cannot join this datachannel session, invitation state invalid', logger));
        }
      });
    }
    /**
     * Declines this invitation & notifies sender
     *
     *  @returns {Void}
     */

  }, {
    key: "decline",
    value: function decline(reason) {
      if (this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
        this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_DECLINED); //send notification to sender

        this.apiRTCManager.sendData(this.sender.getId(), {
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
          invitationId: this.id,
          reason: reason,
          answer: 'decline'
        });
        this.apiRTCManager.webRTCClient.refuseCall(this.id);
      }
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return RECEIVED_DATACHANNEL_INVITATION_EVENTS;
    }
  }]);

  return ReceivedDataChannelInvitation;
}(_ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__.ReceivedInvitation);



/***/ }),

/***/ "./src/public/ReceivedFileTransferInvitation.js":
/*!******************************************************!*\
  !*** ./src/public/ReceivedFileTransferInvitation.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReceivedFileTransferInvitation": () => (/* binding */ ReceivedFileTransferInvitation)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReceivedInvitation */ "./src/public/ReceivedInvitation.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.get('ReceivedInvitation');
var RECEIVED_FILE_TRANSFER_INVITATION_EVENTS = ['error', 'progress', 'statusChange'];
/**
 * ReceivedFileTransferInvitation
 *
 * Defines an invitation received by this client for a call
 *  @extends ReceivedInvitation
 *  @fires ReceivedFileTransferInvitation#error
 *  @fires ReceivedFileTransferInvitation#progress
 */

var ReceivedFileTransferInvitation = /*#__PURE__*/function (_ReceivedInvitation) {
  _inherits(ReceivedFileTransferInvitation, _ReceivedInvitation);

  var _super = _createSuper(ReceivedFileTransferInvitation);

  /**
   * When an error occured during file transfer
   *
   * @event ReceivedFileTransferInvitation#error
   * @type {Error}
   */

  /**
   * Emitted periodically during file transfer and contains file transfer progression information
   *
   * @event ReceivedFileTransferInvitation#progress
   * @type {TransferInformation}
   */
  function ReceivedFileTransferInvitation(sender, id, fileInfo) {
    var _this;

    _classCallCheck(this, ReceivedFileTransferInvitation);

    _this = _super.call(this, sender, id);
    logger.debug('Create ReceivedFileTransferInvitation');
    _this.type = 'sendFile';
    _this.fileInfo = fileInfo;

    _this.apiRTCManager.onEvent('hangup', function (e) {
      logger.debug('hangup');
      var callId = e.detail.callId.toString();

      if (_this.getId() === callId) {
        logger.debug('hangup for ReceivedFileTransferInvitation');

        if (_this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ENDED) {
          logger.debug('invitation ended');
        } else {
          logger.debug('invitation is cancelled');

          _this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_CANCELLED);
        }

        if (apiRTC.userAgentInstance.currentSession.invitationsMap.has(e.detail.remoteId + '-sendfile-' + callId)) {
          apiRTC.userAgentInstance.currentSession.invitationsMap["delete"](e.detail.remoteId + '-sendfile-' + callId);
        }
      }
    });

    return _this;
  }
  /**
   * Returns available events for this class
   *
   *  @returns {Array<string>}
   */


  _createClass(ReceivedFileTransferInvitation, [{
    key: "accept",
    value:
    /**
     * Accepts this invitation & notifies sender
     *
     *  @returns {Promise<Object>} {file, name, type} received an object with file, file name and file type parameters in promise
     */
    function accept() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (_this2.getStatus() !== _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_INVITATION_STATE_INVALID, 'accept() - Cannot join this file transfer session, invitation state invalid', logger));
        } else {
          _this2.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ACCEPTED); //send notification to sender


          _this2.apiRTCManager.sendData(_this2.sender.getId(), {
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
            invitationId: _this2.id,
            answer: 'accept'
          });

          var self = _this2;

          var fileReceivedHandler = function fileReceivedHandler(e) {
            if (e.detail.callId.toString() === self.id.toString()) {
              logger.debug("typeof(e.detail.data.file) :", _typeof(e.detail.data.file));

              if (typeof e.detail.data.file === 'string') {
                resolve({
                  file: e.detail.data.file,
                  name: e.detail.data.name,
                  type: e.detail.data.type
                });
              } else {
                //TODO : ne faire que si type BLOB ??? voir les diffrents types de fichiers possible
                var reader = new FileReader();
                reader.addEventListener('loadend', function () {
                  _this2.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ENDED);

                  _this2.apiRTCManager.webRTCClient.hangUp(self.id.toString());

                  try {
                    logger.info('accept() - file received from ' + self.sender.getUsername() + ' !');
                    resolve({
                      file: e.detail.data.file,
                      name: e.detail.data.name,
                      type: e.detail.data.type
                    });
                  } catch (err) {
                    logger.error('File Error', err);
                    reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'accept() - Could not read file received', logger));
                  }
                });
                reader.readAsArrayBuffer(e.detail.data.file);
              }

              _this2.apiRTCManager.removeEventListener('onFileReceived', fileReceivedHandler);
            }
          };

          var fileProgressHandler = function fileProgressHandler(e) {
            if (e.detail.callId.toString() === self.id.toString()) {
              logger.trace('file transfering', e.detail);

              _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(self).emit('progress', {
                uuid: e.detail.uuid,
                fileSize: e.detail.fileSize,
                remainingSize: e.detail.remainingSize,
                percentage: e.detail.percentage,
                sendChunkNb: e.detail.sendChunkNb,
                transferDuration: e.detail.transferDuration,
                lastPacket: e.detail.lastPacket
              });
            }
          };

          _this2.apiRTCManager.onEvent('onFileReceived', fileReceivedHandler);

          _this2.apiRTCManager.onEvent('onFileProgress', fileProgressHandler);

          _this2.apiRTCManager.onEvent('receiveDataChannelError', function (e) {
            if (e.detail.callId.toString() === self.id.toString()) {
              logger.warn('receiveDataChannelError', e.detail);

              _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(self).emit('error', 'receiveDataChannelError');
            }
          }); //Accepting call without media


          var callConfiguration = {
            mediaTypeForIncomingCall: 'DATA'
          };

          _this2.apiRTCManager.webRTCClient.acceptCall(_this2.id, callConfiguration);
        }
      });
    }
    /**
     * Returns file information
     *
     *  @returns {FileInfo}
     */

  }, {
    key: "getFileInfo",
    value: function getFileInfo() {
      return this.fileInfo;
    }
    /**
     * Declines this invitation & notifies sender
     *
     *  @returns {Void}
     */

  }, {
    key: "decline",
    value: function decline(reason) {
      logger.log('decline');

      if (this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
        this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_DECLINED); //send notification to sender

        this.apiRTCManager.sendData(this.sender.getId(), {
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
          invitationId: this.id,
          reason: reason,
          answer: 'decline'
        });
        this.apiRTCManager.webRTCClient.refuseCall(this.id);
      }
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return RECEIVED_FILE_TRANSFER_INVITATION_EVENTS;
    }
  }]);

  return ReceivedFileTransferInvitation;
}(_ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__.ReceivedInvitation);



/***/ }),

/***/ "./src/public/ReceivedInvitation.js":
/*!******************************************!*\
  !*** ./src/public/ReceivedInvitation.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReceivedInvitation": () => (/* binding */ ReceivedInvitation),
/* harmony export */   "_eventEmitter": () => (/* reexport safe */ _Invitation__WEBPACK_IMPORTED_MODULE_0__._eventEmitter),
/* harmony export */   "_status": () => (/* reexport safe */ _Invitation__WEBPACK_IMPORTED_MODULE_0__._status)
/* harmony export */ });
/* harmony import */ var _Invitation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Invitation */ "./src/public/Invitation.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_1__.Logger.get('ReceivedInvitation');
/**
 * ReceivedInvitation
 * Defines an invitation received by this client
 * @abstract
 * @fires ReceivedInvitation#statusChange
 * @extends Observable
 */

var ReceivedInvitation = /*#__PURE__*/function (_Invitation) {
  _inherits(ReceivedInvitation, _Invitation);

  var _super = _createSuper(ReceivedInvitation);

  /**
   * Emitted invitation status change
   *
   * @event ReceivedInvitation#statusChange
   * @type {StatusChangeInfo}
   */
  function ReceivedInvitation(sender, id) {
    var _this;

    _classCallCheck(this, ReceivedInvitation);

    _this = _super.call(this);
    _this.id = id;
    _this.sender = sender;
    _this.receiveTime = Date.now();
    return _this;
  }
  /**
   * Accepts this invitation & notifies sender
   *
   *  @returns {Promise<any>}
   */


  _createClass(ReceivedInvitation, [{
    key: "accept",
    value: function accept() {
      return new Promise();
    }
    /**
     * Declines this invitation & notifies sender
     *  @param {string} reason
     *  @returns {Void}
     */

  }, {
    key: "decline",
    value: function decline(reason) {}
    /**
     * Returns invitation / request sender
     *
     *  @returns {Contact}
     */

  }, {
    key: "getSender",
    value: function getSender() {
      return this.sender;
    }
    /**
     * Returns invitation receive time
     *
     *  @returns {Date}
     */

  }, {
    key: "getReceiveTime",
    value: function getReceiveTime() {
      return this.receiveTime;
    }
    /**
     * Returns invitation id
     *
     *  @returns {string}
     */

  }, {
    key: "getId",
    value: function getId() {
      return this.id;
    }
  }]);

  return ReceivedInvitation;
}(_Invitation__WEBPACK_IMPORTED_MODULE_0__.Invitation);



/***/ }),

/***/ "./src/public/ReceivedPointerSharingInvitation.js":
/*!********************************************************!*\
  !*** ./src/public/ReceivedPointerSharingInvitation.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReceivedPointerSharingInvitation": () => (/* binding */ ReceivedPointerSharingInvitation)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReceivedInvitation */ "./src/public/ReceivedInvitation.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.get('ReceivedInvitation');
/**
 * ReceivedPointerSharingInvitation
 *
 * Defines an invitation received by this client for a call
 * @extends ReceivedInvitation
 */

var ReceivedPointerSharingInvitation = /*#__PURE__*/function (_ReceivedInvitation) {
  _inherits(ReceivedPointerSharingInvitation, _ReceivedInvitation);

  var _super = _createSuper(ReceivedPointerSharingInvitation);

  function ReceivedPointerSharingInvitation(sender, id, session) {
    var _this;

    _classCallCheck(this, ReceivedPointerSharingInvitation);

    _this = _super.call(this, sender, id);
    _this.session = session;
    _this.type = 'pointerSharing';
    return _this;
  }
  /**
   * Accepts this invitation by joining pointer sharing room.
   *
   * @return {Promise<PointerSharingRoom>}
   */


  _createClass(ReceivedPointerSharingInvitation, [{
    key: "accept",
    value: function accept() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (_this2.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          _this2.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ACCEPTED);

          _this2.session.joinPointerSharingRoom(_this2.id).then(resolve)["catch"](function (err) {
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'accept() - cannot accept invitation', logger));
          });
        } else {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_INVITATION_STATE_INVALID, 'accept() - cannot accept invitation', logger));
        }
      });
    }
    /**
     * Declines this invitation & notifies sender
     *
     * @return {Void}
     */

  }, {
    key: "decline",
    value: function decline(reason) {
      if (this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
        this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_DECLINED);
      }
    }
  }]);

  return ReceivedPointerSharingInvitation;
}(_ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__.ReceivedInvitation);



/***/ }),

/***/ "./src/public/ReceivedRemoteControlInvitation.js":
/*!*******************************************************!*\
  !*** ./src/public/ReceivedRemoteControlInvitation.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReceivedRemoteControlInvitation": () => (/* binding */ ReceivedRemoteControlInvitation)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReceivedInvitation */ "./src/public/ReceivedInvitation.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_2__.Logger.get('ReceivedInvitation');
/**
 * ReceivedRemoteControlInvitation
 *
 * Defines an invitation received by this client for a call
 *  @extends ReceivedInvitation
 */

var ReceivedRemoteControlInvitation = /*#__PURE__*/function (_ReceivedInvitation) {
  _inherits(ReceivedRemoteControlInvitation, _ReceivedInvitation);

  var _super = _createSuper(ReceivedRemoteControlInvitation);

  function ReceivedRemoteControlInvitation(sender, id) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, ReceivedRemoteControlInvitation);

    _this = _super.call(this, sender, id);
    logger.info('Create ReceivedRemoteControlInvitation');
    _this.type = 'remote control';

    if (options.cloudConvId) {
      _this.cloudConvId = options.cloudConvId;
    }

    if (options.webconf === true) {
      _this.webconf = true;
    }

    return _this;
  }
  /**
   * Accepts this invitation & notifies sender
   *
   *  @returns {Promise<string>} roomId in promise
   */


  _createClass(ReceivedRemoteControlInvitation, [{
    key: "accept",
    value: function accept() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (_this2.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          _this2.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ACCEPTED);

          resolve(_this2.id);
        } else {
          reject(Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_INVITATION_STATE_INVALID, 'accept() - Cannot acccept remote control, invitation state invalid', logger));
        }
      });
    }
    /**
     * Declines this invitation & notifies sender
     *
     *  @returns {Void}
     */

  }, {
    key: "decline",
    value: function decline(reason) {
      if (this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
        this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_DECLINED);
      }
    }
  }]);

  return ReceivedRemoteControlInvitation;
}(_ReceivedInvitation__WEBPACK_IMPORTED_MODULE_1__.ReceivedInvitation);



/***/ }),

/***/ "./src/public/ReceivedWhiteboardInvitation.js":
/*!****************************************************!*\
  !*** ./src/public/ReceivedWhiteboardInvitation.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReceivedWhiteboardInvitation": () => (/* binding */ ReceivedWhiteboardInvitation)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReceivedInvitation */ "./src/public/ReceivedInvitation.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.get('ReceivedInvitation');
/**
 * ReceivedWhiteboardInvitation
 *
 * Defines an invitation received by this client for a call
 *  @extends ReceivedInvitation
 */

var ReceivedWhiteboardInvitation = /*#__PURE__*/function (_ReceivedInvitation) {
  _inherits(ReceivedWhiteboardInvitation, _ReceivedInvitation);

  var _super = _createSuper(ReceivedWhiteboardInvitation);

  function ReceivedWhiteboardInvitation(sender, id) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, ReceivedWhiteboardInvitation);

    _this = _super.call(this, sender, id);
    logger.info('Create ReceivedWhiteboardInvitation');
    _this.type = 'whiteboard';

    if (options.cloudConvId) {
      _this.cloudConvId = options.cloudConvId;
    }

    if (options.webconf === true) {
      _this.webconf = true;
    }

    return _this;
  }
  /**
   * Accepts this invitation & notifies sender
   *
   *  @returns {Promise<string>} roomId in promise
   */


  _createClass(ReceivedWhiteboardInvitation, [{
    key: "accept",
    value: function accept() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (_this2.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          _this2.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ACCEPTED); //send notification to sender


          _this2.apiRTCManager.sendData(_this2.sender.getId(), {
            event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
            invitationId: 'wb-' + _this2.id,
            answer: 'accept'
          });

          _this2.apiRTCManager.whiteBoardClient.leaveRoom();

          _this2.apiRTCManager.whiteBoardClient.start();

          var joinOpts = {};

          if (_this2.cloudConvId) {
            joinOpts.convId = _this2.cloudConvId;
          }

          if (_this2.webconf === true) {
            joinOpts.webconf = true;
          }

          _this2.apiRTCManager.whiteBoardClient.joinRoom(_this2.id, joinOpts);

          resolve(_this2.id);
        } else {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_INVITATION_STATE_INVALID, 'accept() - Cannot join this whiteboard session, invitation state invalid', logger));
        }
      });
    }
    /**
     * Declines this invitation & notifies sender
     *
     *  @returns {Void}
     */

  }, {
    key: "decline",
    value: function decline(reason) {
      if (this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
        this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_DECLINED); //send notification to sender

        this.apiRTCManager.sendData(this.sender.getId(), {
          event: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER,
          invitationId: 'wb-' + this.id,
          reason: reason,
          answer: 'decline'
        });
      }
    }
  }]);

  return ReceivedWhiteboardInvitation;
}(_ReceivedInvitation__WEBPACK_IMPORTED_MODULE_2__.ReceivedInvitation);



/***/ }),

/***/ "./src/public/SentInvitation.js":
/*!**************************************!*\
  !*** ./src/public/SentInvitation.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SentInvitation": () => (/* binding */ SentInvitation)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _Invitation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Invitation */ "./src/public/Invitation.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



 //import {ApiRTCManager} from '../private/ApiRTCManager';


var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_3__.Logger.get('SentInvitation'); //const apiRTCManager = ApiRTCManager.get();

var SENT_INVITATION_EVENTS = ['response', 'receive', 'statusChange'];
/**
 * SentInvitation
 *
 * Defines an invitation sent by this client
 *
 * @extends Invitation
 * @fires SentInvitation#response
 * @fires SentInvitation#receive
 * @fires SentInvitation#statusChange
 *
 */

var SentInvitation = /*#__PURE__*/function (_Invitation) {
  _inherits(SentInvitation, _Invitation);

  var _super = _createSuper(SentInvitation);

  /**
   * When the invitation status changed
   *
   * @event SentInvitation#response
   * @type {symbol}
   * @deprecated Please note that this event is now deprecated as we have added a statusChange event
   */

  /**
   * When the invitation has been received by the contact
   *
   * @event SentInvitation#receive
   * @type {Void}
   */

  /**
   * Emitted invitation status change
   *
   * @event SentInvitation#statusChange
   * @type {StatusChangeInfo}
   */

  /**
   * @param {Contact|null} destination
   * @param {Conversation} conversation
   * @param {object} options
   */
  function SentInvitation(destination, conversation) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, SentInvitation);

    _this = _super.call(this);
    _this.conversation = conversation;
    logger.info('Create SentInvitation');
    _this.destination = destination;
    _this.id = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.guid();
    _this.sendTime = Date.now();
    _this.expirationTime = null;
    _this.expirationTimeout = null;

    if (options.hasOwnProperty('expirationTime')) {
      _this.expirationTime = options.expirationTime; //when invitation expired

      _this.expirationTimeout = setTimeout(function () {
        if (_this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          logger.info('Conversation invitation expired');

          _this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_EXPIRED);

          _Invitation__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('response', _this.getStatus()); //DEPRECATED with statusChange event

        }
      }, options.expirationTime);
    } //receive event propagation


    if (options.hasOwnProperty('receiveNotifier')) {
      options.receiveNotifier.on('receive', function () {
        _Invitation__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('receive');
      });
    } //let delete listener if invitation was answered


    _this.apiRTCManager.onEvent('receiveData', function (e) {
      if (typeof e.detail.data.event !== 'undefined') {
        if (e.detail.data.event === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER && e.detail.data.invitationId.toString() === _this.id.toString() && _this.getStatus() === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY) {
          logger.info('Received invitation answer for ' + _this.id, e.detail.data);

          if (_this.expirationTimeout !== null) {
            clearTimeout(_this.expirationTimeout);
          }

          if (e.detail.data.answer === 'accept') {
            _this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ACCEPTED);
          } else {
            _this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_DECLINED);
          }

          _Invitation__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('response', _this.getStatus()); //DEPRECATED with statusChange event

        }
      }
    });

    _this.apiRTCManager.onEvent('hangup', function (e) {
      logger.debug('hangup');
      var callId = e.detail.callId.toString();

      if (_this.getId() === callId) {
        logger.debug('hangup for sentInvitation');

        _this.setStatus(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_ENDED);
      }
    });

    return _this;
  }
  /**
   * Returns available events for this class
   *
   *  @returns {Array<string>}
   */


  _createClass(SentInvitation, [{
    key: "getId",
    value:
    /**
     * Returns Invitation's id
     *
     *  @returns {string} Invitation id
     */
    function getId() {
      return this.id;
    }
    /**
     * Adds a listener called when the Sent invitation has been answered or has expired
     *
     *  @returns {Void}
     */

  }, {
    key: "onResponse",
    value: function onResponse(listener) {
      this.on('response', listener);
    }
    /**
     * Cancel the ongoing invitation
     *
     *  @returns {Void}
     */

  }, {
    key: "cancel",
    value: function cancel() {
      logger.info('cancel');

      if (this.type === 'sendFile') {
        logger.info('cancel sendfile');
        this.apiRTCManager.webRTCClient.hangUp(this.id);
      } else {
        logger.warn('cancel is not managed for invitation with type :', this.type);
      }
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return SENT_INVITATION_EVENTS;
    }
  }]);

  return SentInvitation;
}(_Invitation__WEBPACK_IMPORTED_MODULE_2__.Invitation);



/***/ }),

/***/ "./src/public/Session.js":
/*!*******************************!*\
  !*** ./src/public/Session.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PointerSharingRoom": () => (/* binding */ PointerSharingRoom),
/* harmony export */   "Session": () => (/* binding */ Session)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _utils_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Observable */ "./src/utils/Observable.js");
/* harmony import */ var _ReceivedConversationInvitation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ReceivedConversationInvitation */ "./src/public/ReceivedConversationInvitation.js");
/* harmony import */ var _ReceivedCallInvitation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ReceivedCallInvitation */ "./src/public/ReceivedCallInvitation.js");
/* harmony import */ var _ReceivedFileTransferInvitation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ReceivedFileTransferInvitation */ "./src/public/ReceivedFileTransferInvitation.js");
/* harmony import */ var _ReceivedWhiteboardInvitation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ReceivedWhiteboardInvitation */ "./src/public/ReceivedWhiteboardInvitation.js");
/* harmony import */ var _ReceivedDataChannelInvitation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ReceivedDataChannelInvitation */ "./src/public/ReceivedDataChannelInvitation.js");
/* harmony import */ var _ReceivedConversationJoinRequest__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ReceivedConversationJoinRequest */ "./src/public/ReceivedConversationJoinRequest.js");
/* harmony import */ var _ReceivedPointerSharingInvitation__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ReceivedPointerSharingInvitation */ "./src/public/ReceivedPointerSharingInvitation.js");
/* harmony import */ var _Core_AicConsoleManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Core/AicConsoleManager */ "./src/Core/AicConsoleManager.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../private/ApiRTCManager */ "./src/private/ApiRTCManager.js");
/* harmony import */ var _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @apizee/cloudapi-js-sdk/CloudAPI */ "./node_modules/@apizee/cloudapi-js-sdk/CloudAPI.js");
/* harmony import */ var _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../private/ConversationCatalog */ "./src/private/ConversationCatalog.js");
/* harmony import */ var _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../private/ContactCatalog */ "./src/private/ContactCatalog.js");
/* harmony import */ var _private_CallCatalog__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../private/CallCatalog */ "./src/private/CallCatalog.js");
/* harmony import */ var _UserData__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./UserData */ "./src/public/UserData.js");
/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Stream */ "./src/public/Stream.js");
/* harmony import */ var _ReceivedRemoteControlInvitation__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./ReceivedRemoteControlInvitation */ "./src/public/ReceivedRemoteControlInvitation.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* globals apiCC */




















var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_11__.Logger.get('Session');
var apiRTCManager = _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_12__.ApiRTCManager.get();
var cloudApi = new _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_13__["default"]();
var callCatalog = _private_CallCatalog__WEBPACK_IMPORTED_MODULE_16__.CallCatalog.get();
var SESSION_EVENTS = ['rawData', 'whiteboardInvitation', 'fileTransferInvitation', 'conversationMessage', 'conversationData', 'dataChannelInvitation', 'contactMessage', 'contactData', 'customEvent', 'conversationInvitation', 'incomingCall', 'disconnect', 'error', 'contactListUpdate', 'reconnecting', 'reconnection', 'conversationJoinRequest', 'newMediaAvailableFromContact', 'whiteboardRoomMemberUpdate', 'incomingScreenSharingCall', 'pointerSharingInvitation', 'pointerLocationChanged', 'incomingScreenSharingCallInvitation', 'cloudEventOccurred', 'remoteAppMessage', 'remoteControlInvitation'];

var _ua = new WeakMap();

var _updatePresenceRoutine = new WeakMap();

var activeSession = null;
var UPDATE_PRESENCE_INTERVAL = 30000;

var _apiRTCEventListeners = new WeakMap();

var _pointerSharingRooms = new WeakMap();
/**
 * Session represent the connected environment of an UA.
 * It's created after UA registration.
 *
 * @extends Observable
 * @fires Session#conversationMessage
 * @fires Session#conversationData
 * @fires Session#contactMessage
 * @fires Session#contactData
 * @fires Session#rawData
 * @fires Session#conversationInvitation
 * @fires Session#incomingCall
 * @fires Session#disconnect
 * @fires Session#error
 * @fires Session#reconnection
 * @fires Session#reconnecting
 * @fires Session#contactListUpdate
 * @fires Session#conversationJoinRequest
 * @fires Session#whiteboardInvitation
 * @fires Session#whiteboardRoomMemberUpdate
 * @fires Session#fileTransferInvitation
 * @fires Session#dataChannelInvitation
 * @fires Session#newMediaAvailableFromContact
 * @fires Session#customEvent
 * @fires Session#incomingScreenSharingCall
 * @fires Session#pointerSharingInvitation
 * @fires Session#pointerLocationChanged
 * @fires Session#incomingScreenSharingCallInvitation
 * @fires Session#cloudEventOccurred
 * @fires Session#remoteControlInvitation
 */
//  @fires Session#disconnectionWarning


var Session = /*#__PURE__*/function (_Observable) {
  _inherits(Session, _Observable);

  var _super = _createSuper(Session);

  /**
   * Fired when a conversation message is received
   *
   * @event Session#conversationMessage
   * @type {object}
   * @property {Contact} sender
   * @property {string} content - content of the message
   * @property {Conversation} conversation
   */

  /**
   * Fired when conversation data is received
   *
   * @event Session#conversationData
   * @type {object}
   * @property {Contact} sender
   * @property {Conversation} conversation
   * @property {object} content
   */

  /**
   * Fired when a message is received from a contact
   *
   * @event Session#contactMessage
   * @type {object}
   * @property {Contact} sender
   * @property {string} content - content of the message
   * @property {integer} uuid - message unique id
   * @property {date} time - date of when the message was received
   */

  /**
   * Fired when data is received from a contact
   *
   * @event Session#contactData
   * @type {object}
   * @property {Contact} sender
   * @property {object} content
   */

  /**
   * Fired when raw data is received from a contact (for older apiRTC app compatibility)
   *
   * @event Session#rawData
   * @type {object}
   * @property {Contact} sender
   * @property {object} content
   */

  /**
   * Fired when a conversation invitation is received
   *
   * @event Session#conversationInvitation
   * @type {ReceivedConversationInvitation}
   */

  /**
   * Fired when user receives an incoming call
   *
   * @event Session#incomingCall
   * @type {ReceivedCallInvitation}
   */

  /**
   * Fired when user receives an incoming screenSharing call
   *
   * @event Session#incomingScreenSharingCall
   * @type {Call}
   */

  /**
   * Fired when user receives an incoming screenSharing call Invitation
   *
   * @event Session#incomingScreenSharingCallInvitation
   * @type {ReceivedCallInvitation}
   */

  /**
   * Fired when a whiteboard session invitation is received
   *
   * @event Session#whiteboardInvitation
   * @type {ReceivedWhiteboardInvitation}
   */

  /**
   * Fired when a pointer sharing invitation is received
   *
   * @event Session#pointerSharingInvitation
   * @type {ReceivedPointerSharingInvitation}
   */

  /**
   * Fired when the pointer location changed for a contact.
   *
   * @event Session#pointerLocationChanged
   * @type {object}
   * @property {Contact} sender
   * @property {object} source
   * @property {number} x
   * @property {number} y
   * @property {object} data
   */

  /**
   * Fired when a member connect or disconnect from whiteboard room
   *
   * @event Session#whiteboardRoomMemberUpdate
   * @type {object}
   * @property {string} roomId event identifier
   * @property {string} status online / offline
   * @property {Contact[]} contacts contacts updated
   */

  /**
   * Fired when a file transfer invitation is received
   *
   * @event Session#fileTransferInvitation
   * @type {ReceivedFileTransferInvitation}
   */

  /**
   * Fired when a data channel invitation is received
   *
   * @event Session#dataChannelInvitation
   * @type {ReceivedDataChannelInvitation}
   */

  /**
   * Fired when a conversation join request is received
   * This event is fired only if the user is the moderator from the conversation
   *
   * @event Session#conversationJoinRequest
   * @type {ReceivedConversationJoinRequest}
   */

  /*
   * Fired when connectivity to the network has been lost
   *
   * @event Session#disconnectionWarning
   * @type {Void}
   */

  /**
   * Fired on disconnection with CCS server
   *
   * @event Session#disconnect
   * @type {Void}
   */

  /**
   * Fired when an error is detected on connection with CCS server
   *
   * @event Session#error
   * @type {Void}
   */

  /**
   * Fired when connectivity to the network has been recovered
   *
   * @event Session#reconnection
   * @type {Void}
   */

  /**
   * Fired when a new connection to server is tried
   *
   * @event Session#reconnecting
   * @type {Void}
   */

  /**
   * Fired when a custom data event has been received
   *
   * @event Session#customEvent
   * @type {object}
   * @property {string} event event identifier
   * @property {object} content
   * @property {Contact} sender
   * @property {Conversation} conversation Associated conversation, field may not be present
   */

  /**
   * Fired when the contact list has been updated
   * The contact list is updated when a contact leaves a group, joins a group or if its user data changed
   *
   * @event Session#contactListUpdate
   * @type {object}
   * @property {Object<string, Contact[]>} leftGroup - Contacts who left a group mapped by group
   * @property {Object<string, Contact[]>} joinedGroup - Contacts who joined a group mapped by group
   * @property {Contact[]} userDataChanged - Contacts whose userdata changed
   */

  /**
   * Fired when a new media is available from a contact
   *
   * @event Session#newMediaAvailableFromContact
   * @type {object}
   * @property {Contact} sender
   * @property {CloudMediaInfo} media
   */

  /**
   * fired when a remote control invitation is sended from a contact
   * 
   * @event Session#remoteControlInvitation
   * @type {ReceivedRemoteControlInvitation}
   */

  /*
   * @event Session#cloudEventOccurred
   * @type {object}
   * @property {string} topic
   * @property {object} target
   */
  function Session(ua) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Session);

    _this = _super.call(this, logger);
    logger.debug('Create Session');
    _this.id = null;
    _this.token = null; // ApiRTC Cloud Token

    _this.ccsToken = null; // Token when using CCS JSON Token authentication

    _ua.set(_assertThisInitialized(_this), ua);

    _updatePresenceRoutine.set(_assertThisInitialized(_this), null);

    _pointerSharingRooms.set(_assertThisInitialized(_this), {});

    _this.isRecording = false;
    _this.userData = new _UserData__WEBPACK_IMPORTED_MODULE_17__.UserData();
    _this.contactListUpdateListenerSetted = false; //Indicate if a listener exist for contactListUpdate

    _this.waitingContactListUpdateEvent = []; //used to stored contactListUpdate events when no listerner is setted

    _this.remoteControlActive = false; //Link apiRTC events used by this class

    var contactCatalog = _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_15__.ContactCatalog.get();
    var conversationCatalog = _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_14__.ConversationCatalog.get();
    var apiRTCEventListeners = {}; // Contain all invitations

    _this.invitationsMap = new Map(); //Key is senderId + invitationType + callId (callId is necessary in case with simultaneous file transfers)

    apiRTCEventListeners.channelEvent = function (e) {
      switch (e.detail.channelEvent) {
        case 'onChannelReconnecting':
          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('reconnecting', e);

          break;

        case 'onChannelReconnect':
          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('reconnection', e);

          break;

        case 'onChannelError':
          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('error', e);

          break;

        case 'onChannelDisconnect':
          logger.error('Session :: onChannelDisconnect');

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('disconnect', e);

          break;
      }
    };

    apiRTCEventListeners.incomingCall = function (e) {
      var contact = contactCatalog.getOrCreateContact(e.detail.callerId);
      var callId = e.detail.callId.toString();

      if (e.detail.callType === 'data') {
        logger.info('Received file transfer invitation from ' + contact.getUsername()); // Make sure data call information has been received from the contact beforehand
        // Otherwise set the data call on hold

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsFileInfo.has(callId)) {
          var fileInfo = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsFileInfo.get(callId);

          var invitation = null;

          if (_this.invitationsMap.has(e.detail.callerId + '-sendfile-' + callId)) {
            invitation = _this.invitationsMap.get(e.detail.callerId + '-sendfile-' + callId);
            logger.debug('invitation already exist :', invitation);
          } else {
            invitation = new _ReceivedFileTransferInvitation__WEBPACK_IMPORTED_MODULE_5__.ReceivedFileTransferInvitation(contact, callId, fileInfo);

            _this.invitationsMap.set(e.detail.callerId + '-sendfile-' + callId, invitation);
          }

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('fileTransferInvitation', invitation);
        } else if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataChannelInvitations.has(callId)) {
          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('dataChannelInvitation', new _ReceivedDataChannelInvitation__WEBPACK_IMPORTED_MODULE_7__.ReceivedDataChannelInvitation(contact, callId));
        } else {
          logger.debug('File information has not been received yet, putting invitation on hold');

          _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsOnHold.set(callId);
        }
      } else if (e.detail.callType === 'screenSharing') {
        if (apiRTC.session.apiCCWebRTCClient.webRTCClient.userAcceptOnIncomingScreenSharingCall === true) {
          logger.debug('Received screenSharingCallInvitation from ' + contact.getUsername());

          var _invitation = new _ReceivedCallInvitation__WEBPACK_IMPORTED_MODULE_4__.ReceivedCallInvitation(contact, callId, e.detail.callType, {
            isRecorded: e.detail.hasOwnProperty('recordedCall') ? e.detail.recordedCall : false
          });

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('incomingScreenSharingCallInvitation', _invitation);
        } else {
          logger.debug('Received screenSharingCall from ' + contact.getUsername());
          var call = callCatalog.getOrCreateCall(callId, contact, {
            started: true,
            isRecorded: e.detail.hasOwnProperty('recordedCall') ? e.detail.recordedCall : false
          });

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('incomingScreenSharingCall', call);
        }
      } else {
        logger.info('Received call invitation from ' + contact.getUsername());

        var _invitation2 = new _ReceivedCallInvitation__WEBPACK_IMPORTED_MODULE_4__.ReceivedCallInvitation(contact, callId, e.detail.callType, {
          isRecorded: e.detail.hasOwnProperty('recordedCall') ? e.detail.recordedCall : false
        });

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('incomingCall', _invitation2);
      }
    };

    apiRTCEventListeners.roomInvitation = function (e) {
      var contact = contactCatalog.getOrCreateContact(e.detail.senderId);

      if (e.detail.roomType === 'whiteBoard') {
        if (contact !== null) {
          logger.info('Received whiteboard invitation from ' + contact.getUsername());
          var invitationOpts = {};

          if (e.detail.cloudConvId) {
            invitationOpts.cloudConvId = e.detail.cloudConvId;
          }

          if (e.detail.webconf === true) {
            invitationOpts.webconf = true;
          }

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('whiteboardInvitation', new _ReceivedWhiteboardInvitation__WEBPACK_IMPORTED_MODULE_6__.ReceivedWhiteboardInvitation(contact, e.detail.roomId, invitationOpts));
        }
      } else if (e.detail.roomType === 'pointerSharing') {
        if (contact !== null && !conversationCatalog.getConversations().has(e.detail.roomId) && !conversationCatalog.getConferences().has(e.detail.roomId)) {
          logger.info('Received pointer sharing invitation from ' + contact.getUsername());

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('pointerSharingInvitation', new _ReceivedPointerSharingInvitation__WEBPACK_IMPORTED_MODULE_9__.ReceivedPointerSharingInvitation(contact, e.detail.roomId, _assertThisInitialized(_this)));
        }
      }
    };

    apiRTCEventListeners.roomMemberUpdate = function (e) {
      var contacts = [];

      var _iterator = _createForOfIteratorHelper(e.detail.contactList),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var c = _step.value;
          contacts.push(contactCatalog.getOrCreateContact(c.contactId));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (e.detail.roomType === 'whiteBoard') {
        logger.info('Received whiteboard room member update');

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('whiteboardRoomMemberUpdate', {
          contacts: contacts,
          roomId: e.detail.roomId,
          status: e.detail.status
        });
      }
    };

    apiRTCEventListeners.receiveRoomMessage = function (e) {
      logger.debug('receiveRoomMessage', e);

      if (e.detail.roomType === 'pointerSharing' && e.detail.message.type === 'pointerLocation' && _pointerSharingRooms.get(_assertThisInitialized(_this)).hasOwnProperty(e.detail.roomId)) {
        var sender = contactCatalog.getOrCreateContact(e.detail.senderId);
        var pointerLocationChanged = {
          sender: sender,
          source: e.detail.message.source,
          x: e.detail.message.x,
          y: e.detail.message.y
        };

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(e.detail.message, 'data', 'object')) {
          pointerLocationChanged.data = e.detail.message.data;
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('pointerLocationChanged', pointerLocationChanged);
      }
    };

    apiRTCEventListeners.receiveIMMessage = function (e) {
      var contact = contactCatalog.getOrCreateContact(e.detail.senderId);
      logger.debug('Received IM from ' + contact.getUsername() + ' : ', e.detail.message);

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('contactMessage', {
        sender: contact,
        content: e.detail.message,
        uuid: e.detail.UUCSeq,
        time: e.detail.time
      });
    };

    apiRTCEventListeners.receiveData = function (e) {
      var sender = contactCatalog.getOrCreateContact(e.detail.senderId);
      var data = e.detail.data;
      var conversation = null;

      if (typeof data.roomname !== 'undefined') {
        if (conversationCatalog.isConference(data.roomname)) {
          conversation = conversationCatalog.getOrCreateConference(conversationCatalog.getNameFromTechnicalName(data.roomname));
        } else {
          conversation = conversationCatalog.getOrCreateConversation(conversationCatalog.getNameFromTechnicalName(data.roomname));
        }
      }

      logger.trace('Received data from ' + sender.getId(), e.detail);

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('rawData', {
        //for older apps using apiRTC compatibility
        sender: sender,
        content: data
      });

      if (typeof data.event !== 'undefined') {
        switch (data.event) {
          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_ANSWER_IDENTIFIER:
          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_PERSISTENT_DATA_UPDATE_IDENTIFIER:
            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_DATA_IDENTIFIER:
            logger.debug('Received contact data from ' + sender.getUsername(), data.content);

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('contactData', {
              sender: sender,
              content: data.content
            });

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_REMOTE_CONNECTION_APP:
            console.log(_this.remoteControlActive);

            if (_this.remoteControlActive == false) {
              _this.remoteControlActive = true;
              logger.debug('Received remote app data from ' + sender.getUsername(), data.content);
              var remoteControlInvitation = new _ReceivedRemoteControlInvitation__WEBPACK_IMPORTED_MODULE_19__.ReceivedRemoteControlInvitation(data.contactID, data.convName, _assertThisInitialized(_this));
              console.log(remoteControlInvitation.getStatus());

              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('remoteControlInvitation', remoteControlInvitation);

              console.log(remoteControlInvitation.getStatus());

              if (remoteControlInvitation.getStatus() == _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_STANDBY || remoteControlInvitation.getStatus() == _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.INVITATION_STATUS_DECLINED) {
                console.log("Prise de contrle  distance refuse");
              } else {
                _this.remoteControlAppManage(data);
              }
            }

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_REMOTE_CONNECTION_APP_CALLBACK:
            logger.debug('Received remote app callback data from ' + sender.getUsername(), data.content);

            _this.remoteControlAppManageCallback(data);

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_DATA_COMMAND:
            logger.debug('Receive data command');

            _this.remoteControlDataCommand(data);

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_DATA_IDENTIFIER:
            if (typeof data.roomname !== 'undefined') {
              logger.debug('Received conversation data from ' + sender.getUsername(), data.content);

              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('conversationData', {
                sender: sender,
                conversation: conversation,
                content: data.content
              });
            } else {
              console.log("Room name undefined");
            }

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_NEW_MEDIA_IDENTIFIER:
            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('newMediaAvailableFromContact', {
              sender: sender,
              media: data.media
            });

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_DATACHANNEL_INVITATION:
            logger.debug('Received datachannel invitation from ' + sender.getUsername());

            _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataChannelInvitations.set(data.callId.toString(), true);

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsOnHold.has(data.callId.toString())) {
              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('dataChannelInvitation', new _ReceivedDataChannelInvitation__WEBPACK_IMPORTED_MODULE_7__.ReceivedDataChannelInvitation(sender, data.callId.toString()));
            }

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_SEND_FILEINFO_IDENTIFIER:
            logger.debug('Received file info from ' + sender.getUsername(), data.fileInfo);
            var callId = data.callId.toString();

            _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsFileInfo.set(callId, data.fileInfo);

            if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc._private.dataCallsOnHold.has(callId)) {
              var invitation = null;

              if (_this.invitationsMap.has(sender.getId() + '-sendfile-' + callId)) {
                invitation = _this.invitationsMap.get(sender.getId() + '-sendfile-' + callId);
                logger.debug('invitation already exist :', invitation);
              } else {
                invitation = new _ReceivedFileTransferInvitation__WEBPACK_IMPORTED_MODULE_5__.ReceivedFileTransferInvitation(sender, callId, data.fileInfo);

                _this.invitationsMap.set(e.detail.callerId + '-sendfile-' + callId, invitation);
              }

              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('fileTransferInvitation', invitation);
            } else {
              logger.debug('no dataCallsOnHold');
            }

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_INVITATION_IDENTIFIER:
            if (typeof data.roomname !== 'undefined') {
              logger.info('Received conversation invitation from ' + sender.getUsername());
              var _options = {
                session: _assertThisInitialized(_this)
              };

              if (data.hasOwnProperty('password')) {
                _options.password = data.password;
              }

              if (conversation) {
                if (data.hasOwnProperty('friendlyName') && conversation.name === conversation.friendlyName) {
                  conversation.friendlyName = data.friendlyName;
                }

                _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('conversationInvitation', new _ReceivedConversationInvitation__WEBPACK_IMPORTED_MODULE_3__.ReceivedConversationInvitation(sender, data, conversation, _options));
              } else {
                _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('conversationInvitation', new _ReceivedConversationInvitation__WEBPACK_IMPORTED_MODULE_3__.ReceivedConversationInvitation(sender, data, null, _options));
              }
            }

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_JOIN_REQUEST_IDENTIFIER:
            logger.info('Received conversation join request from ' + sender.getUsername());

            if (conversation) {
              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('conversationJoinRequest', new _ReceivedConversationJoinRequest__WEBPACK_IMPORTED_MODULE_8__.ReceivedConversationJoinRequest(sender, conversation, data.invitationId));
            } else {
              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('conversationJoinRequest', new _ReceivedConversationJoinRequest__WEBPACK_IMPORTED_MODULE_8__.ReceivedConversationJoinRequest(sender, null, null));
            }

            break;

          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_MODERATOR_CONNECTED_IDENTIFIER:
          case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_CLOSED_IDENTIFIER:
            break;

          default:
            var eventData = {
              event: data.event,
              content: data,
              sender: sender
            };

            if (conversation !== null) {
              eventData.conversation = conversation;
            }

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('customEvent', eventData);

            break;
        }
      } else {
        // Special compatibility cases
        if (typeof data.command !== 'undefined') {
          switch (data.command) {
            // Izeeconf waiting room message
            case 'userWaiting':
            case 'userWaiting-new':
              logger.info('Received conversation join request from ' + sender.getUsername());

              if (conversation) {
                _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('conversationJoinRequest', new _ReceivedConversationJoinRequest__WEBPACK_IMPORTED_MODULE_8__.ReceivedConversationJoinRequest(sender, conversation, null));
              } else {
                _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('conversationJoinRequest', new _ReceivedConversationJoinRequest__WEBPACK_IMPORTED_MODULE_8__.ReceivedConversationJoinRequest(sender, null, null));
              }

              break;
          }
        }
      }
    };

    apiRTCEventListeners.receiveGroupChatMessage = function (e) {
      var sender = contactCatalog.getOrCreateContact(e.detail.senderId);
      var conversation = null;
      var roomname = e.detail.groupChatId.toString();

      if (typeof roomname !== 'undefined') {
        if (conversationCatalog.isConference(roomname)) {
          conversation = conversationCatalog.getOrCreateConference(conversationCatalog.getNameFromTechnicalName(roomname));
        } else {
          conversation = conversationCatalog.getOrCreateConversation(conversationCatalog.getNameFromTechnicalName(roomname));
        }
      }

      if (conversation !== null) {
        logger.debug('Received conversation message from ' + sender.getUsername(), e.detail.message);
        var conversationMessage = {
          sender: sender,
          conversation: conversation,
          content: e.detail.message
        };

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(e.detail, 'metadata', 'object')) {
          conversationMessage.metadata = e.detail.metadata;
        }

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('conversationMessage', conversationMessage);
      }
    };

    apiRTCEventListeners.cloudEventOccurred = function (e) {
      var cloudEventOccurred = {
        topic: e.detail.topic,
        target: e.detail.target
      };

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('cloudEventOccurred', cloudEventOccurred);
    };

    apiRTCEventListeners.callEstablished = function (e) {
      if (e.detail.callId !== undefined) {
        var callId = e.detail.callId.toString();
        logger.debug('callEstablished', e.detail, callId);
        var call = callCatalog.getCall(callId, null, {});

        if (call !== null) {
          call.manageCallEstablishedEvent(e);
        }
      } else {
        logger.debug('callEstablished', e.detail);
      }
    };

    apiRTCEventListeners.remoteStreamAdded = function (e) {
      if (e.detail.callId !== undefined) {
        var callId = e.detail.callId.toString();
        logger.debug('remoteStreamAdded', e.detail, callId);
        var call = callCatalog.getCall(callId, null, {});

        if (call !== null) {
          call.manageRemoteStreamAddedEvent(e);
        }
      } else {
        logger.debug('remoteStreamAdded', e.detail);
      }
    };

    apiRTCEventListeners.remoteStreamRemoved = function (e) {
      if (e.detail.callId !== undefined) {
        var callId = e.detail.callId.toString();
        logger.debug('remoteStreamRemoved', e.detail, callId);
        var call = callCatalog.getCall(callId, null, {});

        if (call !== null) {
          call.manageRemoteStreamRemovedEvent(e);
        }
      } else {
        logger.debug('remoteStreamRemoved', e.detail);
      }
    };

    apiRTCEventListeners.userMediaSuccess = function (e) {
      var callId = null;

      if (e.detail.callId !== undefined && e.detail.callId !== null) {
        callId = e.detail.callId.toString();
        logger.debug('userMediaSuccess', e.detail, callId);
        var call = callCatalog.getCall(callId, null, {});

        if (call !== null) {
          call.manageUserMediaSuccessEvent(e);
        }
      } else {
        logger.debug('userMediaSuccess', e.detail);
      }
    };

    apiRTCEventListeners.onCallStatsUpdate = function (e) {
      // Please, do not commit any log for this event.
      if (e.detail.callId !== undefined) {
        var callId = e.detail.callId.toString();
        var call = callCatalog.getCall(callId, null, {});

        if (call !== null) {
          call.manageCallStatsUpdateEvent(e);
        }
      } else {
        logger.debug('onCallStatsUpdate', e.detail);
      }
    };

    apiRTCEventListeners.error = function (e) {
      logger.debug('error', e.detail);

      if (e.detail.roomName !== null && typeof e.detail.roomName !== 'undefined') {
        logger.debug('error on conversation :', e.detail, e.detail.roomName, e.detail.callId);
        var conversation = null;

        if (typeof e.detail.roomName !== 'undefined') {
          if (conversationCatalog.isConference(e.detail.roomName)) {
            conversation = conversationCatalog.getOrCreateConference(conversationCatalog.getNameFromTechnicalName(e.detail.roomName));
          } else {
            conversation = conversationCatalog.getOrCreateConversation(conversationCatalog.getNameFromTechnicalName(e.detail.roomName));
          }

          if (conversation !== null) {
            conversation.manageErrorEvent(e);
          }
        }
      } else if (e.detail.callId !== undefined) {
        var callId = e.detail.callId.toString();
        logger.debug('error', e.detail, callId);
        var call = callCatalog.getCall(callId, null, {});

        if (call !== null) {
          call.manageErrorEvent(e);

          if (e.detail.errorCode === 'RECORDING_FAILED') {
            //Removing recorded call
            callCatalog.removeCallFromList(call.getId());
          }
        }
      } else {
        logger.debug('error', e.detail);

        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('error', e.detail);
      }
    };

    apiRTCEventListeners.disconnectionWarning = function (e) {
      if (e.detail.roomName !== null) {
        logger.debug('disconnectionWarning on conversation :', e.detail, e.detail.roomName, e.detail.callId);
        var conversation = null;

        if (typeof e.detail.roomName !== 'undefined') {
          if (conversationCatalog.isConference(e.detail.roomName)) {
            conversation = conversationCatalog.getOrCreateConference(conversationCatalog.getNameFromTechnicalName(e.detail.roomName));
          } else {
            conversation = conversationCatalog.getOrCreateConversation(conversationCatalog.getNameFromTechnicalName(e.detail.roomName));
          }

          if (conversation !== null) {
            conversation.manageDisconnectionWarningEvent(e);
          }
        }
      } else if (e.detail.callId) {
        var callId = e.detail.callId.toString();
        logger.debug('disconnectionWarning', e.detail, callId);
        var call = callCatalog.getCall(callId, null, {});

        if (call !== null) {
          call.manageDisconnectionWarningEvent(e);
        }
      } else {
        logger.debug('disconnectionWarning', e.detail);
      }
    };

    apiRTCEventListeners.hangup = function (e) {
      if (e.detail.callId) {
        var callId = e.detail.callId.toString();
        logger.debug('hangup', e.detail, callId);
        var call = callCatalog.getCall(callId, null, {});

        if (call !== null) {
          call.manageHangupEvent(e);

          if (call.isRecorded() === false) {
            callCatalog.removeCallFromList(call.getId());
          } //ELSE : call will be removed from list when recorded file is received

        }
      } else {
        logger.debug('hangup', e.detail);
      }
    };

    apiRTCEventListeners.recordedStreamsAvailable = function (e) {
      if (e.detail.userId2) {
        var contact = contactCatalog.getOrCreateContact(e.detail.userId2);
        var call = callCatalog.getCall(null, contact);

        if (call) {
          call.manageRecordAvailableEvent(e);
          callCatalog.removeCallFromList(call.getId());
        }
      } else {
        logger.debug('recordedStreamsAvailable', e.detail);
      }
    };

    apiRTCEventListeners.desktopCapture = function (e) {
      if (e.detail.callId) {
        var callId = e.detail.callId.toString();
        logger.warn('desktopCapture', e.detail, callId);
        var call = callCatalog.getCall(callId, null, {});

        if (call !== null) {
          call.manageDesktopCaptureEvent(e);
          callCatalog.removeCallFromList(call.getId());
        }
      } else {
        logger.debug('desktopCapture', e.detail);
      }
    };

    apiRTCEventListeners.userMediaError = function (e) {
      if (e.detail.callId) {
        var callId = e.detail.callId.toString();
        logger.warn('userMediaError', e.detail, callId);
        var call = callCatalog.getCall(callId, null, {});

        if (call !== null) {
          call.manageUserMediaErrorEvent(e);

          if (e.detail.tryAudioCallActivated === false) {
            callCatalog.removeCallFromList(call.getId());
          }
        }
      } else {
        logger.debug('userMediaError', e.detail);
      }
    };

    logger.debug('av apiRTCManager onEvent ...');
    apiRTCManager.onEvent('disconnectionWarning', apiRTCEventListeners.disconnectionWarning).onEvent('incomingCall', apiRTCEventListeners.incomingCall).onEvent('roomInvitation', apiRTCEventListeners.roomInvitation).onEvent('roomMemberUpdate', apiRTCEventListeners.roomMemberUpdate).onEvent('receiveRoomMessage', apiRTCEventListeners.receiveRoomMessage).onEvent('receiveIMMessage', apiRTCEventListeners.receiveIMMessage).onEvent('receiveData', apiRTCEventListeners.receiveData).onEvent('receiveGroupChatMessage', apiRTCEventListeners.receiveGroupChatMessage).onEvent('cloudEventOccurred', apiRTCEventListeners.cloudEventOccurred) //Adding Events that are related to calls
    .onEvent('callEstablished', apiRTCEventListeners.callEstablished).onEvent('remoteStreamAdded', apiRTCEventListeners.remoteStreamAdded).onEvent('remoteStreamRemoved', apiRTCEventListeners.remoteStreamRemoved).onEvent('userMediaSuccess', apiRTCEventListeners.userMediaSuccess).onEvent('onCallStatsUpdate', apiRTCEventListeners.onCallStatsUpdate).onEvent('error', apiRTCEventListeners.error).onEvent('hangup', apiRTCEventListeners.hangup).onEvent('recordedStreamsAvailable', apiRTCEventListeners.recordedStreamsAvailable).onEvent('desktopCapture', apiRTCEventListeners.desktopCapture).onEvent('userMediaError', apiRTCEventListeners.userMediaError);
    apiRTC.addEventListener('channelEvent', apiRTCEventListeners.channelEvent);
    contactCatalog.onUpdate(function (updatedContacts) {
      //WORKAROUND PRESENCE ISSUE AP-1393
      if (_this.contactListUpdateListenerSetted === false) {
        logger.debug("No listener for contactListUpdate, storing event ...");

        _this.waitingContactListUpdateEvent.push(updatedContacts);
      } //END OF WORKAROUND


      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('contactListUpdate', updatedContacts);
    });

    _apiRTCEventListeners.set(_assertThisInitialized(_this), apiRTCEventListeners);

    return _this;
  }
  /**
   * Returns available events for this class
   *
   *  @returns {Array<string>}
   */


  _createClass(Session, [{
    key: "getToken",
    value:
    /**
     * Returns this session's token if this is a cloud user's session, otherwise returns null
     *
     *  @returns {string} token
     */
    function getToken() {
      return this.token;
    }
    /**
     * Returns Apizee token associated to the session
     *
     *  @returns {string} token
     */

  }, {
    key: "getApzToken",
    value: function getApzToken() {
      var JWTApzToken = null;

      if (apiRTC.session !== undefined && apiRTC.session !== null) {
        JWTApzToken = apiRTC.session.JWTApzToken;
      }

      return JWTApzToken;
    }
    /**
     * Returns this session's id
     *
     *  @returns {string} id
     */

  }, {
    key: "getId",
    value: function getId() {
      return this.id;
    }
    /**
     * Returns this session's user agent
     *
     *  @returns {UserAgent} ua
     */

  }, {
    key: "getUserAgent",
    value: function getUserAgent() {
      return _ua.get(this);
    }
    /**
     * Returns contact from id. Deprecated : please use getOrCreateContact
     *
     *  @param {String} id
     *  @returns {Contact} contact
     *  @deprecated
     *
     */

  }, {
    key: "getContact",
    value: function getContact(id) {
      logger.warn('getContact() - Method deprecated, use Session.getOrCreateContact() instead');
      return _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_15__.ContactCatalog.get().getOrCreateContact(id);
    }
    /**
     * Returns contact from id. Contact will be created if doesn't exist.
     *
     *  @param {String} id
     *  @returns {Contact} contact
     */

  }, {
    key: "getOrCreateContact",
    value: function getOrCreateContact(id) {
      return _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_15__.ContactCatalog.get().getOrCreateContact(id);
    }
    /**
     * Gets a conversation from name for N-N communication.
     *
     * Deprecated in favor of Session#getOrCreateConversation.
     *
     * @deprecated
     *
     * @param {String} conversationName can be set to null to generate a random conversation name
     * @param {Object} options
     *
     * @returns {Conversation} returned conversation
     */

  }, {
    key: "createConversation",
    value: function createConversation(conversationName) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      logger.warn('createConversation() - Method deprecated, use Session.getConversation() instead');
      return this.getConversation(conversationName, options);
    }
    /**
     * Gets a conversation from name for N-N communication.
     *
     * Deprecated in favor of Session#getOrCreateConversation.
     *
     * @deprecated
     *
     * @param {String} conversationName can be set to null to generate a random conversation name
     * @param {Object} options
     *
     * @returns {Conversation} returned conversation
     */

  }, {
    key: "getConversation",
    value: function getConversation(conversationName) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      logger.trace('Getting conversation ' + conversationName, options);
      return _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_14__.ConversationCatalog.get().getOrCreateConversation(conversationName);
    }
    /**
     * Gets a conference from name for enterprise N-N communication.
     *
     * Deprecated in favor of Session#getOrCreateConversation.
     *
     * @deprecated
     *
     * @param {string} conferenceName can be set to null to generate a random conference name
     * @param {Object} options
     *
     * @returns {Conference} returned conference
     */

  }, {
    key: "getConference",
    value: function getConference(conferenceName) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      logger.trace('Getting conference ' + conferenceName, options);
      return _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_14__.ConversationCatalog.get().getOrCreateConference(conferenceName);
    }
    /**
     * Gets or creates a Conversation for a given name.
     * If the given name matches the pattern ([^:]+)[:]([^:]+) then a Conference is returned,
     * otherwise a Conversation is returned.
     * Note that options are only used to create Conversation, i.e. if the Conversation
     * already exists, options are ignored.
     * @param {string} name - Conversation name.
     * @param {object} options
     * @param {boolean} options.meshModeEnabled=false - Whether the mesh mode is enabled.
     * @param {boolean} options.meshOnlyEnabled=false - Whether the mesh mode is the only mode allowed, i.e. no transition to another mode will occur.
     * @param {boolean} options.moderationEnabled=false - Whether moderation is enabled for the new Conversation.
     * @param {boolean} options.moderator=false - Whether the UserAgent shall be added to the list of moderators.
     * @return {(Conversation|Conference)} A Conversation or a Conference, depending on the given name.
     */

  }, {
    key: "getOrCreateConversation",
    value: function getOrCreateConversation(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var ret = null,
          realName = _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_14__.ConversationCatalog.get().getNameFromTechnicalName(name);

      if (_private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_14__.ConversationCatalog.get().isConference(name)) {
        ret = _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_14__.ConversationCatalog.get().getOrCreateConference(realName, options);
      } else {
        ret = _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_14__.ConversationCatalog.get().getOrCreateConversation(realName, options);
      }

      return ret;
    }
    /**
     * Gets or creates a conference for a given name.
     * If the given name matches the pattern ([^:]+)[:]([^:]+) then a Conference is returned,
     * otherwise a Conversation is returned.
     * Note that options are only used to create Conference, i.e. if the Conference
     * already exists, options are ignored.
     * @param {String} name - Conference name.
     * @param {object} options
     * @param {boolean} options.meshModeEnabled=false - Whether the mesh mode is enabled.
     * @param {boolean} options.meshOnlyEnabled=false - Whether the mesh mode is the only mode allowed, i.e. no transition to another mode will occur.
     * @return {(Conversation|Conference)} A Conversation or a Conference, depending on the given name.
     */

  }, {
    key: "getOrCreateConference",
    value: function getOrCreateConference(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.getOrCreateConversation(name, options);
    }
    /**
     * Gets all currently joined conversations
     *
     *  @param {Object} options
     *  @returns {Object<string, Conversation>} returned active conversations
     */

  }, {
    key: "getActiveConversations",
    value: function getActiveConversations() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var res = {};
      var conversations = _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_14__.ConversationCatalog.get().getConversations();

      var _iterator2 = _createForOfIteratorHelper(conversations.keys()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var key = _step2.value;
          var conversation = conversations.get(key);

          if (conversation.isJoined()) {
            res[key] = conversation;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return res;
    }
    /**
     * Gets all currently joined conferences
     *
     *  @param {Object} options
     *  @returns {Object<string, Conference>} returned active conferences
     */

  }, {
    key: "getActiveConferences",
    value: function getActiveConferences() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var res = {};
      var conferences = _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_14__.ConversationCatalog.get().getConferences();

      var _iterator3 = _createForOfIteratorHelper(conferences.keys()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var key = _step3.value;
          var conference = conferences.get(key);

          if (conference.isJoined()) {
            res[key] = conference;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return res;
    }
    /**
     * Returns whiteboard client
     *
     *  @returns {WhiteboardClient} WhiteboardClient
     */

  }, {
    key: "getWhiteboardClient",
    value: function getWhiteboardClient() {
      logger.trace('getWhiteboardClient()');
      return apiRTCManager.whiteBoardClient;
    }
  }, {
    key: "getremoteControlStatus",
    value: function getremoteControlStatus() {
      return this.remoteControlActive;
    }
  }, {
    key: "setRemoteControlStatus",
    value: function setRemoteControlStatus(state) {
      if (_typeof(state) == Boolean) {
        this.remoteControlActive = state;
      }
    }
    /**
     * Sets user data for this user session
     * User data is visible from other users
     *
     *  @param {Object} userData
     *  @returns {void}
     */

  }, {
    key: "setUserData",
    value: function setUserData(userData) {
      this.userData.setProps(userData).setToSession();
    }
    /**
     * Set session's username
     *
     *  @param {string} username
     *  @returns {void}
     */

  }, {
    key: "setUsername",
    value: function setUsername(username) {
      this.userData.setProp('username', username).setToSession();
    }
    /**
     * Set session's photo URL
     *
     *  @param {string} url
     *  @returns {void}
     */

  }, {
    key: "setPhotoUrl",
    value: function setPhotoUrl(url) {
      this.userData.setProp('photo_url', url).setToSession();
    }
    /**
     * Gets user data for this user session
     *
     *  @returns {Object} contact's userdata
     */

  }, {
    key: "getUserData",
    value: function getUserData() {
      return this.userData;
    }
    /**
     * Gets this session's username
     *
     *  @returns {string} contact's username
     */

  }, {
    key: "getUsername",
    value: function getUsername() {
      if (this.userData.get('username') !== null) {
        return this.userData.get('username');
      } else if (this.userData.get('nickname') !== null) {
        return this.userData.get('nickname');
      } else {
        return this.id.toString();
      }
    }
    /**
     * Gets this session's photo URL
     *
     * @return {string} photo URL on success, null otherwise.
     */

  }, {
    key: "getPhotoUrl",
    value: function getPhotoUrl() {
      if (this.userData.get('photo_url') !== null) {
        return this.userData.get('photo_url');
      } else if (this.userData.get('photoUrl') !== null) {
        return this.userData.get('photoUrl');
      } else {
        return null;
      }
    }
    /**
     *  Subscribe to a group and know who is present in the group
     *  Unless you also joined the group, the user will not be visible to others within this group
     *
     *  @param {string} group Presence group to subscribe to
     *  @returns {void}
     */

  }, {
    key: "subscribeToGroup",
    value: function subscribeToGroup(group) {
      if (!this.getSubscribedPresenceGroup().includes(group)) {
        apiRTCManager.apiRTCSession.subscribePresenceGroup([group]);
      } else {
        logger.debug('Already subscribed to this group');
        var index = apiCC.session.subscribeToPresenceGroupAddedByApiRTC.indexOf(group); //Check if element need to be removed from presenceGroupAddedByApiRTC

        if (index !== -1) {
          apiCC.session.subscribeToPresenceGroupAddedByApiRTC.splice(index, 1);
        }
      }
    }
    /**
     *  Unsubscribe to a group, the session will no longer receive events from user joining and leaving this group
     *
     *  @param {string} group Presence group to unsubscribe to
     *  @returns {void}
     */

  }, {
    key: "unsubscribeToGroup",
    value: function unsubscribeToGroup(group) {
      if (this.getSubscribedPresenceGroup().includes(group)) {
        apiRTCManager.unsubscribeToPresenceGroup(group);
      } else {
        logger.debug('Not subscribed to this group');
      }
    }
    /**
     *  Joins and subscribes to a group
     *  The user will be visible to both users inside the group and users who subscribed to it
     *
     *  @param {string} group Presence group to join
     *  @returns {void}
     */

  }, {
    key: "joinGroup",
    value: function joinGroup(group) {
      if (!this.getPresenceGroup().includes(group)) {
        apiRTCManager.joinAndSubscribeToPresenceGroup(group);
      } else {
        logger.debug('Already joined this group');
        var index = apiCC.session.presenceGroupAddedByApiRTC.indexOf(group); //Check if element need to be removed from presenceGroupAddedByApiRTC

        if (index !== -1) {
          apiCC.session.presenceGroupAddedByApiRTC.splice(index, 1);
        }
      }
    }
    /**
     *  Leaves and unsubscribes to a group
     *  Users within the group and users who subscribed to it will be notified
     *
     *  @param {String} group Presence group to leave
     *  @returns {Void}
     */

  }, {
    key: "leaveGroup",
    value: function leaveGroup(group) {
      if (this.getPresenceGroup().includes(group)) {
        apiRTCManager.leaveAndUnsubscribeToPresenceGroup(group);
      } else {
        logger.debug('Group was not joined');
      }
    }
    /*
     * Subscribes to a Cloud Event.
     * @method subscribeToCloudEvent
     * @param {string} topic
     * @param {object} headers
     */

  }, {
    key: "subscribeToCloudEvent",
    value: function subscribeToCloudEvent(topic, headers) {
      apiRTCManager.subscribeToCloudEvent(topic, headers);
    }
    /*
     * Cancels the subscription to a Cloud Event.
     * @method unsubscribeToCloudEvent
     * @param {string} topic
     * @param {object} headers
     */

  }, {
    key: "unsubscribeToCloudEvent",
    value: function unsubscribeToCloudEvent(topic, headers) {
      apiRTCManager.unsubscribeToCloudEvent(topic, headers);
    }
    /**
     *  Join conversationSpace
     *
     *  @param {String} conversationSpace conversationSpace to join
     *  @returns {Void}
     */

  }, {
    key: "joinConversationSpace",
    value: function joinConversationSpace(conversationSpace) {
      apiRTCManager.apiRTCSession.joinConversationSpace(conversationSpace);
    }
    /**
     *  Leave conversationSpace
     *
     *  @param {String} conversationSpace conversationSpace to leave
     *  @returns {Void}
     */

  }, {
    key: "leaveConversationSpace",
    value: function leaveConversationSpace(conversationSpace) {
      apiRTCManager.apiRTCSession.leaveConversationSpace(conversationSpace);
    }
    /**
     * Returns contact list
     *
     *  @param {String} group If defined, restrict list to user inside defined group
     *  @returns {Object<string, Contact>} contact list
     */

  }, {
    key: "getContacts",
    value: function getContacts(group) {
      logger.trace('getContacts()');
      var res = {};
      var contacts = _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_15__.ContactCatalog.get().getContacts(group);

      var _iterator4 = _createForOfIteratorHelper(contacts.keys()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var key = _step4.value;
          res[key] = contacts.get(key);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return res;
    }
    /**
     * Returns contact list array
     *
     *  @param {String} group If defined, restrict list to user inside defined group
     *  @returns {Contact[]} contact list array
     */

  }, {
    key: "getContactsArray",
    value: function getContactsArray(group) {
      logger.log('getContactsArray');
      var contacts = _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_15__.ContactCatalog.get().getContacts(group);
      return Array.from(contacts.values());
    }
    /**
     * Returns online contact list array
     *
     *  @param {String} group If defined, restrict list to user inside defined group
     *  @returns {Contact[]} online contact list array
     */

  }, {
    key: "getOnlineContactsArray",
    value: function getOnlineContactsArray(group) {
      logger.log('getOnlineContactsArray');
      var contacts = _private_ContactCatalog__WEBPACK_IMPORTED_MODULE_15__.ContactCatalog.get().getOnlineContacts(group);
      return Array.from(contacts.values());
    }
    /**
     * Returns call with Id
     *
     *  @returns {Object<string, Call>} call
     */

  }, {
    key: "getCall",
    value: function getCall(callId) {
      logger.trace('getCall()');
      var call = _private_CallCatalog__WEBPACK_IMPORTED_MODULE_16__.CallCatalog.get().getCall(callId);
      return call;
    }
    /**
     * Returns call list
     *
     *  @returns {Object<string, Call>} call list
     */

  }, {
    key: "getCalls",
    value: function getCalls() {
      logger.trace('getCalls()');
      var res = {};
      var contacts = _private_CallCatalog__WEBPACK_IMPORTED_MODULE_16__.CallCatalog.get().getCalls();

      var _iterator5 = _createForOfIteratorHelper(contacts.keys()),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var key = _step5.value;
          res[key] = contacts.get(key);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return res;
    }
    /**
     * @typedef DisconnectOptions
     * @type {Object}
     * @property {boolean} invalidateUserToken - should the user token be invalidated upon disconnection?
     */

    /**
     * Disconnects this session
     * Session will no longer receive events once disconnected
     *
     *  @param {DisconnectOptions} options
     *  @returns {Promise<void>}
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        invalidateUserToken: true
      };
      return new Promise(function (resolve, reject) {
        logger.info('disconnect()');

        if (_this2.token === null && _this2.id === null) {
          logger.error('disconnect() - Session is already disconnected');
          reject('disconnect() - Session is already disconnected');
        } else {
          // Leave active conversations
          var conversations = _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_14__.ConversationCatalog.get().getConversations();

          var _iterator6 = _createForOfIteratorHelper(conversations.keys()),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var conversation = _step6.value;

              if (conversation.status === _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONVERSATION_STATUS_JOINED) {
                conversation.leave();
              }
            } // Stop update presence routine

          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }

          clearInterval(_updatePresenceRoutine.get(_this2));

          _updatePresenceRoutine.set(_this2, null);

          if (_this2.token !== null && options.hasOwnProperty('invalidateUserToken') && options.invalidateUserToken) {
            cloudApi.invalidateUserToken(_this2.token).then(function () {
              activeSession = null;
              var opts = {
                invalidateApiCCId: true
              };
              apiRTCManager.disconnect(opts);
              _this2.id = null;
              _this2.token = null; //clean ApiRTCManager Event

              var apiRTCEventListeners = _apiRTCEventListeners.get(_this2);

              for (var _i = 0, _Object$keys = Object.keys(apiRTCEventListeners); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i];
                logger.info('Session, removing apiRTCManager event :', key);
                var listener = apiRTCEventListeners[key];
                apiRTCManager.removeEventListener(key, listener);
              }

              resolve();
            })["catch"](function (err) {
              logger.error('disconnect() - An error occured during disconnection', err);
              reject(new Error('disconnect() - An error occured during disconnection'));
            });
          } else {
            activeSession = null;
            apiRTCManager.disconnect();
            _this2.id = null; //clean ApiRTCManager Event

            var apiRTCEventListeners = _apiRTCEventListeners.get(_this2);

            for (var _i2 = 0, _Object$keys2 = Object.keys(apiRTCEventListeners); _i2 < _Object$keys2.length; _i2++) {
              var key = _Object$keys2[_i2];
              logger.info('Session, removing apiRTCManager event :', key);
              var listener = apiRTCEventListeners[key];
              apiRTCManager.removeEventListener(key, listener);
            }

            resolve();
          }
        }
      });
    }
    /**
     * A promise for generic ApiRTC cloud platform REST requests
     * Avoid using this method unless you know what you are doing
     *
     *  @param {String} url
     *  @param {Object} params
     *  @param {String} method
     *  @returns {Promise<object>} json result in promise
     */

  }, {
    key: "cloudRequest",
    value: function cloudRequest(url, params, method) {
      return cloudApi.cloudRequest(url, params, method);
    }
    /**
     * Promise to send rawData for older apps compatibility
     *
     *  @param {Contact} contact
     *  @param {Object} data
     *  @returns {Promise<void>}
     */

  }, {
    key: "sendRawData",
    value: function sendRawData(contact, data) {
      return new Promise(function (resolve, reject) {
        if (contact !== null && contact !== undefined) {
          apiRTCManager.sendData(contact.getId(), data).then(resolve)["catch"](function (err) {
            switch (err) {
              case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT:
                reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT, 'sendRawData() - Data transmission timed out ', logger));
                break;

              case _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND:
                reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND, 'sendRawData() - Contact was not found ', logger));
                break;

              default:
                reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendRawData() - Data transmission timed out ', logger));
                break;
            }
          });
        } else {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'sendRawData() - Contact undefined', logger));
        }
      });
    }
    /**
     * Starts recording the first user's outgoing stream
     *  NOTE : This function is present for backward compatibility purposes, prefer the use of a recorded call or Stream.startRecord() instead
     *  @param {string} mode can be 'AUDIO-ONLY', 'VIDEO-ONLY', 'AUDIO-VIDEO'
     *  @param {string} filename
     *  @returns {void}
     */

  }, {
    key: "startRecordingOutgoingStream",
    value: function startRecordingOutgoingStream(mode, filename) {
      if (!this.isRecording) {
        apiRTCManager.webRTCClient.startRecording(mode, filename);
        this.isRecording = true;
      } else {
        logger.error('startRecordingOutgoingStream() - already recording');
      }
    }
    /**
     * @typedef RecordInformation
     * @type {Object}
     * @property {string} filename
     * @property {string} url
     */

    /**
     * Stops the recording started with Session.startRecordingOutgoingStream() and returns information to get the record from the server
     *  NOTE : This function is present for backward compatibility purposes, prefer the use of a recorded call or Stream.startRecord() instead
     *  @returns {Promise<RecordInformation>} Record information in promise
     */

  }, {
    key: "stopRecordingOutgoingStream",
    value: function stopRecordingOutgoingStream() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.isRecording) {
          _this3.isRecording = false;
          apiRTCManager.onceEvent('MCURecordedStreamsAvailable', function (e) {
            resolve({
              filename: e.detail.recordedFileName,
              url: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.RECORD_PLAY_URL + e.detail.recordedFileName
            });
          });
          apiRTCManager.webRTCClient.stopRecording();
        } else {
          logger.error('stopRecordingOutgoingStream() - not recording');
          reject(new Error('stopRecordingOutgoingStream() - not recording'));
        }
      });
    }
    /**
     * Initializes a session once it is connected
     *
     *  @ignore
     *  @param {string} id
     *  @returns {void}
     */

  }, {
    key: "init",
    value: function init(id) {
      var _this4 = this;

      this.id = id;
      activeSession = this;

      if (_updatePresenceRoutine.get(this) === null) {
        _updatePresenceRoutine.set(this, setInterval(function () {
          updateConferencePresence(_this4);
        }, UPDATE_PRESENCE_INTERVAL));
      }
    }
    /**
     * Sets MCU server to be used
     * Clients on different MCU servers will be unable to see each other's streams in a conversation / conference even if they are in the same room
     *
     *  @param {string} server
     *  @returns {void}
     */

  }, {
    key: "setMCUServer",
    value: function setMCUServer(server) {
      apiRTCManager.webRTCClient.setMCUConnector(server);
    }
    /**
     * Set the possibilty for the user to have multiple calls at the same time (default true)
     *
     *  @param {boolean} value
     *  @returns {void}
     */

  }, {
    key: "allowMultipleCalls",
    value: function allowMultipleCalls(value) {
      apiRTCManager.webRTCClient.setAllowMultipleCalls(value);
    }
    /**
     * Enables call stats monotoring.
     *
     * @param {enabled} enabled Whether to enable call stats monitoring
     * @param {interval} interval Update interval in milliseconds
     * @returns {void}
     */

  }, {
    key: "setCallStatsMonitoringEnabled",
    value: function setCallStatsMonitoringEnabled(enabled, interval) {
      apiRTCManager.webRTCClient.enableCallStatsMonitoring(enabled, interval);
    }
    /**
     * Enables quality evaluating.
     *
     * @param {enabled} enabled Whether to enable quality evaluating
     * @param {interval} interval Update interval in milliseconds
     * @returns {void}
     */

  }, {
    key: "setQualityEvaluatingEnabled",
    value: function setQualityEvaluatingEnabled(enabled, interval) {
      apiRTCManager.webRTCClient.enableQualityEvaluating(enabled, interval);
    }
    /**
     * Gets contact from a websessionId
     *
     *  @param {string} webSessionId
     *  @returns {Promise<Contact>} Associated contact in promise
     */

  }, {
    key: "getContactFromWebSession",
    value: function getContactFromWebSession(webSessionId) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        cloudApi.getSessionHistory(webSessionId, _this5.getToken()).then(function (res) {
          if (res.exist.toString() !== '1') {
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_NOT_FOUND, 'No such web session', logger));
          } else if (res.user1.toString() === _this5.getId()) {
            resolve(_this5.getContact(res.user2));
          } else if (res.user2.toString() === _this5.getId()) {
            resolve(_this5.getContact(res.user1));
          } else {
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_UNAUTHORIZED, 'User has no access to this web session', logger));
          }
        })["catch"](function (err) {
          if (err.hasOwnProperty('code')) {
            reject({
              code: err.code,
              error: err.error
            });
          } else if (err.hasOwnProperty('http_code')) {
            if (err.http_code.toString().startsWith('4')) {
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'Error while getting contact from websession', logger));
            } else {
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_SERVER_UNAVAILABLE, 'Error while getting contact from websession', logger));
            }
          } else {
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'Error while getting contact from websession', logger));
          }
        });
      });
    }
    /**
     * Joins a pointer sharing room identified by a given roomId.
     * @param {string} roomId
     * @return {Promise<PointerSharingRoom>}
     */

  }, {
    key: "joinPointerSharingRoom",
    value: function joinPointerSharingRoom(roomId) {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        if (_pointerSharingRooms.get(_this6).hasOwnProperty(roomId)) {
          return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'joinPointerSharingRoom() - cannot join pointer sharing room again', logger));
        }

        apiRTCManager.pointerSharingClient.joinRoom(roomId, {
          success: function success(roomId) {
            var newRoom = new PointerSharingRoom(_this6, roomId);
            _pointerSharingRooms.get(_this6)[roomId] = newRoom;
            resolve(newRoom);
          },
          failure: function failure(err, roomId) {
            if (err === 'timeout') {
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_TIMED_OUT, 'joinPointerSharingRoom() - cannot join pointer sharing room', logger));
            } else {
              reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'joinPointerSharingRoom() - cannot join pointer sharing room', logger));
            }
          }
        });
      });
    }
    /**
     * Gets all subscribed presence group in an array
     * @returns {Array<string>} Subscribed presence group array
     */

  }, {
    key: "getSubscribedPresenceGroup",
    value: function getSubscribedPresenceGroup() {
      if (apiCC !== undefined && apiCC.session !== null && apiCC.session !== undefined) {
        return apiCC.session.subscribeToPresenceGroup;
      } else {
        return [];
      }
    }
    /**
     * Gets presence group in an array
     * @returns {Array<string>} Presence group array
     */

  }, {
    key: "getPresenceGroup",
    value: function getPresenceGroup() {
      if (apiCC !== undefined && apiCC.session !== null && apiCC.session !== undefined) {
        return apiCC.session.presenceGroup;
      } else {
        return [];
      }
    }
    /**
     * Client side - Manage remote connection event
     * 
     * @ignore
     * @param {object} data 
     */

  }, {
    key: "remoteControlAppManage",
    value: function remoteControlAppManage(data) {
      var _this7 = this;

      var agentContact = this.getOrCreateContact(data.contactID);
      var clientContact = this.getOrCreateContact(this.getId());
      var streams = Array.from(clientContact.getActiveStreams().values());
      var streamId;

      for (var _i3 = 0, _streams = streams; _i3 < _streams.length; _i3++) {
        var stream = _streams[_i3];

        if (stream.isScreensharing()) {
          streamId = stream.getId();
        }
      }

      this.consoleManager = new _Core_AicConsoleManager__WEBPACK_IMPORTED_MODULE_10__.AicConsoleManager(agentContact); //chercher si la session en cours  deja un screen de partag ?

      if (!streamId) {
        _Stream__WEBPACK_IMPORTED_MODULE_18__.Stream.createDisplayMediaStream(null, null).then(function (stream) {
          //need to publish this stream
          var conversation = _this7.getOrCreateConversation(data.convName);

          conversation.publish(stream).then(function (remoteStream) {
            var streamID = Array.from(remoteStream.publishedInConversations.values())[0];

            _this7.downloadFromURL(data.content, "aic_agent_signed.exe").then(function () {
              _this7.consoleManager.aic_agent_start("127.0.0.1").then(function () {
                var screenResolution = _this7.getScreenResolution(); //send an event to contact


                agentContact.sendRemoteControlInvitationCallback(screenResolution, streamID, _this7.getId()).then(function () {});
              });
            })["catch"](function (err) {
              _private_Logger__WEBPACK_IMPORTED_MODULE_11__.Logger.error(err);
            });
          });
        })["catch"](function (err) {
          _private_Logger__WEBPACK_IMPORTED_MODULE_11__.Logger.error(err);
        });
      } else {
        this.downloadFromURL(data.content, "aic_agent_signed.exe").then(function () {
          //Tester l'execution de la console
          _this7.consoleManager.aic_agent_start("127.0.0.1").then(function () {
            var screenResolution = _this7.getScreenResolution();

            agentContact.sendRemoteControlInvitationCallback(screenResolution, streamId, _this7.getId()).then(function () {});
          });
        })["catch"](function (err) {
          _private_Logger__WEBPACK_IMPORTED_MODULE_11__.Logger.error(err);
        });
      }
    }
    /**
     * Executed on client side - Send data to aic console
     * 
     * @ignore
     * @param {Object} data 
     */

  }, {
    key: "remoteControlDataCommand",
    value: function remoteControlDataCommand(data) {
      if (data.content && typeof data.content !== "undefined" && data.content.event) {
        switch (data.content.event) {
          case 'command':
            if (typeof data.content.value !== "undefined" && data.content.value) {
              if (this.consoleManager.getWs()) {
                this.consoleManager.aic_agent_send_message(data.content.value);
              }
            }

            break;

          default:
            break;
        }
      }
    }
    /**
     * Download file from url
     * url = path to element, name = string name element
     * 
     * @ignore
     * @param {String} url 
     * @param {String} name 
     * @returns 
     */

  }, {
    key: "downloadFromURL",
    value: function downloadFromURL(url, name) {
      return new Promise(function (resolve, reject) {
        try {
          //Tlcharger la console sur le poste client
          var link = document.createElement("a");
          link.download = name;
          link.href = url;
          link.click();
          link = null;
          resolve();
        } catch (error) {
          reject("Erreur URL de Tlchargement. Dplac ou supprim");
        }
      });
    }
    /**
    * function send data in conversation, with "Screen resolution message."
    * Screen dimention and screen resolution 
    * 
    * @ignore
    * 
    * @return {void}
    */

  }, {
    key: "getScreenResolution",
    value: function getScreenResolution() {
      logger.debug("getScreenResolution");
      var screen_width = window.screen.width;
      var screen_height = window.screen.height;
      var ratio_screen_width = window.screen.width * window.devicePixelRatio;
      var ratio_screen_height = window.screen.height * window.devicePixelRatio;
      return {
        width: screen_width,
        height: screen_height,
        width_ratio: ratio_screen_width,
        height_ratio: ratio_screen_height
      };
    }
    /**
     * Executed on agent side, execute remote control listener on DOM content
     * 
     * @ignore
     * @param {Object} data 
     */

  }, {
    key: "remoteControlAppManageCallback",
    value: function remoteControlAppManageCallback(data) {
      var clientContact = this.getOrCreateContact(data.id_client);
      this.consoleManager = new _Core_AicConsoleManager__WEBPACK_IMPORTED_MODULE_10__.AicConsoleManager(clientContact); //faut passer le client ici

      this.consoleManager.aic_control_start(data.id, data.content.width, data.content.height);
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return SESSION_EVENTS;
    }
    /**
     * Returns currently active session
     *
     *  @returns {Session}
     */

  }, {
    key: "getActiveSession",
    value: function getActiveSession() {
      return activeSession;
    }
  }]);

  return Session;
}(_utils_Observable__WEBPACK_IMPORTED_MODULE_2__.Observable);
/**
 * Represents a room/client for pointer sharing.
 * @class PointerSharingRoom
 */


var PointerSharingRoom = function PointerSharingRoom(session, roomId) {
  this.session = session;
  this.roomId = roomId;
  /**
   * Returns the roomId of this one.
   * @function PointerSharingRoom#getRoomId
   * @return {string}
   */

  this.getRoomId = function () {
    return this.roomId;
  };
  /**
   * Tests whether the room/client represented by this one is active.
   * @function PointerSharingRoom#isActive
   * @return {boolean} True if this one is active, false otherwise.
   */


  this.isActive = function () {
    return this.session !== null && this.roomId !== null && apiRTCManager.pointerSharingClient.roomActive(this.roomId);
  };
  /**
   * Leaves the room.
   * @function PointerSharingRoom#leaveRoom
   * @return {Promise}
   */


  this.leaveRoom = function () {
    var _this8 = this;

    return new Promise(function (resolve, reject) {
      if (_this8.session === null || _this8.roomId === null) {
        return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'leaveRoom() - cannot leave room again', logger));
      }

      apiRTCManager.pointerSharingClient.leaveRoom(_this8.roomId);
      delete _pointerSharingRooms.get(_this8.session)[_this8.roomId];
      _this8.session = null;
      _this8.roomId = null;
      resolve();
    });
  };
  /**
   * Invites a given contact into the room represented by this one.
   * @function PointerSharingRoom#invite
   * @param {Contact} contact
   * @param {object} data
   * @return {Promise}
   */


  this.invite = function (contact, data) {
    var _this9 = this;

    return new Promise(function (resolve, reject) {
      if (_this9.session === null || _this9.roomId === null) {
        return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'invite() - cannot invite', logger));
      }

      apiRTCManager.pointerSharingClient.inviteInRoom(_this9.roomId, contact.getId(), data);
      resolve();
    });
  };
  /**
   * Sends pointer location to other members of the room represented by this one.
   * @function PointerSharingRoom#sendPointerLocation
   * @param {object} source
   * @param {number} x
   * @param {number} y
   * @param {object} data - Optional data.
   * @return {Promise}
   */


  this.sendPointerLocation = function (source, x, y, data) {
    var _this10 = this;

    return new Promise(function (resolve, reject) {
      if (_this10.session === null || _this10.roomId === null) {
        return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'sendPointerLocation() - cannot send pointer location', logger));
      }

      var res = apiRTCManager.pointerSharingClient.sendPointerLocation(_this10.roomId, source, x, y, data);

      if (!res) {
        return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_WRONG_STATE, 'sendPointerLocation() - cannot send pointer location', logger));
      }

      resolve();
    });
  };
};
/*
 * Sends update to cloud for each currently joined conference
 */


var updateConferencePresence = function updateConferencePresence(session) {
  var conferences = session.getActiveConferences();

  for (var _i4 = 0, _Object$keys3 = Object.keys(conferences); _i4 < _Object$keys3.length; _i4++) {
    var key = _Object$keys3[_i4];
    var conference = conferences[key];
    cloudApi.updateConferencePresence(conference, session, apiRTCManager.getActiveApiKey());
  }
};



/***/ }),

/***/ "./src/public/Stream.js":
/*!******************************!*\
  !*** ./src/public/Stream.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Stream": () => (/* binding */ Stream),
/* harmony export */   "_localStreams": () => (/* binding */ _localStreams)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _utils_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Observable */ "./src/utils/Observable.js");
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Session */ "./src/public/Session.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../private/ApiRTCManager */ "./src/private/ApiRTCManager.js");
/* harmony import */ var _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../private/ConversationCatalog */ "./src/private/ConversationCatalog.js");
/* harmony import */ var wasm_check__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! wasm-check */ "./node_modules/wasm-check/dist/wasm-check.min.js");
/* harmony import */ var wasm_check__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(wasm_check__WEBPACK_IMPORTED_MODULE_7__);
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* globals apiCC, AudioWorkletNode, AudioContext, MediaStreamAudioDestinationNode, AudioNode, MediaStreamAudioSourceNode, AudioDestinationNode, mergeReality, ImageCapture, SelfieSegmentation, MediaStreamTrack, Path2D, MediaStreamTrackProcessor, MediaStreamTrackGenerator, OffscreenCanvas, TransformStream, VideoFrame, Hands, Sentry */








var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_4__.Logger.get('Stream');
var apiRTCManager = _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_5__.ApiRTCManager.get();
var conversationCatalog = _private_ConversationCatalog__WEBPACK_IMPORTED_MODULE_6__.ConversationCatalog.get();
var STREAM_EVENTS = ['stopped', 'trackStopped', 'audioAmplitude', 'audioAmplitudeInfo', 'muteStateChange', 'activeStateChange', 'backgroundSubstractionStopVisibilityChange', 'backgroundSubstractionStopComputeTime', 'AIESnapshot', 'AIELog', 'audioFlowStatusChanged', 'videoFlowStatusChanged', 'remoteAudioFlowStatusChanged', 'remoteVideoFlowStatusChanged', 'release']; // Dictionary of all local streams with userMediaStreamId as keys.

var _localStreams = new Map();

var _isScreensharingStream = new WeakMap();

var _audioJavascriptNode = new WeakMap();

var _audioSourceNode = new WeakMap();

var _apiRTCEventListeners = new WeakMap(); // Fallover option for Stream#trackStopped event


var trackStoppedReference = {};
/**
 * Stream
 *  @extends Observable
 *  @fires Stream#audioAmplitude
 *  @fires Stream#audioAmplitudeInfo
 *  @fires Stream#muteStateChange
 *  @fires Stream#backgroundSubstractionStopVisibilityChange
 *  @fires Stream#backgroundSubstractionStopComputeTime
 *  @fires Stream#AIESnapshot
 *  @fires Stream#AIELog
 *  @fires Stream#audioFlowStatusChanged
 *  @fires Stream#videoFlowStatusChanged
 *  @fires Stream#remoteAudioFlowStatusChanged
 *  @fires Stream#remoteVideoFlowStatusChanged
 *  @fires Stream#release
 */

var Stream = /*#__PURE__*/function (_Observable) {
  _inherits(Stream, _Observable);

  var _super = _createSuper(Stream);

  /**
   * @typedef StreamOptions
   * @type {Object}
   * @property {string} type type of stream value can be 'audio' or 'video'
   * @property {boolean} [screensharing] indicate whether stream in a screensharing or not. Value  : true or false
   * @property {Contact} [contact] associated contact of the stream
   * @property {streamId} [streamId] Identifier of the stream
   * @property {MediaDevice} [audioInput] audioInput device id, can be null
   * @property {MediaDevice} [videoInput] videoInput device id, can be null
   */

  /**
   * Emitted when user media is released or when related call is terminated.
   *
   * @event Stream#stopped
   * @type {object}
   * @property {number} streamId - stream identifier.
   * @property {string} userMediaStreamId - user media stream identifier (optional).
   * @property {string} callId - related call identifier (optional).
   */

  /**
   * Signals a stream track was stopped (known issue: does not work on Firefox)
   *
   * @event Stream#trackStopped
   * @type {object}
   * @property {string} type 'video' or 'audio'
   * @property {string} id track id
   */

  /**
   * Stream current audio amplitude obtained from audio analysis
   *
   * @event Stream#audioAmplitude
   * @type {number}
   */

  /**
   * Stream current audio amplitude & speaking status info obtained from audio analysis
   *
   * @event Stream#audioAmplitudeInfo
   * @type {object}
   * @property {number} amplitude - amplitude.
   * @property {boolean} isSpeaking - is sound/speaking detected considering threshold
   */

  /**
   * Deprecated - Emitted when stream video or audio mute state changed
   *
   * @event Stream#muteStateChange
   * @type {object}
   * @property {number} streamId - stream identifier.
   * @property {string} userMediaStreamId - user media stream identifier (optional).
   * @property {string} callId - related call identifier (optional).
   * @property {string} type 'video' or 'audio'
   * @property {boolean} muted new state
   */

  /**
   * Emitted when stream video or audio active state changed
   *
   * @event Stream#activeStateChange
   * @type {object}
   * @property {number} streamId - stream identifier.
   * @property {callId} callId - identifier of related call.
   * @property {string} type 'video' or 'audio'
   * @property {boolean} active new state
   */

  /**
   * Emitted when a filter is applied on stream and the user hides current navigator tab
   *
   * @event Stream#backgroundSubstractionStopVisibilityChange
   * @type {object}
   * @property {number} streamId - stream identifier.
   * @property {string} userMediaStreamId - user media stream identifier
   */

  /**
   * Emitted when the background substraction process is stopped due to bad filter frame rate
   *
   * @event Stream#backgroundSubstractionStopComputeTime
   * @type {object}
   * @property {number} streamId - stream identifier.
   * @property {string} userMediaStreamId - user media stream identifier
   */

  /**
   * Emitted when a snapshot is taken of stream with AI annotation
   *
   * @event Stream#AIESnapshot
   * @type {object}
   * @property {Image} image - The snapshot
   */

  /**
   * Emitted when a log is generated after a new AI annotation
   *
   * @event Stream#AIELog
   * @type {object}
   * @property {string} log - log informations
   */

  /**
   * @typedef MediaStreamTrackFlowStatus
   * @type {Object}
   * @property {boolean} enabled the status of the track that is handled by apiRTC at the application level
   * @property {boolean} muted the status of the track that is NOT handled by apiRTC, maybe at a browser level, network error, or something else.
   */

  /**
   * Emitted when either enabled or muted value changed for the audio track of the stream
   * 
   * @event Stream#audioFlowStatusChanged
   * @type {MediaStreamTrackFlowStatus}
   */

  /**
   * Emitted when either enabled or muted value changed for the video track of the stream
   * 
   * @event Stream#videoFlowStatusChanged
   * @type {MediaStreamTrackFlowStatus}
   */

  /**
   * Emitted, on a stream you subscribed, when either enabled or muted value changed for the audio track by the publisher
   * 
   * @event Stream#remoteAudioFlowStatusChanged
   * @type {MediaStreamTrackFlowStatus}
   */

  /**
   * Emitted, on a stream you subscribed, when either enabled or muted value changed for the video track by the publisher
   * 
   * @event Stream#remoteVideoFlowStatusChanged
   * @type {MediaStreamTrackFlowStatus}
   */

  /**
   * Emitted, on a stream release
   * 
   * @event Stream#release
   * @type {object}
   */

  /*
   * Creates a new stream
   *
   *  @param {MediaStream} data Stream data, can be set to null in case stream is not initialized yet
   *  @param {StreamOptions} options options.type is required
   *  @returns {Stream}
   */
  function Stream(data) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Stream);

    _this = _super.call(this, logger);

    if (options.constructor === true) {
      //logger.error('Constructor of Stream is used internaly');
      delete options.constructor;
    } else {
      throw new Error('Stream constructor should not be used directly, please use a static method of class Stream such as : createStreamFromUserMedia, createStreamFromMediaStream, createScreensharingStream'); //logger.error('Stream constructor should not be used directly, please use a static method of class Stream such as : createStreamFromUserMedia, createStreamFromMediaStream, createScreensharingStream');
    }

    if (!options.hasOwnProperty('type')) {
      throw new Error('Cannot create Stream with no type');
    }

    logger.debug('Create Stream with options', options);
    _this.data = data;
    _this.audioInput = options.hasOwnProperty('audioInput') ? options.audioInput : null;
    _this.videoInput = options.hasOwnProperty('videoInput') ? options.videoInput : null;
    _this.audioFilterIsApplied = false;
    _this.videoFilterIsApplied = false;
    _this.audioAppliedFilter = 'none';
    _this.videoAppliedFilter = 'none';
    _this.originalMediaTrack = null;

    if (options.hasOwnProperty('userMediaStreamId')) {
      _this.userMediaStreamId = options.userMediaStreamId;
      _this.isRemote = false;

      _localStreams.set(_this.userMediaStreamId, _assertThisInitialized(_this));
    } else {
      _this.userMediaStreamId = null;
      _this.isRemote = true;
    }

    if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'streamId', 'number')) {
      _this.streamId = options.streamId;
    } else if (_this.userMediaStreamId !== null) {
      _this.streamId = Number(_this.userMediaStreamId);
    } else if (Number.MAX_SAFE_INTEGER !== undefined) {
      _this.streamId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
    } else {
      _this.streamId = Math.floor(Math.random() * 1024 * 1024 * 1024);
    }

    _this.contact = options.hasOwnProperty('contact') ? options.contact : null;

    if (options.hasOwnProperty('callId')) {
      _this.callId = options.callId;
      _this.callAudioAvailable = options.callAudioAvailable;
      _this.callAudioActive = options.callAudioActive;
      _this.callAudioMuted = options.callAudioMuted;
      _this.callAudioSilent = options.callAudioSilent;
      _this.callVideoAvailable = options.callVideoAvailable;
      _this.callVideoActive = options.callVideoActive;
      _this.callVideoMuted = options.callVideoMuted;
      _this.callVideoSilent = options.callVideoSilent;
    } else {
      _this.callId = null;
    }

    _this.publishedInConversations = new Map();
    _this.mediaRecorder = null;
    _this.recordedBlobs = [];

    _isScreensharingStream.set(_assertThisInitialized(_this), options.hasOwnProperty('screensharing') ? options.screensharing : false);

    _audioJavascriptNode.set(_assertThisInitialized(_this), null);

    _audioSourceNode.set(_assertThisInitialized(_this), null);

    _this.type = options.type;
    _this.promises = [];

    if (apiRTC.browser !== 'IE') {
      if (_this.data !== null) {
        //this.enableAudioAnalysis();
        var fireOnEnded = function fireOnEnded(track) {
          track.addEventListener('ended', function (stream) {
            if (!trackStoppedReference.hasOwnProperty(track.id)) {
              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('trackStopped', {
                type: track.kind,
                id: track.id
              });

              trackStoppedReference[track.id] = true;
            }
          });
        };

        var _iterator = _createForOfIteratorHelper(_this.data.getVideoTracks()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var videoTrack = _step.value;
            fireOnEnded(videoTrack);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var _iterator2 = _createForOfIteratorHelper(_this.data.getAudioTracks()),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var audioTrack = _step2.value;
            fireOnEnded(audioTrack);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }

    var apiRTCEventListeners = {};

    if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(_this.userMediaStreamId, 'string')) {
      // Local stream, i.e. user media.
      apiRTCEventListeners.userMediaStop = function (e) {
        if (e.detail.userMediaStreamId === _this.userMediaStreamId) {
          // Emitting event to end user.
          var stopped = {
            streamId: _this.streamId,
            userMediaStreamId: _this.userMediaStreamId
          };

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('stopped', stopped); // Cleaning up all listeners.


          var listeners = _apiRTCEventListeners.get(_assertThisInitialized(_this));

          if (listeners) {
            for (var k in listeners) {
              apiRTC.removeEventListener(k, listeners[k]);
            }
          }
        }
      };

      apiRTCEventListeners.localStreamUpdated = function (e) {
        if (e.detail.userMediaStreamId === _this.userMediaStreamId && e.detail.callId === null) {
          // Emitting event to end user.
          if (e.detail.changeList.indexOf('audioIsMuted') >= 0) {
            var changed = {
              streamId: _this.streamId,
              userMediaStreamId: _this.userMediaStreamId,
              type: 'audio',
              muted: e.detail.audioIsMuted
            };

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('muteStateChange', changed);

            _this.sendAudioFlowStatusChanged();
          }

          if (e.detail.changeList.indexOf('videoIsMuted') >= 0) {
            var _changed = {
              streamId: _this.streamId,
              userMediaStreamId: _this.userMediaStreamId,
              type: 'video',
              muted: e.detail.videoIsMuted
            };

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('muteStateChange', _changed);

            _this.sendVideoFlowStatusChanged();
          }

          if (e.detail.changeList.indexOf('audioIsSilent') >= 0) {
            _this.sendAudioFlowStatusChanged();
          }

          if (e.detail.changeList.indexOf('videoIsSilent') >= 0) {
            _this.sendVideoFlowStatusChanged();
          }
        }
      };

      apiRTCEventListeners.backgroundSubstractionStopVisibilityChange = function (e) {
        if (e.detail.userMediaStreamId === _this.userMediaStreamId) {
          var stopped = {
            streamId: _this.streamId,
            userMediaStreamId: _this.userMediaStreamId
          };

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('backgroundSubstractionStopVisibilityChange', stopped);
        }
      };

      apiRTCEventListeners.backgroundSubstractionStopComputeTime = function (e) {
        if (e.detail.userMediaStreamId === _this.userMediaStreamId) {
          var stopped = {
            streamId: _this.streamId,
            userMediaStreamId: _this.userMediaStreamId
          };

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('backgroundSubstractionStopComputeTime', stopped);
        }
      };

      apiRTCEventListeners.AIESnapshot = function (e) {
        if (e.detail.userMediaStreamId === _this.userMediaStreamId) {
          var image = e.detail.image;

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('AIESnapshot', image);
        }
      };

      apiRTCEventListeners.AIELog = function (e) {
        if (e.detail.userMediaStreamId === _this.userMediaStreamId) {
          var log = e.detail.log;

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('AIELog', log);
        }
      };
    } else if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isTypeof(_this.callId, 'string')) {
      // Remote stream.
      apiRTCEventListeners.hangup = function (e) {
        if (e.detail.hangupType === 'remote' && e.detail.callId === _this.callId) {
          // Emitting event to end user.
          var stopped = {
            streamId: _this.streamId,
            callId: _this.callId
          };

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('stopped', stopped); // Cleaning up all listeners.


          var listeners = _apiRTCEventListeners.get(_assertThisInitialized(_this));

          for (var k in listeners) {
            apiRTC.removeEventListener(k, listeners[k]);
          }
        }
      };

      apiRTCEventListeners.remoteStreamUpdated = function (e) {
        if (e.detail.callId === _this.callId) {
          if (e.detail.changeList.indexOf('audioIsActive') >= 0) {
            _this.callAudioActive = e.detail.audioIsActive;
            var changed = {
              streamId: _this.streamId,
              callId: _this.callId,
              type: 'audio',
              active: e.detail.audioIsActive
            };

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('activeStateChange', changed);
          }

          if (e.detail.changeList.indexOf('audioIsMuted') >= 0) {
            _this.callAudioMuted = e.detail.audioIsMuted;
            var _changed2 = {
              streamId: _this.streamId,
              callId: _this.callId,
              type: 'audio',
              muted: e.detail.audioIsMuted
            };

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('muteStateChange', _changed2);

            _this.sendRemoteAudioFlowStatusChanged({
              enabled: e.detail.audioIsMuted,
              muted: e.detail.audioIsSilent
            });
          }

          if (e.detail.changeList.indexOf('videoIsActive') >= 0) {
            _this.callVideoActive = e.detail.videoIsActive;
            var _changed3 = {
              streamId: _this.streamId,
              callId: _this.callId,
              type: 'video',
              active: e.detail.videoIsActive
            };

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('activeStateChange', _changed3);
          }

          if (e.detail.changeList.indexOf('videoIsMuted') >= 0) {
            _this.callVideoMuted = e.detail.videoIsMuted;
            var _changed4 = {
              streamId: _this.streamId,
              callId: _this.callId,
              type: 'video',
              muted: e.detail.videoIsMuted
            };

            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('muteStateChange', _changed4);

            _this.sendRemoteVideoFlowStatusChanged({
              enabled: e.detail.videoIsMuted,
              muted: e.detail.videoIsSilent
            });
          }

          if (e.detail.changeList.indexOf('audioIsSilent') >= 0) {
            _this.callAudioSilent = e.detail.audioIsSilent;

            _this.sendRemoteAudioFlowStatusChanged({
              enabled: e.detail.audioIsMuted,
              muted: e.detail.audioIsSilent
            });
          }

          if (e.detail.changeList.indexOf('videoIsSilent') >= 0) {
            _this.callVideoSilent = e.detail.videoIsSilent;

            _this.sendRemoteVideoFlowStatusChanged({
              enabled: e.detail.videoIsMuted,
              muted: e.detail.videoIsSilent
            });
          }

          if (e.detail.changeList.indexOf('audioIsSilentLocally') >= 0) {
            _this.sendAudioFlowStatusChanged();
          }

          if (e.detail.changeList.indexOf('videoIsSilentLocally') >= 0) {
            _this.sendVideoFlowStatusChanged();
          }
        }
      };
    } // Registering listeners.


    if (Object.keys(apiRTCEventListeners).length > 0) {
      _apiRTCEventListeners.set(_assertThisInitialized(_this), apiRTCEventListeners);

      for (var k in apiRTCEventListeners) {
        apiRTC.addEventListener(k, apiRTCEventListeners[k]);
      }
    }

    return _this;
  }
  /**
   * Returns available events for this class
   *
   *  @returns {Array<string>}
   */


  _createClass(Stream, [{
    key: "getContact",
    value:
    /**
     * Gets the stream's owner, returns null if the stream is local
     *
     *  @returns {Contact}
     */
    function getContact() {
      return this.contact;
    }
    /**
     * Gets the stream's MediaStream object, returns null if the stream has no data
     *
     *  @returns {MediaStream}
     */

  }, {
    key: "getData",
    value: function getData() {
      return this.data;
    }
    /**
     * Returns conversations the stream is published in
     *
     *  @returns {Conversation[]}
     */

  }, {
    key: "getConversations",
    value: function getConversations() {
      var res = [];

      var _iterator3 = _createForOfIteratorHelper(this.publishedInConversations.keys()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var key = _step3.value;
          res.push(conversationCatalog.getConversations(key));
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return res;
    }
    /**
     * Checks if stream is a screenshare
     *
     *  @returns {boolean}
     */

  }, {
    key: "isScreensharing",
    value: function isScreensharing() {
      return _isScreensharingStream.get(this);
    }
    /**
     * Checks if stream has mediastream tracks or data
     *
     * @returns {boolean}
     */

  }, {
    key: "hasData",
    value: function hasData() {
      return this.data !== null;
    }
    /**
     * Checks if stream has at least one video track
     *
     * @returns {boolean}
     */

  }, {
    key: "hasVideo",
    value: function hasVideo() {
      if (this.callId) {
        // Remote stream.
        return this.callVideoAvailable && this.callVideoActive;
      } else if (this.hasData()) {
        // Local stream.
        return this.data.getVideoTracks().length > 0;
      }

      return false;
    }
    /**
     * Checks if stream has at least one audio track
     *
     * @returns {boolean}
     */

  }, {
    key: "hasAudio",
    value: function hasAudio() {
      if (this.callId) {
        // Remote stream.
        return this.callAudioAvailable && this.callAudioActive;
      } else if (this.hasData()) {
        // Local stream.
        return this.data.getAudioTracks().length > 0;
      }

      return false;
    }
    /**
     * Returns whether the video track in muted.
     *
     * @return {boolean} true if the video track is muted, false otherwise.
     */

  }, {
    key: "isVideoMuted",
    value: function isVideoMuted() {
      if (this.callId) {
        // Remote stream.
        return this.callVideoMuted;
      } else if (this.hasData()) {
        // Local stream.
        var tracks = this.data.getVideoTracks();
        return tracks && tracks.length > 0 && !tracks[0].enabled;
      }

      return false;
    }
    /**
     * Returns whether the audio track in muted.
     *
     * @return {boolean} true if the audio track is muted, false otherwise.
     */

  }, {
    key: "isAudioMuted",
    value: function isAudioMuted() {
      if (this.callId) {
        // Remote stream.
        return this.callAudioMuted;
      } else if (this.hasData()) {
        // Local stream.
        var tracks = this.data.getAudioTracks();
        return tracks && tracks.length > 0 && !tracks[0].enabled;
      }

      return false;
    }
    /**
     * Returns this stream's type
     *
     *  @returns {String} type
     */

  }, {
    key: "getType",
    value: function getType() {
      return this.type;
    }
    /**
     * @typedef StreamReleaseOptions
     * @type {Object}
     * @property {Boolean} releaseParentStream=true release will also apply on parent streams if exist (streams for noiseReduction, blur ...)
     * @property {Boolean} releaseChildrenStream=true release will also apply on children streams if exist (streams for noiseReduction, blur ...)
     */

    /**
     * Release all tracks (either video or audio) used by this stream
     *  @param {StreamReleaseOptions} options
     *  @returns {Void}
     */

  }, {
    key: "release",
    value: function release() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this.childType === 'noiseReduction' && this.parent !== undefined) {
        //This is a noiseReduction Stream, need to stop all audioNode process
        apiCC.audioProcessor.stopAudioNodeCtx(this.parent.nodeCtx); //Reactivation of active Speaker on parent

        var userMediaStream = apiCC.getUserMediaStream(this.parent.userMediaStreamId);
        apiCC.audioProcessor.listenToAudio(this.parent.data, userMediaStream);
      }

      if (this.hasData()) {
        this.releaseAudio();
        this.releaseVideo();
        this.data = null;

        if (this.userMediaStreamId) {
          apiCC.releaseUserMediaStream(this.userMediaStreamId);

          _localStreams["delete"](this.userMediaStreamId);
        }
      }

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('release', {
        streamId: this.streamId,
        userMediaStreamId: this.userMediaStreamId
      });

      if (options.releaseChildrenStream !== false) {
        this.releaseAllChildren();
      }

      if (options.releaseParentStream !== false) {
        if (this.parent !== undefined) {
          logger.debug("release parent is also requested");
          this.parent.release(options);
        }
      }
    }
    /*
     * Release all audio tracks used by this stream
     *
     *  @returns {Void}
     */

  }, {
    key: "releaseAudio",
    value: function releaseAudio() {
      var _this2 = this;

      if (this.hasData()) {
        this.disableAudioAnalysis();
        this.data.getAudioTracks().forEach(function (track) {
          track.stop();

          if (!trackStoppedReference.hasOwnProperty(track.id)) {
            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_this2).emit('trackStopped', {
              type: track.kind,
              id: track.id
            });

            trackStoppedReference[track.id] = true;
          }
        });
      }
    }
    /*
     * Release all Video tracks used by this stream
     *
     *  @returns {Void}
     */

  }, {
    key: "releaseVideo",
    value: function releaseVideo() {
      var _this3 = this;

      if (this.hasData()) {
        this.data.getVideoTracks().forEach(function (track) {
          track.stop();

          if (!trackStoppedReference.hasOwnProperty(track.id)) {
            _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_this3).emit('trackStopped', {
              type: track.kind,
              id: track.id
            });

            trackStoppedReference[track.id] = true;
          }
        });
      }
    }
    /**
     * Deprecated - Mutes this stream's audio
     * If this stream is published to another contact, the stream will also be muted on the contact's side
     * If this stream is subscribed from another contact, muting the stream will have no impact on the contact's side
     *
     *  @returns {Void}
     */

  }, {
    key: "muteAudio",
    value: function muteAudio() {
      logger.warn('This method is deprecated now, please use Stream.disableAudio() instead');
      this.disableAudio();
    }
    /**
     * Deprecated - Mutes this stream's video
     * If this stream is published to another contact, the stream will also be muted on the contact's side
     * If this stream is subscribed from another contact, muting the stream will have no impact on the contact's side
     *
     *  @returns {Void}
     */

  }, {
    key: "muteVideo",
    value: function muteVideo() {
      logger.warn('This method is deprecated now, please use Stream.disableVideo() instead');
      this.disableVideo();
    }
    /**
     * Deprecated - Unmutes this stream's audio
     * If this stream is published to another contact, the stream will also be unmuted on the contact's side
     * If this stream is subscribed from another contact, unmuting the stream will have no impact on the contact's side, moreover, it will not unmute the stream if it has been muted by the contact
     *
     *  @returns {Void}
     */

  }, {
    key: "unmuteAudio",
    value: function unmuteAudio() {
      logger.warn('This method is deprecated now, please use Stream.enableAudio() instead');
      this.enableAudio();
    }
    /**
     * Deprecated - Unmutes this stream's video
     * If this stream is published to another contact, the stream will also be unmuted on the contact's side
     * If this stream is subscribed from another contact, muting the stream will have no impact on the contact's side, moreover, it will not unmute the stream if it has been muted by the contact
     *
     *  @returns {Void}
     */

  }, {
    key: "unmuteVideo",
    value: function unmuteVideo() {
      logger.warn('This method is deprecated now, please use Stream.enableVideo() instead');
      this.enableVideo();
    }
    /**
     * Enables this stream's audio
     * If this stream is published to another contact, the stream will also be enabled on the contact's side
     * If this stream is subscribed from another contact, enabling the stream will have no impact on the contact's side, moreover, it will not enable the stream if it has been disabled by the contact
     *
     *  @returns {Void}
     */

  }, {
    key: "enableAudio",
    value: function enableAudio() {
      if (this.userMediaStreamId) {
        // Local stream.
        var userMediaStream = apiCC.getUserMediaStream(this.userMediaStreamId);

        if (userMediaStream) {
          userMediaStream.unMuteAudioOnStreams("enabled");
        }
      } else if (this.callId) {
        // Remote stream.
        if (this.hasData()) {
          this.data.getAudioTracks().forEach(function (track) {
            track.enabled = true;
          });
          this.sendAudioFlowStatusChanged();
        }
      }

      if (this.childType === 'noiseReduction' && this.parent !== undefined) {
        logger.debug('this is a noiseReduction stream, need to unmute parent if necessary');
        this.parent.enableAudio();
      }
    }
    /**
     * Disables this stream's audio
     * If this stream is published to another contact, the stream will also be disabled on the contact's side
     * If this stream is subscribed from another contact, disabling the stream will have no impact on the contact's side
     *
     *  @returns {Void}
     */

  }, {
    key: "disableAudio",
    value: function disableAudio() {
      if (this.userMediaStreamId) {
        // Local stream.
        var userMediaStream = apiCC.getUserMediaStream(this.userMediaStreamId);

        if (userMediaStream) {
          userMediaStream.muteAudioOnStreams("enabled");
        }
      } else if (this.callId) {
        // Remote stream.
        if (this.hasData()) {
          this.data.getAudioTracks().forEach(function (track) {
            track.enabled = false;
          });
          this.sendAudioFlowStatusChanged();
        }
      }
    }
    /**
     * Enables this stream's video
     * If this stream is published to another contact, the stream will also be enabled on the contact's side
     * If this stream is subscribed from another contact, enabling the stream will have no impact on the contact's side, moreover, it will not enable the stream if it has been disabled by the contact
     *
     *  @returns {Void}
     */

  }, {
    key: "enableVideo",
    value: function enableVideo() {
      if (this.userMediaStreamId) {
        // Local stream.
        var userMediaStream = apiCC.getUserMediaStream(this.userMediaStreamId);

        if (userMediaStream) {
          userMediaStream.unMuteVideoOnStreams("enabled");
        }
      } else if (this.callId) {
        // Remote stream.
        if (this.hasData()) {
          this.data.getVideoTracks().forEach(function (track) {
            track.enabled = true;
          });
          this.sendVideoFlowStatusChanged("enabled");
        }
      }

      if ((this.childType === 'blur' || this.childType === 'backgroundImage') && this.parent !== undefined) {
        logger.debug('this is a blur or backgroundImage stream, need to unmute parent if necessary');
        this.parent.enableVideo();
      }
    }
    /**
     * Disables this stream's video
     * If this stream is published to another contact, the stream will also be disabled on the contact's side
     * If this stream is subscribed from another contact, disabling the stream will have no impact on the contact's side
     *
     *  @returns {Void}
     */

  }, {
    key: "disableVideo",
    value: function disableVideo() {
      if (this.userMediaStreamId) {
        // Local stream.
        var userMediaStream = apiCC.getUserMediaStream(this.userMediaStreamId);

        if (userMediaStream) {
          userMediaStream.muteVideoOnStreams("enabled");
        }
      } else if (this.callId) {
        // Remote stream.
        if (this.hasData()) {
          this.data.getVideoTracks().forEach(function (track) {
            track.enabled = false;
          });
          this.sendVideoFlowStatusChanged();
        }
      }
    }
    /**
     * Returns the audio flow status of this stream (i.e. if you enabled/disabled it or if the track is muted or not)
     * The flow status returned is corresponding to this stream instance, if this is a subscribed stream do not be confused with the publisher flow status.
     * 
     * @returns {MediaStreamTrackFlowStatus}
     */

  }, {
    key: "getAudioFlowStatus",
    value: function getAudioFlowStatus() {
      var result = {};
      this.data.getAudioTracks().forEach(function (track) {
        result.enabled = track.enabled;
        result.muted = track.muted;
      });
      return result;
    }
    /**
     * Returns the video flow status of this stream (i.e. if you enabled/disabled it or if the track is muted or not)
     * The flow status returned is corresponding to this stream instance, if this is a subscribed stream do not be confused with the publisher flow status.
     * 
     * @returns {MediaStreamTrackFlowStatus}
     */

  }, {
    key: "getVideoFlowStatus",
    value: function getVideoFlowStatus() {
      var result = {};
      this.data.getVideoTracks().forEach(function (track) {
        result.enabled = track.enabled;
        result.muted = track.muted;
      });
      return result;
    }
    /**
     * To use on subscribed streams only
     * Returns the audio flow status of the stream on publisher side (i.e. if publisher enabled/disabled it or if the track is muted or not)
     * 
     * @returns {Promise<MediaStreamTrackFlowStatus>}
     */

  }, {
    key: "getRemoteAudioFlowStatus",
    value: function getRemoteAudioFlowStatus() {
      var _this4 = this;

      return new Promise(function (resolve, reject) {
        if (_this4.isRemote) {
          logger.debug('getRemoteAudioFlowStatus()');

          if (_this4.contact !== null) {
            var timeout = _this4.addPendingPromise('getRemoteAudioFlowStatus', resolve, reject);

            _this4.contact.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_REMOTE_AUDIO_FLOW_STATUS_IDENTIFIER, {
              requesterId: _Session__WEBPACK_IMPORTED_MODULE_3__.Session.getActiveSession().getUserAgent().userId,
              callId: _this4.callId,
              streamId: _this4.getId(),
              timeout: timeout
            });
          } else {
            return reject('No contact associated');
          }
        } else {
          return reject('Please use this function on a remote Stream');
        }
      });
    }
    /**
     * To use on subscribed streams only
     * Returns the video flow status of the stream on publisher side (i.e. if publisher enabled/disabled it or if the track is muted or not)
     * 
     * @returns {Promise<MediaStreamTrackFlowStatus>}
     */

  }, {
    key: "getRemoteVideoFlowStatus",
    value: function getRemoteVideoFlowStatus() {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        if (_this5.isRemote) {
          logger.debug('getRemoteVideoFlowStatus()');

          if (_this5.contact !== null) {
            var timeout = _this5.addPendingPromise('getRemoteVideoFlowStatus', resolve, reject);

            _this5.contact.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_REMOTE_VIDEO_FLOW_STATUS_IDENTIFIER, {
              requesterId: _Session__WEBPACK_IMPORTED_MODULE_3__.Session.getActiveSession().getUserAgent().userId,
              callId: _this5.callId,
              streamId: _this5.getId(),
              timeout: timeout
            });
          } else {
            return reject('No contact associated');
          }
        } else {
          return reject('Please use this function on a remote Stream');
        }
      });
    }
    /**
     * Attaches stream to video DOM element
     *
     *  @param {HTMLElement} element
     *  @returns {void}
     */

  }, {
    key: "attachToElement",
    value: function attachToElement(element) {
      logger.debug('attachToElement');
      apiRTCManager.attachMediaStream(element, this.data);
    }
    /**
     * Detaches stream to video DOM element
     * 
     *  @param {HTMLElement} element
     *  @returns {void}
     */

  }, {
    key: "detachFromElement",
    value: function detachFromElement(element) {
      logger.debug('detachFromElement');
      apiRTCManager.detachMediaStream(element, this.data);
    }
    /**
     * Add stream to DIV elementz
     *
     *  @param {String} divId Div Id where to add the stream
     *  @param {String} mediaEltId Id of the media element that will be added in the div
     *  @param {String} style Json string with format {width : "160px", height : "120px"} to define width and height of the media element
     *  @param {Boolean} muted Boolean to set if media element is muted or not
     *  @returns {void}
     */

  }, {
    key: "addInDiv",
    value: function addInDiv(divId, mediaEltId, style, muted, options) {
      logger.debug('addInDiv');
      apiRTCManager.addStreamInDiv(this.data, this.type, divId, mediaEltId, style, muted, options);
    }
    /**
     * Remove stream from DIV element
     *
     *  @param {String} divId Div Id where to add the stream
     *  @param {String} mediaEltId Id of the media element that will be added in the div
     *  @returns {void}
     */

  }, {
    key: "removeFromDiv",
    value: function removeFromDiv(divId, mediaEltId) {
      logger.debug('removeFromDiv');
      apiRTCManager.removeElementFromDiv(divId, mediaEltId);
    }
    /**
     * @typedef MediaRecorderOptions
     * @type {Object}
     * @property {DOMString} mimeType The container and codec format(s) [RFC2046] for the recording, which may include any parameters that are defined for the format
     * @property {unsigned_Long} audioBitsPerSecond Aggregate target bits per second for encoding of the Audio track(s), if any.
     * This is a hint for the encoder and the value might be surpassed, not achieved, or only be achieved over a long period of time.
     * @property {unsigned_Long} videoBitsPerSecond Aggregate target bits per second for encoding of the Video track(s), if any.
     * This is a hint for the encoder and the value might be surpassed, not achieved, or only be achieved over a long period of time.
     * @property {unsigned_Long} bitsPerSecond Aggregate target bits per second for encoding of all Video and Audio Track(s) present.
     * This parameter overrides either audioBitsPerSecond or videoBitsPerSecond if present, and might be distributed among the present track encoders as the UA sees fit.
     * This parameter is a hint for the encoder(s) and the total value might be surpassed, not achieved, or only be achieved over a long period of time.
     */

    /**
     * Starts the recording of the stream with a promise
     * The stream is recorded locally
     * The stream can only have one record process active at a time
     *  @param {MediaRecorderOptions} options
     *  @returns {Promise<void>}
     */

  }, {
    key: "startRecord",
    value: function startRecord(options) {
      logger.info('startRecord :', options);
      return apiCC.recordMgr.record(this.data, options);
    }
    /**
     * Stops the recording of the stream with a promise
     *
     *  @returns {Promise<Blob>} Blob of the recorded stream in promise
     */

  }, {
    key: "stopRecord",
    value: function stopRecord() {
      logger.info('stopRecord() - Stopping record');
      return apiCC.recordMgr.stop();
    }
    /**
     * Pause the recording of the stream with a promise
     *  @returns {Promise<void>}
     */

  }, {
    key: "pauseRecord",
    value: function pauseRecord() {
      logger.info('pauseRecord() - Pausing record');
      return apiCC.recordMgr.pause();
    }
    /**
     * Resume the recording of the stream with a promise
     *  @returns {Promise<void>}
     */

  }, {
    key: "resumeRecord",
    value: function resumeRecord() {
      logger.info('resumeRecord() - Resuming record');
      return apiCC.recordMgr.resume();
    }
    /**
     * Enables audio analysis of Stream
     * This allows the Stream#audioAmplitude event to be emitted
     *
     *  @returns {void}
     */

  }, {
    key: "enableAudioAnalysis",
    value: function enableAudioAnalysis() {
      var _this6 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      logger.info('enableAudioAnalysis()');
      var audioContext = _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.getAudioContext(),
          timer = null,
          notified = false;

      var sourceNode = _audioSourceNode.get(this);

      var javascriptNode = _audioJavascriptNode.get(this);

      if (!audioContext) {
        logger.error('enableAudioAnalysis() - AudioContext is not available, unable to enable audio analysis');
      } else if (!this.hasData()) {
        logger.error('enableAudioAnalysis() - Stream has no data, unable to enable audio analysis');
      } else if (sourceNode !== null || javascriptNode !== null) {
        logger.error('enableAudioAnalysis() - Audio analysis already enabled');
      } else {
        sourceNode = audioContext.createMediaStreamSource(this.data);
        javascriptNode = audioContext.createScriptProcessor(2048, 1, 1); // Connect to destination, otherwise it isn't called

        javascriptNode.connect(audioContext.destination); // Process information from the analyser node to get amplitude

        javascriptNode.onaudioprocess = function () {
          // Get the average for the first channel
          var array = new Uint8Array(javascriptNode.analyser.frequencyBinCount);
          var amplitude;
          var values = 0;
          javascriptNode.analyser.getByteFrequencyData(array); // Get all the frequency amplitudes

          var _iterator4 = _createForOfIteratorHelper(array),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var value = _step4.value;
              values += value;
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          amplitude = values / array.length;

          _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_this6).emit('audioAmplitude', amplitude); // Calculate speaking or not state
          // Take first ~10% max values (more sensitive tnan avg)


          var maxValues = 0;
          array.sort(function (a, b) {
            return b - a;
          });
          array = array.slice(0, 50);

          for (var i = 0; i < array.length; i++) {
            maxValues += array[i];
          }

          amplitude = maxValues / array.length;
          var threshold = typeof options.threshold === 'number' ? options.threshold : _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_AUDIO_ANALYSIS_THRESHOLD; // Keep 'active' status inside timeframe

          if (amplitude > threshold) {
            if (!notified) {
              notified = true;

              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_this6).emit('audioAmplitudeInfo', {
                amplitude: amplitude,
                isSpeaking: true
              });
            }

            if (timer !== null) {
              clearTimeout(timer);
            }

            timer = setTimeout(function () {
              _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_this6).emit('audioAmplitudeInfo', {
                amplitude: amplitude,
                isSpeaking: false
              });

              notified = false;
            }, 1000);
          }
        }; // Setup a analyzer


        javascriptNode.analyser = audioContext.createAnalyser();
        javascriptNode.analyser.smoothingTimeConstant = 0.5;
        javascriptNode.analyser.fftSize = 1024; // Connect the source to the analyser

        sourceNode.connect(javascriptNode.analyser);
        javascriptNode.analyser.connect(javascriptNode);

        _audioJavascriptNode.set(this, javascriptNode);

        _audioSourceNode.set(this, sourceNode);
      }
    }
    /**
     * Disables audio analysis of Stream
     * The Stream#audioAmplitude event will no longer be emitted
     *
     *  @returns {void}
     */

  }, {
    key: "disableAudioAnalysis",
    value: function disableAudioAnalysis() {
      logger.info('disableAudioAnalysis()');

      var sourceNode = _audioSourceNode.get(this);

      var javascriptNode = _audioJavascriptNode.get(this); // Free nodes


      if (sourceNode !== null) {
        sourceNode.disconnect();
      }

      if (javascriptNode !== null) {
        javascriptNode.analyser.disconnect();
        javascriptNode.disconnect();
      }

      _audioJavascriptNode.set(this, null);

      _audioSourceNode.set(this, null);
    }
    /**
     * @typedef SnapshotOptions
     * @type {Object}
     * @property {Object} filters
     * @property {Object} filters.blur A CSS <length>. Applies a Gaussian blur to the drawing.
     * It defines the value of the standard deviation to the Gaussian function, i.e., how many pixels on the screen blend into each other;
     * thus, a larger value will create more blur. A value of 0 leaves the input unchanged.
     * @property {Object} filters.brightness A CSS <percentage>. Applies a linear multiplier to the drawing, making it appear brighter or darker.
     * A value under 100% darkens the image, while a value over 100% brightens it.
     * A value of 0% will create an image that is completely black, while a value of 100% leaves the input unchanged.
     * @property {Object} filters.contrast A CSS <percentage>. Adjusts the contrast of the drawing. A value of 0% will create a drawing that is completely black.
     * A value of 100% leaves the drawing unchanged.
     * @property {Object} filters.grayscale A CSS <percentage>. Converts the drawing to grayscale. A value of 100% is completely grayscale.
     * A value of 0% leaves the drawing unchanged.
     * @property {Object} filters.hue-rotate A CSS <angle>. Applies a hue rotation on the drawing. A value of 0deg leaves the input unchanged.
     * @property {Object} filters.invert A CSS <percentage>. Inverts the drawing. A value of 100% means complete inversion.
     * A value of 0% leaves the drawing unchanged.
     * @property {Object} filters.opacity A CSS <percentage>. Applies transparency to the drawing. A value of 0% means completely transparent.
     * A value of 100% leaves the drawing unchanged.
     * @property {Object} filters.saturate A CSS <percentage>. Saturates the drawing. A value of 0% means completely un-saturated.
     * A value of 100% leaves the drawing unchanged.
     * @property {Object} filters.sepia A CSS <percentage>. Converts the drawing to sepia. A value of 100% means completely sepia.
     * A value of 0% leaves the drawing unchanged.
     * @property {Object} output Enable to select the output format . Default format is a Data URI with image/png type. Value can be set to blob
     * output === 'blob'
     * @property {Object} outputMimeType A DOMString indicating the image format. The default type is image/png.
     * @property {Object} outputQualityArgument A Number between 0 and 1 indicating image quality if the requested type is image/jpeg or image/webp.
     * If this argument is anything else, the default values 0.92 and 0.80 are used for image/jpeg and image/webp respectively. Other arguments are ignored.
     * @property {Object} width Enable to select the width of the snapshot. Default value is the video width
     * @property {Object} height Enable to select the height of the snapshot. Default value is the video height
     * @property {Object} divId div identifier. If defined, snapshot will be done from the defined video div
     */

    /**
     * Takes a dataURI/png snapshot from stream
     *
     *  @param {SnapshotOptions} options
     *  @returns {Promise<string>} media PNG dataURI in promise
     */

  }, {
    key: "takeSnapshot",
    value: function takeSnapshot() {
      var _this7 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      logger.info('takeSnapshot()');
      var video = null,
          processImage = null;
      return new Promise(function (resolve, reject) {
        if (!_this7.hasData()) {
          var errorMsg = 'takeSnapshot() - Stream has no data, cannot get snapshot';
          logger.error(errorMsg);
          reject(new Error(errorMsg));
        } else {
          if (!_this7.hasVideo()) {
            logger.warn('takeSnapshot() - This stream does not have a video track');
          }

          video = document.createElement('video');

          processImage = function processImage(removeVideo) {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            if (options.hasOwnProperty('width')) {
              canvas.width = options.width;
            }

            if (options.hasOwnProperty('height')) {
              canvas.height = options.height;
            } // Set filters for snapshot


            if (options.hasOwnProperty('filters')) {
              var filters = [];

              for (var _i = 0, _Object$keys = Object.keys(options.filters); _i < _Object$keys.length; _i++) {
                var key = _Object$keys[_i];
                filters.push(key + '(' + options.filters[key] + ')');
              }

              context.filter = filters.join(' ');
            }

            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            if (removeVideo === true) {
              video.remove();
            }

            if (options.hasOwnProperty('output') && options.output === 'blob') {
              if (options.outputMimeType !== undefined) {
                logger.debug('options.outputMimeType is defined :', options.outputMimeType);
                canvas.toBlob(function (blob) {
                  resolve(blob);
                }, options.outputMimeType, options.outputQualityArgument);
              } else {
                canvas.toBlob(function (blob) {
                  resolve(blob);
                }, 'image/png');
              }
            } else {
              if (options.outputMimeType !== undefined) {
                logger.debug('options.outputMimeType is defined :', options.outputMimeType);
                resolve(canvas.toDataURL(options.outputMimeType, options.outputQualityArgument));
              } else {
                resolve(canvas.toDataURL('image/png'));
              }
            }
          };

          var canvas = document.createElement('canvas');
          var context = canvas.getContext('2d');

          if (options.divId === undefined || options.divId === null) {
            setTimeout(function () {
              _this7.attachToElement(video);

              video.addEventListener('canplay', function () {
                processImage(true);
              });
              video.muted = true;
              video.play();
              /*
                                  var playPromise = video.play();
                                  if (playPromise !== undefined) {
                                      playPromise.then(function() {
                                        // Automatic playback started!
                                        logger.error("play OK");
                                      }).catch(function(error) {
                                          logger.error("play error :", error);
                                      });
                                  }
              */
            }, 1000);
          } else {
            video = document.getElementById(options.divId);

            if (video === null) {
              logger.error('divId not found for snapshot');
            } else {
              processImage(false);
            }
          }
        }
      });
    }
    /**
     * Returns stream ID.
     *
     * @return {string} Stream ID.
     */

  }, {
    key: "getId",
    value: function getId() {
      return String(this.streamId);
    }
    /**
     * Returns the owner of the stream reprensented by this one.
     *
     * @return {UserAgent|Contact}
     */

  }, {
    key: "getOwner",
    value: function getOwner() {
      if (this.contact) {
        return this.contact;
      }

      return _Session__WEBPACK_IMPORTED_MODULE_3__.Session.getActiveSession().getUserAgent();
    }
    /**
     * @typedef StreamLabels
     * @type {Object}
     * @property {string} audioSourceLabel - Label of the audio source. If the corresponding source has or had no label, the attribute MUST instead return the empty string.
     * @property {string} videoSourceLabel - Label of the video source. If the corresponding source has or had no label, the attribute MUST instead return the empty string.
     */

    /**
     * Returns the labels of device source used for the stream.
     *
     * @return {StreamLabels}
     */

  }, {
    key: "getLabels",
    value: function getLabels() {
      var streamLabels = {};

      if (this.hasData() && this.data.getAudioTracks().length > 0) {
        streamLabels.audioSourceLabel = "";

        if (this.data.getAudioTracks()[0].label) {
          streamLabels.audioSourceLabel = this.data.getAudioTracks()[0].label;
        }
      }

      if (this.hasData() && this.data.getVideoTracks().length > 0) {
        streamLabels.videoSourceLabel = "";

        if (this.data.getVideoTracks()[0].label) {
          streamLabels.videoSourceLabel = this.data.getVideoTracks()[0].label;
        }
      }

      logger.debug("getLabels:", streamLabels);
      return streamLabels;
    }
  }, {
    key: "checkImageCaptureCompatibility",
    value: function checkImageCaptureCompatibility() {
      return typeof ImageCapture === "undefined";
    }
  }, {
    key: "getLocalMediaStreamTrack",
    value: function getLocalMediaStreamTrack() {
      var result = null;

      if (this.data.getVideoTracks().length === 1) {
        result = this.data.getVideoTracks()[0];
      }

      return result;
    }
  }, {
    key: "getLocalMediaStreamAudioTrack",
    value: function getLocalMediaStreamAudioTrack() {
      var result = null;

      if (this.data.getAudioTracks().length === 1) {
        result = this.data.getAudioTracks()[0];
      }

      return result;
    }
    /** There could be a problem when trying to set multiple capabilities that belongs to ImageCapture API and non ImageCapture API capabilities
     * ImageCapture API capabilities : whiteBalanceMode, exposureMode, focusMode, pointsOfInterest, exposureCompensation, colorTemperature, iso, brightness, contrast, pan, saturation, sharpness, focusDistance, tilt, zoom, torch
     * Others : width, height, frameRate, aspectRatio, facingMode, resizeMode
     * You have to set them separely in separated call
     */

    /**
     * Resets streams constraints and then applies specified constraints to specified values as webrtc applyConstraints function. This function also work on a remote stream.
     *  @param {MediaTrackConstraints} constraints - Object containing constraints to modify and their values to apply
     *  @returns {Promise<void>}
     */

  }, {
    key: "applyConstraints",
    value: function applyConstraints(constraints) {
      var _this8 = this;

      return new Promise(function (resolve, reject) {
        if (_this8.isRemote) {
          logger.debug("applyConstraints() on a remote stream");

          if (_this8.contact !== null) {
            var timeout = _this8.addPendingPromise('applyConstraints', resolve, reject);

            _this8.contact.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_APPLY_CONSTRAINTS_IDENTIFIER, {
              requesterId: _Session__WEBPACK_IMPORTED_MODULE_3__.Session.getActiveSession().getUserAgent().userId,
              callId: _this8.callId,
              streamId: _this8.getId(),
              timeout: timeout,
              constraints: constraints
            });
          } else {
            return reject('No contact associated');
          }
        } else {
          logger.debug("applyConstraints()");

          if (!MediaStreamTrack.prototype.hasOwnProperty('applyConstraints')) {
            return reject('Navigator not compatible with this function');
          }

          var promiseAudio = null;
          var promiseVideo = null;

          if (constraints === undefined) {
            return reject('Missing argument');
          }

          if (constraints.audio !== undefined) {
            promiseAudio = _this8.getLocalMediaStreamAudioTrack().applyConstraints(constraints.audio)["catch"](function (e) {
              return reject(e);
            });
          }

          if (constraints.video !== undefined) {
            promiseVideo = _this8.getLocalMediaStreamTrack().applyConstraints(constraints.video)["catch"](function (e) {
              return reject(e);
            });
          }

          Promise.all([promiseAudio, promiseVideo]).then(function (values) {
            if (values[0] !== null) {
              logger.debug('audio constraints applied');
            }

            if (values[1] !== null) {
              logger.debug('video constraints applied');
            }

            return resolve();
          });
        }
      });
    }
  }, {
    key: "applyConstraint",
    value: function applyConstraint(capability, value) {
      logger.error("Due to a certain amount of problems with this function it has been desactivated, please use Stream.applyConstraints instead");
    }
  }, {
    key: "setCapability",
    value: function setCapability(capability, value) {
      logger.error("Due to a certain amount of problems with this function it has been desactivated, please use Stream.applyConstraints instead");
    }
    /**
     * Get all capabilities for this stream and their actual values. This function also work for a remote stream.
     *  @returns {Promise<MediaTrackSettings>}
     */

  }, {
    key: "getSettings",
    value: function getSettings() {
      var _this9 = this;

      return new Promise(function (resolve, reject) {
        if (_this9.isRemote) {
          logger.debug("getSettings() on a remote stream");

          if (_this9.contact !== null) {
            var timeout = _this9.addPendingPromise('getSettings', resolve, reject);

            _this9.contact.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_SETTINGS_IDENTIFIER, {
              requesterId: _Session__WEBPACK_IMPORTED_MODULE_3__.Session.getActiveSession().getUserAgent().userId,
              callId: _this9.callId,
              streamId: _this9.getId(),
              timeout: timeout
            });
          } else {
            return reject('No contact associated');
          }
        } else {
          logger.debug("getSettings()");

          if (!MediaStreamTrack.prototype.hasOwnProperty('getSettings')) {
            return reject('Navigator not compatible with this function');
          }

          return resolve({
            audio: _this9.getStreamTrackSettings(_this9.getLocalMediaStreamAudioTrack()),
            video: _this9.getStreamTrackSettings(_this9.getLocalMediaStreamTrack())
          });
        }
      });
    }
  }, {
    key: "getStreamTrackSettings",
    value: function getStreamTrackSettings(streamTrack) {
      if (streamTrack !== null) {
        return streamTrack.getSettings();
      }
    }
    /**
     * Get all capabilities that may be modified for this stream and their accepted value ranges. This function also work for a remote stream.
     *  @returns {Promise<MediaTrackCapabilities>}
     */

  }, {
    key: "getCapabilities",
    value: function getCapabilities() {
      var _this10 = this;

      return new Promise(function (resolve, reject) {
        if (_this10.isRemote) {
          logger.debug("getCapabilities() on a remote stream");

          if (_this10.contact !== null) {
            var timeout = _this10.addPendingPromise('getCapabilities', resolve, reject);

            _this10.contact.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_CAPABILITIES_IDENTIFIER, {
              requesterId: _Session__WEBPACK_IMPORTED_MODULE_3__.Session.getActiveSession().getUserAgent().userId,
              callId: _this10.callId,
              streamId: _this10.getId(),
              timeout: timeout
            });
          } else {
            return reject('No contact associated');
          }
        } else {
          logger.debug("getCapabilities()");

          if (!MediaStreamTrack.prototype.hasOwnProperty('getCapabilities')) {
            return reject('Navigator not compatible with this function');
          }

          return resolve({
            audio: _this10.getStreamTrackCapabilities(_this10.getLocalMediaStreamAudioTrack()),
            video: _this10.getStreamTrackCapabilities(_this10.getLocalMediaStreamTrack())
          });
        }
      });
    }
  }, {
    key: "getStreamTrackCapabilities",
    value: function getStreamTrackCapabilities(streamTrack) {
      if (streamTrack !== null) {
        return streamTrack.getCapabilities();
      }

      return {};
    }
    /**
     * Get applied constraints on this stream. This function also work for a remote stream.
     *  @returns {Promise<MediaTrackConstraints>}
     */

  }, {
    key: "getConstraints",
    value: function getConstraints() {
      var _this11 = this;

      return new Promise(function (resolve, reject) {
        if (_this11.isRemote) {
          logger.debug("getConstraints() on a remote stream");

          if (_this11.contact !== null) {
            var timeout = _this11.addPendingPromise('getConstraints', resolve, reject);

            _this11.contact.sendCustomEvent(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.CONTACT_GET_CONSTRAINTS_IDENTIFIER, {
              requesterId: _Session__WEBPACK_IMPORTED_MODULE_3__.Session.getActiveSession().getUserAgent().userId,
              callId: _this11.callId,
              streamId: _this11.getId(),
              timeout: timeout
            });
          } else {
            return reject('No contact associated');
          }
        } else {
          logger.debug("getConstraints()");

          if (!MediaStreamTrack.prototype.hasOwnProperty('getConstraints')) {
            return reject('Navigator not compatible with this function');
          }

          return resolve({
            audio: _this11.getStreamTrackConstraints(_this11.getLocalMediaStreamAudioTrack()),
            video: _this11.getStreamTrackConstraints(_this11.getLocalMediaStreamTrack())
          });
        }
      });
    }
  }, {
    key: "getStreamTrackConstraints",
    value: function getStreamTrackConstraints(streamTrack) {
      if (streamTrack !== null) {
        return streamTrack.getConstraints();
      }

      return {};
    }
    /**
     * Takes a snapshot of the local stream and returns it as an Image object.
     *  @returns {Promise<Image>}
     */

  }, {
    key: "takePhoto",
    value: function takePhoto() {
      var _this12 = this;

      return new Promise(function (resolve, reject) {
        logger.debug("takePhoto()");

        if (_this12.checkImageCaptureCompatibility()) {
          reject('Your navigator is not compatible with takePhoto()');
          return;
        }

        var localMediaStreamTrack = _this12.getLocalMediaStreamTrack();

        if (localMediaStreamTrack !== null) {
          var imageCapture = new ImageCapture(localMediaStreamTrack);
          imageCapture.takePhoto().then(function (blob) {
            var i = new Image();
            i.src = URL.createObjectURL(blob);
            resolve(i);
          })["catch"](function (error) {
            reject('takePhoto() error: ', error);
            return;
          });
        } else {
          reject('No local mediaStreamTrack found');
          return;
        }
      });
    }
    /**
     * Activates the AI annotation filter process if options were correctly provided on stream creation.
     *  @returns {void}
     */

  }, {
    key: "activateAIAnnotations",
    value: function activateAIAnnotations() {
      var streamAIE = this.getStreamAIE();

      if (streamAIE !== null) {
        streamAIE.activateAnnotations();
      }
    }
    /**
     * Stops the AI annotation filter process
     *  @returns {void}
     */

  }, {
    key: "stopAIAnnotations",
    value: function stopAIAnnotations() {
      var streamAIE = this.getStreamAIE();

      if (streamAIE !== null) {
        streamAIE.stopAnnotations();
      }
    }
    /**
     * Activates a log return event on each new annotation information
     *  @param {number} [minLogPeriod] - the minimal time (in seconds) between two logs
     *  @returns {void}
     */

  }, {
    key: "activateAILogs",
    value: function activateAILogs() {
      var minLogPeriod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (typeof minLogPeriod !== "number") {
        return logger.error("minLogPeriod parameter must be an integer");
      }

      var streamAIE = this.getStreamAIE();

      if (streamAIE !== null) {
        streamAIE.activateLogs(minLogPeriod);
      }
    }
    /**
     * Stops the AI annotation logs process
     *  @returns {void}
     */

  }, {
    key: "stopAILogs",
    value: function stopAILogs() {
      var streamAIE = this.getStreamAIE();

      if (streamAIE !== null) {
        streamAIE.stopLogs();
      }
    }
    /**
     * Activates a snapshot of frames with AI annotations return event
     *  @param {number} [minSnapshotPeriod] - the minimal time (in seconds) between two snapshots
     *  @returns {void}
     */

  }, {
    key: "activateAISnapshots",
    value: function activateAISnapshots() {
      var minSnapshotPeriod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      if (typeof minSnapshotPeriod !== "number") {
        return logger.error("minSnapshotPeriod parameter must be an integer");
      }

      var streamAIE = this.getStreamAIE();

      if (streamAIE !== null) {
        streamAIE.activateSnapshots(minSnapshotPeriod);
      }
    }
    /**
     * Stops the AI annotation snapshot process
     *  @returns {void}
     */

  }, {
    key: "stopAISnapshots",
    value: function stopAISnapshots() {
      var streamAIE = this.getStreamAIE();

      if (streamAIE !== null) {
        streamAIE.stopSnapshots();
      }
    }
  }, {
    key: "getStreamAIE",
    value: function getStreamAIE() {
      var streamAIE = null;

      if (apiCC !== undefined) {
        var userMediaStream = apiCC.getUserMediaStream(this.userMediaStreamId);

        if (userMediaStream.mediaFilterManager !== null) {
          var filters = userMediaStream.mediaFilterManager.filters;
          Object.values(filters).forEach(function (filter) {
            if (filter.streamAIE !== null) {
              streamAIE = filter.streamAIE;
            }
          });

          if (streamAIE === null) {
            logger.error("Applied filter is not an AI filter");
          }
        } else {
          logger.error("No filter applied on stream");
        }
      }

      return streamAIE;
    }
  }, {
    key: "addChildren",
    value: function addChildren(child, type) {
      if (this.childrenTypeExists(type)) {
        logger.error("This stream already has a sub instance running for this");
        return;
      }

      if (this.childrens === undefined) {
        this.childrens = [];
      }

      this.childrens.push(child);
    }
  }, {
    key: "releaseChildren",
    value: function releaseChildren(type) {
      if (this.childrens !== undefined) {
        this.childrens.forEach(function (child, index) {
          if (child.childType === type) {
            var releaseOptions = {};
            releaseOptions.releaseParentStream = false;
            child.release(releaseOptions);
          }
        });
      }
    }
  }, {
    key: "releaseAllChildren",
    value: function releaseAllChildren() {
      logger.debug("releaseAllChildren");

      if (this.childrens !== undefined) {
        this.childrens.forEach(function (child, index) {
          var releaseOptions = {};
          releaseOptions.releaseParentStream = false;
          child.release(releaseOptions);
        });
      }
    }
  }, {
    key: "removeChildren",
    value: function removeChildren(type) {
      var _this13 = this;

      if (this.childrens !== undefined) {
        this.childrens.forEach(function (child, index) {
          if (child.childType === type) {
            return _this13.childrens.splice(index, 1);
          }
        });
      }
    }
  }, {
    key: "childrenTypeExists",
    value: function childrenTypeExists(type) {
      var res = false;

      if (this.childrens !== undefined) {
        this.childrens.forEach(function (child) {
          if (child.childType === type) {
            res = true;
          }
        });
      }

      return res;
    }
  }, {
    key: "createChildStreamFromStream",
    value: function createChildStreamFromStream(parentMediaStream, childStreamType) {
      var _this14 = this;

      var parentStreamCtx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return new Promise(function (resolve, reject) {
        logger.debug('createChildStreamFromStream');
        var newStreamOptions = {};
        newStreamOptions.type = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_NO_INPUT;

        if (parentMediaStream.getAudioTracks().length > 0) {
          newStreamOptions.type = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_AUDIO;
        }

        if (parentMediaStream.getVideoTracks().length > 0) {
          newStreamOptions.type = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_VIDEO;
        }

        var that = _this14;
        apiRTC.createUserMediaStream({
          'type': 'media',
          'stream': parentMediaStream,
          'success': function success(userMediaStream) {
            logger.debug('[createChildStreamFromStream] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
            newStreamOptions.constructor = true;
            newStreamOptions.userMediaStreamId = userMediaStream.userMediaStreamId;
            var newStream = new ChildStream(userMediaStream.stream, newStreamOptions, that, childStreamType); //Keeping info on activated filters from parent stream

            newStream.parentStreamCtx = parentStreamCtx;

            if (parentStreamCtx.audioFilterIsApplied === true) {
              newStream.audioFilterIsApplied = parentStreamCtx.audioFilterIsApplied;
              newStream.audioAppliedFilter = parentStreamCtx.audioAppliedFilter;
            }

            if (parentStreamCtx.videoFilterIsApplied === true) {
              newStream.videoFilterIsApplied = parentStreamCtx.videoFilterIsApplied;
              newStream.videoAppliedFilter = parentStreamCtx.videoAppliedFilter;
            }

            resolve(newStream);
          },
          'failure': function failure(userMediaStream, err) {
            logger.debug('[createChildStreamFromStream] failure :', err);
            reject();
          },
          'childStreamType': childStreamType
        });
      });
    }
  }, {
    key: "applyMuteStatusFromParent",
    value: function applyMuteStatusFromParent() {
      var _this15 = this;

      // Sync the effect track muted state with the original track state.
      //apiRTCStream.nodeCtx.outputMediaTrack.enabled = apiRTCStream.nodeCtx.originalMediaTrack.enabled;
      var i = 0;
      this.data.getAudioTracks().forEach(function (track) {
        track.enabled = _this15.parent.data.getAudioTracks()[i].enabled;
        i++;
      });
      var y = 0;
      this.data.getVideoTracks().forEach(function (track) {
        track.enabled = _this15.parent.data.getVideoTracks()[y].enabled;
        y++;
      });
    }
  }, {
    key: "loadTFLiteModule",
    value: function loadTFLiteModule() {
      return new Promise(function (resolve, reject) {
        var tfliteUrl = '';

        if (wasm_check__WEBPACK_IMPORTED_MODULE_7__.feature.simd) {
          tfliteUrl = 'https://cdn.apizee.com/apiRTC/lib/tflite/tflite-simd.js';
        } else {
          tfliteUrl = 'https://cdn.apizee.com/apiRTC/lib/tflite/tflite.js';
        }

        if (apiRTC.userAgentInstance.tFLiteModuleLoaded === false) {
          logger.debug('loading tflite');
          var args = {
            async: true,
            numRetries: 20,
            reqdelay: 200,
            success: function success() {
              logger.debug('loaded successfully', wasm_check__WEBPACK_IMPORTED_MODULE_7__.feature.simd);

              if (wasm_check__WEBPACK_IMPORTED_MODULE_7__.feature.simd) {
                createTFLiteSIMDModule().then(function (module) {
                  // jshint ignore:line
                  apiRTC.userAgentInstance.tFLiteSIMDModule = module;
                  apiRTC.userAgentInstance.tFLiteModuleLoaded = true;
                  resolve(module);
                });
              } else {
                createTFLiteModule().then(function (module) {
                  // jshint ignore:line
                  apiRTC.userAgentInstance.tFLiteSIMDModule = module;
                  apiRTC.userAgentInstance.tFLiteModuleLoaded = true;
                  resolve(module);
                });
              }
            },
            error: function error(depsNotFound) {
              reject('Resources loading failed, depsNotFound: ' + depsNotFound);
            },
            retrycb: function retrycb(numTries, delayMsec) {
              logger.warn('Blur API module loading retry :' + numTries + ' ,delay before retry :' + delayMsec);
            }
          };
          apiCC.resourcesLoader.loadjs([tfliteUrl], 'blur-api', args);
        } else {
          logger.debug('tflite already loaded and TFLiteSIMDModule already created');
          resolve(apiRTC.userAgentInstance.tFLiteSIMDModule);
        }
      });
    } //TODO voir si on peut viter de refaire setupTFLiteModule

  }, {
    key: "setupTFLiteModule",
    value: function setupTFLiteModule(module) {
      return new Promise(function (resolve, reject) {
        logger.debug('setupTFLiteModule');

        if (apiRTC.userAgentInstance.modelLoadedInModule === false) {
          logger.debug('loading model landscape');
          fetch('https://cdn.apizee.com/apiRTC/lib/tflite/models/selfie_segmentation_landscape.tflite').then(function (modelResponse) {
            if (!modelResponse.ok) {
              throw new Error('Failed to download tflite model!');
            }

            logger.debug('loaded successfully');

            var modelBufferOffset = module._getModelBufferMemoryOffset();

            modelResponse.arrayBuffer().then(function (model) {
              module.HEAPU8.set(new Uint8Array(model), modelBufferOffset);

              module._loadModel(model.byteLength);

              logger.debug('module setup complete');
              apiRTC.userAgentInstance.modelLoadedInModule = true;
              apiRTC.userAgentInstance.tFLiteSIMDModule = module;
              resolve(module);
            });
          })["catch"](function (e) {
            logger.error('Something went wrong during tflite model loading..', e);
          });
        } else {
          logger.debug('model landscape already loaded in module');
          resolve(apiRTC.userAgentInstance.tFLiteSIMDModule);
        }
      });
    }
  }, {
    key: "onMaskFrameTimer",
    value: function onMaskFrameTimer(response) {
      if (response.data.id === this.blurVariables.TIMEOUT_TICK) {
        this.renderMask();
      }
    }
  }, {
    key: "renderMask",
    value: function renderMask() {
      this.resizeSource();
      this.runInference();
      this.runPostProcessing();
      this.blurVariables.maskFrameTimerWorker.postMessage({
        id: this.blurVariables.SET_TIMEOUT,
        timeMs: 1000 / 30
      });
    }
  }, {
    key: "resizeSource",
    value: function resizeSource() {
      this.blurVariables.segmentationMaskCtx.drawImage(this.blurVariables.inputVideoElement, 0, 0, this.blurVariables.inputVideoElement.width, this.blurVariables.inputVideoElement.height, 0, 0, this.blurVariables.width, this.blurVariables.height);
      var imageData = this.blurVariables.segmentationMaskCtx.getImageData(0, 0, this.blurVariables.width, this.blurVariables.height);
      var inputMemoryOffset = this.blurVariables.tfliteModel._getInputMemoryOffset() / 4;

      for (var i = 0; i < this.blurVariables.segmentationPixelCount; i++) {
        this.blurVariables.tfliteModel.HEAPF32[inputMemoryOffset + i * 3] = imageData.data[i * 4] / 255;
        this.blurVariables.tfliteModel.HEAPF32[inputMemoryOffset + i * 3 + 1] = imageData.data[i * 4 + 1] / 255;
        this.blurVariables.tfliteModel.HEAPF32[inputMemoryOffset + i * 3 + 2] = imageData.data[i * 4 + 2] / 255;
      }
    }
  }, {
    key: "runInference",
    value: function runInference() {
      this.blurVariables.tfliteModel._runInference();

      var outputMemoryOffset = this.blurVariables.tfliteModel._getOutputMemoryOffset() / 4;

      for (var i = 0; i < this.blurVariables.segmentationPixelCount; i++) {
        var person = this.blurVariables.tfliteModel.HEAPF32[outputMemoryOffset + i]; // Sets only the alpha component of each pixel.

        this.blurVariables.segmentationMask.data[i * 4 + 3] = 255 * person;
      }

      this.blurVariables.segmentationMaskCtx.putImageData(this.blurVariables.segmentationMask, 0, 0);
    }
  }, {
    key: "runPostProcessing",
    value: function runPostProcessing() {
      var _ref = this.blurVariables.firstVideoTrack.getSettings ? this.blurVariables.firstVideoTrack.getSettings() : this.blurVariables.firstVideoTrack.getConstraints(),
          height = _ref.height,
          width = _ref.width;

      this.blurVariables.outputCanvasElement.height = height;
      this.blurVariables.outputCanvasElement.width = width;
      this.blurVariables.outputCanvasCtx.globalCompositeOperation = 'copy'; // Draw segmentation mask.
      // Smooth out the edges.

      this.blurVariables.outputCanvasCtx.filter = this.blurVariables.virtualBackground === "image" ? "blur(4px)" : "blur(8px)";
      this.blurVariables.outputCanvasCtx.drawImage(this.blurVariables.segmentationMaskCanvas, 0, 0, this.blurVariables.width, this.blurVariables.height, 0, 0, this.blurVariables.inputVideoElement.width, this.blurVariables.inputVideoElement.height);
      this.blurVariables.outputCanvasCtx.globalCompositeOperation = 'source-in';
      this.blurVariables.outputCanvasCtx.filter = 'none';
      this.blurVariables.outputCanvasCtx.drawImage(this.blurVariables.inputVideoElement, 0, 0); // Draw the background.

      this.blurVariables.outputCanvasCtx.globalCompositeOperation = 'destination-over';

      if (this.blurVariables.virtualBackground === "image") {
        if (this.blurVariables.outputCanvasElement.width / this.blurVariables.outputCanvasElement.height === this.blurVariables.imageRatio) {
          this.blurVariables.outputCanvasCtx.drawImage(this.blurVariables.virtualImage, 0, 0, this.blurVariables.virtualImage.width, this.blurVariables.virtualImage.height, 0, 0, this.blurVariables.outputCanvasElement.width, this.blurVariables.outputCanvasElement.height);
        } else {
          if (this.blurVariables.imageRatio > 1) {
            var box_crop_w = this.blurVariables.virtualImage.height * (this.blurVariables.outputCanvasElement.width / this.blurVariables.outputCanvasElement.height);
            var box_crop_h = this.blurVariables.virtualImage.height;
            var box_crop_x = Math.abs(this.blurVariables.virtualImage.width - box_crop_w) / 2;
            var box_crop_y = 0;

            if (box_crop_w > this.blurVariables.virtualImage.width) {
              box_crop_w = this.blurVariables.virtualImage.width;
              box_crop_x = 0;
            }

            this.blurVariables.outputCanvasCtx.drawImage(this.blurVariables.virtualImage, box_crop_x, box_crop_y, box_crop_w, box_crop_h, 0, 0, this.blurVariables.outputCanvasElement.width, this.blurVariables.outputCanvasElement.height);
          } else {
            var _box_crop_w = this.blurVariables.virtualImage.width;

            var _box_crop_h = this.blurVariables.virtualImage.width / (this.blurVariables.outputCanvasElement.width / this.blurVariables.outputCanvasElement.height);

            var _box_crop_x = 0;

            var _box_crop_y = Math.abs(this.blurVariables.virtualImage.height - _box_crop_h) / 2;

            if (_box_crop_h > this.blurVariables.virtualImage.height) {
              _box_crop_h = this.blurVariables.virtualImage.height;
              _box_crop_y = 0;
            }

            this.blurVariables.outputCanvasCtx.drawImage(this.blurVariables.virtualImage, _box_crop_x, _box_crop_y, _box_crop_w, _box_crop_h, 0, 0, this.blurVariables.outputCanvasElement.width, this.blurVariables.outputCanvasElement.height);
          }
        }
      } else {
        this.blurVariables.outputCanvasCtx.filter = "blur(15px)";
        this.blurVariables.outputCanvasCtx.drawImage(this.blurVariables.inputVideoElement, 0, 0);
      }
    }
  }, {
    key: "startSelfieSegmentation",
    value: function startSelfieSegmentation() {
      var _this16 = this;

      return new Promise(function (resolve, reject) {
        logger.debug('startSelfieSegmentation');

        _this16.loadTFLiteModule().then(function (module) {
          _this16.setupTFLiteModule(module).then(function (tflite) {
            _this16.blurVariables.tfliteModel = tflite;
            _this16.blurVariables.firstVideoTrack = _this16.data.getVideoTracks()[0];

            if (_this16.blurVariables.firstVideoTrack !== null && _this16.blurVariables.firstVideoTrack !== undefined) {
              var _ref2 = _this16.blurVariables.firstVideoTrack.getSettings ? _this16.blurVariables.firstVideoTrack.getSettings() : _this16.blurVariables.firstVideoTrack.getConstraints(),
                  height = _ref2.height,
                  frameRate = _ref2.frameRate,
                  width = _ref2.width;

              _this16.blurVariables.height = 144;
              _this16.blurVariables.width = 256;
              _this16.blurVariables.frameRate = frameRate;
              _this16.blurVariables.segmentationPixelCount = _this16.blurVariables.width * _this16.blurVariables.height;
              _this16.onMaskFrameTimer = _this16.onMaskFrameTimer.bind(_this16);
              _this16.blurVariables.outputCanvasElement = document.createElement('canvas');

              _this16.blurVariables.outputCanvasElement.getContext('2d'); // Workaround for FF issue https://bugzilla.mozilla.org/show_bug.cgi?id=1388974


              _this16.blurVariables.inputVideoElement = document.createElement('video');
              _this16.blurVariables.SET_TIMEOUT = 1;
              _this16.blurVariables.CLEAR_TIMEOUT = 2;
              _this16.blurVariables.TIMEOUT_TICK = 3;
              _this16.blurVariables.maskFrameTimerWorker = new Worker(URL.createObjectURL(new Blob(["\n                                        var timer;\n                                        onmessage = function(request) {\n                                            switch (request.data.id) {\n                                            case ".concat(_this16.blurVariables.SET_TIMEOUT, ": {\n                                                timer = setTimeout(() => {\n                                                    postMessage({ id: ").concat(_this16.blurVariables.TIMEOUT_TICK, " });\n                                                }, request.data.timeMs);\n                                                break;\n                                            }\n                                            case ").concat(_this16.blurVariables.CLEAR_TIMEOUT, ": {\n                                                if (timer) {\n                                                    clearTimeout(timer);\n                                                }\n                                                break;\n                                            }\n                                            }\n                                        };\n                                    ")], {
                type: 'application/javascript'
              })), {
                name: 'Blur effect worker'
              });
              _this16.blurVariables.maskFrameTimerWorker.onmessage = _this16.onMaskFrameTimer;
              _this16.blurVariables.segmentationMask = new ImageData(_this16.blurVariables.width, _this16.blurVariables.height);
              _this16.blurVariables.segmentationMaskCanvas = document.createElement('canvas');
              _this16.blurVariables.segmentationMaskCanvas.width = _this16.blurVariables.width;
              _this16.blurVariables.segmentationMaskCanvas.height = _this16.blurVariables.height;
              _this16.blurVariables.segmentationMaskCtx = _this16.blurVariables.segmentationMaskCanvas.getContext('2d');
              _this16.blurVariables.outputCanvasElement.width = parseInt(width, 10);
              _this16.blurVariables.outputCanvasElement.height = parseInt(height, 10);
              _this16.blurVariables.outputCanvasCtx = _this16.blurVariables.outputCanvasElement.getContext('2d');
              _this16.blurVariables.inputVideoElement.width = parseInt(width, 10);
              _this16.blurVariables.inputVideoElement.height = parseInt(height, 10);
              _this16.blurVariables.inputVideoElement.autoplay = true;
              _this16.blurVariables.inputVideoElement.srcObject = _this16.data;

              _this16.blurVariables.inputVideoElement.onloadeddata = function () {
                _this16.blurVariables.inputVideoElement.muted = true;

                _this16.blurVariables.maskFrameTimerWorker.postMessage({
                  id: _this16.blurVariables.SET_TIMEOUT,
                  timeMs: 1000 / 30
                });
              };

              resolve(_this16.blurVariables.outputCanvasElement.captureStream(parseInt(_this16.blurVariables.frameRate, 10)));
            } else {
              reject("No video track on stream");
            }
          })["catch"](function () {
            logger.error('Catch on setupTFLiteModule');
            return reject('Catch on setupTFLiteModule');
          });
        })["catch"](function () {
          logger.error('Catch on loadTFLiteModule');
          return reject('Catch on loadTFLiteModule');
        });
      });
    }
  }, {
    key: "stopSelfieSegmentation",
    value: function stopSelfieSegmentation() {
      logger.debug('stopSelfieSegmentation');
      this.blurVariables.maskFrameTimerWorker.postMessage({
        id: this.blurVariables.CLEAR_TIMEOUT
      });
      this.blurVariables.maskFrameTimerWorker.terminate();
    }
  }, {
    key: "checkChildTypeConditions",
    value: function checkChildTypeConditions() {
      if (this.childType !== undefined && this.videoFilterIsApplied) {
        return "This stream is already a childStream : need to remove previous applied effect : " + this.childType;
      }

      if (this.childrenTypeExists("blur")) {
        return "This stream already has a blur sub instance running : need to unblur()";
      }

      if (this.childrenTypeExists("backgroundImage")) {
        return "This stream already has a backgroundImage sub instance running : need to unBackgroundImage()";
      }

      if (!MediaStreamTrack.prototype.hasOwnProperty('getSettings') || !MediaStreamTrack.prototype.hasOwnProperty('getConstraints')) {
        return 'Navigator not compatible with this function';
      }

      return 'OK';
    }
    /**
     * Creates a stream which is a blurred version of the actual stream.
     * @returns {Promise<Stream>}
     */

  }, {
    key: "blur",
    value: function blur() {
      var _this17 = this;

      return new Promise(function (resolve, reject) {
        var ret = _this17.checkChildTypeConditions();

        if (ret !== 'OK') {
          return reject(ret);
        }

        if (apiCC.userAgentInstance.getCapabilities().backgroundRemoval === 'OFF') {
          return reject('Navigator not compatible with this function');
        }

        var that = _this17;
        _this17.blurVariables = {};
        _this17.blurVariables.virtualBackground = "blur";

        _this17.startSelfieSegmentation().then(function (mediaStream) {
          var _iterator5 = _createForOfIteratorHelper(that.data.getAudioTracks()),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var audioTrack = _step5.value;
              mediaStream.addTrack(audioTrack.clone());
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          var parentStreamCtx = {
            audioFilterIsApplied: _this17.audioFilterIsApplied,
            audioAppliedFilter: _this17.audioAppliedFilter,
            videoFilterIsApplied: _this17.videoFilterIsApplied,
            videoAppliedFilter: _this17.videoAppliedFilter,
            childType: _this17.childType
          };
          that.createChildStreamFromStream(mediaStream, "blur", parentStreamCtx).then(function (blurredStream) {
            _this17.addChildren(blurredStream, "blur");

            blurredStream.applyMuteStatusFromParent();
            return resolve(blurredStream);
          })["catch"](function () {
            logger.error('Catch on createChildStreamFromStream blur');
            return reject("error on createChildStreamFromStream");
          });
        })["catch"](function (reason) {
          logger.error('Catch on startSelfieSegmentation blur : ', reason);
          return reject(reason);
        });
      });
    }
    /**
     * Stops the blur process if started for this stream and return the original stream.
     * Can be applied on original Stream or on the blurred stream
     * @returns {Promise<Stream>}
     */

  }, {
    key: "unblur",
    value: function unblur() {
      var _this18 = this;

      return new Promise(function (resolve, reject) {
        if (apiCC.userAgentInstance.getCapabilities().backgroundRemoval === 'OFF') {
          return reject('Navigator not compatible with this function');
        }

        if (_this18.childType === 'blur') {
          logger.debug('This is the blurred stream : applying process with parent stream');
          var streamToApplyUnBlur = _this18.parent;
          streamToApplyUnBlur.stopSelfieSegmentation();
          streamToApplyUnBlur.releaseChildren("blur");
          streamToApplyUnBlur.removeChildren("blur");
          return resolve(streamToApplyUnBlur);
        } else if (_this18.childrenTypeExists('blur')) {
          logger.debug('This is the parent stream : applying process with this stream');

          _this18.stopSelfieSegmentation();

          _this18.releaseChildren("blur");

          _this18.removeChildren("blur");

          return resolve(_this18);
        } else {
          logger.debug('No blurred instance found for this stream');
          return reject('No blurred instance found for this stream');
        }
      });
    }
    /**
     * Creates a stream which is a clone version of the actual stream with an image in background.
     * @property {string} imageUrl url of the image to apply in background
     * @returns {Promise<Stream>}
     */

  }, {
    key: "backgroundImage",
    value: function backgroundImage(imageUrl) {
      var _this19 = this;

      logger.debug('backgroundImage', imageUrl);
      return new Promise(function (resolve, reject) {
        var ret = _this19.checkChildTypeConditions();

        if (ret !== 'OK') {
          return reject(ret);
        }

        if (apiCC.userAgentInstance.getCapabilities().backgroundRemoval === 'OFF') {
          return reject('Navigator not compatible with this function');
        }

        var that = _this19;
        _this19.blurVariables = {};
        _this19.blurVariables.virtualBackground = "image";
        _this19.blurVariables.virtualImage = new Image();
        _this19.blurVariables.virtualImage.crossOrigin = 'anonymous';
        _this19.blurVariables.virtualImage.src = imageUrl;

        _this19.blurVariables.virtualImage.onload = function () {
          _this19.blurVariables.imageRatio = _this19.blurVariables.virtualImage.width / _this19.blurVariables.virtualImage.height;

          _this19.startSelfieSegmentation().then(function (mediaStream) {
            var _iterator6 = _createForOfIteratorHelper(that.data.getAudioTracks()),
                _step6;

            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var audioTrack = _step6.value;
                mediaStream.addTrack(audioTrack.clone());
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }

            var parentStreamCtx = {
              audioFilterIsApplied: _this19.audioFilterIsApplied,
              audioAppliedFilter: _this19.audioAppliedFilter,
              videoFilterIsApplied: _this19.videoFilterIsApplied,
              videoAppliedFilter: _this19.videoAppliedFilter,
              childType: _this19.childType
            };
            that.createChildStreamFromStream(mediaStream, "backgroundImage", parentStreamCtx).then(function (blurredStream) {
              _this19.addChildren(blurredStream, "backgroundImage");

              blurredStream.applyMuteStatusFromParent();
              return resolve(blurredStream);
            })["catch"](function () {
              logger.error('Catch on createChildStreamFromStream bck');
              return reject("error on createChildStreamFromStream");
            });
          })["catch"](function (reason) {
            logger.error('Catch on startSelfieSegmentation bck : ', reason);
            return reject(reason);
          });
        };

        _this19.blurVariables.virtualImage.onerror = function () {
          logger.debug('Error on image loading');
          return reject('Error on image loading');
        };
      });
    }
    /**
     * Stops the background image process if started for this stream and return the original stream.
     * Can be applied on original Stream or on the backgrounded stream
     * @returns {Promise<Stream>}
     */

  }, {
    key: "unBackgroundImage",
    value: function unBackgroundImage() {
      var _this20 = this;

      logger.debug('unBackgroundImage');
      return new Promise(function (resolve, reject) {
        if (apiCC.userAgentInstance.getCapabilities().backgroundRemoval === 'OFF') {
          return reject('Navigator not compatible with this function');
        }

        if (_this20.childType === 'backgroundImage') {
          logger.debug('This is the backgroundImage stream : applying process with parent stream');
          var streamToApplyUnBackground = _this20.parent;
          streamToApplyUnBackground.stopSelfieSegmentation();
          streamToApplyUnBackground.releaseChildren("backgroundImage");
          streamToApplyUnBackground.removeChildren("backgroundImage");
          return resolve(streamToApplyUnBackground);
        } else if (_this20.childrenTypeExists('backgroundImage')) {
          logger.debug('This is the parent stream : applying process with this stream');

          _this20.stopSelfieSegmentation();

          _this20.releaseChildren("backgroundImage");

          _this20.removeChildren("backgroundImage");

          return resolve(_this20);
        } else {
          logger.debug('No background image instance found for this stream');
          return reject('No background image instance found for this stream');
        }
      });
    }
    /**
     * @typedef VideoProcessorOptions
     * @type {Object}
     * @property {string} backgroundImageUrl imageUrl to be used for background subtraction
     */

    /**
     * A promise for applying a stream filter
     * Possible filters are "none", "blur" : people background is blurred, "backgroundImage" : people background is replaced by a background image
     * @param {'none'|'blur'|'backgroundImage'} videoProcessorType type of filter to be applied . Value can be 'none'||'blur'||'backgroundImage'
     * @param {VideoProcessorOptions} options
     * @returns {Promise<Stream|ApplyVideoProcessorError>} Created Stream with applied filter in a promise
     */

  }, {
    key: "applyVideoProcessor",
    value: function applyVideoProcessor(videoProcessorType, options) {
      var _this21 = this;

      return new Promise(function (resolve, reject) {
        if (videoProcessorType !== "none" && videoProcessorType !== "blur" && videoProcessorType !== "backgroundImage") {
          return reject(new ApplyVideoProcessorError("Requested videoProcessorType is not correct", 'none', _this21));
        } //Determining actual applied Effect and stream


        var streamToApplyEffect = _this21;
        var actualAppliedEffect = "none";
        var streamWithEffect = null;
        var videoFilteredStream = _this21;
        var noiseFilterNeedtoBeReapplied = false;

        if (_this21.childType === "noiseReduction" && _this21.videoFilterIsApplied === true) {
          logger.debug("This is a noised reduced stream ... applying filter on parent");
          videoFilteredStream = _this21.parent; //Remove noiseReduction before process : we will reapply noise reduction at the end

          var releaseOptions = {};
          releaseOptions.releaseParentStream = false;

          _this21.release(releaseOptions);

          noiseFilterNeedtoBeReapplied = true;
        }

        if (videoFilteredStream.childType !== undefined && videoFilteredStream.videoFilterIsApplied === true) {
          //"This stream is already a childStream : need to remove previous applied effect : ";
          if (videoFilteredStream.childType === "blur") {
            actualAppliedEffect = "blur";
          } else if (videoFilteredStream.childType === "backgroundImage") {
            actualAppliedEffect = "backgroundImage";
          }

          streamToApplyEffect = videoFilteredStream.parent;
          streamWithEffect = videoFilteredStream;
        }

        if (videoFilteredStream.childrenTypeExists("blur")) {
          //"This stream already has a blur sub instance running : need to unblur()");
          actualAppliedEffect = "blur";
          videoFilteredStream.childrens.forEach(function (child) {
            streamWithEffect = child;
          });
        }

        if (videoFilteredStream.childrenTypeExists("backgroundImage")) {
          //"This stream already has a backgroundImage sub instance running : need to unBackgroundImage()");
          actualAppliedEffect = "backgroundImage";
          videoFilteredStream.childrens.forEach(function (child) {
            streamWithEffect = child;
          });
        }

        logger.debug("actual applied effect =", actualAppliedEffect);

        if (videoProcessorType === "none" && actualAppliedEffect === "none") {
          return reject(new ApplyVideoProcessorError('Requested videoProcessorType none and no effect applied', 'none', streamToApplyEffect));
        } else if (videoProcessorType === "none" && actualAppliedEffect === "blur") {
          logger.debug("need to unblur");
          streamToApplyEffect.unblur().then(function (stream) {
            if (noiseFilterNeedtoBeReapplied === true) {
              stream.startNoiseReduction().then(function (noisedStream) {
                return resolve(noisedStream);
              })["catch"](function (error) {
                logger.error('Catch on startNoiseReduction :', error);
                return reject(new ApplyAudioProcessorError(error, stream.audioAppliedFilter, streamToApplyEffect));
              });
            } else {
              return resolve(stream);
            }
          })["catch"](function (error) {
            logger.error('Catch on unblur: ', error);
            return reject(new ApplyVideoProcessorError(error, 'none', streamToApplyEffect));
          });
        } else if (videoProcessorType === "none" && actualAppliedEffect === "backgroundImage") {
          logger.debug("need to unBackgroundImage");
          streamToApplyEffect.unBackgroundImage().then(function (stream) {
            if (noiseFilterNeedtoBeReapplied === true) {
              stream.startNoiseReduction().then(function (noisedStream) {
                return resolve(noisedStream);
              })["catch"](function (error) {
                logger.error('Catch on startNoiseReduction :', error);
                return reject(new ApplyAudioProcessorError(error, stream.audioAppliedFilter, streamToApplyEffect));
              });
            } else {
              return resolve(stream);
            }
          })["catch"](function (error) {
            logger.error('Catch on unBackgroundImage :', error);
            return reject(new ApplyVideoProcessorError(error, 'none', streamToApplyEffect));
          });
        } else if (videoProcessorType === "blur" && actualAppliedEffect === "none") {
          logger.debug("need to blur");
          streamToApplyEffect.blur().then(function (stream) {
            if (noiseFilterNeedtoBeReapplied === true) {
              stream.startNoiseReduction().then(function (noisedStream) {
                return resolve(noisedStream);
              })["catch"](function (error) {
                logger.error('Catch on startNoiseReduction :', error);
                return reject(new ApplyAudioProcessorError(error, stream.audioAppliedFilter, streamToApplyEffect));
              });
            } else {
              return resolve(stream);
            }
          })["catch"](function (error) {
            logger.error('Catch on blur :', error);
            return reject(new ApplyVideoProcessorError(error, 'none', streamToApplyEffect));
          });
        } else if (videoProcessorType === "blur" && actualAppliedEffect === "blur") {
          return reject(new ApplyVideoProcessorError('Requested videoProcessorType blur and blur already applied', 'blur', streamWithEffect));
        } else if (videoProcessorType === "blur" && actualAppliedEffect === "backgroundImage") {
          logger.debug("need to unBackgroundImage then blur");
          var backupStreamUrl = streamToApplyEffect.blurVariables.virtualImage.src;
          streamToApplyEffect.unBackgroundImage().then(function (stream) {
            stream.blur().then(function (stream) {
              if (noiseFilterNeedtoBeReapplied === true) {
                stream.startNoiseReduction().then(function (noisedStream) {
                  return resolve(noisedStream);
                })["catch"](function (error) {
                  logger.error('Catch on startNoiseReduction :', error);
                  return reject(new ApplyAudioProcessorError(error, stream.audioAppliedFilter, streamToApplyEffect));
                });
              } else {
                return resolve(stream);
              }
            })["catch"](function (error) {
              logger.warn('Catch on blur - unBackgroundImage to blur :', error);
              logger.debug('Reactivating previous effect : backgroundImage');
              streamToApplyEffect.backgroundImage(backupStreamUrl).then(function (stream) {
                //This case is considered as an error as blur effect is not applied
                logger.warn('Could not apply blur effect, background restored');

                if (noiseFilterNeedtoBeReapplied === true) {
                  stream.startNoiseReduction().then(function (noisedStream) {
                    return reject(new ApplyVideoProcessorError('Could not apply blur effect, background restored', 'backgroundImage', noisedStream));
                  })["catch"](function (error) {
                    logger.error('Catch on startNoiseReduction :', error);
                    return reject(new ApplyVideoProcessorError('Could not apply blur effect, background restored', 'backgroundImage', stream));
                  });
                } else {
                  return reject(new ApplyVideoProcessorError('Could not apply blur effect, background restored', 'backgroundImage', stream));
                }
              })["catch"](function (error) {
                logger.error('Could not apply blur effect and error in restoring background :', error);
                return reject(new ApplyVideoProcessorError('Could not apply blur effect and error in restoring background', 'none', streamToApplyEffect));
              });
            });
          })["catch"](function (error) {
            logger.error('Catch on unBackgroundImage :', error);
            return reject(new ApplyVideoProcessorError(error, 'none', streamToApplyEffect));
          });
        } else if (videoProcessorType === "backgroundImage" && actualAppliedEffect === "none") {
          logger.debug("need to backgroundImage");

          if (options === undefined || options.backgroundImageUrl === undefined) {
            return reject(new ApplyVideoProcessorError('Error options.backgroundImageUrl is not defined', 'none', streamToApplyEffect));
          }

          streamToApplyEffect.backgroundImage(options.backgroundImageUrl).then(function (stream) {
            if (noiseFilterNeedtoBeReapplied === true) {
              stream.startNoiseReduction().then(function (noisedStream) {
                return resolve(noisedStream);
              })["catch"](function (error) {
                logger.error('Catch on startNoiseReduction :', error);
                return reject(new ApplyVideoProcessorError('Could not apply blur effect, background restored', 'backgroundImage', stream));
              });
            } else {
              return resolve(stream);
            }
          })["catch"](function (error) {
            logger.error('Catch on backgroundImage :', error);
            return reject(new ApplyVideoProcessorError(error, 'none', streamToApplyEffect));
          });
        } else if (videoProcessorType === "backgroundImage" && actualAppliedEffect === "blur") {
          logger.debug("need to unblur then backgroundImage");
          streamToApplyEffect.unblur().then(function (stream) {
            stream.backgroundImage(options.backgroundImageUrl).then(function (stream) {
              if (noiseFilterNeedtoBeReapplied === true) {
                stream.startNoiseReduction().then(function (noisedStream) {
                  return resolve(noisedStream);
                })["catch"](function (error) {
                  logger.error('Catch on startNoiseReduction :', error);
                  return reject(new ApplyVideoProcessorError('Could not apply blur effect, background restored', 'backgroundImage', stream));
                });
              } else {
                return resolve(stream);
              }
            })["catch"](function (error) {
              logger.warn('Catch on backgroundImage - unBackgroundImage to blur :', error);
              logger.debug('Reactivating previous effect : blur');
              streamToApplyEffect.blur().then(function (stream) {
                //This case is considered as an error as blur effect is not applied
                if (noiseFilterNeedtoBeReapplied === true) {
                  stream.startNoiseReduction().then(function (noisedStream) {
                    return reject(new ApplyVideoProcessorError('Could not apply background effect, blur restored', 'blur', noisedStream));
                  })["catch"](function (error) {
                    logger.error('Catch on startNoiseReduction :', error);
                    return reject(new ApplyVideoProcessorError('Could not apply background effect, blur restored', 'blur', stream));
                  });
                } else {
                  logger.warn('Could not apply background effect, blur restored');
                  return reject(new ApplyVideoProcessorError('Could not apply background effect, blur restored', 'blur', stream));
                }
              })["catch"](function (error) {
                logger.error('Could not apply background effect and error in restoring blur :', error);
                return reject(new ApplyVideoProcessorError('Could not apply background effect and error in restoring blur', 'none', streamToApplyEffect));
              });
            });
          })["catch"](function (error) {
            logger.error('Catch on unblur :', error);
            return reject(new ApplyVideoProcessorError(error, 'none', streamToApplyEffect));
          });
        } else if (videoProcessorType === "backgroundImage" && actualAppliedEffect === "backgroundImage") {
          var streamUrl = streamToApplyEffect.blurVariables.virtualImage.src; //Checking if background image is already applied : process on filename because url can be modified (//file: vs //localhost ...)
          //This checking is not applied on data:image/ base64 (this can be used when image is located in localStorage)

          if (options.backgroundImageUrl.startsWith('data:image') === false && streamUrl.substring(streamUrl.lastIndexOf('/') + 1) === options.backgroundImageUrl.substring(options.backgroundImageUrl.lastIndexOf('/') + 1)) {
            logger.debug('Same background image is already applied');
            return reject(new ApplyVideoProcessorError('Requested videoProcessorType backgroundImage and backgroundImage with the same image already applied', 'backgroundImage', streamWithEffect));
          } else {
            logger.debug('New background image is to be applied');
            streamToApplyEffect.unBackgroundImage().then(function (stream) {
              stream.backgroundImage(options.backgroundImageUrl).then(function (stream) {
                if (noiseFilterNeedtoBeReapplied === true) {
                  stream.startNoiseReduction().then(function (noisedStream) {
                    return resolve(noisedStream);
                  })["catch"](function (error) {
                    logger.error('Catch on startNoiseReduction :', error);
                    return reject(new ApplyVideoProcessorError('Could not apply background effect, blur restored', 'blur', stream));
                  });
                } else {
                  return resolve(stream);
                }
              })["catch"](function (error) {
                logger.warn('Catch on backgroundImage - change background image :', error);
                logger.debug('Reactivating previous effect : backgroundImage');
                streamToApplyEffect.backgroundImage(streamUrl).then(function (stream) {
                  //This case is considered as an error as selected backgroundImage effect is not applied
                  if (noiseFilterNeedtoBeReapplied === true) {
                    stream.startNoiseReduction().then(function (noisedStream) {
                      logger.warn('Could not apply new image on background, former background restored');
                      return reject(new ApplyVideoProcessorError('Could not apply new image on background, former background restored', 'backgroundImage', noisedStream));
                    })["catch"](function (error) {
                      logger.error('Catch on startNoiseReduction :', error);
                      return reject(new ApplyVideoProcessorError('Could not apply background effect, blur restored', 'blur', stream));
                    });
                  } else {
                    return reject(new ApplyVideoProcessorError('Could not apply new image on background, former background restored', 'backgroundImage', stream));
                  }
                })["catch"](function (error) {
                  logger.error('Could not apply new image on background and error in restoring former background :', error);
                  return reject(new ApplyVideoProcessorError('Could not apply new image on background and error in restoring former background', 'none', streamToApplyEffect));
                });
              });
            })["catch"](function (error) {
              logger.error('Catch on unBackgroundImage :', error);
              return reject(new ApplyVideoProcessorError(error, 'none', streamToApplyEffect));
            });
          }
        }
      });
    }
  }, {
    key: "checkAudioProcessorType",
    value: function checkAudioProcessorType(audioProcessorType) {
      if (audioProcessorType !== "none" && audioProcessorType !== "noiseReduction") {
        return "Requested audioProcessorType is not correct";
      }

      if (audioProcessorType === "none" && this.audioAppliedFilter !== "noiseReduction") {
        return "Not a noised reduction stream";
      }

      return 'OK';
    }
    /**
     * A promise for applying a stream filter
     * Possible filters are "none", blur : people background is blurred, people background is replaced by a background image
     * @param {'none'|'noiseReduction'} audioProcessorType type of filter to be applied . Value can be 'none'||'noiseReduction'
     * @returns {Promise<Stream|ApplyAudioProcessorError>} Created Stream with applied filter in a promise
     */

  }, {
    key: "applyAudioProcessor",
    value: function applyAudioProcessor(audioProcessorType) {
      var _this22 = this;

      return new Promise(function (resolve, reject) {
        //Determining actual applied Effect and stream
        var streamToApplyEffect = _this22;
        var videoEffectTobeReapplied = "none";
        var videoEffectTobeReappliedImageSrc = "none";

        var ret = _this22.checkAudioProcessorType(audioProcessorType);

        if (ret !== 'OK') {
          return reject(new ApplyAudioProcessorError(ret, _this22.audioAppliedFilter, _this22));
        }

        if (audioProcessorType === "none") {
          if (_this22.childType !== "noiseReduction" && _this22.parent.childType === "noiseReduction") {
            //applying process on parent stream as this one must be a video effect stream
            logger.debug("applying process on parent stream as this one must be a video effect stream");
            streamToApplyEffect = _this22.parent;
            videoEffectTobeReapplied = _this22.childType;

            if (_this22.parent.blurVariables !== undefined && _this22.parent.blurVariables.virtualImage !== undefined) {
              videoEffectTobeReappliedImageSrc = _this22.parent.blurVariables.virtualImage.src;
            } //Release actual stream : we will recreated a new one without noiseReduction filter and with video filter


            var releaseOptions = {};
            releaseOptions.releaseParentStream = false;

            _this22.release(releaseOptions);
          } else {
            //This case shoudn't be possible
            logger.debug("no noiseReduction applied");
          }

          streamToApplyEffect.stopNoiseReduction();

          if (videoEffectTobeReapplied !== "none") {
            var videoProcessorOptions = {
              backgroundImageUrl: videoEffectTobeReappliedImageSrc
            };
            streamToApplyEffect.parent.applyVideoProcessor(videoEffectTobeReapplied, videoProcessorOptions).then(function (stream) {
              logger.debug('Release noiseReduction stream');
              var releaseOptions = {};
              releaseOptions.releaseParentStream = false;
              streamToApplyEffect.release(releaseOptions);
              return resolve(stream);
            })["catch"](function (reason) {
              // rejet
              logger.error('Catch on applyVideoProcessor() - reapply effect : ', reason);
              return reject(new ApplyAudioProcessorError("Error on restoring applied video filter", this.audioAppliedFilter, this));
            });
          } else {
            logger.debug('Release noiseReduction stream');
            var streamToresolve = _this22.parent;
            var _releaseOptions = {};
            _releaseOptions.releaseParentStream = false;
            streamToApplyEffect.release(_releaseOptions);
            return resolve(streamToresolve);
          }
        } else if (audioProcessorType === "noiseReduction") {
          streamToApplyEffect.startNoiseReduction().then(function (noisedStream) {
            return resolve(noisedStream);
          })["catch"](function (error) {
            logger.error('Catch on startNoiseReduction :', error);
            return reject(new ApplyAudioProcessorError(error, streamToApplyEffect.audioAppliedFilter, streamToApplyEffect));
          });
        }
      });
    }
    /**
     * Creates a stream with a noise reduction filter applied.
     * @returns {Promise<Stream>}
     */

  }, {
    key: "startNoiseReduction",
    value: function startNoiseReduction() {
      return apiCC.audioProcessor.startNoiseReduction(this);
    }
    /**
     * Stops the noised reduction filter if started for this stream and return the original stream.
     */

  }, {
    key: "stopNoiseReduction",
    value: function stopNoiseReduction() {
      apiCC.audioProcessor.stopAudioNodeCtx(this.parent.nodeCtx);
    }
  }, {
    key: "createMediaStreamTrackProcessor",
    value: function createMediaStreamTrackProcessor() {
      var isAudio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      logger.debug("mediaStreamTrackProcessor kind: ".concat(isAudio ? "audio" : "video", " created"));

      if (isAudio) {
        var audio_tracks = this.data.getAudioTracks();

        if (audio_tracks.length) {
          return new MediaStreamTrackProcessor({
            track: audio_tracks[0]
          });
        } else {
          throw new Error("No audio tracks found");
        }
      } else {
        var video_tracks = this.data.getVideoTracks();

        if (video_tracks.length) {
          return new MediaStreamTrackProcessor({
            track: video_tracks[0]
          });
        } else {
          throw new Error("No video tracks found");
        }
      }
    }
  }, {
    key: "createMediaStreamTrackGenerator",
    value: function createMediaStreamTrackGenerator() {
      var isAudio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      logger.debug("mediaStreamTrackGenerator kind: ".concat(isAudio ? "audio" : "video", " created"));

      if (isAudio) {
        return new MediaStreamTrackGenerator({
          kind: "audio"
        });
      } else {
        return new MediaStreamTrackGenerator({
          kind: "video"
        });
      }
    }
  }, {
    key: "loadSegmentationAPI",
    value: function loadSegmentationAPI() {
      return new Promise(function (resolve, reject) {
        var args = {
          async: true,
          numRetries: 20,
          reqdelay: 200,
          success: function success() {
            logger.debug('Segmentation API loaded');
            mergeReality.then(resolve);
          },
          error: function error(depsNotFound) {
            reject('Resources loading failed, depsNotFound: ' + depsNotFound);
          },
          retrycb: function retrycb(numTries, delayMsec) {
            logger.warn('Blur API model loading retry :' + numTries + ' ,delay before retry :' + delayMsec);
          }
        };
        apiCC.resourcesLoader.loadjs(['https://cdn.apizee.com/apiRTC/lib/mergereality/v1.0/merge_reality.js'], 'merge-reality', args);
      });
    }
  }, {
    key: "startMergeReality",
    value: function startMergeReality(lib) {
      var _this23 = this;

      this.mergeRealityData = {};
      this.mergeRealityLib = lib;
      this.mergeRealityData.stop = false;
      /* Stream sizes */

      this.mergeRealityData.WIDTH = this.getSettings().width;
      this.mergeRealityData.HEIGHT = this.getSettings().height;
      /* Canvas assignation */

      this.mergeRealityData.WEBCAM_CANVAS = new OffscreenCanvas(this.mergeRealityData.WIDTH, this.mergeRealityData.HEIGHT);
      this.mergeRealityData.WEBCAM_CTX = this.mergeRealityData.WEBCAM_CANVAS.getContext("2d", {
        alpha: false
      });
      this.mergeRealityData.MASK_CANVAS = new OffscreenCanvas(this.mergeRealityData.WIDTH, this.mergeRealityData.HEIGHT);
      this.mergeRealityData.MASK_CTX = this.mergeRealityData.MASK_CANVAS.getContext("2d", {
        alpha: true
      });
      this.mergeRealityData.SCREEN_VIDEO = document.createElement("video");
      /* Background Segmentation */

      this.mergeRealityData.BG_SUB = new this.mergeRealityLib.BackgroundSubtractor();
      this.mergeRealityData.background = new this.mergeRealityLib.BackgroundImage(this.mergeRealityData.WEBCAM_CTX.getImageData(0, 0, this.mergeRealityData.WIDTH, this.mergeRealityData.HEIGHT), this.mergeRealityData.WIDTH, this.mergeRealityData.HEIGHT);
      /* Insertable streams */

      this.mergeRealityData.MSTP = this.createMediaStreamTrackProcessor().readable;
      this.mergeRealityData.MSTG = this.createMediaStreamTrackGenerator();
      this.mergeRealityData.SINK = this.mergeRealityData.MSTG.writable;
      this.mergeRealityData.MASK_TRANSFORMER = new TransformStream({
        transform: function transform(frame, controller) {
          if (!_this23.mergeRealityData.stop) {
            _this23.mergeRealityData.MASK_CTX.save();

            _this23.mergeRealityData.MASK_CTX.clearRect(0, 0, _this23.mergeRealityData.WIDTH, _this23.mergeRealityData.HEIGHT);

            _this23.mergeRealityData.WEBCAM_CTX.clearRect(0, 0, _this23.mergeRealityData.WIDTH, _this23.mergeRealityData.HEIGHT);

            _this23.mergeRealityData.WEBCAM_CTX.drawImage(frame, 0, 0);

            _this23.mergeRealityData.MASK_DATA = _this23.mergeRealityData.BG_SUB.computeMask(_this23.mergeRealityData.WEBCAM_CTX.getImageData(0, 0, _this23.mergeRealityData.WIDTH, _this23.mergeRealityData.HEIGHT), _this23.mergeRealityData.background);
            _this23.mergeRealityData.RES = _this23.mergeRealityData.BG_SUB.applyTransparency(_this23.mergeRealityData.WEBCAM_CTX.getImageData(0, 0, _this23.mergeRealityData.WIDTH, _this23.mergeRealityData.HEIGHT), _this23.mergeRealityData.MASK_DATA);

            _this23.mergeRealityData.MASK_CTX.putImageData(_this23.mergeRealityData.RES, 0, 0);

            _this23.mergeRealityData.MASK_CTX.globalCompositeOperation = "destination-atop";

            _this23.mergeRealityData.MASK_CTX.drawImage(_this23.mergeRealityData.SCREEN_VIDEO, 0, 0, _this23.mergeRealityData.WIDTH, _this23.mergeRealityData.HEIGHT);

            _this23.mergeRealityData.MASK_CTX.restore();

            controller.enqueue(new VideoFrame(_this23.mergeRealityData.MASK_CANVAS));
          }

          frame.close();
        }
      });
      this.mergeRealityData.RES_MS = new MediaStream();
    }
  }, {
    key: "stopMergeReality",
    value: function stopMergeReality() {
      this.mergeRealityData.stop = true;
    }
  }, {
    key: "calibrateBackground",
    value: function calibrateBackground() {
      if (this.childrenTypeExists('merge')) {
        this.mergeRealityData.background = new this.mergeRealityLib.BackgroundImage(this.mergeRealityData.WEBCAM_CTX.getImageData(0, 0, this.mergeRealityData.WIDTH, this.mergeRealityData.HEIGHT), this.mergeRealityData.WIDTH, this.mergeRealityData.HEIGHT);
      } else {
        logger.error('No merged instance found for this stream');
      }
    }
    /*
     * Creates a stream which is a merged into another stream
     *  @returns {Promise<Stream>}
     */

  }, {
    key: "mergeReality",
    value: function mergeReality(remote_stream) {
      var _this24 = this;

      return new Promise(function (resolve, reject) {
        if (window.MediaStreamTrackGenerator === undefined || window.MediaStreamTrackProcessor === undefined || window.TransformStream === undefined) {
          return reject("Your browser does not support InsertableStreams");
        }

        if (_this24.childrenTypeExists("merge")) {
          return reject("This stream already has a sub instance running for this");
        }

        _this24.loadSegmentationAPI().then(function (lib) {
          _this24.startMergeReality(lib);
          /* Transform stream */


          remote_stream.attachToElement(_this24.mergeRealityData.SCREEN_VIDEO);
          _this24.mergeRealityData.SCREEN_VIDEO.autoplay = true;

          _this24.mergeRealityData.MSTP.pipeThrough(_this24.mergeRealityData.MASK_TRANSFORMER).pipeTo(_this24.mergeRealityData.SINK);

          _this24.mergeRealityData.RES_MS.addTrack(_this24.mergeRealityData.MSTG);

          var _iterator7 = _createForOfIteratorHelper(_this24.data.getAudioTracks()),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var audioTrack = _step7.value;

              _this24.mergeRealityData.RES_MS.addTrack(audioTrack);
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }

          var that = _this24;
          var parentStreamCtx = {
            audioFilterIsApplied: _this24.audioFilterIsApplied,
            audioAppliedFilter: _this24.audioAppliedFilter,
            videoFilterIsApplied: _this24.videoFilterIsApplied,
            videoAppliedFilter: _this24.videoAppliedFilter,
            childType: _this24.childType
          };

          _this24.createChildStreamFromStream(_this24.mergeRealityData.RES_MS, "merge", parentStreamCtx).then(function (mergedStream) {
            that.addChildren(mergedStream, "merge");
            mergedStream.applyMuteStatusFromParent();
            resolve(mergedStream);
          })["catch"](function () {
            logger.error('Catch on createChildStreamFromStream mergeReality');
          });
        });
      });
    }
    /*
     * Stop the merge if it started
     *  @returns {void}
     */

  }, {
    key: "unmergeReality",
    value: function unmergeReality() {
      if (this.childrenTypeExists('merge')) {
        this.stopMergeReality();
        this.releaseChildren("merge");
        this.removeChildren("merge");
      } else {
        logger.error('No merged instance found for this stream');
      }
    }
  }, {
    key: "addPendingPromise",
    value: function addPendingPromise(functionNametimeout, resolve, reject) {
      var delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5000;

      var rejectFn = function rejectFn() {
        reject("Timeout problem during ".concat(functionNametimeout, " process on a remote stream"));
      };

      var timeout = setTimeout(rejectFn, delay);
      this.promises.push({
        timeout: timeout,
        resolve: resolve,
        reject: reject
      });
      return timeout;
    }
  }, {
    key: "resolvePendingPromise",
    value: function resolvePendingPromise(timeout, result) {
      this.promises.forEach(function (promise) {
        if (timeout === promise.timeout) {
          clearTimeout(timeout);
          promise.resolve(result);
        }
      });
    }
  }, {
    key: "rejectPendingPromise",
    value: function rejectPendingPromise(timeout, error) {
      this.promises.forEach(function (promise) {
        if (timeout === promise.timeout) {
          clearTimeout(timeout);
          promise.reject(error);
        }
      });
    }
  }, {
    key: "sendAudioFlowStatusChanged",
    value: function sendAudioFlowStatusChanged() {
      var audioFlowStatus = this.getAudioFlowStatus();

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('audioFlowStatusChanged', audioFlowStatus);
    }
  }, {
    key: "sendVideoFlowStatusChanged",
    value: function sendVideoFlowStatusChanged() {
      var videoFlowStatus = this.getVideoFlowStatus();

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('videoFlowStatusChanged', videoFlowStatus);
    }
  }, {
    key: "sendRemoteAudioFlowStatusChanged",
    value: function sendRemoteAudioFlowStatusChanged(remoteAudioFlowStatus) {
      remoteAudioFlowStatus.enabled = !remoteAudioFlowStatus.enabled; // logic changed because wording changed : before it was named "muted" and now this is "enabled"

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('remoteAudioFlowStatusChanged', remoteAudioFlowStatus);
    }
  }, {
    key: "sendRemoteVideoFlowStatusChanged",
    value: function sendRemoteVideoFlowStatusChanged(remoteVideoFlowStatus) {
      remoteVideoFlowStatus.enabled = !remoteVideoFlowStatus.enabled; // logic changed because wording changed : before it was named "muted" and now this is "enabled"

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(this).emit('remoteVideoFlowStatusChanged', remoteVideoFlowStatus);
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return STREAM_EVENTS;
    }
    /**
     * @typedef CreateStreamFromUserMediaOptions
     * @type {Object}
     * @property {boolean} enhancedAudioActivated add possibility to create an enhanced audio flow (echoCancellation deactivated, noiseReduction deactivated ...) - Only supported on Chrome
     * @property {string} facingMode facingMode should be equal to 'user', 'environment', 'left', 'right' or 'deactivated'.
     */

    /**
     * Helper function to create a new stream using user's video & audio sources
     *
     *  @param {MediaDevice} audioInput  audioInput device id, can be null. set to false if audio track is not requested
     *  @param {MediaDevice} videoInput  videoInput device id, can be null. set to false if video track is not requested
     *  @param {object} constraints  other MediaTrackConstraints that can be specified for stream
     *  @param {CreateStreamFromUserMediaOptions} options
     *  @returns {Promise<Stream>} Created stream in promise
     */

  }, {
    key: "createStreamFromUserMedia",
    value: function createStreamFromUserMedia(audioInput, videoInput, constraints) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      logger.debug('createStreamFromUserMedia');
      logger.debug('audioInput :', audioInput);
      logger.debug('videoInput :', videoInput);
      logger.debug('constraints :', constraints);
      logger.debug('options :', options);
      return new Promise(function (resolve, reject) {
        var audioPresent = audioInput !== false && (audioInput !== null || constraints === undefined || constraints !== undefined && constraints.hasOwnProperty('audio'));
        var videoPresent = videoInput !== false && (videoInput !== null || constraints === undefined || constraints !== undefined && constraints.hasOwnProperty('video'));
        var newStreamOptions = {
          type: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_NO_INPUT,
          audioInput: audioInput,
          videoInput: videoInput
        };
        var callType = 'media';

        if (videoPresent) {
          newStreamOptions.type = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_VIDEO;
        } else if (audioPresent) {
          newStreamOptions.type = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_AUDIO;
        }

        if (audioPresent && !videoPresent) {
          callType = 'audio';
        } else if (!audioPresent && videoPresent) {
          callType = 'videoOnly';
        }

        if (audioPresent && options.enhancedAudioActivated === true) {
          logger.debug('Enhanced Audio is activated');

          if (apiRTC.browser !== 'Chrome') {
            logger.debug('enhancedAudioActivated option is only available for Chrome');
          } else {
            if (constraints === undefined) {
              constraints = {};
            }

            if (!constraints.audio || _typeof(constraints.audio) !== 'object') {
              constraints.audio = {};
            }

            if (constraints.video === undefined) {
              constraints.video = {};
            }

            constraints.audio.echoCancellation = false;
            constraints.audio.autoGainControl = false;
            constraints.audio.noiseSuppression = false;
          }
        }

        apiRTC.createUserMediaStream({
          'audioSourceId': audioInput,
          'videoSourceId': videoInput,
          'facingMode': options.facingMode,
          'gum_config': constraints,
          'filters': options.filters,
          'type': callType,
          'success': function success(userMediaStream) {
            logger.debug('[createStreamFromUserMedia] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
            newStreamOptions.constructor = true;
            newStreamOptions.userMediaStreamId = userMediaStream.userMediaStreamId;
            resolve(new Stream(userMediaStream.stream, newStreamOptions));
          },
          'failure': function failure(userMediaStream, err) {
            logger.debug('[createStreamFromUserMedia] failure :', err);
            reject(err);
          }
        });
      });
    }
    /**
     * Helper function to create a new stream using an existing mediaStream
     *
     *  @param {MediaStream} mediaStream  mediaStream to use to create a Stream
     *  @returns {Promise<Stream>} Created stream in promise
     */

  }, {
    key: "createStreamFromMediaStream",
    value: function createStreamFromMediaStream(mediaStream) {
      logger.debug('createStreamFromMediaStream');
      return new Promise(function (resolve, reject) {
        var newStreamOptions = {};
        newStreamOptions.type = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_NO_INPUT;

        if (mediaStream.getAudioTracks().length > 0) {
          newStreamOptions.type = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_AUDIO;
        }

        if (mediaStream.getVideoTracks().length > 0) {
          newStreamOptions.type = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_VIDEO;
        }

        apiRTC.createUserMediaStream({
          'type': 'media',
          'stream': mediaStream,
          'success': function success(userMediaStream) {
            logger.debug('[createStreamFromUserMedia] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
            newStreamOptions.constructor = true;
            newStreamOptions.userMediaStreamId = userMediaStream.userMediaStreamId;
            resolve(new Stream(userMediaStream.stream, newStreamOptions));
          },
          'failure': function failure(userMediaStream, err) {
            logger.debug('[createStreamFromUserMedia] failure :', err);
            reject();
          }
        });
      });
    }
    /**
     * Helper function to create a screensharing stream : Check also createDisplayMediaStream()
     * The feature works both on Firefox and Chrome
     * On Chrome, the ApiRTC screensharing extention needs to be installed beforehand
     *
     *@param {Object} captureSourceType This enables to choose what the user will be propose to share between screen, applications, browser tab and audio.
     * Usage is different depending the browser :
     * -on Chrome, captureSourceTypevalue value is an array that can be ["screen", "window", "tab", "audio"]. This array is used to restrict what will be proposed to the user
     * -on Firefox, captureSourceTypevalue value is a string that can be "screen", "window" or "application". This string is used to choose what will be proposed to the user
     *  @returns {Promise<Stream>} Created stream in promise
     */

  }, {
    key: "createScreensharingStream",
    value: function createScreensharingStream(captureSourceType) {
      return new Promise(function (resolve, reject) {
        apiRTC.createUserMediaStream({
          'type': 'screenSharing',
          'captureSourceType': captureSourceType,
          'success': function success(userMediaStream) {
            logger.debug('[createStreamFromUserMedia] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
            var stream = new Stream(userMediaStream.stream, {
              constructor: true,
              type: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_VIDEO,
              userMediaStreamId: userMediaStream.userMediaStreamId
            });

            _isScreensharingStream.set(stream, true);

            resolve(stream);
          },
          'failure': function failure(userMediaStream, err) {
            logger.debug('[createStreamFromUserMedia] failure :', err);
            reject(err);
          }
        });
      });
    }
    /**
     * NEW FUNCTION
     *
     * Helper function to create a screensharing stream : when possible it will use getDisplayMedia() function
     * This function is the evolution of createScreensharingStream(), parameters are based on getDisplayMedia()
     *
     * @param {Object} displayMediaStreamConstraints displayMediaStreamConstraints as defined in : https://w3c.github.io/mediacapture-screen-share/#displaymediastreamconstraints
     * For retro compatibility with createScreensharingStream() function, value can also be set as captureSourceType :This enables to choose what the user will be proposed to share between screen, applications, browser tab and audio.
     * Usage is different depending the browser :
     * -on Chrome, captureSourceTypevalue value is an array that can be ["screen", "window", "tab", "audio"]. This array is used to restrict what will be proposed to the user
     * -on Firefox, captureSourceTypevalue value is a string that can be "screen", "window" or "application". This string is used to choose what will be proposed to the user
     * @param {Boolean} forceExtensionOnChrome This can be used to force the usage of Chrome extension (all getDisplayMedia constraints are not yet implemented and extension usage can still be interesting depending on use cases)
     * @returns {Promise<Stream>} Created stream in promise
     */

  }, {
    key: "createDisplayMediaStream",
    value: function createDisplayMediaStream(displayMediaStreamConstraints, forceExtensionOnChrome) {
      return new Promise(function (resolve, reject) {
        apiRTC.createUserMediaStream({
          'type': 'screenSharing',
          'captureSourceType': displayMediaStreamConstraints,
          'displayMediaStreamConstraints': displayMediaStreamConstraints,
          'forceExtensionOnChrome': forceExtensionOnChrome,
          'success': function success(userMediaStream) {
            logger.debug('[createStreamFromUserMedia] success; userMediaStreamId: ' + userMediaStream.userMediaStreamId);
            var stream = new Stream(userMediaStream.stream, {
              constructor: true,
              type: _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.STREAM_TYPE_VIDEO,
              userMediaStreamId: userMediaStream.userMediaStreamId
            });

            _isScreensharingStream.set(stream, true);

            resolve(stream);
          },
          'failure': function failure(userMediaStream, err) {
            logger.debug('[createStreamFromUserMedia] failure :', err);
            reject(err);
          }
        });
      });
    }
    /**
     * Returns local streams list
     *
     *  @returns {Stream[]} local streams list
     */

  }, {
    key: "getLocalStreams",
    value: function getLocalStreams() {
      return _localStreams.values();
    }
    /**
     * Returns local stream with its identifier
     *
     *  @param {String} streamId
     *  @returns {Stream} stream
     */

  }, {
    key: "getStream",
    value: function getStream(streamId) {
      if (typeof streamId !== 'undefined' && streamId !== null && _localStreams.has(streamId.toString())) {
        return _localStreams.get(streamId.toString());
      } else {
        return null;
      }
    }
  }]);

  return Stream;
}(_utils_Observable__WEBPACK_IMPORTED_MODULE_2__.Observable);

var ChildStream = /*#__PURE__*/function (_Stream) {
  _inherits(ChildStream, _Stream);

  var _super2 = _createSuper(ChildStream);

  function ChildStream(data, options, parent, type) {
    var _this25;

    _classCallCheck(this, ChildStream);

    _this25 = _super2.call(this, data, options);
    _this25.parent = parent;
    _this25.childType = type;

    if (type === "noiseReduction") {
      _this25.audioFilterIsApplied = true;
      _this25.audioAppliedFilter = type;
    }

    if (type === "blur" || type === "backgroundImage") {
      _this25.videoFilterIsApplied = true;
      _this25.videoAppliedFilter = type;
    }

    return _this25;
  }

  _createClass(ChildStream, [{
    key: "release",
    value: function release(options) {
      if (this.childType === "blur" || this.childType === "backgroundImage") {
        this.parent.stopSelfieSegmentation();
      }

      this.parent.removeChildren(this.childType);

      if (this.clonedStream !== undefined) {
        logger.debug("to be released ...");
        this.clonedStream.getAudioTracks().forEach(function (track) {
          track.stop();
        });
        this.clonedStream.getVideoTracks().forEach(function (track) {
          track.stop();
        });
      }

      _get(_getPrototypeOf(ChildStream.prototype), "release", this).call(this, options);
    }
  }]);

  return ChildStream;
}(Stream);
/**
 * ApplyVideoProcessorError
 * @extends Error
 * @property {'none'|'blur'|'backgroundImage'} appliedVideoProcessorType - The type of effect applied on the stream present in this error
 * @property {Stream} stream - available stream. In case of error, apiRTC tries to restore previous applied effect
 */


var ApplyVideoProcessorError = /*#__PURE__*/function (_Error) {
  _inherits(ApplyVideoProcessorError, _Error);

  var _super3 = _createSuper(ApplyVideoProcessorError);

  function ApplyVideoProcessorError(message, appliedVideoProcessorType, stream) {
    var _this26;

    _classCallCheck(this, ApplyVideoProcessorError);

    _this26 = _super3.call(this, message);
    _this26.name = _this26.constructor.name;
    _this26.appliedVideoProcessorType = appliedVideoProcessorType;
    _this26.stream = stream;
    return _this26;
  }

  return _createClass(ApplyVideoProcessorError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * ApplyAudioProcessorError
 * @extends Error
 * @property {'none'|'noiseReduction'} appliedAudioProcessorType - The type of effect applied on the stream present in this error
 * @property {Stream} stream - available stream. In case of error, apiRTC tries to restore previous applied effect
 */


var ApplyAudioProcessorError = /*#__PURE__*/function (_Error2) {
  _inherits(ApplyAudioProcessorError, _Error2);

  var _super4 = _createSuper(ApplyAudioProcessorError);

  function ApplyAudioProcessorError(message, appliedAudioProcessorType, stream) {
    var _this27;

    _classCallCheck(this, ApplyAudioProcessorError);

    _this27 = _super4.call(this, message);
    _this27.name = _this27.constructor.name;
    _this27.appliedAudioProcessorType = appliedAudioProcessorType;
    _this27.stream = stream;
    return _this27;
  }

  return _createClass(ApplyAudioProcessorError);
}( /*#__PURE__*/_wrapNativeSuper(Error));



/***/ }),

/***/ "./src/public/UserAgent.js":
/*!*********************************!*\
  !*** ./src/public/UserAgent.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UserAgent": () => (/* binding */ UserAgent)
/* harmony export */ });
/* harmony import */ var _utils_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Constants */ "./src/utils/Constants.js");
/* harmony import */ var _utils_Misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Misc */ "./src/utils/Misc.js");
/* harmony import */ var _utils_Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Observable */ "./src/utils/Observable.js");
/* harmony import */ var _Stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Stream */ "./src/public/Stream.js");
/* harmony import */ var _Session__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Session */ "./src/public/Session.js");
/* harmony import */ var _Enterprise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Enterprise */ "./src/public/Enterprise.js");
/* harmony import */ var _UserData__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UserData */ "./src/public/UserData.js");
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../private/ApiRTCManager */ "./src/private/ApiRTCManager.js");
/* harmony import */ var _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @apizee/cloudapi-js-sdk/CloudAPI */ "./node_modules/@apizee/cloudapi-js-sdk/CloudAPI.js");
/* harmony import */ var _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Core/BrowserInfo */ "./src/Core/BrowserInfo.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* globals apiCC, MediaStreamTrack*/











var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_7__.Logger.get('UserAgent');
var apiRTCManager = _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_8__.ApiRTCManager.get();
var cloudApi = new _apizee_cloudapi_js_sdk_CloudAPI__WEBPACK_IMPORTED_MODULE_9__["default"]();
var AUTH_PREFIX_APIZEE = 'apizee:';
var AUTH_PREFIX_APIRTC = 'apirtc:';
var AUTH_PREFIX_TOKEN = 'token:';
var AUTH_PREFIX_ANONYMOUS = 'apzkey:';
var AUTH_PREFIX_ANONYMOUS_APIKEY = 'apiKey:'; //const AUTH_PREFIX_SITEKEY = 'sitekey:';

var _enterprise = new WeakMap();

var USERAGENT_EVENTS = ['mediaDeviceChanged', 'externalJsLoadingStatus', 'ccsConnectionStatus', 'userMediaError'];
/**
 * User Agent
 *
 * The UserAgent serves as the base to use apiRTC.
 * A user agent can be authenticated or not. For an ApiRTC cloud platform user , the uri is prefixed with 'apirtc:'.
 * He can be anonymous if it's a client of an ApiRTC cloud platform enterprise, use prefix apiKey:<APIKey> as uri.
 * Once registered, its Session object can be used to communicate with other contacts using the platform on the same API key and CCS server
 *
 *  @extends Observable
 *  @fires UserAgent#mediaDeviceChanged
 *  @fires UserAgent#externalJsLoadingStatus
 */

var UserAgent = /*#__PURE__*/function (_Observable) {
  _inherits(UserAgent, _Observable);

  var _super = _createSuper(UserAgent);

  /**
   * @typedef UserAgentOptions
   * @type {Object}
   * @property {string} uri Registration URI, must be have the form 'apirtc:<cloud_login>' for cloud users or 'apiKey:<api_key>' for anonymous users
   * @property {boolean} apiRTCMediaDeviceDetectionEnabled Used to enable media device detection on apiRTC when event is not managed by browser (Ex : mediaDeviceChanged not supported on Chrome/Android)
   * @property {string} apiRTCMediaDeviceDetectionDelay=10000 Used to define the delay of Media Device detection. Check apiRTCMediaDeviceDetectionEnabled.
   *
   */

  /**
   * Fired when user media list have changed. call getUserMediaDevices() to get an updated MediaDeviceList
   *
   * @event UserAgent#mediaDeviceChanged
   * @type {object}
   * @property {array} added array of added input/ouput
   * @property {array} removed array of removed input/ouput
   * @property {array} updated array of updated input/ouput
   * @property {String} updateReason give an updated reason. Value can be 'updatedOnDeviceChange' or 'updatedAfterGetUserMediaSuccess'
   * @property {Boolean} firstMediaDeviceListInitialization indicate of this is the first event occurrence with a real list from device
   */

  /**
   * Fired when externalJs loading status change. This can be an insteresting information to detect network failure.
   *
   * @event UserAgent#externalJsLoadingStatus
   * @type {object}
   * @property {string} extjs external js concerned by the event
   * @property {string} status status of the loading : loaded, error, retry
   */

  /**
   * Fired when ccs Connection status change. This can be an insteresting information to detect network failure.
   *
   * @event UserAgent#ccsConnectionStatus
   * @type {object}
   * @property {string} status status of the CCS connection : connected, disconnected, error, retry
   */

  /**
   * Create an User Agent
   *
   * @param {UserAgentOptions} options all user connection options
   * @example <caption>Create an UserAgent</caption>
   * var user1 = new apiRTC.UserAgent({
   *   uri: 'apirtc:user2@apirtc.com'
   * });
   * @returns {UserAgent} Created object
   *
   */
  function UserAgent() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, UserAgent);

    _this = _super.call(this, logger);
    logger.debug('Create UserAgent');
    _this.uri = options.hasOwnProperty('uri') ? options.uri : null;
    _this.userId = null;
    _this.username = null;
    _this.profile = null;
    _this.preRegisterUserData = new _UserData__WEBPACK_IMPORTED_MODULE_6__.UserData();
    _this.callStatsMonitoringEnabled = null;
    _this.callStatsMonitoringInterval = null;
    _this.meshModeEnabled = null;
    _this.apiRTCMediaDeviceDetectionEnabled = options.hasOwnProperty('apiRTCMediaDeviceDetectionEnabled') ? options.apiRTCMediaDeviceDetectionEnabled : false; //Used to enable media device detection on apiRTC when event is not managed by browser (Ex : NOK on Chrome/Android)

    _this.apiRTCMediaDeviceDetectionDelay = options.hasOwnProperty('apiRTCMediaDeviceDetectionDelay') ? options.apiRTCMediaDeviceDetectionDelay : _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.APIRTC_MEDIA_DEVICE_DETECTION_DELAY; // deprecated.

    _this.targetBandwidthUsage = 0;
    _this.videoBandwidthSettings = {
      overallIncoming: 3000,
      overallOutgoing: 3000 // perCallIncoming
      // perCallOutgoing

    };
    _this.currentSession = null;
    _this.enterprise = null;
    _this.capabilities = {
      //User Agent capabilities
      whiteboardCursor: 'ON',
      mediaDeviceChanged: 'ON',
      //Whether mediaDeviceChanged event is supported on device
      webRTCCompliant: 'ON',
      //Whether WebRTC is supported on browser
      screenSharingCompliant: 'ON',
      //Whether screenSharing is supported on browser
      qoSStatCompliant: 'ON',
      //Whether QoS is supported on browser
      backgroundRemoval: 'ON',
      //Wether backgroundRemoval functions (blur/imageBackground) are supported on browser
      streamCapabilities: 'ON',
      //Wether Stream capabilities functions are supported on browser
      noiseReduction: 'ON' //Wether Noise Reduction functions are supported on browser
      //TODO to be completed
      //dataChannel
      //audioDevicePresent
      //videoDevicePresent
      //dataChannelCapable
      //+ Voir pour redescendre au niveau de apiRTC Core

    };
    _this.browser = apiRTC.browser;
    _this.browser_major_version = apiRTC.browser_major_version;
    _this.browser_version = apiRTC.browser_version;
    _this.osName = apiRTC.osName;
    _this.osVersion = apiRTC.osVersion;
    _this.browserInfo = apiRTC.browserInfo;
    _this.browserDetails = apiRTC.browserDetails;
    _this.tFLiteModuleLoaded = false;
    _this.tFLiteSIMDModule = null;
    _this.modelLoadedInModule = false;

    _enterprise.set(_assertThisInitialized(_this), null);

    apiRTCManager.createWhiteBoard();
    apiCC.activateScreenSharing();

    var mediaDeviceChangedHandler = function mediaDeviceChangedHandler(e) {
      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('mediaDeviceChanged', {
        added: e.detail.diff.added,
        removed: e.detail.diff.removed,
        updated: e.detail.diff.updated,
        updateReason: e.detail.updateReason,
        firstMediaDeviceListInitialization: e.detail.firstMediaDeviceListInitialization
      });
    };

    apiRTC.addEventListener("mediaDeviceChanged", mediaDeviceChangedHandler);

    var externalJsLoadingStatusHandler = function externalJsLoadingStatusHandler(e) {
      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('externalJsLoadingStatus', {
        extjs: e.detail.extjs,
        status: e.detail.status
      });
    };

    apiRTC.addEventListener("externalJsLoadingStatus", externalJsLoadingStatusHandler);

    var channelEventHandler = function channelEventHandler(e) {
      var ccsConnectionStatus = null;

      if (e.detail.channelEvent === 'onChannelOpened') {
        ccsConnectionStatus = 'connected';
      } else if (e.detail.channelEvent === 'onChannelDisconnect') {
        ccsConnectionStatus = 'disconnected';
      } else if (e.detail.channelEvent === 'onChannelReconnecting') {
        ccsConnectionStatus = 'retry';
      } else if (e.detail.channelEvent === 'onChannelConnectError') {
        ccsConnectionStatus = 'error';
      } else if (e.detail.channelEvent === 'onChannelError') {
        ccsConnectionStatus = 'error';
      }

      if (ccsConnectionStatus !== null) {
        //ccsConnectionStatus is defined, emitting event on UA
        _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('ccsConnectionStatus', {
          status: ccsConnectionStatus
        });
      }
    };

    apiRTC.addEventListener("channelEvent", channelEventHandler);

    var userMediaErrorHandler = function userMediaErrorHandler(e) {
      var userMediaError = {
        error: e.detail.error
      };

      if (e.detail.callType === 'media') {
        userMediaError.audio = true;
        userMediaError.video = true;
        userMediaError.screenSharing = false;
      } else if (e.detail.callType === 'audio') {
        userMediaError.audio = true;
        userMediaError.video = false;
        userMediaError.screenSharing = false;
      } else if (e.detail.callType === 'videoOnly') {
        userMediaError.audio = false;
        userMediaError.video = true;
        userMediaError.screenSharing = false;
      } else if (e.detail.callType === 'screenSharing') {
        userMediaError.audio = false;
        userMediaError.video = true;
        userMediaError.screenSharing = true;
      } else if (e.detail.callType === 'screenSharingWithAudio') {
        userMediaError.audio = true;
        userMediaError.video = true;
        userMediaError.screenSharing = true;
      }

      _utils_Observable__WEBPACK_IMPORTED_MODULE_2__._eventEmitter.get(_assertThisInitialized(_this)).emit('userMediaError', userMediaError);
    };

    apiRTC.addEventListener("userMediaError", userMediaErrorHandler);

    _this.checkUACapabilities();

    if (_this.capabilities.mediaDeviceChanged === 'OFF') {
      logger.debug('mediaDeviceChanged is not supported');

      if (_this.apiRTCMediaDeviceDetectionEnabled === true) {
        logger.debug('apiRTCMediaDeviceDetectionEnabled is activated, starting process');
        setInterval(function () {
          apiCC.mediaDeviceMgr.getMediaDevices();
        }, _this.apiRTCMediaDeviceDetectionDelay);
      }
    } //Save userAgent instance in apiRTC


    apiRTC.userAgentInstance = _assertThisInitialized(_this);
    return _this;
  }
  /**
   * Returns available events for this class
   *
   *  @returns {Array<string>}
   */


  _createClass(UserAgent, [{
    key: "fetchUserMediaDevices",
    value:
    /**
     * @typedef MediaDeviceList
     * @type {Object}
     * @property {Object<string, MediaDevice>} audioinput
     * @property {Object<string, MediaDevice>} audiooutput
     * @property {Object<string, MediaDevice>} videoinput
     */

    /**
     * A promise for fetching user media devices which can be used for creating a Stream object
     * Use getUserMediaDevices() instead of this function
     * @deprecated
     *
     * @returns {Promise<MediaDeviceList>}
     */
    function fetchUserMediaDevices() {
      logger.warn("DEPRECATION WARNING : fetchUserMediaDevices() is now deprecated, use getUserMediaDevices() instead"); //fetch user media sources

      return new Promise(function (resolve, reject) {
        if (apiCC.browser === 'IE' && apiCC.browser_version > 8.0) {
          apiCC.getMediaDevicesWithCB(apiCC.mediaDeviceMgr.gotSources);
          resolve(apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArray);
        } else {
          //Media device detection
          apiCC.getMediaDevices().then(function (sources) {
            apiCC.mediaDeviceMgr.gotSources(sources);
            resolve(apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArray);
          })["catch"](function () {
            logger.log("Error on MediaDeviceManager::getMediaDevices");
            apiCC.mediaDeviceMgr.gotSources(null);
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'fetchUserMediaDevices() - Could not get media devices', logger));
          });
        }
      });
    }
    /**
     * return user media devices
     *
     *  @returns {MediaDeviceList}
     */

  }, {
    key: "getUserMediaDevices",
    value: function getUserMediaDevices() {
      return apiCC.mediaDeviceMgr.mediaDeviceSourceInfosArray;
    }
    /**
    * @typedef FilterDescriptor
    * @type {Object}
    * @property {String} type Accepted values are : backgroundSubtraction and AIEFilter
    * @property {(BackgroundFilter|AIEFilter)} options
    */

    /**
     * @typedef BackgroundFilter
     * @type {Object}
     * @property {String} backgroundMode The name of the effect to apply on background. Accepted values are : blur, transparent and image
     * @property {object} [image] The data of the image to show in background if backgroundMode is set to : image
     */

    /**
     * @typedef AIEFilter
     * @type {Object}
     * @property {String} modelName The name of the model loaded in the AI server to call for object detection
     * @property {number} [scoreThresh] Score threshold to apply on the objectness scores of detected objects, between 0 and 1
     * @property {number} [maxBoxes] Maximum number of boxes detected by the model
     * @property {boolean} [forceReload] If set to true the model will be loaded even if it has already been loaded
     * @property {List<string>} [classFilter=all] List of the classes to detect, set "all" to detect all objects, "all" is the default value if not set
     * @property {AIEDrawingConfig} [drawingConfig] Object containing the parameters for bounding box drawing
     */

    /**
     * @typedef AIEDrawingConfig
     * @type {Object}
     * @property {String} color The default color used for bounding boxes and text backgrounds
     * @property {String} textColor The default color used for text
     * @property {number} lineWidth Width of the bounding boxes lines
     * @property {String} font The font of the canvas rendering context
     * @property {object} colorMap Object which fields are classes to detect and which values are the color to use to draw the respecting class
     */

    /**
     * @typedef CreateStreamOptions
     * @type {Object}
     * @property {string|boolean} audioInputId audio input device id (obtained from UserAgent.fetchUserMediaDevices); set to false if audio track is not requested
     * @property {string|boolean} videoInputId video input device id (obtained from UserAgent.fetchUserMediaDevices); set to false if video track is not requested
     * @property {object} constraints other MediaTrackConstraints
     * @property {boolean} enhancedAudioActivated add possibility to create an enhanced audio flow (echoCancellation deactivated, noiseReduction deactivated ...) - Only supported on Chrome
     * @property {string} facingMode facingMode should be equal to 'user', 'environment', 'left', 'right' or 'deactivated'.
     * @property {Array<FilterDescriptor>} filters descriptors of media stream filters
     */

    /**
     * A promise for creating a stream object
     *
     *  @param {CreateStreamOptions} options
     *  @returns {Promise<Stream>} Created Stream in a promise
     */

  }, {
    key: "createStream",
    value: function createStream() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      logger.info('createStream() with option :', options);
      return _Stream__WEBPACK_IMPORTED_MODULE_3__.Stream.createStreamFromUserMedia(options.audioInputId, options.videoInputId, options.constraints, options);
    }
    /**
     * A promise for creating a stream object from a MediaStream
     *
     *  @param {MediaStream} mediaStream
     *  @returns {Promise<Stream>} Created Stream in a promise
     */

  }, {
    key: "createStreamFromMediaStream",
    value: function createStreamFromMediaStream(mediaStream) {
      logger.info('createStreamFromMediaStream()');
      return _Stream__WEBPACK_IMPORTED_MODULE_3__.Stream.createStreamFromMediaStream(mediaStream);
    }
    /**
     * @typedef NetworkInformation
     * @type {Object}
     * @property {string} testServer Server used for network tests
     * @property {number} httpPing Http ping RTT value with cloud server (value might be higher than a standard ping)
     * @property {Object} upload Upload test information
     * @property {Object} download Download test information
     */

    /**
     * fetchNetworkInformation Version 2. Returns a promise that gives the result for a network test
     * This version of the method is more precise on result but use more network ressources.
     *
     *  @param {string} testServer Server used for the network test (optional)
     *  @param {array} bandwidthRatingThresholds Thresholds used for rating. Default value is [300,500,1000,1500,2000]
     *  @returns {Promise<NetworkInformation>} Network test result in a promise
     */

  }, {
    key: "fetchNetworkInformation_v2",
    value: function fetchNetworkInformation_v2(ptestServer, bandwidthRatingThresholds) {
      logger.debug("fetchNetworkInformation Version 2 :", ptestServer);
      var testServer = cloudApi.cloudUrl;

      if (ptestServer !== undefined && ptestServer !== null) {
        testServer = ptestServer;
      }

      var result = {
        testServer: testServer,
        httpPing: {},
        upload: {},
        download: {}
      };

      if (bandwidthRatingThresholds !== undefined && bandwidthRatingThresholds !== null && Array.isArray(bandwidthRatingThresholds)) {
        apiRTC.bandwidthRatingThresholds = bandwidthRatingThresholds;
        logger.debug("New bandwidthRatingThresholds is defined :", apiRTC.bandwidthRatingThresholds);
      } else {
        logger.debug("Using default bandwidthRatingThresholds :", apiRTC.bandwidthRatingThresholds);
      }

      apiRTC.bandwidthTestServer = testServer;
      logger.info("Start Network test");
      return new Promise(function (resolve, reject) {
        apiRTC.testUserPing(function (err, res) {
          if (err !== null) {
            reject(err);
          } else {
            result.httpPing = res; //first estimation of upload bandwidth

            apiRTC.testUserUpload(250000, function (err, res) {
              if (err !== null) {
                reject(err);
              } else {
                result.upload.kbps = res.kBPerSec * 8;
                result.upload.rating = res.rating;
                apiRTC.testUserUploadLoop(500000, result.upload, function (err, res) {
                  if (err !== null) {
                    reject(err);
                  } else {
                    result.upload.kbps = res.kBPerSec * 8;
                    result.upload.rating = res.rating; // First estimation of download bandwidth with small file

                    apiRTC.testUserDownload(256, function (err, res) {
                      if (err !== null) {
                        reject(err);
                      } else {
                        result.download.kbps = res.kBPerSec * 8;
                        result.download.rating = res.rating;
                        apiRTC.testUserDownloadLoop(1000, result.download, function (err, res) {
                          if (err !== null) {
                            reject(err);
                          } else {
                            result.download.kbps = res.kBPerSec * 8;
                            result.download.rating = res.rating;
                            resolve(result);
                          }
                        });
                      }
                    });
                  }
                });
              }
            });
          }
        });
      });
    }
    /**
     *  fetchNetworkInformation Version 1. Returns a promise that gives the result for a network test
     *  Adviced method to get a network estimation
     *
     *  @param {string} testServer Server used for the network test (optional)
     *  @returns {Promise<NetworkInformation>} Network test result in a promise
     */

  }, {
    key: "fetchNetworkInformation_v1",
    value: function fetchNetworkInformation_v1(ptestServer, bandwidthRatingThresholds) {
      logger.debug("fetchNetworkInformation Version 1 :", ptestServer);
      var testServer = cloudApi.cloudUrl;

      if (ptestServer !== undefined && ptestServer !== null) {
        testServer = ptestServer;
      }

      var result = {
        testServer: testServer,
        httpPing: {},
        upload: {},
        download: {}
      };

      if (bandwidthRatingThresholds !== undefined && bandwidthRatingThresholds !== null && Array.isArray(bandwidthRatingThresholds)) {
        apiRTC.bandwidthRatingThresholds = bandwidthRatingThresholds;
        logger.debug("New bandwidthRatingThresholds is defined :", apiRTC.bandwidthRatingThresholds);
      } else {
        logger.debug("Using default bandwidthRatingThresholds :", apiRTC.bandwidthRatingThresholds);
      }

      apiRTC.bandwidthTestServer = testServer;
      logger.info("Start Network test");
      return new Promise(function (resolve, reject) {
        apiRTC.testUserPing(function (err, res) {
          if (err !== null) {
            reject(err);
          } else {
            result.httpPing = res; //first estimation of upload bandwidth

            apiRTC.testUserUpload(250000, function (err, res) {
              if (err !== null) {
                reject(err);
              } else {
                result.upload.kbps = res.kBPerSec * 8;
                result.upload.rating = res.rating;

                if (result.upload.kbps >= 1000) {
                  apiRTC.testUserUpload(500000, function (err, res) {
                    if (err !== null) {
                      reject(err);
                    } else {
                      result.upload.kbps = res.kBPerSec * 8;
                      result.upload.rating = res.rating;
                    }
                  });
                } // First estimation of download bandwidth with small file


                apiRTC.testUserDownload(256, function (err, res) {
                  if (err !== null) {
                    reject(err);
                  } else {
                    result.download.kbps = res.kBPerSec * 8;
                    result.download.rating = res.rating;

                    if (result.download.kbps >= 500 && result.download.kbps < 1500) {
                      apiRTC.testUserDownload(500, function (err, res) {
                        if (err !== null) {
                          reject(err);
                        } else {
                          result.download.kbps = res.kBPerSec * 8;
                          result.download.rating = res.rating;
                          resolve(result);
                        }
                      });
                    } else if (result.download.kbps >= 1500) {
                      apiRTC.testUserDownload(768, function (err, res) {
                        if (err !== null) {
                          reject(err);
                        } else {
                          result.download.kbps = res.kBPerSec * 8;
                          result.download.rating = res.rating;
                          resolve(result);
                        }
                      });
                    } else {
                      resolve(result);
                    }
                  }
                });
              }
            });
          }
        });
      });
    }
    /**
     *  Returns a promise that gives the result for a network test.
     *  This method is the recommend one to be used : testings are based on fetchNetworkInformation Version 1.
     *
     *  @param {string} testServer Server used for the network test (optional)
     *  @param {array} bandwidthRatingThresholds Thresholds used for rating. Default value is [300,500,1000,1500,2000]
     *  @returns {Promise<NetworkInformation>} Network test result in a promise
     */

  }, {
    key: "fetchNetworkInformation",
    value: function fetchNetworkInformation(ptestServer, bandwidthRatingThresholds) {
      return this.fetchNetworkInformation_v1(ptestServer, bandwidthRatingThresholds);
    }
    /**
     * @typedef GeolocationPositionOptions
     * @type {Object}
     * @property {boolean} enableHighAccuracy If false, the device can take the liberty to save resources by responding more quickly and/or using less power.
     * @property {number} timeout Meaning that getCurrentPosition() won't return until the position is available
     * @property {number} maximumAge If set to Infinity the device must return a cached position regardless of its age
     */

    /**
     * @typedef GeolocationCoordonates
     * @type {Object}
     * @property {number} latitude Representing the position's latitude in decimal degrees
     * @property {number} longitude Representing the position's longitude in decimal degrees
     * @property {number} altitude Representing the psoition's altitude in meters, relative to sea level.
     * @property {number} accuracy Representing the accuracy of the latitude and longitude properties, expressed in meters
     * @property {number} altitudeAccuracy Representing the accuracy of the altitude expressed in meters. This value can be null
     * @property {number} heading Representing the direction in which the device is traveling. This value specified in degrees. 0 = True North, 90 = East, 270 = West
     * @property {number} speed Representing the velocity of the device in meters per seconds. This value can be null
     */

    /**
     * @typedef GeolocationPosition
     * @type {Object}
     * @property {GeolocationCoordonates} coords Coordinates object defining the current position
     * @property {number} timestamp A DOMTimestamp representing the time at which the location was retrieved
     */

    /**
     * @typedef GeolocationPositionError
     * @type {Object}
     * @property {number} code Representing the error code: PERMISSION_DENIED, POSITION_UNAVAILABLE or TIMEOUT
     * @property {string} message Human-readable DOMString describing the details of the error
     */

    /**
     * Returns a promise that gives the position for a geolocation request
     * https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition
     *
     * @param {GeolocationPositionOptions} positionOptions Optional position options object
     * @returns {Promise<GeolocationPosition>|Promise<GeolocationPositionError>} Geolocation position in a promise
     */

  }, {
    key: "fetchGeolocationInformation",
    value: function fetchGeolocationInformation(positionOptions) {
      if (typeof positionOptions === 'undefined' || positionOptions === null) {
        positionOptions = {
          // Default options
          enableHighAccuracy: false,
          timeout: Infinity,
          maximumAge: 0
        };
      }

      return new Promise(function (resolve, reject) {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(function (position) {
            resolve(position);
          }, function (positionError) {
            reject(positionError);
          }, positionOptions);
        }
      });
    }
    /**
     * Sets user data for this user session
     * User data is visible from other users
     *
     *  @param {Object} userData
     *  @returns {void}
     */

  }, {
    key: "setUserData",
    value: function setUserData(userData) {
      if (this.currentSession) {
        this.currentSession.setUserData(userData);
      }
    }
    /**
     * Set user agent username
     *
     *  @param {string} username
     *  @returns {void}
     */

  }, {
    key: "setUsername",
    value: function setUsername(username) {
      if (this.currentSession) {
        this.currentSession.setUsername(username);
      } else {
        this.preRegisterUserData.setProp('username', username);
      }
    }
    /**
     * Set user agent photo url
     *
     *  @param {string} url
     *  @returns {void}
     */

  }, {
    key: "setPhotoUrl",
    value: function setPhotoUrl(url) {
      if (this.currentSession) {
        this.currentSession.setPhotoUrl(url);
      } else {
        this.preRegisterUserData.setProp('photo_url', url);
      }
    }
    /**
     * Returns user agent user data
     *
     *  @returns {Object} contact's userdata
     */

  }, {
    key: "getUserData",
    value: function getUserData() {
      return this.currentSession ? this.currentSession.getUserData() : this.preRegisterUserData;
    }
    /**
     * Returns user agent username
     *
     *  @returns {String} username
     */

  }, {
    key: "getUsername",
    value: function getUsername() {
      if (this.currentSession) {
        return this.currentSession.getUsername();
      } else {
        if (this.preRegisterUserData.get('username') !== null) {
          return this.preRegisterUserData.get('username');
        } else if (this.preRegisterUserData.get('nickname') !== null) {
          return this.preRegisterUserData.get('nickname');
        } else {
          return this.username;
        }
      }
    }
    /**
     * Returns photo URL of this one.
     *
     * @return {string} photo URL on success, null otherwise.
     */

  }, {
    key: "getPhotoUrl",
    value: function getPhotoUrl() {
      if (this.currentSession) {
        return this.currentSession.getPhotoUrl();
      } else {
        if (this.preRegisterUserData.get('photo_url') !== null) {
          return this.preRegisterUserData.get('photo_url');
        } else if (this.preRegisterUserData.get('photoUrl') !== null) {
          return this.preRegisterUserData.get('photoUrl');
        } else {
          return null;
        }
      }
    }
    /**
     * Returns cloud profile of this one.
     * @param {string} bearerToken
     * @param {Boolean} forceUpdate forces profile update; optional, defaults to false.
     *
     * @returns {Promise<object>} Profile information in promise
     */

  }, {
    key: "fetchProfileInformation",
    value: function fetchProfileInformation(bearerToken) {
      var _this2 = this;

      var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return new Promise(function (resolve, reject) {
        var apiKey = null;

        if (_this2.profile !== null && !forceUpdate) {
          // Get profile from cache
          resolve(_this2.profile);
        } else if (_this2.userId && (apiKey = apiRTCManager.getActiveApiKey()) !== null) {
          cloudApi.getUserProfile(apiKey, _this2.userId, bearerToken).then(function (res) {
            _this2.profile = res;
            resolve(res);
          })["catch"](reject);
        } else {
          reject('fetchProfileInformation() - missing registration');
        }
      });
    }
    /**
     * Returns user agent enterprise (set when registered using 'apirtc:' URI)
     *
     *  @returns {Enterprise} enterprise Will be set to null if no enterprise is set
     */

  }, {
    key: "getEnterprise",
    value: function getEnterprise() {
      return _enterprise.get(this);
    }
    /**
     * Returns connected session for this UserAgent
     *
     *  @returns {Session} session Returns null if the UA is not connected
     */

  }, {
    key: "getCurrentSession",
    value: function getCurrentSession() {
      return this.currentSession;
    }
    /**
     * Returns eventCenter for this UserAgent
     *
     *  @returns {EventCenter} Returns EventCenter
     */

  }, {
    key: "getEventCenter",
    value: function getEventCenter() {
      return apiRTC.eventCenter;
    }
    /**
     * @typedef RegisterInformation
     * @type {Object}
     * @property {string} cloudUrl Registration ApiRTC cloud platform url
     * @property {number} cloudFetchRetries=100 Number of fetch retry when sending request to your ApiRTC cloud platform
     * @property {number} cloudFetchRetryDelay=200 Delay in ms between fetch retry when sending request to your ApiRTC cloud platform. This delay is increased on each retry : retryDelay = retryDelay x retryNumber.
     * @property {string} id Set a predefined id for the session instead of the cloud id or a random id
     * @property {string} uri Set this user agent uri for registration
     * @property {string} mcu Preferred MCU server
     * @property {string} ccs Preferred CCS server
     * @property {string} password UserAgent password for 'apirtc:' user agents
     * @property {string[]} groups Presence groups the user agent will join on registration
     * @property {string[]} subscribeTo Presence groups the user agent will subscribe to on registration
     * @property {Object} userData Set initial userData like photo, nickname...
     * @property {number} extJsLoadingRetryNb=100 Number of retry on external Js loading
     * @property {number} extJsLoadingRetryDelay=200 Delay in ms between two retries on external Js loading. This delay is increased on each retry : retryDelay = retryDelay x retryNumber.
     * @property {number} ccsConnectionRetryNb=Infinity Number of retry on CCS connection
     * @property {number} ccsConnectionRetryDelay=1000 Delay in ms to initially wait before attempting a new reconnection to CCS. Then it is affected with a random factor of 0.5
     * @property {number} contactDisconnectionDelay=10000 Delay in ms before a contact is actually seen as offline after it disconnected (eg. short reconnection after page switching)
     * @property {string} turnServerAddress=mp1.apizee.com Turn server address to be used for all calls
     * @property {boolean} userAcceptOnIncomingDataCall=true This option will enables you to request user to accept or refuse the data call
     * @property {boolean} userAcceptOnIncomingScreenSharingCall=false This option will enables you to request user to accept or refuse the screenSharing call.
     * @property {boolean} idConversionActivated When this option is activated if id is a string, it will be converted to a numeric value. This is deactivated by default.
     * @property {number} idPersistenceTimeout Time in ms to keep a given id after unregistration.
     * @property {string} token token parameter to be used for user authentication
     * @property {string} captcha_token captcha_token parameter to be used for user authentication
     */

    /**
     * start Whiteboard. This enable whiteboard feature in an offline mode.
     * @property {string} canvasId Identifier of the canvas to use for whiteboard
     * @property {string} cursorColor=invisible User cursor color, sets the user cursor color that will be seen by other participants. Set to '#000000' to have a black cursor.
     */

  }, {
    key: "startWhiteboard",
    value: function startWhiteboard(canvasId, cursorColor) {
      logger.trace('startWhiteboard()');
      apiRTCManager.whiteBoardClient.start();
      apiRTCManager.whiteBoardClient.setCanvas(canvasId);

      if (cursorColor !== null && cursorColor !== undefined) {
        apiRTCManager.whiteBoardClient.setUserCursorColor(cursorColor);
      }
    }
    /**
     * stop Whiteboard. Stop whiteboard feature.
     */

  }, {
    key: "stopWhiteboard",
    value: function stopWhiteboard() {
      logger.trace('stopWhiteboard()');
      apiRTCManager.whiteBoardClient.stop();
    }
    /**
     * Returns whiteboard client
     *
     *  @returns {WhiteboardClient} WhiteboardClient
     */

  }, {
    key: "getWhiteboardClient",
    value: function getWhiteboardClient() {
      logger.trace('getWhiteboardClient()');
      return apiRTCManager.whiteBoardClient;
    }
    /**
     * Register a UA to the server. If the User Agent URI is prefixed with 'apirtc:', a password has to be specified in the options
     *
     *  @param {RegisterInformation} options all user connection options
     *  @example <caption>Register an UserAgent</caption>
     *  user1.register({
     *          password: 'aaaa'
     *      })
     *      .then((session) => {
     *          // OK : UserAgent is connected to the ApiRTC platform
     *      })
     *      .catch((error) => {
     *          // error : UserAgent could not be connected to the ApiRTC platform
     *      });
     * @returns {Promise<Session>} Connected Session in a promise
     */

  }, {
    key: "register",
    value: function register() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Promise(function (resolve, reject) {
        logger.info('Register ' + _this3.uri);

        if (options.hasOwnProperty('uri')) {
          _this3.uri = options.uri;
        }

        if (options.hasOwnProperty('cloudUrl')) {
          cloudApi.setCloudURL(options.cloudUrl);
        }

        if (options.hasOwnProperty('cloudFetchRetries')) {
          cloudApi.setFetchRetries(options.cloudFetchRetries);
        }

        if (options.hasOwnProperty('cloudFetchRetryDelay')) {
          cloudApi.setFetchRetryDelay(options.cloudFetchRetryDelay);
        }

        if (_this3.uri === null) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_REGISTRATION_URI_INVALID, 'register() - Cannot register UserAgent, no uri was specified', logger));
          return;
        }

        if (_this3.currentSession) {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_APIRTC_SESSION_ALREADY_ON, 'register() - Session already ON', logger));
          return;
        }

        if (_this3.uri.startsWith(AUTH_PREFIX_TOKEN)) {
          registerPrefixToken(_this3, options, resolve, reject);
        } else if (_this3.uri.startsWith(AUTH_PREFIX_APIZEE) || _this3.uri.startsWith(AUTH_PREFIX_APIRTC)) {
          registerPrefixApizee(_this3, options, resolve, reject);
        } else if (_this3.uri.startsWith(AUTH_PREFIX_ANONYMOUS) || _this3.uri.startsWith(AUTH_PREFIX_ANONYMOUS_APIKEY)) {
          registerPrefixAnonymous(_this3, options, resolve, reject);
        } else {
          var prefix = _this3.uri.split(':')[0];

          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_REGISTRATION_URI_INVALID, 'register() - prefix invalid used for uri :' + prefix, logger));
        }
      });
    }
    /**
     * Unregisters this UserAgent
     *
     *  @example <caption>Unregister n UserAgent</caption>
     *  ua.unregister()
     *      .then(() => {
     *          // OK : UserAgent is disconnected from the ApiRTC platform
     *      })
     *      .catch((error) => {
     *          // error : an error occured during unregistration
     *      });
     *  @param {DisconnectOptions} options
     *  @returns {Promise<void>}
     */

  }, {
    key: "unregister",
    value: function unregister() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        invalidateUserToken: true
      };
      return new Promise(function (resolve, reject) {
        if (_this4.currentSession !== null) {
          _this4.currentSession.disconnect(options).then(function () {
            _this4.currentSession = null;

            _enterprise.set(_this4, null);

            resolve();
          })["catch"](function (err) {
            reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'unregister() - unregistration error', logger));
          });
        } else {
          reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'unregister() - no current session', logger));
        }
      });
    }
    /**
     * Tests whether the UserAgent represented by this one is registered.
     *
     *  @returns {boolean} true if UA is already registered.
     */

  }, {
    key: "isRegistered",
    value: function isRegistered() {
      return this.currentSession !== null;
    }
    /**
     * @typedef DefaultDevices
     * @type {Object}
     * @property {MediaDevice} audioInput
     * @property {MediaDevice} audioOutput
     * @property {MediaDevice} videoInput
     */

    /**
     * Returns UserAgent default devices
     *
     * @returns {DefaultDevices}
     */

  }, {
    key: "getDefaultDevices",
    value: function getDefaultDevices() {
      return {
        audioInput: apiCC.mediaDeviceMgr.defaultAudioInput,
        audioOutput: apiCC.mediaDeviceMgr.defaultAudioOuput,
        videoInput: apiCC.mediaDeviceMgr.defaultVideoInput
      };
    }
    /**
     * Enables call statistics monitoring.
     * @param {boolean} enabled - If true, call statistics monitoring is enabled, otherwise call statistics monitoring is disabled.
     * @param {object} options - Options.
     * @param {number} options.interval - User defined iteration interval. In milliseconds. Minimum of 1000 milliseconds.
     */

  }, {
    key: "enableCallStatsMonitoring",
    value: function enableCallStatsMonitoring(enabled) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (['chrome', 'firefox'].indexOf(apiCC.browserDetails.type) < 0) {
        logger.warn('enableCallStatsMonitoring() is only supported on Chrome and Firefox, support on other browsers will be added soon');
        return;
      }

      if (enabled === true) {
        this.callStatsMonitoringEnabled = true;

        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'interval', 'number') && options.interval >= 1000) {
          this.callStatsMonitoringInterval = options.interval;
        }

        if (this.isRegistered && apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.enableCallStatsMonitoring(true, this.callStatsMonitoringInterval);
        }
      } else {
        this.callStatsMonitoringEnabled = false;

        if (this.isRegistered && apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.enableCallStatsMonitoring(false);
        }
      }
    }
    /**
     * Enables detecting the active speaker.
     * @param {boolean} enabled - If true, detecting the active speaker is enabled, otherwise detecting the active speaker is disabled.
     * @param {object} options - Options.
     * @param {number} options.threshold - User defined threshold. In dB. Default is 50 dB.
     */

  }, {
    key: "enableActiveSpeakerDetecting",
    value: function enableActiveSpeakerDetecting(enabled) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (enabled === true) {
        if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'threshold', 'number') && options.threshold > 0) {
          apiRTC.enableActiveSpeakerDetecting(true, options.threshold);
        } else {
          apiRTC.enableActiveSpeakerDetecting(true);
        }
      } else {
        apiRTC.enableActiveSpeakerDetecting(false);
      }
    }
    /**
     * Enables mesh room mode during conference.
     *
     * @param {boolean} enabled=false - Whether mesh room mode shall be used during conference.
     */

  }, {
    key: "enableMeshRoomMode",
    value: function enableMeshRoomMode(enabled) {
      if (enabled === false || enabled === true) {
        this.meshModeEnabled = enabled;

        if (this.isRegistered && apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.enableMeshRoomMode(enabled);
        }
      } else {
        logger.error('Wrong value', enabled);
      }
    }
    /**
     * Set target bandwitdh usage for video calls (700 is default, be sure to set at least to 300)
     *
     * @param {number} kbps Target bandwitdh usage for video calls in kbps
     * @returns {void}
     * @see setOverallIncomingVideoBandwidth
     * @see setOverallOutgoingVideoBandwidth
     * @see setPerCallIncomingVideoBandwidth
     * @see setPerCallOutgoingVideoBandwidth
     */

  }, {
    key: "setTargetBandwidthUsage",
    value: function setTargetBandwidthUsage(kbps) {
      if (typeof kbps !== 'number' && !isNaN(kbps) && kbps > 0) {
        this.targetBandwidthUsage = kbps;

        if (this.isRegistered) {
          apiRTCManager.webRTCClient.setVideoBandwidth(kbps);
        }
      } else {
        logger.error('Unvalid target bandwidth usage value', kbps);
      }
    }
    /**
     * Sets video bandwidth limitation for the overall incoming traffic.
     *
     * @param {number} bandwidth bandwidth usage in kilobits per second.
     * @returns {void}
     */

  }, {
    key: "setOverallIncomingVideoBandwidth",
    value: function setOverallIncomingVideoBandwidth(bandwidth) {
      if (bandwidth > 0) {
        // Setting the limit.
        this.videoBandwidthSettings.overallIncoming = bandwidth;

        if (this.isRegistered && apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.setOverallIncomingVideoBandwidth(bandwidth);
        }
      } else {
        // Canceling the limit.
        delete this.videoBandwidthSettings.overallIncoming;

        if (this.isRegistered && apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.setOverallIncomingVideoBandwidth(0);
        }
      }
    }
    /**
     * Sets video bandwidth limitation for the overall outgoing traffic.
     *
     * @param {number} bandwidth bandwidth usage in kilobits per second.
     * @returns {void}
     */

  }, {
    key: "setOverallOutgoingVideoBandwidth",
    value: function setOverallOutgoingVideoBandwidth(bandwidth) {
      if (bandwidth > 0) {
        // Setting the limit.
        this.videoBandwidthSettings.overallOutgoing = bandwidth;

        if (this.isRegistered && apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.setOverallOutgoingVideoBandwidth(bandwidth);
        }
      } else {
        // Canceling the limit.
        delete this.videoBandwidthSettings.overallOutgoing;

        if (this.isRegistered && apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.setOverallOutgoingVideoBandwidth(0);
        }
      }
    }
    /**
     * Sets video bandwidth limitation for incoming traffic (on per-call basis).
     *
     * @param {number} bandwidth bandwidth usage in kilobits per second.
     * @returns {void}
     */

  }, {
    key: "setPerCallIncomingVideoBandwidth",
    value: function setPerCallIncomingVideoBandwidth(bandwidth) {
      if (bandwidth > 0) {
        // Setting the limit.
        this.videoBandwidthSettings.perCallIncoming = bandwidth;

        if (this.isRegistered && apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.setPerCallIncomingVideoBandwidth(bandwidth);
        }
      } else {
        // Canceling the limit.
        delete this.videoBandwidthSettings.perCallIncoming;

        if (this.isRegistered && apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.setPerCallIncomingVideoBandwidth(0);
        }
      }
    }
    /**
     * Sets video bandwidth limitation for outgoing traffic (on per-call basis).
     *
     * @param {number} bandwidth bandwidth usage in kilobits per second.
     * @returns {void}
     */

  }, {
    key: "setPerCallOutgoingVideoBandwidth",
    value: function setPerCallOutgoingVideoBandwidth(bandwidth) {
      if (bandwidth > 0) {
        // Setting the limit.
        this.videoBandwidthSettings.perCallOutgoing = bandwidth;

        if (this.isRegistered && apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.setPerCallOutgoingVideoBandwidth(bandwidth);
        }
      } else {
        // Canceling the limit.
        delete this.videoBandwidthSettings.perCallOutgoing;

        if (this.isRegistered && apiRTCManager.webRTCClient) {
          apiRTCManager.webRTCClient.setPerCallOutgoingVideoBandwidth(0);
        }
      }
    }
    /**
     * Update media stream during a call. If changing video bandwidth during call,  use setTargetBandwidthUsage before updating the media stream.
     *
     * @param {number} callId call ID.
     * @param {number} callId local stream ID.
     *
     * *  @example <caption>Change video bandwidth during call</caption>
     * user1.setTargetBandwidthUsage (1000);
     * user1.updateMediaDeviceOnCall(callID, localStream.userMediaStreamId);
     *
     *
     * @returns {void}
     */

  }, {
    key: "updateMediaOnCall",
    value: function updateMediaOnCall(callId, streamId) {
      apiRTCManager.webRTCClient.updateMediaDeviceOnCall(callId, streamId);
    }
    /**
     * @typedef UserAgentCapabities
     * @type {Object}
     * @property {string} whiteboardCursor value is 'ON' whether cursor on whiteboard is supported on device. 'OFF' if not supported
     * @property {string} mediaDeviceChanged value is 'ON' whether mediaDeviceChanged event is supported on device. 'OFF' if not supported
     * @property {string} webRTCCompliant value is 'ON' whether WebRTC is supported on browser. 'OFF' if not supported
     * @property {string} screenSharingCompliant value is 'ON' whether screenSharing is supported on browser. 'OFF' if not supported
     * @property {string} qoSStatCompliant value is 'ON' whether QoS Statitics are supported on browser. 'OFF' if not supported
     * @property {string} backgroundRemoval value is 'ON' whether backgroundRemoval functions (blur/imageBackground) are supported on browser. 'OFF' if not supported
     * @property {string} streamCapabilities value is 'ON' wether Stream capabilities functions are supported on browser. 'OFF' if not supported
     * @property {string} noiseReduction value is 'ON' wether Noise Reduction functions are supported on browser. 'OFF' if not supported
     */

    /**
     * get UserAgent capabilities.
     *
     * @returns {UserAgentCapabities}
     */

  }, {
    key: "getCapabilities",
    value: function getCapabilities() {
      return this.capabilities;
    }
    /**
     * get UserAgent browser name.
     *
     * @returns {String} Returns browser name
     */

  }, {
    key: "getBrowser",
    value: function getBrowser() {
      return this.browser;
    }
    /**
     * get UserAgent browser major version.
     *
     * @returns {String} Returns browser major version
     */

  }, {
    key: "getBrowserMajorVersion",
    value: function getBrowserMajorVersion() {
      return this.browser_major_version;
    }
    /**
     * get UserAgent browser version.
     *
     * @returns {String} Returns browser version
     */

  }, {
    key: "getBrowserVersion",
    value: function getBrowserVersion() {
      return this.browser_version;
    }
    /**
     * get UserAgent OS name.
     *
     * @returns {String} Returns OS name
     */

  }, {
    key: "getOsName",
    value: function getOsName() {
      return this.osName;
    }
    /**
     * get UserAgent OS version.
     *
     * @returns {String} Returns OS version
     */

  }, {
    key: "getOsVersion",
    value: function getOsVersion() {
      return this.osVersion;
    }
    /**
     * get UserAgent browser information.
     *
     * @returns {String} Returns browser information
     */

  }, {
    key: "getBrowserInfo",
    value: function getBrowserInfo() {
      return this.browserInfo;
    }
    /**
     * get UserAgent browser details information.
     *
     * @returns {String} Returns browserDetails information : this can be used to determine if browser is based on Chromium
     */

  }, {
    key: "getBrowserDetails",
    value: function getBrowserDetails() {
      return this.browserDetails;
    }
    /**
     * get UserAgent CPU architecture information if available.
     *
     * @returns {String} Returns cpu architecture, could be one of the following : 68k, amd64, arm[64/hf], avr, ia[32/64], irix[64], mips[64], pa-risc, ppc, sparc[64] or undefined
     */

  }, {
    key: "getCPUArchitecture",
    value: function getCPUArchitecture() {
      return this.getUserData().cpuArchitecture;
    }
    /**
     * get UserAgent device vendor if available.
     *
     * @returns {String} Returns device vendor, could be one of the following : Acer, Alcatel, Amazon, Apple, ... , Vodafone, Xbox, Xiaomi, Zebra, ZTE or undefined
     */

  }, {
    key: "getDeviceVendor",
    value: function getDeviceVendor() {
      return this.getUserData().deviceVendor;
    }
    /**
     * get UserAgent device model if available.
     *
     * @returns {String} Returns device model
     */

  }, {
    key: "getDeviceModel",
    value: function getDeviceModel() {
      return this.getUserData().deviceModel;
    }
    /**
     * get UserAgent browser engine name if available.
     *
     * @returns {String} Returns browser engine name, could be one of the following : Amaya, Blink, EdgeHTML, Flow, Gecko, Goanna, iCab, KHTML, Links, Lynx, NetFront, NetSurf, Presto, Tasman, Trident, w3m, WebKit or undefined
     */

  }, {
    key: "getEngineName",
    value: function getEngineName() {
      return this.getUserData().engineName;
    }
    /**
     * get UserAgent browser engine version if available.
     *
     * @returns {String} Returns browser engine version
     */

  }, {
    key: "getEngineVersion",
    value: function getEngineVersion() {
      return this.getUserData().engineVersion;
    }
    /*
    * checkUACapabilities : check available feature on UserAgent
    */

  }, {
    key: "checkUACapabilities",
    value: function checkUACapabilities() {
      logger.debug("checkUACapabilities"); //TO be completed
      // logger.debug("browser :", apiRTC.browser);
      // logger.debug("browser_major_version :", apiRTC.browser_major_version);
      // logger.debug("browser_version :", apiRTC.browser_version);
      // logger.debug("osName :", apiRTC.osName);
      //Ckecking whiteboardCursor support

      if (apiRTC.osName === "iOS") {
        logger.debug("Deactivating whiteboardCursor for iOS");
        this.capabilities.whiteboardCursor = 'OFF';
      } //Ckecking mediaDeviceChanged support


      if (apiRTC.osName === "Android" && apiRTC.browser === "Chrome") {
        logger.debug("mediaDeviceChanged not supported on Chrome/Android");
        this.capabilities.mediaDeviceChanged = 'OFF';
      }

      if (_Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_10__.browser === "Safari" || _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_10__.browser === "Mobile Safari") {
        logger.debug("mediaDeviceChanged not supported on Safari");
        this.capabilities.mediaDeviceChanged = 'OFF';
      }

      if (apiRTC.webRTCCompliant === false) {
        logger.debug("WebRTC not compliant");
        this.capabilities.webRTCCompliant = 'OFF';
      }

      if (apiRTC.screenSharingCompliant === false) {
        logger.debug("screenSharing not compliant");
        this.capabilities.screenSharingCompliant = 'OFF';
      }

      if (apiRTC.qoSStatCompliant === false) {
        logger.debug("qoS Stat not compliant");
        this.capabilities.qoSStatCompliant = 'OFF';
      }

      if (!('requestVideoFrameCallback' in HTMLVideoElement.prototype) || _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_10__.browser === "Safari" || _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_10__.browser === "Mobile Safari") {
        logger.debug("background removal not compliant");
        this.capabilities.backgroundRemoval = 'OFF';
      }

      if (!('getCapabilities' in MediaStreamTrack.prototype)) {
        logger.debug("Stream capabilities not compliant");
        this.capabilities.streamCapabilities = 'OFF';
      }

      if (_Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_10__.browser === "Safari" || _Core_BrowserInfo__WEBPACK_IMPORTED_MODULE_10__.browser === "Mobile Safari") {
        logger.debug("noiseReduction not compliant");
        this.capabilities.noiseReduction = 'OFF';
      }
    }
    /**
     * Runs Precall test
     *
     * @param {callback} precallTestTerminated
     * @param {boolean} enableCamResolutionTest true to execute camera resolution test, false otherwise
     * @param {number} maxVideoBandwidth video bandwidth limitation of the auto webrtc call
     * @param {string} audioSourceId video device ID
     * @param {string} videoSourceId audio device ID
     */

  }, {
    key: "startPrecallTest",
    value: function startPrecallTest(precallTestTerminated, enableCamResolutionTest, maxVideoBandwidth, audioSourceId, videoSourceId) {
      apiRTCManager.webRTCClient.startPrecallTest(precallTestTerminated, enableCamResolutionTest, maxVideoBandwidth, audioSourceId, videoSourceId);
    }
  }, {
    key: "sendLogToCloud",
    value: function sendLogToCloud(externalLog, enterpriseId, cloudURL, notSending) {
      apiCC.sendLogToCloud(externalLog, enterpriseId, cloudURL, notSending);
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return USERAGENT_EVENTS;
    }
  }]);

  return UserAgent;
}(_utils_Observable__WEBPACK_IMPORTED_MODULE_2__.Observable);
/*
 * Register wrapper for Apizee prefix (called from UserAgent.register())
 */


var registerPrefixApizee = function registerPrefixApizee(ua, options, resolve, reject) {
  var splittedUri = ua.uri.split(':');
  logger.debug('register() - Registration using prefix :' + splittedUri[0]);
  var username = splittedUri[1];

  if (options.password !== null && typeof options.password === 'string') {
    cloudApi.authentication(username, options.password, options.captcha_token).then(function (response) {
      return initializeCloudUASession(ua, response.token, options);
    }).then(function (session) {
      resolve(session);
    })["catch"](function (err) {
      logger.error("registerPrefixApizee err : ", err.message);
      var errorMsg = 'register() - An error occured during cloud credentials registration :' + JSON.stringify(err);
      var errorObj = err;
      errorObj.message = errorMsg;

      if (err.hasOwnProperty('code')) {
        errorObj.code = err.code;
      } else if (err.hasOwnProperty('http_code')) {
        if (err.http_code.toString().startsWith('4')) {
          errorObj.code = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_INVALID_CREDENTIALS;
        } else {
          errorObj.code = _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_SERVER_UNAVAILABLE;
        }
      }

      reject(errorObj);
    });
  } else {
    reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_INVALID_CREDENTIALS, 'register() - No password was specified for ' + AUTH_PREFIX_APIZEE + ' UserAgent registration', logger));
  }
};
/*
 * Register wrapper for Token prefix (called from UserAgent.register())
 */


var registerPrefixToken = function registerPrefixToken(ua, options, resolve, reject) {
  logger.debug('register() - Registration using prefix :' + AUTH_PREFIX_TOKEN);
  var token = ua.uri.split(':')[1];
  cloudApi.checkUserToken(token).then(function (response) {
    return initializeCloudUASession(ua, token, options);
  }).then(resolve)["catch"](function (err) {
    reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'register() - An error occured during cloud token registration', logger));
  });
};
/*
 * Register wrapper for Anonymous/API key prefix (called from UserAgent.register())
 */


var registerPrefixAnonymous = function registerPrefixAnonymous(ua, options, resolve, reject) {
  var splittedUri = ua.uri.split(':');
  logger.debug('register() - Registration using prefix :' + splittedUri[0]);
  var apiKey = splittedUri[1];

  if (!apiKey || typeof apiKey !== 'string') {
    return reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'register() - Wrong apiKey', logger));
  } //promise wrapper for getting ccs


  var getCCS = function getCCS() {
    return new Promise(function (resolve2, reject2) {
      cloudApi.getPreferredCCS(apiKey).then(function (res) {
        if (options.ccs && options.ccs !== res.ccs) {
          logger.debug("Overloading CCS address with init option");
          res.ccs = options.ccs;
        }

        resolve2(res);
      })["catch"](function () {
        reject2(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_OTHER, 'register() - Could not get preferred CCS', logger));
      });
    });
  };

  getCCS().then(function (res) {
    ua.currentSession = new _Session__WEBPACK_IMPORTED_MODULE_4__.Session(ua);
    ua.currentSession.user = ua;
    ua.currentSession.token = null;

    if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'nickname', 'string')) {
      ua.username = options.nickname;
    } else {
      ua.username = 'guest-' + _utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.guid().substr(0, 13);
    }

    ua.preRegisterUserData.setProp('username', ua.username);
    ua.preRegisterUserData.setProp('userConfId', ua.username + Date.now());

    if (options.userData) {
      ua.preRegisterUserData.setProps(options.userData);
    }

    var params = {
      apiKey: apiKey,
      MCUActivated: true,
      mcu: options.hasOwnProperty('mcu') ? options.mcu : _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DEFAULT_MCU,
      nickname: ua.username,
      ccsServer: res.ccs,
      bandwidthTestServer: cloudApi.cloudUrl,
      webRTCPluginActivated: true,
      userData: ua.preRegisterUserData,
      tryAudioCallAfterUserMediaError: true,
      extJsLoadingRetryNb: options.extJsLoadingRetryNb,
      extJsLoadingRetryDelay: options.extJsLoadingRetryDelay,
      ccsConnectionRetryNb: options.ccsConnectionRetryNb,
      ccsConnectionRetryDelay: options.ccsConnectionRetryDelay,
      turnServerAddress: options.turnServerAddress,
      userAcceptOnIncomingDataCall: options.userAcceptOnIncomingDataCall,
      userAcceptOnIncomingScreenSharingCall: options.userAcceptOnIncomingScreenSharingCall,
      cloudIsSecured: res.secure
    };

    if (options.hasOwnProperty('id')) {
      params.apiCCId = options.id;
    }

    if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'idPersistenceTimeout', 'number') && options.idPersistenceTimeout >= 0) {
      params.apiCCIdPersistenceTimeout = options.idPersistenceTimeout;
    }

    if (options.hasOwnProperty('groups')) {
      params.presenceGroup = options.groups;
    }

    if (options.hasOwnProperty('subscribeTo')) {
      params.subscribeToPresenceGroup = options.subscribeTo; //params.subscribeToPresenceGroup = params.subscribeToPresenceGroup.concat(options.subscribeTo);
    }

    if (options.hasOwnProperty('contactDisconnectionDelay')) {
      logger.debug("Setting contactDisconnectionDelay :", options.contactDisconnectionDelay);
      apiRTCManager.contactDisconnectionDelay = options.contactDisconnectionDelay;
    }

    params.idConversionActivated = false;

    if (options.hasOwnProperty('idConversionActivated')) {
      params.idConversionActivated = options.idConversionActivated;
    }

    if (options.hasOwnProperty('conversationSpace')) {
      params.conversationSpace = options.conversationSpace;
    }

    if (options.hasOwnProperty('token')) {
      params.token = options.token;
      ua.currentSession.ccsToken = options.token;
    }

    return apiRTCManager.initializeApiRTC(params);
  }).then(function (apiCCid) {
    if (ua.callStatsMonitoringEnabled === false || ua.callStatsMonitoringEnabled === true) {
      apiRTCManager.webRTCClient.enableCallStatsMonitoring(ua.callStatsMonitoringEnabled, ua.callStatsMonitoringInterval);
    }

    if (ua.meshModeEnabled === false || ua.meshModeEnabled === true) {
      apiRTCManager.webRTCClient.enableMeshRoomMode(ua.meshModeEnabled);
    }

    if (ua.targetBandwidthUsage > 0) {
      // deprecated.
      apiRTCManager.webRTCClient.setVideoBandwidth(ua.targetBandwidthUsage);
    }

    if (ua.videoBandwidthSettings.overallIncoming > 0) {
      apiRTCManager.webRTCClient.setOverallIncomingVideoBandwidth(ua.videoBandwidthSettings.overallIncoming);
    }

    if (ua.videoBandwidthSettings.overallOutgoing > 0) {
      apiRTCManager.webRTCClient.setOverallOutgoingVideoBandwidth(ua.videoBandwidthSettings.overallOutgoing);
    }

    if (ua.videoBandwidthSettings.perCallIncoming > 0) {
      apiRTCManager.webRTCClient.setPerCallIncomingVideoBandwidth(ua.videoBandwidthSettings.perCallIncoming);
    }

    if (ua.videoBandwidthSettings.perCallOutgoing > 0) {
      apiRTCManager.webRTCClient.setPerCallOutgoingVideoBandwidth(ua.videoBandwidthSettings.perCallOutgoing);
    }

    ua.userId = apiCCid;
    ua.currentSession.init(apiCCid);
    logger.log('register() - APIRTC init OK', apiCCid); // Initialize session userData

    if (typeof apiRTCManager.apiRTCSession.userData !== 'undefined' && apiRTCManager.apiRTCSession.userData !== null) {
      ua.currentSession.userData = new _UserData__WEBPACK_IMPORTED_MODULE_6__.UserData(apiRTCManager.apiRTCSession.userData);
    }

    resolve(ua.currentSession);
  })["catch"](function (error) {
    reject(_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.createError(_utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.ERROR_APIRTC_INITIALISATION_FAILED, 'register() - ApiRTC Initialization error : ' + error, logger));
    delete ua.currentSession;
    ua.currentSession = null;
  });
};
/*
 * private wrapper function to initialise a cloud user agent's session
 */


var initializeCloudUASession = function initializeCloudUASession(ua, token) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var enterprise = null;
  var userInformation = null;
  logger.debug('initializeCloudUASession :', options);
  return new Promise(function (resolve, reject) {
    cloudApi.getConnectedUserInformation(token).then(function (result) {
      userInformation = result;
      logger.debug('Connected user information : ', result);
      ua.currentSession = new _Session__WEBPACK_IMPORTED_MODULE_4__.Session(ua);
      ua.currentSession.user = ua;
      ua.currentSession.token = result.token;

      if (options.hasOwnProperty('idPersistenceTimeout')) {
        ua.currentSession.idPersistenceTimeout = options.idPersistenceTimeout;
      }

      ua.username = result.nickname;
      ua.preRegisterUserData.setProp('username', ua.username);
      ua.preRegisterUserData.setProp('nickname', ua.username);
      ua.preRegisterUserData.setProp('photo_url', result.photo_url);

      if (result.mail) {
        ua.preRegisterUserData.setProp('mail', result.mail);
      }

      ua.preRegisterUserData.setProp('userConfId', ua.username + Date.now());

      if (options.userData) {
        ua.preRegisterUserData.setProps(options.userData);
      }

      if (options.hasOwnProperty('overLoadedApiRTCKey') && options.overLoadedApiRTCKey !== null && options.overLoadedApiRTCKey !== undefined && result.apiKey !== options.overLoadedApiRTCKey) {
        logger.debug('overLoadedApiRTCKey is defined :', options.overLoadedApiRTCKey); //Using overLoadedApiRTCKey for initializeApiRTC

        enterprise = new _Enterprise__WEBPACK_IMPORTED_MODULE_5__.Enterprise(result.enterpriseId, options.overLoadedApiRTCKey, ua.currentSession); //Remove Id information for initializeApiRTC

        delete options.id;
        ua.userId = null;

        _enterprise.set(ua, enterprise);

        logger.debug('... no enterprise users data loading');
      } else {
        ua.userId = result.userId;
        enterprise = new _Enterprise__WEBPACK_IMPORTED_MODULE_5__.Enterprise(result.enterpriseId, result.apiKey, ua.currentSession);

        _enterprise.set(ua, enterprise);

        return enterprise.load();
      }
    }).then(function () {
      var params = {
        apiKey: enterprise.getApiKey(),
        ccsServer: options.ccs || userInformation.ccs,
        MCUActivated: true,
        mcu: options.hasOwnProperty('mcu') ? options.mcu : _utils_Constants__WEBPACK_IMPORTED_MODULE_0__.Constants.DEFAULT_MCU,
        nickname: ua.username,
        bandwidthTestServer: cloudApi.cloudUrl,
        webRTCPluginActivated: true,
        apiCCId: options.hasOwnProperty('id') ? options.id : ua.userId,
        userData: ua.preRegisterUserData,
        tryAudioCallAfterUserMediaError: true,
        presenceGroup: ['agent'],
        subscribeToPresenceGroup: ['agent', 'visitor'],
        extJsLoadingRetryNb: options.extJsLoadingRetryNb,
        extJsLoadingRetryDelay: options.extJsLoadingRetryDelay,
        ccsConnectionRetryNb: options.ccsConnectionRetryNb,
        ccsConnectionRetryDelay: options.ccsConnectionRetryDelay,
        turnServerAddress: options.turnServerAddress,
        userAcceptOnIncomingDataCall: options.userAcceptOnIncomingDataCall,
        userAcceptOnIncomingScreenSharingCall: options.userAcceptOnIncomingScreenSharingCall
      };

      if (_utils_Misc__WEBPACK_IMPORTED_MODULE_1__.Misc.isPropertyTypeof(options, 'idPersistenceTimeout', 'number') && options.idPersistenceTimeout >= 0) {
        params.apiCCIdPersistenceTimeout = options.idPersistenceTimeout;
      }

      if (options.hasOwnProperty('groups')) {
        params.presenceGroup = options.groups;
      }

      if (options.hasOwnProperty('subscribeTo')) {
        params.subscribeToPresenceGroup = options.subscribeTo; //params.subscribeToPresenceGroup = params.subscribeToPresenceGroup.concat(options.subscribeTo);
      }

      if (options.hasOwnProperty('contactDisconnectionDelay')) {
        logger.debug("Setting contactDisconnectionDelay :", options.contactDisconnectionDelay);
        apiRTCManager.contactDisconnectionDelay = options.contactDisconnectionDelay;
      }

      params.idConversionActivated = false;

      if (options.hasOwnProperty('idConversionActivated')) {
        params.idConversionActivated = options.idConversionActivated;
      }

      if (options.hasOwnProperty('conversationSpace')) {
        params.conversationSpace = options.conversationSpace;
      }

      return apiRTCManager.initializeApiRTC(params);
    }).then(function (apiCCid) {
      if (ua.callStatsMonitoringEnabled === false || ua.callStatsMonitoringEnabled === true) {
        apiRTCManager.webRTCClient.enableCallStatsMonitoring(ua.callStatsMonitoringEnabled, ua.callStatsMonitoringInterval);
      }

      if (ua.meshModeEnabled === false || ua.meshModeEnabled === true) {
        apiRTCManager.webRTCClient.enableMeshRoomMode(ua.meshModeEnabled);
      }

      if (ua.targetBandwidthUsage > 0) {
        // deprecated.
        apiRTCManager.webRTCClient.setVideoBandwidth(ua.targetBandwidthUsage);
      }

      if (ua.videoBandwidthSettings.overallIncoming > 0) {
        apiRTCManager.webRTCClient.setOverallIncomingVideoBandwidth(ua.videoBandwidthSettings.overallIncoming);
      }

      if (ua.videoBandwidthSettings.overallOutgoing > 0) {
        apiRTCManager.webRTCClient.setOverallOutgoingVideoBandwidth(ua.videoBandwidthSettings.overallOutgoing);
      }

      if (ua.videoBandwidthSettings.perCallIncoming > 0) {
        apiRTCManager.webRTCClient.setPerCallIncomingVideoBandwidth(ua.videoBandwidthSettings.perCallIncoming);
      }

      if (ua.videoBandwidthSettings.perCallOutgoing > 0) {
        apiRTCManager.webRTCClient.setPerCallOutgoingVideoBandwidth(ua.videoBandwidthSettings.perCallOutgoing);
      }

      ua.currentSession.init(apiCCid);
      logger.info('APIRTC init OK', apiCCid); // Initialize session userData

      if (typeof apiRTCManager.apiRTCSession.userData !== 'undefined' && apiRTCManager.apiRTCSession.userData !== null) {
        ua.currentSession.userData = new _UserData__WEBPACK_IMPORTED_MODULE_6__.UserData(apiRTCManager.apiRTCSession.userData);
      }

      resolve(ua.currentSession);
    })["catch"](function (err) {
      logger.error(err);
      reject(err);
    });
  });
};



/***/ }),

/***/ "./src/public/UserData.js":
/*!********************************!*\
  !*** ./src/public/UserData.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UserData": () => (/* binding */ UserData)
/* harmony export */ });
/* harmony import */ var _private_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../private/Logger */ "./src/private/Logger.js");
/* harmony import */ var _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../private/ApiRTCManager */ "./src/private/ApiRTCManager.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }



var logger = _private_Logger__WEBPACK_IMPORTED_MODULE_0__.Logger.get('UserData');
var apiRTCManager = _private_ApiRTCManager__WEBPACK_IMPORTED_MODULE_1__.ApiRTCManager.get();
/**
 * User Data
 *
 * The user data is used to define information specific to a contact.
 * For example, informations of contact environment, his webrtc capabilities
 * or his profil informations.
 */

var UserData = /*#__PURE__*/function () {
  /**
   * Create a UserData instance
   *
   * @param {object} data user data object
   */
  function UserData() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, UserData);

    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        this[key] = data[key];
      }
    }
  }
  /**
   * Return user data property value
   *
   * @returns {*|null}
   */


  _createClass(UserData, [{
    key: "get",
    value: function get(prop) {
      if (this.hasOwnProperty(prop) && typeof this[prop] !== 'undefined' && this[prop] !== 'null' && this[prop] !== null) {
        return this[prop];
      } else {
        return null;
      }
    }
    /**
     * Set user data property to session
     */

  }, {
    key: "setToSession",
    value: function setToSession() {
      try {
        // Create new userData object without class methods
        var userData = {};

        for (var prop in this) {
          if (this.hasOwnProperty(prop) && typeof this[prop] !== 'function') {
            userData[prop] = this[prop];
          }
        } // Set new userData object to session


        apiRTCManager.apiRTCSession.setUserData(userData);
      } catch (err) {
        logger.error('setUserData() - could not set userData');
      }
    }
    /**
     * Set user data property
     *
     * @param {string} prop user data property key
     * @param {*} value property property value
     * @returns {UserData} current UserData instance
     */

  }, {
    key: "setProp",
    value: function setProp(prop, value) {
      this[prop] = value;
      return this;
    }
    /**
     * Set user data properties
     *
     * @param {object} props user data object
     * @returns {UserData} current UserData instance
     */

  }, {
    key: "setProps",
    value: function setProps(props) {
      for (var prop in props) {
        if (props.hasOwnProperty(prop)) {
          this[prop] = props[prop];
        }
      }

      return this;
    }
    /**
     * Check equality of two user data objects
     *
     * @param {*} a First user data object or UserData instance
     * @param {*} b Second user data object or UserData instance
     * @returns {boolean} true if objects are equal
     */

  }], [{
    key: "equals",
    value: function equals(a, b) {
      if (!(a instanceof Object) || !(b instanceof Object)) {
        return false;
      }

      for (var i in a) {
        if (typeof b[i] === 'undefined') {
          return false;
        }

        if (_typeof(b[i]) === 'object') {
          if (!this.equals(b[i], a[i])) {
            return false;
          }
        }

        if (b[i] !== a[i]) {
          return false;
        }
      }

      for (var _i in b) {
        if (typeof a[_i] === 'undefined') {
          return false;
        }

        if (_typeof(a[_i]) === 'object') {
          if (!this.equals(a[_i], b[_i])) {
            return false;
          }
        }

        if (a[_i] !== b[_i]) {
          return false;
        }
      }

      return true;
    }
  }]);

  return UserData;
}();



/***/ }),

/***/ "./src/utils/Constants.js":
/*!********************************!*\
  !*** ./src/utils/Constants.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Constants": () => (/* binding */ Constants)
/* harmony export */ });
var Constants = {};
/** @namespace Constants */

/** LOGGER */

Constants.LOG_PREFIX = 'apiRTC';
Constants.LOG_LEVEL_OFF = 0;
Constants.LOG_LEVEL_ERROR = 1;
Constants.LOG_LEVEL_WARN = 2;
Constants.LOG_LEVEL_INFO = 3;
Constants.LOG_LEVEL_DEBUG = 4;
Constants.LOG_LEVEL_TRACE = 5;
Constants.LOG_LEVEL_LABELS = {};
Constants.LOG_LEVEL_LABELS[Constants.LOG_LEVEL_ERROR] = 'ERROR';
Constants.LOG_LEVEL_LABELS[Constants.LOG_LEVEL_WARN] = 'WARN';
Constants.LOG_LEVEL_LABELS[Constants.LOG_LEVEL_INFO] = 'INFO';
Constants.LOG_LEVEL_LABELS[Constants.LOG_LEVEL_DEBUG] = 'DEBUG';
Constants.LOG_LEVEL_LABELS[Constants.LOG_LEVEL_TRACE] = 'TRACE';
/** ERROR CODES */

/**
 * @constant {number} ERROR_OTHER
 * @memberof Constants
 */

Constants.ERROR_OTHER = 0;
/**
 * @constant {number} ERROR_INVALID_CREDENTIALS
 * @memberof Constants
 */

Constants.ERROR_INVALID_CREDENTIALS = 1;
/**
 * @constant {number} ERROR_NETWORK_UNAVAILABLE
 * @memberof Constants
 */

Constants.ERROR_NETWORK_UNAVAILABLE = 2;
/**
 * @constant {number} ERROR_SERVER_UNAVAILABLE
 * @memberof Constants
 */

Constants.ERROR_SERVER_UNAVAILABLE = 3;
/**
 * @constant {number} ERROR_UNAUTHORIZED
 * @memberof Constants
 */

Constants.ERROR_UNAUTHORIZED = 4;
/**
 * @constant {number} ERROR_APIRTC_INITIALISATION_FAILED
 * @memberof Constants
 */

Constants.ERROR_APIRTC_INITIALISATION_FAILED = 5;
/**
 * @constant {number} ERROR_APIRTC_SESSION_ALREADY_ON
 * @memberof Constants
 */

Constants.ERROR_APIRTC_SESSION_ALREADY_ON = 6;
/**
 * @constant {number} ERROR_REGISTRATION_URI_INVALID
 * @memberof Constants
 */

Constants.ERROR_REGISTRATION_URI_INVALID = 7;
/**
 * @constant {number} ERROR_NOT_FOUND
 * @memberof Constants
 */

Constants.ERROR_NOT_FOUND = 8;
/**
 * @constant {number} ERROR_BAD_PARAMETER
 * @memberof Constants
 */

Constants.ERROR_BAD_PARAMETER = 9;
/**
 * @constant {number} ERROR_INVITATION_STATE_INVALID
 * @memberof Constants
 */

Constants.ERROR_INVITATION_STATE_INVALID = 10;
/**
 * @constant {number} ERROR_TIMED_OUT
 * @memberof Constants
 */

Constants.ERROR_TIMED_OUT = 11;
/**
 * @constant {number} ERROR_STREAM_RECORD
 * @memberof Constants
 */

Constants.ERROR_STREAM_RECORD = 12;
/**
 * @constant {number} ERROR_HTTP
 * @memberof Constants
 */

Constants.ERROR_HTTP = 13;
/**
 * @constant {number} ERROR_NOT_ALLOWED
 * @memberof Constants
 */

Constants.ERROR_NOT_ALLOWED = 14;
/**
 * @constant {number} ERROR_OPERATION_CANCELED
 * @memberof Constants
 */

Constants.ERROR_OPERATION_CANCELED = 15;
/**
 * @constant {number} ERROR_WRONG_STATE
 * @memberof Constants
 */

Constants.ERROR_WRONG_STATE = 16;
/**
 * @constant {number} LOG_LEVEL_OFF
 * @memberof Constants
 */

/**
 * @constant {number} LOG_LEVEL_ERROR
 * @memberof Constants
 */

/**
 * @constant {number} LOG_LEVEL_WARN
 * @memberof Constants
 */

/**
 * @constant {number} LOG_LEVEL_INFO
 * @memberof Constants
 */

/**
 * @constant {number} LOG_LEVEL_DEBUG
 * @memberof Constants
 */

/**
 * @constant {number} LOG_LEVEL_TRACE
 * @memberof Constants
 */
//media types

Constants.MEDIA_TYPE_PHOTO = 0;
Constants.MEDIA_TYPE_VIDEO = 1;
Constants.MEDIA_TYPE_AUDIO = 2;
Constants.MEDIA_TYPE_DOC = 3;
Constants.CONTACT_SEND_DATA_COMMAND = 'contact_data_command';
Constants.CONTACT_SEND_REMOTE_CONNECTION_APP = 'contact_remote_app';
Constants.CONTACT_SEND_REMOTE_CONNECTION_APP_CALLBACK = 'contact_remote_app_callback';
Constants.CONTACT_SEND_DATA_IDENTIFIER = 'contact_data';
Constants.CONTACT_NEW_MEDIA_IDENTIFIER = 'contact_new_media';
Constants.CONTACT_SEND_FILEINFO_IDENTIFIER = 'contact_file_info';
Constants.CONTACT_DATACHANNEL_INVITATION = 'contact_datachannel_invitation';
Constants.CONTACT_EVENTCENTER_DATA_REQUEST = 'contact_event_center_data_request';
Constants.CONTACT_EVENTCENTER_DATA_ANSWER = 'contact_event_center_data_answer';
Constants.CONTACT_GET_CAPABILITIES_IDENTIFIER = 'contact_get_capabilities';
Constants.CONTACT_GET_CAPABILITIES_RESULT_IDENTIFIER = 'contact_get_capabilities_result';
Constants.CONTACT_GET_SETTINGS_IDENTIFIER = 'contact_get_settings';
Constants.CONTACT_GET_SETTINGS_RESULT_IDENTIFIER = 'contact_get_settings_result';
Constants.CONTACT_GET_CONSTRAINTS_IDENTIFIER = 'contact_get_constraints';
Constants.CONTACT_GET_CONSTRAINTS_RESULT_IDENTIFIER = 'contact_get_constraints_result'; // Constants.CONTACT_GET_REMOTE_CAPABILITIES_AUTHORIZATION_IDENTIFIER = 'contact_get_remote_capabilities_authorization';
// Constants.CONTACT_GET_REMOTE_CAPABILITIES_AUTHORIZATION_ACCEPT_IDENTIFIER = 'contact_get_remote_capabilities_authorization_accept';
// Constants.CONTACT_GET_REMOTE_CAPABILITIES_AUTHORIZATION_REFUSE_IDENTIFIER = 'contact_get_remote_capabilities_authorization_refuse';

Constants.CONTACT_GET_REMOTE_AUDIO_FLOW_STATUS_IDENTIFIER = 'contact_get_remote_audio_flow_status';
Constants.CONTACT_GET_REMOTE_VIDEO_FLOW_STATUS_IDENTIFIER = 'contact_get_remote_video_flow_status';
Constants.CONTACT_GET_REMOTE_AUDIO_FLOW_STATUS_RESULT_IDENTIFIER = 'contact_get_remote_audio_flow_status_result';
Constants.CONTACT_GET_REMOTE_VIDEO_FLOW_STATUS_RESULT_IDENTIFIER = 'contact_get_remote_video_flow_status_result';
Constants.CONTACT_GET_REMOTE_ERROR = 'contact_get_remote_error';
Constants.CONTACT_APPLY_CONSTRAINTS_IDENTIFIER = 'contact_apply_constraints_identifier';
Constants.CONTACT_APPLY_CONSTRAINTS_RESULT_IDENTIFIER = 'contact_apply_constraints_result_identifier';
Constants.CONVERSATION_ACCESS_GRANTED = 'GRANTED';
Constants.CONVERSATION_NEED_MODERATOR_ACCEPTATION = 'NEED_MODERATOR_ACCEPTATION';
Constants.CONVERSATION_ROLE_MODERATOR = 'moderator';
Constants.CONVERSATION_ROLE_CONTRIBUTOR = 'contributor';
Constants.CONVERSATION_ROLE_GUEST = 'guest';
Constants.CONVERSATION_WAITING_ROOM_PREFIX = 'waiting-room-';
Constants.CONVERSATION_SEND_DATA_IDENTIFIER = 'conv_data';
Constants.CONVERSATION_PERSISTENT_DATA_UPDATE_IDENTIFIER = 'conv_persistent_data_update';
Constants.CONVERSATION_JOIN_REQUEST_IDENTIFIER = 'conv_join_req';
Constants.CONVERSATION_JOIN_ANSWER_IDENTIFIER = 'conv_join_ans';
Constants.CONVERSATION_MODERATOR_CONNECTED_IDENTIFIER = 'conv_moderator_connected';
Constants.CONVERSATION_NEW_MEDIA_IDENTIFIER = 'conv_new_media';
Constants.CONVERSATION_CLOSED_IDENTIFIER = 'conv_closed';
Constants.CONVERSATION_INVITATION_IDENTIFIER = 'conv_invite';
Constants.INVITATION_ANSWER_IDENTIFIER = 'invite_ans';
Constants.RECORD_BASE_URL = 'https://data2.apizee.com:10000/videoManager';
Constants.RECORD_PLAY_URL = Constants.RECORD_BASE_URL + '?action=play&recordedFileName=';
Constants.DEFAULT_MCU = 'mcu4.apizee.com';
Constants.DEFAULT_TURNADDRESS = 'mp1.apizee.com';
/**
 * @constant {Symbol} CALL_STATUS_WAITING_FOR_CALLEE
 * Call is waiting for callee to answer
 * @memberof Constants
 */

Constants.CALL_STATUS_WAITING_FOR_CALLEE = Symbol('CALL_STATUS_WAITING_FOR_CALLEE');
/**
 * @constant {Symbol} CALL_STATUS_ONGOING
 * Call is ongoing
 * @memberof Constants
 */

Constants.CALL_STATUS_ONGOING = Symbol('CALL_STATUS_ONGOING');
/**
 * @constant {Symbol} CALL_STATUS_ENDED
 * Call has ended
 * @memberof Constants
 */

Constants.CALL_STATUS_ENDED = Symbol('CALL_STATUS_ENDED');
/**
 * @constant {Symbol} DATACHANNEL_STATUS_WAITING
 * DataChannel session is waiting for callee to answer
 * @memberof Constants
 */

Constants.DATACHANNEL_STATUS_WAITING = Symbol('DATACHANNEL_STATUS_WAITING');
/**
 * @constant {Symbol} DATACHANNEL_STATUS_ONGOING
 * DataChannel session is ongoing
 * @memberof Constants
 */

Constants.DATACHANNEL_STATUS_ONGOING = Symbol('DATACHANNEL_STATUS_ONGOING');
/**
 * @constant {Symbol} DATACHANNEL_STATUS_ENDED
 * DataChannel session has ended
 * @memberof Constants
 */

Constants.DATACHANNEL_STATUS_ENDED = Symbol('DATACHANNEL_STATUS_ENDED');
/**
 * @constant {Symbol} DATACHANNEL_TYPE_RECEIVE
 * DataChannel session is on receive side only
 * @memberof Constants
 */

Constants.DATACHANNEL_TYPE_RECEIVE = Symbol('DATACHANNEL_TYPE_RECEIVE');
/**
 * @constant {Symbol} DATACHANNEL_TYPE_SEND
 * DataChannel session is on send side only
 * @memberof Constants
 */

Constants.DATACHANNEL_TYPE_SEND = Symbol('DATACHANNEL_TYPE_SEND');
/**
 * @constant {Symbol} CONVERSATION_STATUS_JOINED
 * Conversation is currently joined
 * @memberof Constants
 */

Constants.CONVERSATION_STATUS_JOINED = Symbol('CONVERSATION_STATUS_JOINED');
/**
 * @constant {Symbol} CONVERSATION_STATUS_NOT_JOINED
 * Conversation is not joined
 * @memberof Constants
 */

Constants.CONVERSATION_STATUS_NOT_JOINED = Symbol('CONVERSATION_STATUS_NOT_JOINED');
/**
 * @constant {Symbol} CONVERSATION_STATUS_WAITING
 * User agent is in the conversation's waiting room, waiting for moderator acceptance to join
 * @memberof Constants
 */

Constants.CONVERSATION_STATUS_WAITING = Symbol('CONVERSATION_STATUS_WAITING');
/**
 * @constant {Symbol} CONVERSATION_STATUS_JOINING
 * User agent is currently joining the conversation
 * @memberof Constants
 */

Constants.CONVERSATION_STATUS_JOINING = Symbol('CONVERSATION_STATUS_JOINING');
/**
 * @constant {Symbol} CONVERSATION_WHITEBOARD_STARTED
 * Conversation is currently joined
 * @memberof Constants
 */

Constants.CONVERSATION_WHITEBOARD_STARTED = Symbol('CONVERSATION_WHITEBOARD_STARTED');
/**
 * @constant {Symbol} CONVERSATION_WHITEBOARD_NOT_STARTED
 * Conversation is not joined
 * @memberof Constants
 */

Constants.CONVERSATION_WHITEBOARD_NOT_STARTED = Symbol('CONVERSATION_WHITEBOARD_NOT_STARTED');
/**
 * @constant {Symbol} STATE_IDLE
 * General purpose state.
 * @memberof Constants
 */

Constants.STATE_IDLE = Symbol('STATE_IDLE');
/**
 * @constant {Symbol} STATE_JOINING
 * General purpose state.
 * @memberof Constants
 */

Constants.STATE_JOINING = Symbol('STATE_JOINING');
/**
 * @constant {Symbol} STATE_ACTIVE
 * General purpose state.
 * @memberof Constants
 */

Constants.STATE_ACTIVE = Symbol('STATE_ACTIVE');
/**
 * @constant {Symbol} STATE_LEAVING
 * General purpose state.
 * @memberof Constants
 */

Constants.STATE_LEAVING = Symbol('STATE_LEAVING');
/**
 * @constant {Symbol} INVITATION_STATUS_ACCEPTED
 * Invitation has been accepted
 * @memberof Constants
 */

Constants.INVITATION_STATUS_ACCEPTED = Symbol('INVITATION_STATUS_ACCEPTED');
/**
 * @constant {Symbol} INVITATION_STATUS_DECLINED
 * Invitation has been declined
 * @memberof Constants
 */

Constants.INVITATION_STATUS_DECLINED = Symbol('INVITATION_STATUS_DECLINED');
/**
 * @constant {Symbol} INVITATION_STATUS_STANDBY
 * Invitation is waiting for a response
 * @memberof Constants
 */

Constants.INVITATION_STATUS_STANDBY = Symbol('INVITATION_STATUS_STANDBY');
/**
 * @constant {Symbol} INVITATION_STATUS_EXPIRED
 * Invitation has expired
 * @memberof Constants
 */

Constants.INVITATION_STATUS_EXPIRED = Symbol('INVITATION_STATUS_EXPIRED');
/**
 * @constant {Symbol} INVITATION_STATUS_CANCELLED
 * Invitation has been cancelled
 * @memberof Constants
 */

Constants.INVITATION_STATUS_CANCELLED = Symbol('INVITATION_STATUS_CANCELLED');
/**
 * @constant {Symbol} INVITATION_STATUS_ENDED
 * Invitation is ended
 * @memberof Constants
 */

Constants.INVITATION_STATUS_ENDED = Symbol('INVITATION_STATUS_ENDED');
/**
 * @constant {Symbol} STREAM_TYPE_NO_INPUT
 * Stream has no input
 * @memberof Constants
 */

Constants.STREAM_TYPE_NO_INPUT = 'no_input';
/**
 * @constant {Symbol} STREAM_TYPE_AUDIO
 * Stream is audio-only
 * @memberof Constants
 */

Constants.STREAM_TYPE_AUDIO = 'audio';
/**
 * @constant {Symbol} STREAM_TYPE_VIDEO
 * Stream has at least a video track
 * @memberof Constants
 */

Constants.STREAM_TYPE_VIDEO = 'video';
/**
 * @constant {Symbol} STREAM_AUDIO_ANALYSIS_THRESHOLD
 * Threshold applied for detecting voice or noise in the stream audio
 * @memberof Constants
 */

Constants.STREAM_AUDIO_ANALYSIS_THRESHOLD = 100;
/**
 * @constant {Symbol} STREAM_AUDIO_NOISE_REDUCTION_VAI
 * Threshold applied for the Voice Activity Indicator when noise reduction is turned on
 * @memberof Constants
 */

Constants.STREAM_AUDIO_NOISE_REDUCTION_VAI = {
  'soft': 0.7,
  'medium': 0.8,
  'hard': 0.9
};
/**
 * @constant {number} CONTACT_DISCONNECTION_DELAY
 * Delay before a contact is actually seen as offline after it disconnected (eg. short reconnection after page switching)
 * @memberof Constants
 */

Constants.CONTACT_DISCONNECTION_DELAY = 10000;
/**
 * @constant {number} CONVERSATION_JOIN_REQUEST_INTERVAL
 * The interval between join request message sendings.
 * @memberof Constants
 */

Constants.CONVERSATION_JOIN_REQUEST_INTERVAL = 5000;
/**
 * @constant {number} APIRTC_MEDIA_DEVICE_DETECTION_DELAY
 * The interval between two media device detection for apiRTC media device detection process. Check apiRTCMediaDeviceDetectionEnabled on UserAgent
 * @memberof Constants
 */

Constants.APIRTC_MEDIA_DEVICE_DETECTION_DELAY = 10000;
/**
 * @constant {number} CONVERSATION_GROUP_CHAT_MEMBER_UPDATE_DELAY
 * Maximum delay to wait for group chat member update event.
 * @memberof Constants
 */

Constants.CONVERSATION_GROUP_CHAT_MEMBER_UPDATE_DELAY = 5000;
/**
 * @constant {number} CONVERSATION_WHITEBOARD_START_DELAY
 * Maximum delay to wait for whiteboard start.
 * @memberof Constants
 */

Constants.CONVERSATION_WHITEBOARD_START_DELAY = 5000;
/**
 * @constant {number} CONVERSATION_RECORDING_STARTED_DELAY
 * Maximum delay to wait for the recording started event.
 * @memberof Constants
 */

Constants.CONVERSATION_RECORDING_STARTED_DELAY = 10000;
/**
 * @constant {number} CONVERSATION_RECORDING_STOPPED_DELAY
 * Maximum delay to wait for the recording stopped event.
 * @memberof Constants
 */

Constants.CONVERSATION_RECORDING_STOPPED_DELAY = 5000;
/**
 * @constant {number} CONVERSATION_STREAMING_STARTED_DELAY
 * Maximum delay to wait for the streaming started event.
 * @memberof Constants
 */

Constants.CONVERSATION_STREAMING_STARTED_DELAY = 10000;
/**
 * @constant {number} CONVERSATION_STREAMING_STOPPED_DELAY
 * Maximum delay to wait for the streaming stopped event.
 * @memberof Constants
 */

Constants.CONVERSATION_STREAMING_STOPPED_DELAY = 10000;
/**
 * @constant {number} CONVERSATION_PARTICIPANT_EJECTION_DELAY
 * Maximum delay to wait for the ejected event.
 * @memberof Constants
 */

Constants.CONVERSATION_PARTICIPANT_EJECTION_DELAY = 5000; // Defines the amount of time after sending the 'join request'
// and before actually joining the presence group of the waiting
// room. This avoids an unnecessary join if the CCS gives a
// response right away.

Constants.JOIN_WAITING_ROOM_PRESENCE_GROUP_TIMEOUT = 3000;


/***/ }),

/***/ "./src/utils/EventEmitter.js":
/*!***********************************!*\
  !*** ./src/utils/EventEmitter.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventEmitter": () => (/* binding */ EventEmitter)
/* harmony export */ });
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/**
 * EventEmitter based on v5.1.0 - git.io/ee
 * Unlicense - http://unlicense.org/
 * Oliver Caldwell - http://oli.me.uk/
 */

/**
 * Class for managing events.
 * Can be extended to provide event functionality in other classes.
 *
 * @class EventEmitter Manages event registering and emitting. Based on Oliver Caldwell's work.
 */
var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);
  }
  /**
   * Returns the listener array for the specified event.
   * Will initialise the event object and listener arrays if required.
   * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
   * Each property in the object response is an array of listener functions.
   *
   * @param {String|RegExp} evt Name of the event to return the listeners from.
   * @return {Function[]|Object} All listener functions for the event.
   */


  _createClass(EventEmitter, [{
    key: "getListeners",
    value: function getListeners(evt) {
      var events = this._getEvents();

      var response;
      var key; // Return a concatenated array of all matching events if
      // the selector is a regular expression.

      if (evt instanceof RegExp) {
        response = {};

        for (key in events) {
          if (events.hasOwnProperty(key) && evt.test(key)) {
            response[key] = events[key];
          }
        }
      } else {
        response = events[evt] || (events[evt] = []);
      }

      return response;
    }
    /**
     * Takes a list of listener objects and flattens it into a list of listener functions.
     *
     * @param {Object[]} listeners Raw listener objects.
     * @return {Function[]} Just the listener functions.
     */

  }, {
    key: "flattenListeners",
    value: function flattenListeners(listeners) {
      var flatListeners = [];
      var i;

      for (i = 0; i < listeners.length; i += 1) {
        flatListeners.push(listeners[i].listener);
      }

      return flatListeners;
    }
    /**
     * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
     *
     * @param {String|RegExp} evt Name of the event to return the listeners from.
     * @return {Object} All listener functions for an event in an object.
     */

  }, {
    key: "getListenersAsObject",
    value: function getListenersAsObject(evt) {
      var listeners = this.getListeners(evt);
      var response;

      if (listeners instanceof Array) {
        response = {};
        response[evt] = listeners;
      }

      return response || listeners;
    }
    /**
     * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
     * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {...*} Optional additional arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "emit",
    value: function emit(evt) {
      var args = Array.prototype.slice.call(arguments, 1);
      return this.emitEvent(evt, args);
    }
    /**
     * Adds a listener function to the specified event.
     * The listener will not be added if it is a duplicate.
     * If the listener returns true then it will be removed after it is called.
     * If you pass a regular expression as the event name then the listener will be added to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "addListener",
    value: function addListener(evt, listener) {
      if (!isValidListener(listener)) {
        throw new TypeError('listener must be a function');
      }

      var listeners = this.getListenersAsObject(evt);
      var listenerIsWrapped = _typeof(listener) === 'object';
      var key;

      for (key in listeners) {
        if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
          listeners[key].push(listenerIsWrapped ? listener : {
            listener: listener,
            once: false
          });
        }
      } //WORKAROUND PRESENCE ISSUE AP-1393


      if (evt === "contactListUpdate") {
        apiRTC.userAgentInstance.currentSession.contactListUpdateListenerSetted = true;

        var _iterator = _createForOfIteratorHelper(apiRTC.userAgentInstance.currentSession.waitingContactListUpdateEvent),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var updatedContacts = _step.value;
            //console.error("Some contactListUpdate events are stored, emiting to Session :", updatedContacts);
            this.emit('contactListUpdate', updatedContacts);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        apiRTC.userAgentInstance.currentSession.waitingContactListUpdateEvent = [];
      } else if (evt === "mediaDeviceChanged") {
        //Manage case when mediaDevice are detected on userAgent and mediaDeviceChanged handler is not yet setted
        if (apiRTC.mediaDeviceMgr.mediaDeviceChangedDetected === true) {
          //mediaDeviceChangedDetected should already been fired
          //console.error('generating mediaDeviceChanged event as it already occured before event handler setting');
          var diff = apiRTC.mediaDeviceMgr.getMediaDeviceListsDiff(apiRTC.mediaDeviceMgr.mediaDeviceSourceInfosArray, apiRTC.mediaDeviceMgr.mediaDeviceSourceInfosArrayBeforeGotSources);
          apiRTC.myWebRTC_Event.createMediaDeviceChangedEvent(diff, 'updatedOnDeviceChange', apiRTC.mediaDeviceMgr.realMediaDevicesListInitializationWasAlreadyDone);
        }
      }

      return this;
    }
    /**
     * Semi-alias of addListener. It will add a listener that will be
     * automatically removed after its first execution.
     *
     * @param {String|RegExp} evt Name of the event to attach the listener to.
     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "addOnceListener",
    value: function addOnceListener(evt, listener) {
      return this.addListener(evt, {
        listener: listener,
        once: true
      });
    }
    /**
     * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
     * You need to tell it what event names should be matched by a regex.
     *
     * @param {String} evt Name of the event to create.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "defineEvent",
    value: function defineEvent(evt) {
      this.getListeners(evt);
      return this;
    }
    /**
     * Uses defineEvent to define multiple events.
     *
     * @param {String[]} evts An array of event names to define.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "defineEvents",
    value: function defineEvents(evts) {
      for (var i = 0; i < evts.length; i += 1) {
        this.defineEvent(evts[i]);
      }

      return this;
    }
    /**
     * Removes a listener function from the specified event.
     * When passed a regular expression as the event name, it will remove the listener from all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to remove the listener from.
     * @param {Function} listener Method to remove from the event.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "removeListener",
    value: function removeListener(evt, listener) {
      var listeners = this.getListenersAsObject(evt);
      var index;
      var key;

      for (key in listeners) {
        if (listeners.hasOwnProperty(key)) {
          index = indexOfListener(listeners[key], listener);

          if (index !== -1) {
            listeners[key].splice(index, 1);
          }
        }
      }

      return this;
    }
    /**
     * Adds listeners in bulk using the manipulateListeners method.
     * If you pass an object as the first argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
     * You can also pass it a regular expression to add the array of listeners to all events that match it.
     * Yeah, this function does quite a bit. That's probably a bad thing.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "addListeners",
    value: function addListeners(evt, listeners) {
      // Pass through to manipulateListeners
      return this.manipulateListeners(false, evt, listeners);
    }
    /**
     * Removes listeners in bulk using the manipulateListeners method.
     * If you pass an object as the first argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be removed.
     * You can also pass it a regular expression to remove the listeners from all events that match it.
     *
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "removeListeners",
    value: function removeListeners(evt, listeners) {
      // Pass through to manipulateListeners
      return this.manipulateListeners(true, evt, listeners);
    }
    /**
     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
     * The first argument will determine if the listeners are removed (true) or added (false).
     * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
     * You can also pass it an event name and an array of listeners to be added/removed.
     * You can also pass it a regular expression to manipulate the listeners of all events that match it.
     *
     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
     * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
     * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "manipulateListeners",
    value: function manipulateListeners(remove, evt, listeners) {
      var i;
      var value;
      var single = remove ? this.removeListener : this.addListener;
      var multiple = remove ? this.removeListeners : this.addListeners; // If evt is an object then pass each of its properties to this method

      if (_typeof(evt) === 'object' && !(evt instanceof RegExp)) {
        for (i in evt) {
          if (evt.hasOwnProperty(i) && (value = evt[i])) {
            // Pass the single listener straight through to the singular method
            if (typeof value === 'function') {
              single.call(this, i, value);
            } else {
              // Otherwise pass back to the multiple function
              multiple.call(this, i, value);
            }
          }
        }
      } else {
        // So evt must be a string
        // And listeners must be an array of listeners
        // Loop over it and pass each one to the multiple method
        i = listeners.length;

        while (i--) {
          single.call(this, evt, listeners[i]);
        }
      }

      return this;
    }
    /**
     * Removes all listeners from a specified event.
     * If you do not specify an event then all listeners will be removed.
     * That means every event will be emptied.
     * You can also pass a regex to remove all events that match it.
     *
     * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "removeEvent",
    value: function removeEvent(evt) {
      var type = _typeof(evt);

      var events = this._getEvents();

      var key; // Remove different things depending on the state of evt

      if (type === 'string') {
        // Remove all listeners for the specified event
        delete events[evt];
      } else if (evt instanceof RegExp) {
        // Remove all events matching the regex.
        for (key in events) {
          if (events.hasOwnProperty(key) && evt.test(key)) {
            delete events[key];
          }
        }
      } else {
        // Remove all listeners in all events
        delete this._events;
      }

      return this;
    }
    /**
     * Emits an event of your choice.
     * When emitted, every listener attached to that event will be executed.
     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
     * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
     * So they will not arrive within the array on the other side, they will be separate.
     * You can also pass a regular expression to emit to all events that match it.
     *
     * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
     * @param {Array} [args] Optional array of arguments to be passed to each listener.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "emitEvent",
    value: function emitEvent(evt, args) {
      var listenersMap = this.getListenersAsObject(evt);
      var listeners;
      var listener;
      var i;
      var key;
      var response;

      for (key in listenersMap) {
        if (listenersMap.hasOwnProperty(key)) {
          listeners = listenersMap[key].slice(0);

          for (i = 0; i < listeners.length; i++) {
            // If the listener returns true then it shall be removed from the event
            // The function is executed either with a basic call or an apply if there is an args array
            listener = listeners[i];

            if (listener.once === true) {
              this.removeListener(evt, listener.listener);
            }

            response = listener.listener.apply(this, args || []);

            if (response === this._getOnceReturnValue()) {
              this.removeListener(evt, listener.listener);
            }
          }
        }
      }

      return this;
    }
    /**
     * Sets the current value to check against when executing listeners. If a
     * listeners return value matches the one set here then it will be removed
     * after execution. This value defaults to true.
     *
     * @param {*} value The new value to check for when executing listeners.
     * @return {Object} Current instance of EventEmitter for chaining.
     */

  }, {
    key: "setOnceReturnValue",
    value: function setOnceReturnValue(value) {
      this._onceReturnValue = value;
      return this;
    }
    /**
     * Fetches the current value to check against when executing listeners. If
     * the listeners return value matches this one then it should be removed
     * automatically. It will return true by default.
     *
     * @return {*|Boolean} The current value to check for or the default, true.
     * @private
     */

  }, {
    key: "_getOnceReturnValue",
    value: function _getOnceReturnValue() {
      if (this.hasOwnProperty('_onceReturnValue')) {
        return this._onceReturnValue;
      } else {
        return true;
      }
    }
    /**
     * Fetches the events object and creates one if required.
     *
     * @return {Object} The events storage object.
     * @private
     */

  }, {
    key: "_getEvents",
    value: function _getEvents() {
      return this._events || (this._events = {});
    }
  }]);

  return EventEmitter;
}(); // Shortcuts to improve speed and size


var proto = EventEmitter.prototype;
/**
 * Finds the index of the listener for the event in its storage array.
 *
 * @param {Function[]} listeners Array of listeners to search through.
 * @param {Function} listener Method to look for.
 * @return {Number} Index of the specified listener, -1 if not found
 * @private
 */

var indexOfListener = function indexOfListener(listeners, listener) {
  var i = listeners.length;

  while (i--) {
    if (listeners[i].listener === listener) {
      return i;
    }
  }

  return -1;
};
/**
 * Alias a method while keeping the context correct, to allow for overwriting of target method.
 *
 * @param {String} name The name of the target method.
 * @return {Function} The aliased method
 * @private
 */


var alias = function alias(name) {
  return function aliasClosure() {
    return this[name].apply(this, arguments);
  };
};

var isValidListener = function isValidListener(listener) {
  if (typeof listener === 'function' || listener instanceof RegExp) {
    return true;
  } else if (listener && _typeof(listener) === 'object') {
    return isValidListener(listener.listener);
  } else {
    return false;
  }
};
/**
 * Alias of addListener
 */


proto.on = alias('addListener');
/**
 * Alias of addOnceListener.
 */

proto.once = alias('addOnceListener');
/**
 * Alias of removeListener
 */

proto.off = alias('removeListener');
/**
 * Alias of removeEvent.
 *
 * Added to mirror the node API.
 */

proto.removeAllListeners = alias('removeEvent');
/**
 * Alias of emitEvent
 */

proto.trigger = alias('emitEvent');


/***/ }),

/***/ "./src/utils/Future.js":
/*!*****************************!*\
  !*** ./src/utils/Future.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Future": () => (/* binding */ Future)
/* harmony export */ });
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function matchAlways() {
  return true;
}

function matchSuccess(err) {
  return err === null;
}

function matchFailure(err) {
  return err !== null;
}

var Future = /*#__PURE__*/function () {
  function Future() {
    _classCallCheck(this, Future);

    this._callbacks = [];
    this._timeout = null;
    this._err = null;
    this._data = null;
    this._interrupted = null;
    this._fulfilled = false;
  }

  _createClass(Future, [{
    key: "err",
    get: function get() {
      if (!this._fulfilled) {
        throw new Error('not fulfilled yet');
      }

      return this._err;
    }
  }, {
    key: "data",
    get: function get() {
      if (!this._fulfilled) {
        throw new Error('not fulfilled yet');
      }

      return this._data;
    }
  }, {
    key: "interrupted",
    get: function get() {
      if (!this._fulfilled) {
        throw new Error('not fulfilled yet');
      }

      return this._interrupted;
    }
  }, {
    key: "fulfilled",
    get: function get() {
      return this._fulfilled;
    }
  }, {
    key: "_fulfill",
    value: function _fulfill(err, data, interrupted) {
      this._err = err;
      this._data = data;
      this._interrupted = interrupted;
      this._fulfilled = true;

      var callbacks = this._callbacks.slice();

      this.clear();

      var _iterator = _createForOfIteratorHelper(callbacks),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _step.value,
              match = _step$value.match,
              callback = _step$value.callback;

          if (match(this._err)) {
            callback(this._err, this._data, this._interrupted);
          }
        } // for

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Removes all listeners and clears the timeout.
     */

  }, {
    key: "clear",
    value: function clear() {
      this.clearTimeout();
      this.removeCallback();
    }
    /**
     * Set a timeout for automatic fulfillment.
     * @param {number} delay - The delay in milliseconds.
     * @param {Error | string | null} err - null for success, an Error or a message otherwise.
     * @param {any} data - The result for success.
     */

  }, {
    key: "setTimeout",
    value: function (_setTimeout) {
      function setTimeout(_x, _x2, _x3) {
        return _setTimeout.apply(this, arguments);
      }

      setTimeout.toString = function () {
        return _setTimeout.toString();
      };

      return setTimeout;
    }(function (delay, err, data) {
      var _this = this;

      this.clearTimeout();

      if (err === null) {
        this._timeout = setTimeout(function () {
          _this._fulfill(null, data, true);
        }, delay);
      } else {
        this._timeout = setTimeout(function () {
          _this._fulfill(typeof err === 'string' ? new Error(err) : err, undefined, true);
        }, delay);
      }
    })
  }, {
    key: "clearTimeout",
    value: function (_clearTimeout) {
      function clearTimeout() {
        return _clearTimeout.apply(this, arguments);
      }

      clearTimeout.toString = function () {
        return _clearTimeout.toString();
      };

      return clearTimeout;
    }(function () {
      if (this._timeout !== null) {
        clearTimeout(this._timeout);
        this._timeout = null;
      }
    }
    /**
     * Registers a callback that will be called upon fulfillment.
     * @param {function} callback
     */
    )
  }, {
    key: "onFulfillment",
    value: function onFulfillment(callback) {
      this._callbacks.push({
        match: matchAlways,
        callback: callback
      });
    }
    /**
     * Registers a callback that will be called upon successful fulfillment.
     * @param {function} callback
     */

  }, {
    key: "onSuccess",
    value: function onSuccess(callback) {
      this._callbacks.push({
        match: matchSuccess,
        callback: callback
      });
    }
    /**
     * Registers a callback that will be called upon unsuccessful fulfillment.
     * @param {function} callback
     */

  }, {
    key: "onFailure",
    value: function onFailure(callback) {
      this._callbacks.push({
        match: matchFailure,
        callback: callback
      });
    }
    /**
     * Unregisters a callback or all callbacks.
     * @param {function | undefined} callback
     */

  }, {
    key: "removeCallback",
    value: function removeCallback(callback) {
      if (typeof callback === 'function') {
        var idx = this._callbacks.findIndex(function (e) {
          return e.callback === callback;
        });

        if (idx >= 0) {
          this._callbacks.splice(idx, 1);
        }
      } else {
        this._callbacks.splice(0, this._callbacks.length);
      }
    }
    /**
     * Fulfills the Future represented by this one.
     * @param {Error | string | null} err - null for success, an Error or a message otherwise.
     * @param {any} data - The result for success.
     */

  }, {
    key: "fulfill",
    value: function fulfill(err, data) {
      if (err === null) {
        // Success.
        this._fulfill(null, data, false);
      } else {
        // Failure.
        this._fulfill(typeof err === 'string' ? new Error(err) : err, undefined, false);
      }
    }
  }]);

  return Future;
}();

/***/ }),

/***/ "./src/utils/Misc.js":
/*!***************************!*\
  !*** ./src/utils/Misc.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Misc": () => (/* binding */ Misc)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

//fast-ish guid generation function
var guid = function guid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}; //returns a GET query string from params


var paramsToQueryString = function paramsToQueryString(params) {
  var queryString = '';

  for (var _i = 0, _Object$keys = Object.keys(params); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];

    if (queryString === '') {
      queryString += '?';
    } else {
      queryString += '&';
    }

    if (params[key] === null || typeof params[key] === 'undefined') {
      console.warn('apiRTC Utils - paramsToQueryString : ' + key + ' is undefined!');
    } else {
      queryString += key + '=' + params[key].toString();
    }
  }

  return queryString;
}; //fast hash function


var hashString = function hashString(str) {
  var hash = 0,
      i = 0,
      len = str.length;

  while (i < len) {
    hash = (hash << 5) - hash + str.charCodeAt(i++) << 0;
  }

  return Math.abs(hash);
};

var arrayBuffertoString = function arrayBuffertoString(buf) {
  //return String.fromCharCode.apply(null, new Uint8Array(buf));
  var dataView = new DataView(buf); // The TextDecoder interface is documented at http://encoding.spec.whatwg.org/#interface-textdecoder

  var decoder = new TextDecoder('utf-8');
  return decoder.decode(dataView);
}; //gets audio context


var getAudioContext = function getAudioContext() {
  return apiRTC.audioProcessor.getOrCreateAudioContext();
};
/*
 * Parses a given recording event.
 * @ignore
 * @method parseRecordingEvent
 * @param {string} eventName - Either 'MCURecordingStarted', 'MCURecordingStopped' or 'MCURecordedStreamsAvailable'.
 * @param {object} eventDetail
 * @param {string} eventDetail.roomName
 * @param {string} eventDetail.callId
 * @param {string} eventDetail.recordType
 * @param {string} eventDetail.convId
 * @param {string} eventDetail.mediaId
 * @param {string} eventDetail.mediaURL
 * @param {string} eventDetail.recordedFileName
 * @param {string} eventDetail.mediaType
 * @param {string} eventDetail.mode
 * @param {string} eventDetail.labelEnabled
 * @param {string} eventDetail.labels
 * @param {object} res
 * @return {object}
 */


var parseRecordingEvent = function parseRecordingEvent(eventName, eventDetail) {
  var res = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  ['roomName', 'callId', 'recordType', 'convId', 'mediaId', 'mediaURL', 'recordedFileName'].forEach(function (e) {
    if (eventDetail.hasOwnProperty(e)) {
      // Force string is required for old conversation id (integer)
      res[e] = String(eventDetail[e]);
    }
  });

  if (eventDetail.mediaType === 'AUDIO-ONLY') {
    res.audioOnly = true;
    res.videoOnly = false;
  } else if (eventDetail.mediaType === 'VIDEO-ONLY') {
    res.audioOnly = false;
    res.videoOnly = true;
  } else {
    res.audioOnly = false;
    res.videoOnly = false;
  }

  if (res.recordType === 'composite') {
    if (eventDetail.hasOwnProperty('mode')) {
      res.mode = eventDetail.mode;
    } else {
      res.mode = 'complete';
    }

    if (eventDetail.hasOwnProperty('labelEnabled')) {
      res.labelEnabled = eventDetail.labelEnabled === true;

      if (res.labelEnabled === true && eventDetail.hasOwnProperty('labels')) {
        res.labels = eventDetail.labels;
      }
    } else {
      res.labelEnabled = false;
    }
  }

  return res;
};
/*
 * Creates an ApiRTC error.
 * @method createError
 * @param {number} code - Error unique code.
 * @param {string} message - Description.
 * @param {Logger} logger - Optional logger.
 * @param {Object} options - Optional data.
 * @param {Error} options.fromError - Original error.
 * @param {number} options.httpCode - HTTP response status.
 */


var createError = function createError(code, message, logger) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  if (logger) {
    logger.error(message);
  }

  var ret = {
    code: code
  };

  if (message instanceof String) {
    ret.error = new Error(message);
  } else if (message instanceof Error) {
    ret.error = message;
  } else {
    ret.error = new Error(String(message));
  }

  if (isTypeof(options, 'object')) {
    if (options.hasOwnProperty('fromError')) {
      ret.fromError = options.fromError;
    }

    if (options.hasOwnProperty('httpCode')) {
      ret.httpCode = options.httpCode;
    }
  }

  return ret;
}; //For private shared variables


var _private = {
  dataCallsOnHold: new Map(),
  dataChannelInvitations: new Map(),
  dataCallsFileInfo: new Map()
};

var isSet = function isSet(v) {
  return typeof v !== 'undefined' && v !== null;
};
/*
 * Tests whether a given variable is not null and matches a given type.
 * The type argument may be 'null' to match null type.
 * The type argument may be 'undefined' to match missing property.
 * The type argument may be 'array' to match array type.
 * The type argument may be 'object', 'number' or 'string'.
 * See JanusConnector/utils.js for original implementation.
 * See JanusConnector/test/utilsTests.js for test suite.
 *
 * @method isTypeof
 * @param v {any} variable.
 * @param t {string} type.
 * @return {boolean} true if variable is not undefined/null and matches given type, false otherwise.
 */


function isTypeof(v, t) {
  if (arguments.length === 3) {
    return isPropertyTypeof(arguments[0], arguments[1], arguments[2]);
  }

  if (t === 'null') {
    return v === null;
  }

  if (t === 'array') {
    return v !== null && _typeof(v) === 'object' && Array.isArray(v);
  }

  return v !== null && _typeof(v) === t;
}
/*
 * Tests whether a given object property exists, is not null and matches a given type.
 * The property argument may be an array of string values representing a property path.
 * The type argument may be 'null' to match null type.
 * The type argument may be 'undefined' to match missing property.
 * The type argument may be 'array' to match array type.
 * The type argument may be 'object', 'number' or 'string'.
 * See JanusConnector/utils.js for original implementation.
 * See JanusConnector/test/utilsTests.js for test suite.
 *
 * @method isPropertyTypeof
 * @param o {object} object.
 * @param p {string} property.
 * @param t {string} type.
 * @return {boolean} true if property exists, is not null and matches given type, false otherwise.
 */


function isPropertyTypeof(v, p, t) {
  if (p !== null && _typeof(p) === 'object' && Array.isArray(p) && p.length >= 1) {
    var f = p[0];

    if (p.length > 1) {
      return isTypeof(v, 'object') && isTypeof(f, 'string') && v.hasOwnProperty(f) && isTypeof(v[f], 'object') && isPropertyTypeof(v[f], p.slice(1), t);
    }

    p = f;
  }

  if (t === 'undefined') {
    return isTypeof(v, 'object') && isTypeof(p, 'string') && !v.hasOwnProperty(p) && isTypeof(v[p], t);
  }

  return isTypeof(v, 'object') && isTypeof(p, 'string') && v.hasOwnProperty(p) && isTypeof(v[p], t);
} // Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.


var throttle = function throttle(func, wait) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var context, args, result;
  var timeout = null;
  var previous = 0;

  var later = function later() {
    previous = options.leading === false ? 0 : Date.now();
    timeout = null;
    result = func.apply(context, args);

    if (!timeout) {
      context = args = null;
    }
  };

  return function () {
    var now = Date.now();

    if (!previous && options.leading === false) {
      previous = now;
    }

    var remaining = wait - (now - previous);
    context = this;
    args = arguments;

    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }

      previous = now;
      result = func.apply(context, args);

      if (!timeout) {
        context = args = null;
      }
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }

    return result;
  };
};

var assignObject = function assignObject(target, source) {
  var idx, key, from;

  if (target === undefined || target === null) {
    target = {};
  }

  for (idx = 1; idx < arguments.length; idx += 1) {
    from = arguments[idx];

    for (key in from) {
      if (from.hasOwnProperty(key)) {
        target[key] = from[key];
      }
    }
  }

  return target;
};

var Misc = {
  assignObject: assignObject,
  throttle: throttle,
  guid: guid,
  hashString: hashString,
  arrayBuffertoString: arrayBuffertoString,
  getAudioContext: getAudioContext,
  parseRecordingEvent: parseRecordingEvent,
  paramsToQueryString: paramsToQueryString,
  createError: createError,
  isSet: isSet,
  isTypeof: isTypeof,
  isPropertyTypeof: isPropertyTypeof,
  _private: _private
};


/***/ }),

/***/ "./src/utils/Observable.js":
/*!*********************************!*\
  !*** ./src/utils/Observable.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Observable": () => (/* binding */ Observable),
/* harmony export */   "_eventEmitter": () => (/* binding */ _eventEmitter)
/* harmony export */ });
/* harmony import */ var _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/EventEmitter */ "./src/utils/EventEmitter.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

 //Private fields

var _eventEmitter = new WeakMap();

var _logger = new WeakMap();
/**
 * Observable
 *
 * Instanciates objects that are able to emit events
 *
 */


var Observable = /*#__PURE__*/function () {
  function Observable(logger) {
    _classCallCheck(this, Observable);

    _logger.set(this, logger);

    _eventEmitter.set(this, new _utils_EventEmitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter());
  }
  /**
   * Returns available events for this class
   *
   *  @returns {Array<string>}
   */


  _createClass(Observable, [{
    key: "on",
    value:
    /**
     * Adds a listener to a Observable event
     *
     *  @param {Function} listener
     *  @returns {Observable} this instance for chaining
     */
    function on(eventType, listener) {
      if (this.constructor.getAvailableEvents().indexOf(eventType) > -1) {
        _eventEmitter.get(this).on(eventType, listener);
      } else {
        _logger.get(this).error('No such event ' + eventType);
      }

      return this;
    }
    /**
     * Remove existing listener to Observable event
     *
     *  @param {String} eventType
     *  @param {Function} listener
     *  @returns {Observable} this instance for chaining
     */

  }, {
    key: "removeListener",
    value: function removeListener(eventType, listener) {
      if (this.constructor.getAvailableEvents().indexOf(eventType) > -1) {
        var found = false,
            listeners = _eventEmitter.get(this).getListeners(eventType);

        var _iterator = _createForOfIteratorHelper(listeners),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var obj = _step.value;

            if (obj.listener === listener) {
              found = true;
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (found) {
          _eventEmitter.get(this).off(eventType, listener);
        } else {
          _logger.get(this).trace('removeListener() - No such listener for event ' + eventType);
        }
      } else {
        _logger.get(this).error('No such event ' + eventType);
      }

      return this;
    }
  }], [{
    key: "getAvailableEvents",
    value: function getAvailableEvents() {
      return [];
    }
  }]);

  return Observable;
}();



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd define */
/******/ 	(() => {
/******/ 		__webpack_require__.amdD = function () {
/******/ 			throw new Error('define cannot be used indirect');
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("./node_modules/idempotent-babel-polyfill/lib/index.js");
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/apiRTC.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=apiRTC-srcTmp.js.map